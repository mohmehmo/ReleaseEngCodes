<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C++" filename="/home/mmm/Projects/Arduino/app/testdata/libraries/SD_1.1.1/SD/src/SD.cpp"><comment type="block">/*

 SD - a slightly more friendly wrapper for sdfatlib

 This library aims to expose a subset of SD card functionality
 in the form of a higher level "wrapper" object.

 License: GNU General Public License V3
          (Because sdfatlib is licensed with this.)

 (C) Copyright 2010 SparkFun Electronics


 This library provides four key benefits:

   * Including `SD.h` automatically creates a global
     `SD` object which can be interacted with in a similar
     manner to other standard global objects like `Serial` and `Ethernet`.

   * Boilerplate initialisation code is contained in one method named 
     `begin` and no further objects need to be created in order to access
     the SD card.

   * Calls to `open` can supply a full path name including parent 
     directories which simplifies interacting with files in subdirectories.

   * Utility methods are provided to determine whether a file exists
     and to create a directory heirarchy.


  Note however that not all functionality provided by the underlying
  sdfatlib library is exposed.

 */</comment>

<comment type="block">/*

  Implementation Notes

  In order to handle multi-directory path traversal, functionality that 
  requires this ability is implemented as callback functions.

  Individual methods call the `walkPath` function which performs the actual
  directory traversal (swapping between two different directory/file handles
  along the way) and at each level calls the supplied callback function.

  Some types of functionality will take an action at each level (e.g. exists
  or make directory) which others will only take an action at the bottom
  level (e.g. open).

 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"SD.h"</cpp:file></cpp:include>

<namespace>namespace <name>SDLib</name> <block>{

<comment type="line">// Used by `getNextPathComponent`</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_COMPONENT_LEN</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define> <comment type="line">// What is max length?</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PATH_COMPONENT_BUFFER_LEN</name></cpp:macro> <cpp:value>MAX_COMPONENT_LEN+1</cpp:value></cpp:define>

<function><type><name>bool</name></type> <name>getNextPathComponent</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>p_offset</name></decl></parameter>,
			  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/*

    Parse individual path components from a path.

      e.g. after repeated calls '/foo/bar/baz' will be split
           into 'foo', 'bar', 'baz'.

    This is similar to `strtok()` but copies the component into the
    supplied buffer rather than modifying the original string.


    `buffer` needs to be PATH_COMPONENT_BUFFER_LEN in size.

    `p_offset` needs to point to an integer of the offset at
    which the previous path component finished.

    Returns `true` if more components remain.

    Returns `false` if this is the last component.
      (This means path ended with 'foo' or 'foo/'.)

   */</comment>

  <comment type="line">// TODO: Have buffer local to this function, so we know it's the</comment>
  <comment type="line">//       correct length?</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>bufferOffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><operator>*</operator><name>p_offset</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// Skip root or other separator</comment>
  <if_stmt><if>if <condition>(<expr><name><name>path</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>offset</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="line">// Copy the next next path segment</comment>
  <while>while <condition>(<expr><name>bufferOffset</name> <operator>&lt;</operator> <name>MAX_COMPONENT_LEN</name>
	 <operator>&amp;&amp;</operator> <operator>(</operator><name><name>path</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal><operator>)</operator>
	 <operator>&amp;&amp;</operator> <operator>(</operator><name><name>path</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>bufferOffset</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>path</name><index>[<expr><name>offset</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>bufferOffset</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

  <comment type="line">// Skip trailing separator so we can determine if this</comment>
  <comment type="line">// is the last component in the path or not.</comment>
  <if_stmt><if>if <condition>(<expr><name><name>path</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>offset</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>p_offset</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>

  <return>return <expr><operator>(</operator><name><name>path</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>



<function><type><name>boolean</name></type> <name>walkPath</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filepath</name></decl></parameter>, <parameter><decl><type><name>SdFile</name><modifier>&amp;</modifier></type> <name>parentDir</name></decl></parameter>,
		 <parameter><function_decl><type><name>boolean</name></type> (<modifier>*</modifier><name>callback</name>)<parameter_list>(<parameter><decl><type><name>SdFile</name><modifier>&amp;</modifier></type> <name>parentDir</name></decl></parameter>,
				     <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filePathComponent</name></decl></parameter>,
				     <parameter><decl><type><name>boolean</name></type> <name>isLastComponent</name></decl></parameter>,
				     <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>object</name></decl></parameter>)</parameter_list></function_decl></parameter>,
		 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>object</name> <init>= <expr><name>NULL</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/*
     
     When given a file path (and parent directory--normally root),
     this function traverses the directories in the path and at each
     level calls the supplied callback function while also providing
     the supplied object for context if required.

       e.g. given the path '/foo/bar/baz'
            the callback would be called at the equivalent of
	    '/foo', '/foo/bar' and '/foo/bar/baz'.

     The implementation swaps between two different directory/file
     handles as it traverses the directories and does not use recursion
     in an attempt to use memory efficiently.

     If a callback wishes to stop the directory traversal it should
     return false--in this case the function will stop the traversal,
     tidy up and return false.

     If a directory path doesn't exist at some point this function will
     also return false and not subsequently call the callback.

     If a directory path specified is complete, valid and the callback
     did not indicate the traversal should be interrupted then this
     function will return true.

   */</comment>


  <decl_stmt><decl><type><name>SdFile</name></type> <name>subfile1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SdFile</name></type> <name>subfile2</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><name>PATH_COMPONENT_BUFFER_LEN</name></expr>]</index></name></decl>;</decl_stmt> 

  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SdFile</name> <modifier>*</modifier></type><name>p_parent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SdFile</name> <modifier>*</modifier></type><name>p_child</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SdFile</name> <modifier>*</modifier></type><name>p_tmp_sdfile</name></decl>;</decl_stmt>  
  
  <expr_stmt><expr><name>p_child</name> <operator>=</operator> <operator>&amp;</operator><name>subfile1</name></expr>;</expr_stmt>
  
  <expr_stmt><expr><name>p_parent</name> <operator>=</operator> <operator>&amp;</operator><name>parentDir</name></expr>;</expr_stmt>

  <while>while <condition>(<expr><literal type="boolean">true</literal></expr>)</condition> <block>{<block_content>

    <decl_stmt><decl><type><name>boolean</name></type> <name>moreComponents</name> <init>= <expr><call><name>getNextPathComponent</name><argument_list>(<argument><expr><name>filepath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>boolean</name></type> <name>shouldContinue</name> <init>= <expr><call><name>callback</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>p_parent</name><operator>)</operator></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>!</operator><name>moreComponents</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>shouldContinue</name></expr>)</condition> <block>{<block_content>
      <comment type="line">// TODO: Don't repeat this code?</comment>
      <comment type="line">// If it's one we've created then we</comment>
      <comment type="line">// don't need the parent handle anymore.</comment>
      <if_stmt><if>if <condition>(<expr><name>p_parent</name> <operator>!=</operator> <operator>&amp;</operator><name>parentDir</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><operator>(</operator><operator>*</operator><name>p_parent</name><operator>)</operator><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>moreComponents</name></expr>)</condition> <block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    
    <decl_stmt><decl><type><name>boolean</name></type> <name>exists</name> <init>= <expr><call><name><operator>(</operator><operator>*</operator><name>p_child</name><operator>)</operator><operator>.</operator><name>open</name></name><argument_list>(<argument><expr><operator>*</operator><name>p_parent</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// If it's one we've created then we</comment>
    <comment type="line">// don't need the parent handle anymore.</comment>
    <if_stmt><if>if <condition>(<expr><name>p_parent</name> <operator>!=</operator> <operator>&amp;</operator><name>parentDir</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name><operator>(</operator><operator>*</operator><name>p_parent</name><operator>)</operator><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="line">// Handle case when it doesn't exist and we can't continue...</comment>
    <if_stmt><if>if <condition>(<expr><name>exists</name></expr>)</condition> <block>{<block_content>
      <comment type="line">// We alternate between two file handles as we go down</comment>
      <comment type="line">// the path.</comment>
      <if_stmt><if>if <condition>(<expr><name>p_parent</name> <operator>==</operator> <operator>&amp;</operator><name>parentDir</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>p_parent</name> <operator>=</operator> <operator>&amp;</operator><name>subfile2</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>p_tmp_sdfile</name> <operator>=</operator> <name>p_parent</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p_parent</name> <operator>=</operator> <name>p_child</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p_child</name> <operator>=</operator> <name>p_tmp_sdfile</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  
  <if_stmt><if>if <condition>(<expr><name>p_parent</name> <operator>!=</operator> <operator>&amp;</operator><name>parentDir</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name><operator>(</operator><operator>*</operator><name>p_parent</name><operator>)</operator><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// TODO: Return/ handle different?</comment>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*

   The callbacks used to implement various functionality follow.

   Each callback is supplied with a parent directory handle,
   character string with the name of the current file path component,
   a flag indicating if this component is the last in the path and
   a pointer to an arbitrary object used for context.

 */</comment>

<function><type><name>boolean</name></type> <name>callback_pathExists</name><parameter_list>(<parameter><decl><type><name>SdFile</name><modifier>&amp;</modifier></type> <name>parentDir</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filePathComponent</name></decl></parameter>, 
			    <parameter><decl><type><name>boolean</name></type></decl></parameter> <comment type="block">/* isLastComponent */</comment>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter> <comment type="block">/* object */</comment>)</parameter_list> <block>{<block_content>
  <comment type="block">/*

    Callback used to determine if a file/directory exists in parent
    directory.

    Returns true if file path exists.

  */</comment>
  <decl_stmt><decl><type><name>SdFile</name></type> <name>child</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>boolean</name></type> <name>exists</name> <init>= <expr><call><name><name>child</name><operator>.</operator><name>open</name></name><argument_list>(<argument><expr><name>parentDir</name></expr></argument>, <argument><expr><name>filePathComponent</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  
  <if_stmt><if>if <condition>(<expr><name>exists</name></expr>)</condition> <block>{<block_content>
     <expr_stmt><expr><call><name><name>child</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> 
  </block_content>}</block></if></if_stmt>
  
  <return>return <expr><name>exists</name></expr>;</return>
</block_content>}</block></function>



<function><type><name>boolean</name></type> <name>callback_makeDirPath</name><parameter_list>(<parameter><decl><type><name>SdFile</name><modifier>&amp;</modifier></type> <name>parentDir</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filePathComponent</name></decl></parameter>, 
			     <parameter><decl><type><name>boolean</name></type> <name>isLastComponent</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>object</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/*

    Callback used to create a directory in the parent directory if
    it does not already exist.

    Returns true if a directory was created or it already existed.

  */</comment>
  <decl_stmt><decl><type><name>boolean</name></type> <name>result</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SdFile</name></type> <name>child</name></decl>;</decl_stmt>
  
  <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>callback_pathExists</name><argument_list>(<argument><expr><name>parentDir</name></expr></argument>, <argument><expr><name>filePathComponent</name></expr></argument>, <argument><expr><name>isLastComponent</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>child</name><operator>.</operator><name>makeDir</name></name><argument_list>(<argument><expr><name>parentDir</name></expr></argument>, <argument><expr><name>filePathComponent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt> 
  
  <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


  <comment type="block">/*

boolean callback_openPath(SdFile&amp; parentDir, char *filePathComponent, 
			  boolean isLastComponent, void *object) {

    Callback used to open a file specified by a filepath that may
    specify one or more directories above it.

    Expects the context object to be an instance of `SDClass` and
    will use the `file` property of the instance to open the requested
    file/directory with the associated file open mode property.

    Always returns true if the directory traversal hasn't reached the
    bottom of the directory heirarchy.

    Returns false once the file has been opened--to prevent the traversal
    from descending further. (This may be unnecessary.)

  if (isLastComponent) {
    SDClass *p_SD = static_cast&lt;SDClass*&gt;(object);
    p_SD-&gt;file.open(parentDir, filePathComponent, p_SD-&gt;fileOpenMode);
    if (p_SD-&gt;fileOpenMode == FILE_WRITE) {
      p_SD-&gt;file.seekSet(p_SD-&gt;file.fileSize());
    }
    // TODO: Return file open result?
    return false;
  }
  return true;
}
  */</comment>



<function><type><name>boolean</name></type> <name>callback_remove</name><parameter_list>(<parameter><decl><type><name>SdFile</name><modifier>&amp;</modifier></type> <name>parentDir</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filePathComponent</name></decl></parameter>, 
			<parameter><decl><type><name>boolean</name></type> <name>isLastComponent</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter> <comment type="block">/* object */</comment>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>isLastComponent</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name><name>SdFile</name><operator>::</operator><name>remove</name></name><argument_list>(<argument><expr><name>parentDir</name></expr></argument>, <argument><expr><name>filePathComponent</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>boolean</name></type> <name>callback_rmdir</name><parameter_list>(<parameter><decl><type><name>SdFile</name><modifier>&amp;</modifier></type> <name>parentDir</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filePathComponent</name></decl></parameter>, 
			<parameter><decl><type><name>boolean</name></type> <name>isLastComponent</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter> <comment type="block">/* object */</comment>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>isLastComponent</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SdFile</name></type> <name>f</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>f</name><operator>.</operator><name>open</name></name><argument_list>(<argument><expr><name>parentDir</name></expr></argument>, <argument><expr><name>filePathComponent</name></expr></argument>, <argument><expr><name>O_READ</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name><name>f</name><operator>.</operator><name>rmDir</name></name><argument_list>()</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>



<comment type="block">/* Implementation of class used to create `SDCard` object. */</comment>



<function><type><name>boolean</name></type> <name><name>SDClass</name><operator>::</operator><name>begin</name></name><parameter_list>(<parameter><decl><type><name>uint8_t</name></type> <name>csPin</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/*

    Performs the initialisation required by the sdfatlib library.

    Return true if initialization succeeds, false otherwise.

   */</comment>
  <return>return <expr><call><name><name>card</name><operator>.</operator><name>init</name></name><argument_list>(<argument><expr><name>SPI_HALF_SPEED</name></expr></argument>, <argument><expr><name>csPin</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
         <call><name><name>volume</name><operator>.</operator><name>init</name></name><argument_list>(<argument><expr><name>card</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
         <call><name><name>root</name><operator>.</operator><name>openRoot</name></name><argument_list>(<argument><expr><name>volume</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>boolean</name></type> <name><name>SDClass</name><operator>::</operator><name>begin</name></name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>clock</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>csPin</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name><name>card</name><operator>.</operator><name>init</name></name><argument_list>(<argument><expr><name>SPI_HALF_SPEED</name></expr></argument>, <argument><expr><name>csPin</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
         <call><name><name>card</name><operator>.</operator><name>setSpiClock</name></name><argument_list>(<argument><expr><name>clock</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
         <call><name><name>volume</name><operator>.</operator><name>init</name></name><argument_list>(<argument><expr><name>card</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
         <call><name><name>root</name><operator>.</operator><name>openRoot</name></name><argument_list>(<argument><expr><name>volume</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// this little helper is used to traverse paths</comment>
<function><type><name>SdFile</name></type> <name><name>SDClass</name><operator>::</operator><name>getParentDir</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filepath</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>index</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="line">// get parent directory</comment>
  <decl_stmt><decl><type><name>SdFile</name></type> <name>d1</name> <init>= <expr><name>root</name></expr></init></decl>;</decl_stmt> <comment type="line">// start with the mostparent, root!</comment>
  <decl_stmt><decl><type><name>SdFile</name></type> <name>d2</name></decl>;</decl_stmt>

  <comment type="line">// we'll use the pointers to swap between the two objects</comment>
  <decl_stmt><decl><type><name>SdFile</name> <modifier>*</modifier></type><name>parent</name> <init>= <expr><operator>&amp;</operator><name>d1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SdFile</name> <modifier>*</modifier></type><name>subdir</name> <init>= <expr><operator>&amp;</operator><name>d2</name></expr></init></decl>;</decl_stmt>
  
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>origpath</name> <init>= <expr><name>filepath</name></expr></init></decl>;</decl_stmt>

  <while>while <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>filepath</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

    <comment type="line">// get rid of leading /'s</comment>
    <if_stmt><if>if <condition>(<expr><name><name>filepath</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>filepath</name><operator>++</operator></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>filepath</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <comment type="line">// it was in the root directory, so leave now</comment>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// extract just the name of the next subdirectory</comment>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name>idx</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>filepath</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call> <operator>-</operator> <name>filepath</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;</operator> <literal type="number">12</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>idx</name> <operator>=</operator> <literal type="number">12</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>    <comment type="line">// dont let them specify long names</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>subdirname</name><index>[<expr><literal type="number">13</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>subdirname</name></expr></argument>, <argument><expr><name>filepath</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>subdirname</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="line">// close the subdir (we reuse them) if open</comment>
    <expr_stmt><expr><call><name><name>subdir</name><operator>-&gt;</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name><name>subdir</name><operator>-&gt;</operator><name>open</name></name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>subdirname</name></expr></argument>, <argument><expr><name>O_READ</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <comment type="line">// failed to open one of the subdirectories</comment>
      <return>return <expr><call><name>SdFile</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="line">// move forward to the next subdirectory</comment>
    <expr_stmt><expr><name>filepath</name> <operator>+=</operator> <name>idx</name></expr>;</expr_stmt>

    <comment type="line">// we reuse the objects, close it.</comment>
    <expr_stmt><expr><call><name><name>parent</name><operator>-&gt;</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// swap the pointers</comment>
    <decl_stmt><decl><type><name>SdFile</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><name>parent</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>parent</name> <operator>=</operator> <name>subdir</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>subdir</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><operator>*</operator><name>index</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>filepath</name> <operator>-</operator> <name>origpath</name><operator>)</operator></expr>;</expr_stmt>
  <comment type="line">// parent is now the parent diretory of the file!</comment>
  <return>return <expr><operator>*</operator><name>parent</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>File</name></type> <name><name>SDClass</name><operator>::</operator><name>open</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filepath</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/*

     Open the supplied file path for reading or writing.

     The file content can be accessed via the `file` property of
     the `SDClass` object--this property is currently
     a standard `SdFile` object from `sdfatlib`.

     Defaults to read only.

     If `write` is true, default action (when `append` is true) is to
     append data to the end of the file.

     If `append` is false then the file will be truncated first.

     If the file does not exist and it is opened for writing the file
     will be created.

     An attempt to open a file for reading that does not exist is an
     error.

   */</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>pathidx</name></decl>;</decl_stmt>

  <comment type="line">// do the interative search</comment>
  <decl_stmt><decl><type><name>SdFile</name></type> <name>parentdir</name> <init>= <expr><call><name>getParentDir</name><argument_list>(<argument><expr><name>filepath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pathidx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="line">// no more subdirs!</comment>

  <expr_stmt><expr><name>filepath</name> <operator>+=</operator> <name>pathidx</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>filepath</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
    <comment type="line">// it was the directory itself!</comment>
    <return>return <expr><call><name>File</name><argument_list>(<argument><expr><name>parentdir</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// Open the file itself</comment>
  <decl_stmt><decl><type><name>SdFile</name></type> <name>file</name></decl>;</decl_stmt>

  <comment type="line">// failed to open a subdir!</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>parentdir</name><operator>.</operator><name>isOpen</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>File</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

  <comment type="line">// there is a special case for the Root directory since its a static dir</comment>
  <if_stmt><if>if <condition>(<expr><call><name><name>parentdir</name><operator>.</operator><name>isRoot</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>( <expr><operator>!</operator> <call><name><name>file</name><operator>.</operator><name>open</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>filepath</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <comment type="line">// failed to open the file :(</comment>
      <return>return <expr><call><name>File</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="line">// dont close the root!</comment>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if <condition>( <expr><operator>!</operator> <call><name><name>file</name><operator>.</operator><name>open</name></name><argument_list>(<argument><expr><name>parentdir</name></expr></argument>, <argument><expr><name>filepath</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><call><name>File</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="line">// close the parent</comment>
    <expr_stmt><expr><call><name><name>parentdir</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>mode</name> <operator>&amp;</operator> <operator>(</operator><name>O_APPEND</name> <operator>|</operator> <name>O_WRITE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> 
    <expr_stmt><expr><call><name><name>file</name><operator>.</operator><name>seekSet</name></name><argument_list>(<argument><expr><call><name><name>file</name><operator>.</operator><name>fileSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><call><name>File</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>filepath</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
File SDClass::open(char *filepath, uint8_t mode) {
  //

     Open the supplied file path for reading or writing.

     The file content can be accessed via the `file` property of
     the `SDClass` object--this property is currently
     a standard `SdFile` object from `sdfatlib`.

     Defaults to read only.

     If `write` is true, default action (when `append` is true) is to
     append data to the end of the file.

     If `append` is false then the file will be truncated first.

     If the file does not exist and it is opened for writing the file
     will be created.

     An attempt to open a file for reading that does not exist is an
     error.

   //

  // TODO: Allow for read&amp;write? (Possibly not, as it requires seek.)

  fileOpenMode = mode;
  walkPath(filepath, root, callback_openPath, this);

  return File();

}
*/</comment>


<comment type="line">//boolean SDClass::close() {</comment>
<comment type="line">//  /*</comment>
<comment type="line">//</comment>
<comment type="line">//    Closes the file opened by the `open` method.</comment>
<comment type="line">//</comment>
<comment type="line">//   */</comment>
<comment type="line">//  file.close();</comment>
<comment type="line">//}</comment>


<function><type><name>boolean</name></type> <name><name>SDClass</name><operator>::</operator><name>exists</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filepath</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/*

     Returns true if the supplied file path exists.

   */</comment>
  <return>return <expr><call><name>walkPath</name><argument_list>(<argument><expr><name>filepath</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>callback_pathExists</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="line">//boolean SDClass::exists(char *filepath, SdFile&amp; parentDir) {</comment>
<comment type="line">//  /*</comment>
<comment type="line">//</comment>
<comment type="line">//     Returns true if the supplied file path rooted at `parentDir`</comment>
<comment type="line">//     exists.</comment>
<comment type="line">//</comment>
<comment type="line">//   */</comment>
<comment type="line">//  return walkPath(filepath, parentDir, callback_pathExists);</comment>
<comment type="line">//}</comment>


<function><type><name>boolean</name></type> <name><name>SDClass</name><operator>::</operator><name>mkdir</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filepath</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/*
  
    Makes a single directory or a heirarchy of directories.

    A rough equivalent to `mkdir -p`.
  
   */</comment>
  <return>return <expr><call><name>walkPath</name><argument_list>(<argument><expr><name>filepath</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>callback_makeDirPath</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>boolean</name></type> <name><name>SDClass</name><operator>::</operator><name>rmdir</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filepath</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/*
  
    Remove a single directory or a heirarchy of directories.

    A rough equivalent to `rm -rf`.
  
   */</comment>
  <return>return <expr><call><name>walkPath</name><argument_list>(<argument><expr><name>filepath</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>callback_rmdir</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>boolean</name></type> <name><name>SDClass</name><operator>::</operator><name>remove</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filepath</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>walkPath</name><argument_list>(<argument><expr><name>filepath</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>callback_remove</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="line">// allows you to recurse into a directory</comment>
<function><type><name>File</name></type> <name><name>File</name><operator>::</operator><name>openNextFile</name></name><parameter_list>(<parameter><decl><type><name>uint8_t</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>dir_t</name></type> <name>p</name></decl>;</decl_stmt>

  <comment type="line">//Serial.print("\t\treading dir...");</comment>
  <while>while <condition>(<expr><call><name><name>_file</name><operator>-&gt;</operator><name>readDir</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

    <comment type="line">// done if past last used entry</comment>
    <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>.</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>DIR_NAME_FREE</name></expr>)</condition> <block>{<block_content>
      <comment type="line">//Serial.println("end");</comment>
      <return>return <expr><call><name>File</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// skip deleted entry and entries for . and  ..</comment>
    <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>.</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>DIR_NAME_DELETED</name> <operator>||</operator> <name><name>p</name><operator>.</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>
      <comment type="line">//Serial.println("dots");</comment>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// only list subdirectories and files</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DIR_IS_FILE_OR_SUBDIR</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <comment type="line">//Serial.println("notafile");</comment>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// print file name with possible blank fill</comment>
    <decl_stmt><decl><type><name>SdFile</name></type> <name>f</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><literal type="number">13</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>_file</name><operator>-&gt;</operator><name>dirName</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">//Serial.print("try to open file ");</comment>
    <comment type="line">//Serial.println(name);</comment>

    <if_stmt><if>if <condition>(<expr><call><name><name>f</name><operator>.</operator><name>open</name></name><argument_list>(<argument><expr><name>_file</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <comment type="line">//Serial.println("OK!");</comment>
      <return>return <expr><call><name>File</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>    
    </block_content>}</block></if> <else>else <block>{<block_content>
      <comment type="line">//Serial.println("ugh");</comment>
      <return>return <expr><call><name>File</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>

  <comment type="line">//Serial.println("nothing");</comment>
  <return>return <expr><call><name>File</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>File</name><operator>::</operator><name>rewindDirectory</name></name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>  
  <if_stmt><if>if <condition>(<expr><call><name>isDirectory</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name><name>_file</name><operator>-&gt;</operator><name>rewind</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><name>SDClass</name></type> <name>SD</name></decl>;</decl_stmt>

}</block></namespace><empty_stmt>;</empty_stmt>
</unit>
