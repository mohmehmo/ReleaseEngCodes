<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="/home/mmm/Projects/Arduino/arduino-core/src/processing/app/legacy/PApplet.java"><package>package <name><name>processing</name><operator>.</operator><name>app</name><operator>.</operator><name>legacy</name></name>;</package>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>commons</name><operator>.</operator><name>compress</name><operator>.</operator><name>utils</name><operator>.</operator><name>IOUtils</name></name>;</import>

<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>text</name><operator>.</operator><name>NumberFormat</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>ArrayList</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>StringTokenizer</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>regex</name><operator>.</operator><name>Matcher</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>regex</name><operator>.</operator><name>Pattern</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>zip</name><operator>.</operator><name>GZIPInputStream</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>zip</name><operator>.</operator><name>GZIPOutputStream</name></name>;</import>

<class><specifier>public</specifier> class <name>PApplet</name> <block>{

  <comment type="block" format="javadoc">/** Path to sketch folder */</comment>
  <decl_stmt><decl><type><specifier>public</specifier> <name>String</name></type> <name>sketchPath</name></decl>;</decl_stmt> <comment type="line">//folder;</comment>

  <comment type="block" format="javadoc">/**
   * Full name of the Java version (i.e. 1.5.0_11).
   * Prior to 0125, this was only the first three digits.
   */</comment>
  <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>javaVersionName</name> <init>=
    <expr><call><name><name>System</name><operator>.</operator><name>getProperty</name></name><argument_list>(<argument><expr><literal type="string">"java.version"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/**
   * Version of Java that's in use, whether 1.1 or 1.3 or whatever,
   * stored as a float.
   * &lt;P&gt;
   * Note that because this is stored as a float, the values may
   * not be &lt;EM&gt;exactly&lt;/EM&gt; 1.3 or 1.4. Instead, make sure you're
   * comparing against 1.3f or 1.4f, which will have the same amount
   * of error (i.e. 1.40000001). This could just be a double, but
   * since Processing only uses floats, it's safer for this to be a float
   * because there's no good way to specify a double with the preproc.
   */</comment>
  <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>float</name></type> <name>javaVersion</name> <init>=
    <expr><operator>new</operator> <call><name>Float</name><argument_list>(<argument><expr><call><name><name>javaVersionName</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>floatValue</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/**
   * Current platform in use, one of the
   * PConstants WINDOWS, MACOSX, MACOS9, LINUX or OTHER.
   */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>public</specifier> <name>int</name></type> <name>platform</name></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/**
   * Name associated with the current 'platform' (see PConstants.platformNames)
   */</comment>
  <comment type="line">//static public String platformName;</comment>

  <static>static <block>{<block_content>
    <decl_stmt><decl><type><name>String</name></type> <name>osname</name> <init>= <expr><call><name><name>System</name><operator>.</operator><name>getProperty</name></name><argument_list>(<argument><expr><literal type="string">"os.name"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name><name>osname</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><literal type="string">"Mac"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>platform</name> <operator>=</operator> <name><name>PConstants</name><operator>.</operator><name>MACOSX</name></name></expr>;</expr_stmt>

    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>osname</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><literal type="string">"Windows"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>platform</name> <operator>=</operator> <name><name>PConstants</name><operator>.</operator><name>WINDOWS</name></name></expr>;</expr_stmt>

    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>osname</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><literal type="string">"Linux"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="line">// true for the ibm vm</comment>
      <expr_stmt><expr><name>platform</name> <operator>=</operator> <name><name>PConstants</name><operator>.</operator><name>LINUX</name></name></expr>;</expr_stmt>

    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>platform</name> <operator>=</operator> <name><name>PConstants</name><operator>.</operator><name>OTHER</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></static>

  <comment type="block" format="javadoc">/**
   * Split the provided String at wherever whitespace occurs. Multiple
   * whitespace (extra spaces or tabs or whatever) between items will count as a
   * single break.
   * &lt;P&gt;
   * The whitespace characters are "\t\n\r\f", which are the defaults for
   * java.util.StringTokenizer, plus the unicode non-breaking space character,
   * which is found commonly on files created by or used in conjunction with Mac
   * OS X (character 160, or 0x00A0 in hex).
   * 
   * &lt;PRE&gt;
   * i.e. splitTokens("a b") -&gt; { "a", "b" }
   *      splitTokens("a    b") -&gt; { "a", "b" }
   *      splitTokens("a\tb") -&gt; { "a", "b" }
   *      splitTokens("a \t  b  ") -&gt; { "a", "b" }
   * &lt;/PRE&gt;
   */</comment>
  <function><type><specifier>static</specifier> <specifier>public</specifier> <name><name>String</name><index>[]</index></name></type> <name>splitTokens</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>what</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>splitTokens</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><name><name>PConstants</name><operator>.</operator><name>WHITESPACE</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Splits a string into pieces, using any of the chars in the String 'delim'
   * as separator characters. For instance, in addition to white space, you
   * might want to treat commas as a separator. The delimeter characters won't
   * appear in the returned String array.
   * 
   * &lt;PRE&gt;
   * i.e. splitTokens("a, b", " ,") -&gt; { "a", "b" }
   * &lt;/PRE&gt;
   * 
   * To include all the whitespace possibilities, use the variable WHITESPACE,
   * found in PConstants:
   * 
   * &lt;PRE&gt;
   * i.e. splitTokens("a   | b", WHITESPACE + "|");  -&gt;  { "a", "b" }
   * &lt;/PRE&gt;
   */</comment>
  <function><type><specifier>static</specifier> <specifier>public</specifier> <name><name>String</name><index>[]</index></name></type> <name>splitTokens</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>what</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>delim</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>StringTokenizer</name></type> <name>toker</name> <init>= <expr><operator>new</operator> <call><name>StringTokenizer</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><name>delim</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>String</name></type> <name><name>pieces</name><index>[]</index></name> <init>= <expr><operator>new</operator> <name><name>String</name><index>[<expr><call><name><name>toker</name><operator>.</operator><name>countTokens</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><call><name><name>toker</name><operator>.</operator><name>hasMoreTokens</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pieces</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name><name>toker</name><operator>.</operator><name>nextToken</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>pieces</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Split a string into pieces along a specific character. Most commonly used
   * to break up a String along a space or a tab character.
   * &lt;P&gt;
   * This operates differently than the others, where the single delimeter is
   * the only breaking point, and consecutive delimeters will produce an empty
   * string (""). This way, one can split on tab characters, but maintain the
   * column alignments (of say an excel file) where there are empty columns.
   */</comment>
  <function><type><specifier>static</specifier> <specifier>public</specifier> <name><name>String</name><index>[]</index></name></type> <name>split</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>what</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>delim</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="line">// do this so that the exception occurs inside the user's</comment>
    <comment type="line">// program, rather than appearing to be a bug inside split()</comment>
    <if_stmt><if>if <condition>(<expr><name>what</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>char</name></type> <name><name>chars</name><index>[]</index></name> <init>= <expr><call><name><name>what</name><operator>.</operator><name>toCharArray</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>splitCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="line">// 1;</comment>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>chars</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>delim</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>splitCount</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>splitCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>String</name></type> <name><name>splits</name><index>[]</index></name> <init>= <expr><operator>new</operator> <name><name>String</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>splits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><name>what</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>splits</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>String</name></type> <name><name>splits</name><index>[]</index></name> <init>= <expr><operator>new</operator> <name><name>String</name><index>[<expr><name>splitCount</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>splitIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>startIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>chars</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>delim</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>splits</name><index>[<expr><name>splitIndex</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <name>startIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>splits</name><index>[<expr><name>splitIndex</name></expr>]</index></name> <operator>=</operator> <operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name><name>chars</name><operator>.</operator><name>length</name></name>
                                                       <operator>-</operator> <name>startIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>splits</name></expr>;</return>
  </block_content>}</block></function>

  <function><type><specifier>static</specifier> <specifier>public</specifier> <name><name>String</name><index>[]</index></name></type> <name>subset</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name><name>list</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>String</name></type> <name><name>output</name><index>[]</index></name> <init>= <expr><operator>new</operator> <name><name>String</name><index>[<expr><name>count</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>output</name></expr>;</return>
  </block_content>}</block></function>


  <comment type="block" format="javadoc">/**
   * Join an array of Strings together as a single String,
   * separated by the whatever's passed in for the separator.
   */</comment>
  <function><type><specifier>static</specifier> <specifier>public</specifier> <name>String</name></type> <name>join</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name><name>str</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>separator</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>join</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name><name>String</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>


  <comment type="block" format="javadoc">/**
   * Join an array of Strings together as a single String,
   * separated by the whatever's passed in for the separator.
   * &lt;P&gt;
   * To use this on numbers, first pass the array to nf() or nfs()
   * to get a list of String objects, then use join on that.
   * &lt;PRE&gt;
   * e.g. String stuff[] = { "apple", "bear", "cat" };
   *      String list = join(stuff, ", ");
   *      // list is now "apple, bear, cat"&lt;/PRE&gt;
   */</comment>
  <function><type><specifier>static</specifier> <specifier>public</specifier> <name>String</name></type> <name>join</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name><name>str</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>separator</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>StringBuffer</name></type> <name>buffer</name> <init>= <expr><operator>new</operator> <call><name>StringBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>str</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><call><name><name>buffer</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Parse a String into an int value. Returns 0 if the value is bad.
   */</comment>
  <function><type><specifier>static</specifier> <specifier>final</specifier> <specifier>public</specifier> <name>int</name></type> <name>parseInt</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>what</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>parseInt</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Parse a String to an int, and provide an alternate value that
   * should be used when the number is invalid.
   */</comment>
  <function><type><specifier>static</specifier> <specifier>final</specifier> <specifier>public</specifier> <name>int</name></type> <name>parseInt</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>what</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>otherwise</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <try>try <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><call><name><name>what</name><operator>.</operator><name>indexOf</name></name><argument_list>(<argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name><name>Integer</name><operator>.</operator><name>parseInt</name></name><argument_list>(<argument><expr><name>what</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><call><name><name>Integer</name><operator>.</operator><name>parseInt</name></name><argument_list>(<argument><expr><call><name><name>what</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>NumberFormatException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content> </block_content>}</block></catch></try>
    <return>return <expr><name>otherwise</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Make an array of int elements from an array of String objects.
   * If the String can't be parsed as a number, it will be set to zero.
   *
   * String s[] = { "1", "300", "44" };
   * int numbers[] = parseInt(s);
   *
   * numbers will contain { 1, 300, 44 }
   */</comment>
  <function><type><specifier>static</specifier> <specifier>public</specifier> <name><name>int</name><index>[]</index></name></type> <name>parseInt</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name><name>what</name><index>[]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>parseInt</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Make an array of int elements from an array of String objects.
   * If the String can't be parsed as a number, its entry in the
   * array will be set to the value of the "missing" parameter.
   *
   * String s[] = { "1", "300", "apple", "44" };
   * int numbers[] = parseInt(s, 9999);
   *
   * numbers will contain { 1, 300, 9999, 44 }
   */</comment>
  <function><type><specifier>static</specifier> <specifier>public</specifier> <name><name>int</name><index>[]</index></name></type> <name>parseInt</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name><name>what</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>missing</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name><name>output</name><index>[]</index></name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name><name>what</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>what</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <try>try <block>{<block_content>
        <expr_stmt><expr><name><name>output</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>Integer</name><operator>.</operator><name>parseInt</name></name><argument_list>(<argument><expr><name><name>what</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>NumberFormatException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>output</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>missing</name></expr>;</expr_stmt>
      </block_content>}</block></catch></try>
    </block_content>}</block></for>
    <return>return <expr><name>output</name></expr>;</return>
  </block_content>}</block></function>

  <function><type><specifier>static</specifier> <specifier>public</specifier> <name><name>String</name><index>[]</index></name></type> <name>loadStrings</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>InputStream</name></type> <name>is</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
    <try>try <block>{<block_content>
      <expr_stmt><expr><name>is</name> <operator>=</operator> <call><name>createInput</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>is</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>loadStrings</name><argument_list>(<argument><expr><name>is</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
      <return>return <expr><literal type="null">null</literal></expr>;</return>
    </block_content>}</block> <finally>finally <block>{<block_content>
      <expr_stmt><expr><call><name><name>IOUtils</name><operator>.</operator><name>closeQuietly</name></name><argument_list>(<argument><expr><name>is</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></finally></try>
  </block_content>}</block></function>

  <function><type><specifier>static</specifier> <specifier>public</specifier> <name><name>String</name><index>[]</index></name></type> <name>loadStrings</name><parameter_list>(<parameter><decl><type><name>InputStream</name></type> <name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>BufferedReader</name></type> <name>reader</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
    <try>try <block>{<block_content>
      <expr_stmt><expr><name>reader</name> <operator>=</operator> <operator>new</operator> <call><name>BufferedReader</name><argument_list>(<argument><expr><operator>new</operator> <call><name>InputStreamReader</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="string">"UTF-8"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <decl_stmt><decl><type><name>String</name></type> <name><name>lines</name><index>[]</index></name> <init>= <expr><operator>new</operator> <name><name>String</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>lineCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>String</name></type> <name>line</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
      <while>while <condition>(<expr><operator>(</operator><name>line</name> <operator>=</operator> <call><name><name>reader</name><operator>.</operator><name>readLine</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>lineCount</name> <operator>==</operator> <name><name>lines</name><operator>.</operator><name>length</name></name></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><name>String</name></type> <name><name>temp</name><index>[]</index></name> <init>= <expr><operator>new</operator> <name><name>String</name><index>[<expr><name>lineCount</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>lines</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>temp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lineCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>lines</name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>lines</name><index>[<expr><name>lineCount</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>
      </block_content>}</block></while>

      <if_stmt><if>if <condition>(<expr><name>lineCount</name> <operator>==</operator> <name><name>lines</name><operator>.</operator><name>length</name></name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>lines</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <comment type="line">// resize array to appropriate amount for these lines</comment>
      <decl_stmt><decl><type><name>String</name></type> <name><name>output</name><index>[]</index></name> <init>= <expr><operator>new</operator> <name><name>String</name><index>[<expr><name>lineCount</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>lines</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lineCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>output</name></expr>;</return>

    </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <expr_stmt><expr><call><name><name>e</name><operator>.</operator><name>printStackTrace</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <comment type="line">//throw new RuntimeException("Error inside loadStrings()");</comment>
    </block_content>}</block></catch> <finally>finally <block>{<block_content>
      <expr_stmt><expr><call><name><name>IOUtils</name><operator>.</operator><name>closeQuietly</name></name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></finally></try>
    <return>return <expr><literal type="null">null</literal></expr>;</return>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>saveStrings</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>filename</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name><name>strings</name><index>[]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>saveStrings</name><argument_list>(<argument><expr><call><name>saveFile</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>strings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>


  <function><type><specifier>static</specifier> <specifier>public</specifier> <name>void</name></type> <name>saveStrings</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name><name>strings</name><index>[]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>OutputStream</name></type> <name>outputStream</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
    <try>try <block>{<block_content>
      <expr_stmt><expr><name>outputStream</name> <operator>=</operator> <call><name>createOutput</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>saveStrings</name><argument_list>(<argument><expr><name>outputStream</name></expr></argument>, <argument><expr><name>strings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> <finally>finally <block>{<block_content>
      <expr_stmt><expr><call><name><name>IOUtils</name><operator>.</operator><name>closeQuietly</name></name><argument_list>(<argument><expr><name>outputStream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></finally></try>
  </block_content>}</block></function>


  <function><type><specifier>static</specifier> <specifier>public</specifier> <name>void</name></type> <name>saveStrings</name><parameter_list>(<parameter><decl><type><name>OutputStream</name></type> <name>output</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name><name>strings</name><index>[]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PrintWriter</name></type> <name>writer</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
    <try>try <block>{<block_content>
      <expr_stmt><expr><name>writer</name> <operator>=</operator> <call><name>createWriter</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>writer</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <return>return;</return>
      </block_content>}</block></if></if_stmt>
      <for>for <control>(<init><decl><type><name>String</name></type> <name>string</name> <range>: <expr><name>strings</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>writer</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name><name>writer</name><operator>.</operator><name>flush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> <finally>finally <block>{<block_content>
      <expr_stmt><expr><call><name><name>IOUtils</name><operator>.</operator><name>closeQuietly</name></name><argument_list>(<argument><expr><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></finally></try>
  </block_content>}</block></function>


  <function><type><specifier>static</specifier> <specifier>public</specifier> <name><name>int</name><index>[]</index></name></type> <name>expand</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name><name>list</name><index>[]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>expand</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>list</name><operator>.</operator><name>length</name></name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <function><type><specifier>static</specifier> <specifier>public</specifier> <name><name>int</name><index>[]</index></name></type> <name>expand</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name><name>list</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>newSize</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name><name>temp</name><index>[]</index></name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name>newSize</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>temp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>Math</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><name>newSize</name></expr></argument>, <argument><expr><name><name>list</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>temp</name></expr>;</return>
  </block_content>}</block></function>

  <function><type><specifier>static</specifier> <specifier>final</specifier> <specifier>public</specifier> <name>String</name></type> <name>hex</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>what</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>digits</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>String</name></type> <name>stuff</name> <init>= <expr><call><name><name>Integer</name><operator>.</operator><name>toHexString</name></name><argument_list>(<argument><expr><name>what</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>toUpperCase</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>length</name> <init>= <expr><call><name><name>stuff</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>length</name> <operator>&gt;</operator> <name>digits</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><call><name><name>stuff</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>length</name> <operator>-</operator> <name>digits</name></expr></argument>)</argument_list></call></expr>;</return>

    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>length</name> <operator>&lt;</operator> <name>digits</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><literal type="string">"00000000"</literal><operator>.</operator><call><name>substring</name><argument_list>(<argument><expr><literal type="number">8</literal> <operator>-</operator> <operator>(</operator><name>digits</name><operator>-</operator><name>length</name><operator>)</operator></expr></argument>)</argument_list></call> <operator>+</operator> <name>stuff</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>stuff</name></expr>;</return>
  </block_content>}</block></function>

  <function><type><specifier>static</specifier> <specifier>public</specifier> <specifier>final</specifier> <name>int</name></type> <name>constrain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>amt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>low</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>high</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><ternary><condition><expr><operator>(</operator><name>amt</name> <operator>&lt;</operator> <name>low</name><operator>)</operator></expr> ?</condition><then> <expr><name>low</name></expr> </then><else>: <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>amt</name> <operator>&gt;</operator> <name>high</name><operator>)</operator></expr> ?</condition><then> <expr><name>high</name></expr> </then><else>: <expr><name>amt</name></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</return>
  </block_content>}</block></function>

  <function><type><specifier>static</specifier> <specifier>public</specifier> <specifier>final</specifier> <name>float</name></type> <name>constrain</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>amt</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>low</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>high</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><ternary><condition><expr><operator>(</operator><name>amt</name> <operator>&lt;</operator> <name>low</name><operator>)</operator></expr> ?</condition><then> <expr><name>low</name></expr> </then><else>: <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>amt</name> <operator>&gt;</operator> <name>high</name><operator>)</operator></expr> ?</condition><then> <expr><name>high</name></expr> </then><else>: <expr><name>amt</name></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Attempts to open an application or file using your platform's launcher. The &lt;b&gt;file&lt;/b&gt; parameter is a String specifying the file name and location. The location parameter must be a full path name, or the name of an executable in the system's PATH. In most cases, using a full path is the best option, rather than relying on the system PATH. Be sure to make the file executable before attempting to open it (chmod +x).
   * &lt;br&gt;&lt;br&gt;
   * The &lt;b&gt;args&lt;/b&gt; parameter is a String or String array which is passed to the command line. If you have multiple parameters, e.g. an application and a document, or a command with multiple switches, use the version that takes a String array, and place each individual item in a separate element.
   * &lt;br&gt;&lt;br&gt;
   * If args is a String (not an array), then it can only be a single file or application with no parameters. It's not the same as executing that String using a shell. For instance, open("jikes -help") will not work properly.
   * &lt;br&gt;&lt;br&gt;
   * This function behaves differently on each platform. On Windows, the parameters are sent to the Windows shell via "cmd /c". On Mac OS X, the "open" command is used (type "man open" in Terminal.app for documentation). On Linux, it first tries gnome-open, then kde-open, but if neither are available, it sends the command to the shell without any alterations.
   * &lt;br&gt;&lt;br&gt;
   * For users familiar with Java, this is not quite the same as Runtime.exec(), because the launcher command is prepended. Instead, the &lt;b&gt;exec(String[])&lt;/b&gt; function is a shortcut for Runtime.getRuntime.exec(String[]).
   *
   * @webref input:files
   * @param filename name of the file
   * @usage Application
   */</comment>
  <function><type><specifier>static</specifier> <specifier>public</specifier> <name>void</name></type> <name>open</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>filename</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>open</name><argument_list>(<argument><expr><operator>new</operator> <name><name>String</name><index>[]</index></name> <block>{ <expr><name>filename</name></expr> }</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <decl_stmt><decl><type><specifier>static</specifier> <name>String</name></type> <name>openLauncher</name></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/**
   * Launch a process using a platforms shell. This version uses an array
   * to make it easier to deal with spaces in the individual elements.
   * (This avoids the situation of trying to put single or double quotes
   * around different bits).
   *
   * @param list of commands passed to the command line
   */</comment>
  <function><type><specifier>static</specifier> <specifier>public</specifier> <name>Process</name></type> <name>open</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>String</name><index>[]</index></name></type> <name>params</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>platform</name> <operator>==</operator> <name><name>PConstants</name><operator>.</operator><name>WINDOWS</name></name></expr>)</condition> <block>{<block_content>
      <comment type="line">// just launching the .html file via the shell works</comment>
      <comment type="line">// but make sure to chmod +x the .html files first</comment>
      <comment type="line">// also place quotes around it in case there's a space</comment>
      <comment type="line">// in the user.dir part of the url</comment>
      <expr_stmt><expr><name>params</name> <operator>=</operator> <operator>new</operator> <name><name>String</name><index>[]</index></name> <block>{ <expr><literal type="string">"cmd"</literal></expr>, <expr><literal type="string">"/c"</literal></expr> }</block></expr>;</expr_stmt>

    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>platform</name> <operator>==</operator> <name><name>PConstants</name><operator>.</operator><name>MACOSX</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>params</name> <operator>=</operator> <operator>new</operator> <name><name>String</name><index>[]</index></name> <block>{ <expr><literal type="string">"open"</literal></expr> }</block></expr>;</expr_stmt>

    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>platform</name> <operator>==</operator> <name><name>PConstants</name><operator>.</operator><name>LINUX</name></name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>openLauncher</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// Attempt to use gnome-open</comment>
        <try>try <block>{<block_content>
          <decl_stmt><decl><type><name>Process</name></type> <name>p</name> <init>= <expr><call><name><name>Runtime</name><operator>.</operator><name>getRuntime</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>exec</name><argument_list>(<argument><expr><operator>new</operator> <name><name>String</name><index>[]</index></name> <block>{ <expr><literal type="string">"gnome-open"</literal></expr> }</block></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <comment type="block">/*int result =*/</comment> <expr_stmt><expr><call><name><name>p</name><operator>.</operator><name>waitFor</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <comment type="line">// Not installed will throw an IOException (JDK 1.4.2, Ubuntu 7.04)</comment>
          <expr_stmt><expr><name>openLauncher</name> <operator>=</operator> <literal type="string">"gnome-open"</literal></expr>;</expr_stmt>
        </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content> </block_content>}</block></catch></try>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>openLauncher</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// Attempt with kde-open</comment>
        <try>try <block>{<block_content>
          <decl_stmt><decl><type><name>Process</name></type> <name>p</name> <init>= <expr><call><name><name>Runtime</name><operator>.</operator><name>getRuntime</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>exec</name><argument_list>(<argument><expr><operator>new</operator> <name><name>String</name><index>[]</index></name> <block>{ <expr><literal type="string">"kde-open"</literal></expr> }</block></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <comment type="block">/*int result =*/</comment> <expr_stmt><expr><call><name><name>p</name><operator>.</operator><name>waitFor</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>openLauncher</name> <operator>=</operator> <literal type="string">"kde-open"</literal></expr>;</expr_stmt>
        </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content> </block_content>}</block></catch></try>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>openLauncher</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>err</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"Could not find gnome-open or kde-open, "</literal> <operator>+</operator>
                           <literal type="string">"the open() command may not work."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>openLauncher</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>params</name> <operator>=</operator> <operator>new</operator> <name><name>String</name><index>[]</index></name> <block>{ <expr><name>openLauncher</name></expr> }</block></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <comment type="line">//} else {  // give up and just pass it to Runtime.exec()</comment>
      <comment type="line">//open(new String[] { filename });</comment>
      <comment type="line">//params = new String[] { filename };</comment>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>params</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <comment type="line">// If the 'open', 'gnome-open' or 'cmd' are already included</comment>
      <if_stmt><if>if <condition>(<expr><name><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="line">// then don't prepend those params again</comment>
        <return>return <expr><call><name>exec</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>params</name> <operator>=</operator> <call><name>concat</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>exec</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <return>return <expr><call><name>exec</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></function>

  <function><type><specifier>static</specifier> <specifier>public</specifier> <name>Process</name></type> <name>exec</name><parameter_list>(<parameter><decl><type><name><name>String</name><index>[]</index></name></type> <name>argv</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <try>try <block>{<block_content>
      <return>return <expr><call><name><name>Runtime</name><operator>.</operator><name>getRuntime</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>exec</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <expr_stmt><expr><call><name><name>e</name><operator>.</operator><name>printStackTrace</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <throw>throw <expr><operator>new</operator> <call><name>RuntimeException</name><argument_list>(<argument><expr><literal type="string">"Could not open "</literal> <operator>+</operator> <call><name>join</name><argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></catch></try>
  </block_content>}</block></function>

  <function><type><specifier>static</specifier> <specifier>public</specifier> <name><name>String</name><index>[]</index></name></type> <name>concat</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name><name>a</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name><name>b</name><index>[]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>String</name></type> <name><name>c</name><index>[]</index></name> <init>= <expr><operator>new</operator> <name><name>String</name><index>[<expr><name><name>a</name><operator>.</operator><name>length</name></name> <operator>+</operator> <name><name>b</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>a</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>a</name><operator>.</operator><name>length</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>c</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Identical to match(), except that it returns an array of all matches in
   * the specified String, rather than just the first.
   */</comment>
  <function><type><specifier>static</specifier> <specifier>public</specifier> <name><name>String</name><index>[]</index><index>[]</index></name></type> <name>matchAll</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>what</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>regexp</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>Pattern</name></type> <name>p</name> <init>= <expr><call><name><name>Pattern</name><operator>.</operator><name>compile</name></name><argument_list>(<argument><expr><name>regexp</name></expr></argument>, <argument><expr><name><name>Pattern</name><operator>.</operator><name>MULTILINE</name></name> <operator>|</operator> <name><name>Pattern</name><operator>.</operator><name>DOTALL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Matcher</name></type> <name>m</name> <init>= <expr><call><name><name>p</name><operator>.</operator><name>matcher</name></name><argument_list>(<argument><expr><name>what</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name><name>String</name><index>[]</index></name></argument>&gt;</argument_list></name></type> <name>results</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><call><name><name>m</name><operator>.</operator><name>groupCount</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><call><name><name>m</name><operator>.</operator><name>find</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name><name>String</name><index>[]</index></name></type> <name>groups</name> <init>= <expr><operator>new</operator> <name><name>String</name><index>[<expr><name>count</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>groups</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>m</name><operator>.</operator><name>group</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name><name>results</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><call><name><name>results</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><literal type="null">null</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name><name>String</name><index>[]</index><index>[]</index></name></type> <name>matches</name> <init>= <expr><operator>new</operator> <name><name>String</name><index>[<expr><call><name><name>results</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index><index>[<expr><name>count</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>matches</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><name><name>matches</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>results</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>matches</name></expr>;</return>
  </block_content>}</block></function>
  
  <comment type="block" format="javadoc">/**
   * Match a string with a regular expression, and returns the match as an
   * array. The first index is the matching expression, and array elements
   * [1] and higher represent each of the groups (sequences found in parens).
   *
   * This uses multiline matching (Pattern.MULTILINE) and dotall mode
   * (Pattern.DOTALL) by default, so that ^ and $ match the beginning and
   * end of any lines found in the source, and the . operator will also
   * pick up newline characters.
   */</comment>
  <function><type><specifier>static</specifier> <specifier>public</specifier> <name><name>String</name><index>[]</index></name></type> <name>match</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>what</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>regexp</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>Pattern</name></type> <name>p</name> <init>= <expr><call><name><name>Pattern</name><operator>.</operator><name>compile</name></name><argument_list>(<argument><expr><name>regexp</name></expr></argument>, <argument><expr><name><name>Pattern</name><operator>.</operator><name>MULTILINE</name></name> <operator>|</operator> <name><name>Pattern</name><operator>.</operator><name>DOTALL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>match</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <function><type><specifier>static</specifier> <specifier>public</specifier> <name><name>String</name><index>[]</index></name></type> <name>match</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>what</name></decl></parameter>, <parameter><decl><type><name>Pattern</name></type> <name>pattern</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>Matcher</name></type> <name>m</name> <init>= <expr><call><name><name>pattern</name><operator>.</operator><name>matcher</name></name><argument_list>(<argument><expr><name>what</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>m</name><operator>.</operator><name>find</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><call><name><name>m</name><operator>.</operator><name>groupCount</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name><name>String</name><index>[]</index></name></type> <name>groups</name> <init>= <expr><operator>new</operator> <name><name>String</name><index>[<expr><name>count</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>groups</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>m</name><operator>.</operator><name>group</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <return>return <expr><name>groups</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="null">null</literal></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Integer number formatter.
   */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>private</specifier> <name>NumberFormat</name></type> <name>int_nf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>private</specifier> <name>int</name></type> <name>int_nf_digits</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>private</specifier> <name>boolean</name></type> <name>int_nf_commas</name></decl>;</decl_stmt>

  <function><type><specifier>static</specifier> <specifier>public</specifier> <name><name>String</name><index>[]</index></name></type> <name>nf</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name><name>num</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>digits</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>String</name></type> <name><name>formatted</name><index>[]</index></name> <init>= <expr><operator>new</operator> <name><name>String</name><index>[<expr><name><name>num</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>formatted</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><name><name>formatted</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>nf</name><argument_list>(<argument><expr><name><name>num</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>digits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>formatted</name></expr>;</return>
  </block_content>}</block></function>

  <function><type><specifier>static</specifier> <specifier>public</specifier> <name>String</name></type> <name>nf</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>digits</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int_nf</name> <operator>!=</operator> <literal type="null">null</literal><operator>)</operator> <operator>&amp;&amp;</operator>
        <operator>(</operator><name>int_nf_digits</name> <operator>==</operator> <name>digits</name><operator>)</operator> <operator>&amp;&amp;</operator>
        <operator>!</operator><name>int_nf_commas</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><call><name><name>int_nf</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>int_nf</name> <operator>=</operator> <call><name><name>NumberFormat</name><operator>.</operator><name>getInstance</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>int_nf</name><operator>.</operator><name>setGroupingUsed</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// no commas</comment>
    <expr_stmt><expr><name>int_nf_commas</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>int_nf</name><operator>.</operator><name>setMinimumIntegerDigits</name></name><argument_list>(<argument><expr><name>digits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>int_nf_digits</name> <operator>=</operator> <name>digits</name></expr>;</expr_stmt>
    <return>return <expr><call><name><name>int_nf</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <function><type><specifier>static</specifier> <specifier>final</specifier> <specifier>public</specifier> <name><name>String</name><index>[]</index></name></type> <name>str</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name><name>x</name><index>[]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>String</name></type> <name><name>s</name><index>[]</index></name> <init>= <expr><operator>new</operator> <name><name>String</name><index>[<expr><name><name>x</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>x</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>String</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name><name>x</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <return>return <expr><name>s</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * I want to print lines to a file. I have RSI from typing these
   * eight lines of code so many times.
   * @throws IOException
   */</comment>
  <function><type><specifier>static</specifier> <specifier>public</specifier> <name>PrintWriter</name></type> <name>createWriter</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><call><name>createPath</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="line">// make sure in-between folders exist</comment>
    <decl_stmt><decl><type><name>OutputStream</name></type> <name>output</name> <init>= <expr><operator>new</operator> <call><name>FileOutputStream</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <try>try <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name><name>file</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>toLowerCase</name><argument_list>()</argument_list></call><operator>.</operator><call><name>endsWith</name><argument_list>(<argument><expr><literal type="string">".gz"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>output</name> <operator>=</operator> <operator>new</operator> <call><name>GZIPOutputStream</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <expr_stmt><expr><call><name><name>output</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <throw>throw <expr><name>e</name></expr>;</throw>
    </block_content>}</block></catch></try>
    <return>return <expr><call><name>createWriter</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>


  <comment type="block" format="javadoc">/**
   * I want to print lines to a file. Why am I always explaining myself?
   * It's the JavaSoft API engineers who need to explain themselves.
   */</comment>
  <function><type><specifier>static</specifier> <specifier>public</specifier> <name>PrintWriter</name></type> <name>createWriter</name><parameter_list>(<parameter><decl><type><name>OutputStream</name></type> <name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <try>try <block>{<block_content>
      <decl_stmt><decl><type><name>OutputStreamWriter</name></type> <name>osw</name> <init>= <expr><operator>new</operator> <call><name>OutputStreamWriter</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><literal type="string">"UTF-8"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <return>return <expr><operator>new</operator> <call><name>PrintWriter</name><argument_list>(<argument><expr><name>osw</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>UnsupportedEncodingException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content> </block_content>}</block></catch></try>  <comment type="line">// not gonna happen</comment>
    <return>return <expr><literal type="null">null</literal></expr>;</return>
  </block_content>}</block></function>
  
  <function><type><specifier>static</specifier> <specifier>public</specifier> <name>InputStream</name></type> <name>createInput</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"File passed to createInput() was null"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>
    <try>try <block>{<block_content>
      <decl_stmt><decl><type><name>InputStream</name></type> <name>input</name> <init>= <expr><operator>new</operator> <call><name>FileInputStream</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name><name>file</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>toLowerCase</name><argument_list>()</argument_list></call><operator>.</operator><call><name>endsWith</name><argument_list>(<argument><expr><literal type="string">".gz"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><operator>new</operator> <call><name>GZIPInputStream</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>input</name></expr>;</return>

    </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>err</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"Could not createInput() for "</literal> <operator>+</operator> <name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>e</name><operator>.</operator><name>printStackTrace</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="null">null</literal></expr>;</return>
    </block_content>}</block></catch></try>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Returns a path inside the applet folder to save to. Like sketchPath(),
   * but creates any in-between folders so that things save properly.
   * &lt;p/&gt;
   * All saveXxxx() functions use the path to the sketch folder, rather than
   * its data folder. Once exported, the data folder will be found inside the
   * jar file of the exported application or applet. In this case, it's not
   * possible to save data into the jar file, because it will often be running
   * from a server, or marked in-use if running from a local file system.
   * With this in mind, saving to the data path doesn't make sense anyway.
   * If you know you're running locally, and want to save to the data folder,
   * use &lt;TT&gt;saveXxxx("data/blah.dat")&lt;/TT&gt;.
   */</comment>
  <function><type><specifier>public</specifier> <name>String</name></type> <name>savePath</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>where</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>where</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>String</name></type> <name>filename</name> <init>= <expr><call><name>sketchPath</name><argument_list>(<argument><expr><name>where</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>createPath</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>filename</name></expr>;</return>
  </block_content>}</block></function>


  <comment type="block" format="javadoc">/**
   * Identical to savePath(), but returns a File object.
   */</comment>
  <function><type><specifier>public</specifier> <name>File</name></type> <name>saveFile</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>where</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><operator>new</operator> <call><name>File</name><argument_list>(<argument><expr><call><name>savePath</name><argument_list>(<argument><expr><name>where</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Similar to createInput() (formerly openStream), this creates a Java
   * OutputStream for a given filename or path. The file will be created in
   * the sketch folder, or in the same folder as an exported application.
   * &lt;p/&gt;
   * If the path does not exist, intermediate folders will be created. If an
   * exception occurs, it will be printed to the console, and null will be
   * returned.
   * &lt;p/&gt;
   * Future releases may also add support for handling HTTP POST via this
   * method (for better symmetry with createInput), however that's maybe a
   * little too clever (and then we'd have to add the same features to the
   * other file functions like createWriter). Who you callin' bloated?
   */</comment>
  <function><type><specifier>public</specifier> <name>OutputStream</name></type> <name>createOutput</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>filename</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>createOutput</name><argument_list>(<argument><expr><call><name>saveFile</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>


  <function><type><specifier>static</specifier> <specifier>public</specifier> <name>OutputStream</name></type> <name>createOutput</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <try>try <block>{<block_content>
      <expr_stmt><expr><call><name>createPath</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="line">// make sure the path exists</comment>
      <decl_stmt><decl><type><name>FileOutputStream</name></type> <name>fos</name> <init>= <expr><operator>new</operator> <call><name>FileOutputStream</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name><name>file</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>toLowerCase</name><argument_list>()</argument_list></call><operator>.</operator><call><name>endsWith</name><argument_list>(<argument><expr><literal type="string">".gz"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><operator>new</operator> <call><name>GZIPOutputStream</name><argument_list>(<argument><expr><name>fos</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>fos</name></expr>;</return>

    </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <expr_stmt><expr><call><name><name>e</name><operator>.</operator><name>printStackTrace</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></catch></try>
    <return>return <expr><literal type="null">null</literal></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Prepend the sketch folder path to the filename (or path) that is
   * passed in. External libraries should use this function to save to
   * the sketch folder.
   * &lt;p/&gt;
   * Note that when running as an applet inside a web browser,
   * the sketchPath will be set to null, because security restrictions
   * prevent applets from accessing that information.
   * &lt;p/&gt;
   * This will also cause an error if the sketch is not inited properly,
   * meaning that init() was never called on the PApplet when hosted
   * my some other main() or by other code. For proper use of init(),
   * see the examples in the main description text for PApplet.
   */</comment>
  <function><type><specifier>public</specifier> <name>String</name></type> <name>sketchPath</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>where</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>sketchPath</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>where</name></expr>;</return>
<comment type="line">//      throw new RuntimeException("The applet was not inited properly, " +</comment>
<comment type="line">//                                 "or security restrictions prevented " +</comment>
<comment type="line">//                                 "it from determining its path.");</comment>
    </block_content>}</block></if></if_stmt>
    <comment type="line">// isAbsolute() could throw an access exception, but so will writing</comment>
    <comment type="line">// to the local disk using the sketch path, so this is safe here.</comment>
    <comment type="line">// for 0120, added a try/catch anyways.</comment>
    <try>try <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>new</operator> <call><name>File</name><argument_list>(<argument><expr><name>where</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>isAbsolute</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>where</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content> </block_content>}</block></catch></try>

    <return>return <expr><name>sketchPath</name> <operator>+</operator> <name><name>File</name><operator>.</operator><name>separator</name></name> <operator>+</operator> <name>where</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Takes a path and creates any in-between folders if they don't
   * already exist. Useful when trying to save to a subfolder that
   * may not actually exist.
   */</comment>
  <function><type><specifier>static</specifier> <specifier>public</specifier> <name>void</name></type> <name>createPath</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>path</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>createPath</name><argument_list>(<argument><expr><operator>new</operator> <call><name>File</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>


  <function><type><specifier>static</specifier> <specifier>public</specifier> <name>void</name></type> <name>createPath</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <try>try <block>{<block_content>
      <decl_stmt><decl><type><name>String</name></type> <name>parent</name> <init>= <expr><call><name><name>file</name><operator>.</operator><name>getParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>parent</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>File</name></type> <name>unit</name> <init>= <expr><operator>new</operator> <call><name>File</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>unit</name><operator>.</operator><name>exists</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>unit</name><operator>.</operator><name>mkdirs</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>SecurityException</name></type> <name>se</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>err</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"You don't have permissions to create "</literal> <operator>+</operator>
                         <call><name><name>file</name><operator>.</operator><name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></catch></try>
  </block_content>}</block></function>


}</block></class>
</unit>
