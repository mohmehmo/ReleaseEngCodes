<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/mmm/Projects/Arduino/app/testdata/libraries/SD_1.1.1/SD/src/utility/SdFat.h"><comment type="block">/* Arduino SdFat Library
 * Copyright (C) 2009 by William Greiman
 *
 * This file is part of the Arduino SdFat Library
 *
 * This Library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This Library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with the Arduino SdFat Library.  If not, see
 * &lt;http://www.gnu.org/licenses/&gt;.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SdFat_h</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SdFat_h</name></cpp:macro></cpp:define>
<comment type="block" format="doxygen">/**
 * \file
 * SdFile and SdVolume classes
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>__AVR__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name> <argument_list>(<argument><expr><name>__CPU_ARC__</name></expr></argument>)</argument_list></call></expr></cpp:if> 
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;avr/pgmspace.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Sd2Card.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"FatStructs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Print.h"</cpp:file></cpp:include>
<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="block" format="doxygen">/**
 * Allow use of deprecated functions if non-zero
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALLOW_DEPRECATED_FUNCTIONS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// forward declaration since SdVolume is used in SdFile</comment>
<decl_stmt><decl><type><name>class</name></type> <name>SdVolume</name></decl>;</decl_stmt>
<comment type="line">//==============================================================================</comment>
<comment type="line">// SdFile class</comment>

<comment type="line">// flags for ls()</comment>
<comment type="block" format="doxygen">/** ls() flag to print modify date */</comment>
<decl_stmt><decl><type><name>uint8_t</name> <specifier>const</specifier></type> <name>LS_DATE</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** ls() flag to print file size */</comment>
<decl_stmt><decl><type><name>uint8_t</name> <specifier>const</specifier></type> <name>LS_SIZE</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** ls() flag for recursive list of subdirectories */</comment>
<decl_stmt><decl><type><name>uint8_t</name> <specifier>const</specifier></type> <name>LS_R</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>

<comment type="line">// use the gnu style oflag in open()</comment>
<comment type="block" format="doxygen">/** open() oflag for reading */</comment>
<decl_stmt><decl><type><name>uint8_t</name> <specifier>const</specifier></type> <name>O_READ</name> <init>= <expr><literal type="number">0X01</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** open() oflag - same as O_READ */</comment>
<decl_stmt><decl><type><name>uint8_t</name> <specifier>const</specifier></type> <name>O_RDONLY</name> <init>= <expr><name>O_READ</name></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** open() oflag for write */</comment>
<decl_stmt><decl><type><name>uint8_t</name> <specifier>const</specifier></type> <name>O_WRITE</name> <init>= <expr><literal type="number">0X02</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** open() oflag - same as O_WRITE */</comment>
<decl_stmt><decl><type><name>uint8_t</name> <specifier>const</specifier></type> <name>O_WRONLY</name> <init>= <expr><name>O_WRITE</name></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** open() oflag for reading and writing */</comment>
<decl_stmt><decl><type><name>uint8_t</name> <specifier>const</specifier></type> <name>O_RDWR</name> <init>= <expr><operator>(</operator><name>O_READ</name> <operator>|</operator> <name>O_WRITE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** open() oflag mask for access modes */</comment>
<decl_stmt><decl><type><name>uint8_t</name> <specifier>const</specifier></type> <name>O_ACCMODE</name> <init>= <expr><operator>(</operator><name>O_READ</name> <operator>|</operator> <name>O_WRITE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** The file offset shall be set to the end of the file prior to each write. */</comment>
<decl_stmt><decl><type><name>uint8_t</name> <specifier>const</specifier></type> <name>O_APPEND</name> <init>= <expr><literal type="number">0X04</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** synchronous writes - call sync() after each write */</comment>
<decl_stmt><decl><type><name>uint8_t</name> <specifier>const</specifier></type> <name>O_SYNC</name> <init>= <expr><literal type="number">0X08</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** create the file if nonexistent */</comment>
<decl_stmt><decl><type><name>uint8_t</name> <specifier>const</specifier></type> <name>O_CREAT</name> <init>= <expr><literal type="number">0X10</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** If O_CREAT and O_EXCL are set, open() shall fail if the file exists */</comment>
<decl_stmt><decl><type><name>uint8_t</name> <specifier>const</specifier></type> <name>O_EXCL</name> <init>= <expr><literal type="number">0X20</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** truncate the file to zero length */</comment>
<decl_stmt><decl><type><name>uint8_t</name> <specifier>const</specifier></type> <name>O_TRUNC</name> <init>= <expr><literal type="number">0X40</literal></expr></init></decl>;</decl_stmt>

<comment type="line">// flags for timestamp</comment>
<comment type="block" format="doxygen">/** set the file's last access date */</comment>
<decl_stmt><decl><type><name>uint8_t</name> <specifier>const</specifier></type> <name>T_ACCESS</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** set the file's creation date and time */</comment>
<decl_stmt><decl><type><name>uint8_t</name> <specifier>const</specifier></type> <name>T_CREATE</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** Set the file's write date and time */</comment>
<decl_stmt><decl><type><name>uint8_t</name> <specifier>const</specifier></type> <name>T_WRITE</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>
<comment type="line">// values for type_</comment>
<comment type="block" format="doxygen">/** This SdFile has not been opened. */</comment>
<decl_stmt><decl><type><name>uint8_t</name> <specifier>const</specifier></type> <name>FAT_FILE_TYPE_CLOSED</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** SdFile for a file */</comment>
<decl_stmt><decl><type><name>uint8_t</name> <specifier>const</specifier></type> <name>FAT_FILE_TYPE_NORMAL</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** SdFile for a FAT16 root directory */</comment>
<decl_stmt><decl><type><name>uint8_t</name> <specifier>const</specifier></type> <name>FAT_FILE_TYPE_ROOT16</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** SdFile for a FAT32 root directory */</comment>
<decl_stmt><decl><type><name>uint8_t</name> <specifier>const</specifier></type> <name>FAT_FILE_TYPE_ROOT32</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** SdFile for a subdirectory */</comment>
<decl_stmt><decl><type><name>uint8_t</name> <specifier>const</specifier></type> <name>FAT_FILE_TYPE_SUBDIR</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** Test value for directory type */</comment>
<decl_stmt><decl><type><name>uint8_t</name> <specifier>const</specifier></type> <name>FAT_FILE_TYPE_MIN_DIR</name> <init>= <expr><name>FAT_FILE_TYPE_ROOT16</name></expr></init></decl>;</decl_stmt>

<comment type="block" format="doxygen">/** date field for FAT directory entry */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint16_t</name></type> <name>FAT_DATE</name><parameter_list>(<parameter><decl><type><name>uint16_t</name></type> <name>year</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>month</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>day</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><operator>(</operator><name>year</name> <operator>-</operator> <literal type="number">1980</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">9</literal> <operator>|</operator> <name>month</name> <operator>&lt;&lt;</operator> <literal type="number">5</literal> <operator>|</operator> <name>day</name></expr>;</return>
</block_content>}</block></function>
<comment type="block" format="doxygen">/** year part of FAT directory date field */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint16_t</name></type> <name>FAT_YEAR</name><parameter_list>(<parameter><decl><type><name>uint16_t</name></type> <name>fatDate</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><literal type="number">1980</literal> <operator>+</operator> <operator>(</operator><name>fatDate</name> <operator>&gt;&gt;</operator> <literal type="number">9</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<comment type="block" format="doxygen">/** month part of FAT directory date field */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint8_t</name></type> <name>FAT_MONTH</name><parameter_list>(<parameter><decl><type><name>uint16_t</name></type> <name>fatDate</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><operator>(</operator><name>fatDate</name> <operator>&gt;&gt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0XF</literal></expr>;</return>
</block_content>}</block></function>
<comment type="block" format="doxygen">/** day part of FAT directory date field */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint8_t</name></type> <name>FAT_DAY</name><parameter_list>(<parameter><decl><type><name>uint16_t</name></type> <name>fatDate</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><name>fatDate</name> <operator>&amp;</operator> <literal type="number">0X1F</literal></expr>;</return>
</block_content>}</block></function>
<comment type="block" format="doxygen">/** time field for FAT directory entry */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint16_t</name></type> <name>FAT_TIME</name><parameter_list>(<parameter><decl><type><name>uint8_t</name></type> <name>hour</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>minute</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>second</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><name>hour</name> <operator>&lt;&lt;</operator> <literal type="number">11</literal> <operator>|</operator> <name>minute</name> <operator>&lt;&lt;</operator> <literal type="number">5</literal> <operator>|</operator> <name>second</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<comment type="block" format="doxygen">/** hour part of FAT directory time field */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint8_t</name></type> <name>FAT_HOUR</name><parameter_list>(<parameter><decl><type><name>uint16_t</name></type> <name>fatTime</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><name>fatTime</name> <operator>&gt;&gt;</operator> <literal type="number">11</literal></expr>;</return>
</block_content>}</block></function>
<comment type="block" format="doxygen">/** minute part of FAT directory time field */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint8_t</name></type> <name>FAT_MINUTE</name><parameter_list>(<parameter><decl><type><name>uint16_t</name></type> <name>fatTime</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return<expr><operator>(</operator><name>fatTime</name> <operator>&gt;&gt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0X3F</literal></expr>;</return>
</block_content>}</block></function>
<comment type="block" format="doxygen">/** second part of FAT directory time field */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint8_t</name></type> <name>FAT_SECOND</name><parameter_list>(<parameter><decl><type><name>uint16_t</name></type> <name>fatTime</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><literal type="number">2</literal><operator>*</operator><operator>(</operator><name>fatTime</name> <operator>&amp;</operator> <literal type="number">0X1F</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<comment type="block" format="doxygen">/** Default date for file timestamps is 1 Jan 2000 */</comment>
<decl_stmt><decl><type><name>uint16_t</name> <specifier>const</specifier></type> <name>FAT_DEFAULT_DATE</name> <init>= <expr><operator>(</operator><operator>(</operator><literal type="number">2000</literal> <operator>-</operator> <literal type="number">1980</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">9</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>|</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** Default time for file timestamp is 1 am */</comment>
<decl_stmt><decl><type><name>uint16_t</name> <specifier>const</specifier></type> <name>FAT_DEFAULT_TIME</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">11</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="block" format="doxygen">/**
 * \class SdFile
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */</comment>
<decl_stmt><decl><type><name>class</name></type> <name>SdFile</name> <range>: <expr><name>public</name> <name>Print</name> <block>{
 <expr><name>public</name><operator>:</operator>
  <comment type="block" format="doxygen">/** Create an instance of SdFile. */</comment>
  <call><name>SdFile</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>type_</name><argument_list>(<argument>FAT_FILE_TYPE_CLOSED</argument>)</argument_list></macro> <block>{}</block>
  <comment type="block" format="doxygen">/**
   * writeError is set to true if an error occurs during a write().
   * Set writeError to false before calling print() and/or write() and check
   * for true after calls to print() and/or write().
   */</comment>
  <comment type="line">//bool writeError;</comment>
  <comment type="block" format="doxygen">/**
   * Cancel unbuffered reads for this file.
   * See setUnbufferedRead()
   */</comment>
  <name>void</name> <macro><name>clearUnbufferedRead</name><argument_list>(<argument>void</argument>)</argument_list></macro> <block>{
    <expr><name>flags_</name> <operator>&amp;=</operator> <operator>~</operator><name>F_FILE_UNBUFFERED_READ</name></expr>;
  }</block>
  <name>uint8_t</name> <call><name>close</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>uint8_t</name> <call><name>contiguousRange</name><argument_list>(<argument><expr><name>uint32_t</name><operator>*</operator> <name>bgnBlock</name></expr></argument>, <argument><expr><name>uint32_t</name><operator>*</operator> <name>endBlock</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>uint8_t</name> <macro><name>createContiguous</name><argument_list>(<argument>SdFile* dirFile</argument>,
          <argument>const char* fileName</argument>, <argument>uint32_t size</argument>)</argument_list></macro></expr>;
  <comment type="block" format="doxygen">/** \return The current cluster number for a file or directory. */</comment>
  <expr><name>uint32_t</name> <macro><name>curCluster</name><argument_list>(<argument>void</argument>)</argument_list></macro> <specifier>const</specifier> <block>{<return>return <expr><name>curCluster_</name></expr>;</return>}</block>
  <comment type="block" format="doxygen">/** \return The current position for a file or directory. */</comment>
  <name>uint32_t</name> <macro><name>curPosition</name><argument_list>(<argument>void</argument>)</argument_list></macro> <specifier>const</specifier> <block>{<return>return <expr><name>curPosition_</name></expr>;</return>}</block>
  <comment type="block" format="doxygen">/**
   * Set the date/time callback function
   *
   * \param[in] dateTime The user's call back function.  The callback
   * function is of the form:
   *
   * \code
   * void dateTime(uint16_t* date, uint16_t* time) {
   *   uint16_t year;
   *   uint8_t month, day, hour, minute, second;
   *
   *   // User gets date and time from GPS or real-time clock here
   *
   *   // return date using FAT_DATE macro to format fields
   *   *date = FAT_DATE(year, month, day);
   *
   *   // return time using FAT_TIME macro to format fields
   *   *time = FAT_TIME(hour, minute, second);
   * }
   * \endcode
   *
   * Sets the function that is called when a file is created or when
   * a file's directory entry is modified by sync(). All timestamps,
   * access, creation, and modify, are set when a file is created.
   * sync() maintains the last access date and last modify date/time.
   *
   * See the timestamp() function.
   */</comment>
  <specifier>static</specifier> <name>void</name> <macro><name>dateTimeCallback</name><argument_list>(
    <argument>void (*dateTime)(uint16_t* date, uint16_t* time)</argument>)</argument_list></macro> <block>{
    <expr><name>dateTime_</name> <operator>=</operator> <name>dateTime</name></expr>;
  }</block>
  <comment type="block" format="doxygen">/**
   * Cancel the date/time callback function.
   */</comment>
  <specifier>static</specifier> <name>void</name> <macro><name>dateTimeCallbackCancel</name><argument_list>(<argument>void</argument>)</argument_list></macro> <block>{
    <comment type="line">// use explicit zero since NULL is not defined for Sanguino</comment>
    <expr><name>dateTime_</name> <operator>=</operator> <literal type="number">0</literal></expr>;
  }</block>
  <comment type="block" format="doxygen">/** \return Address of the block that contains this file's directory. */</comment>
  <name>uint32_t</name> <macro><name>dirBlock</name><argument_list>(<argument>void</argument>)</argument_list></macro> <specifier>const</specifier> <block>{<return>return <expr><name>dirBlock_</name></expr>;</return>}</block>
  <name>uint8_t</name> <call><name>dirEntry</name><argument_list>(<argument><expr><name>dir_t</name><operator>*</operator> <name>dir</name></expr></argument>)</argument_list></call></expr>;
  <comment type="block" format="doxygen">/** \return Index of this file's directory in the block dirBlock. */</comment>
  <expr><name>uint8_t</name> <macro><name>dirIndex</name><argument_list>(<argument>void</argument>)</argument_list></macro> <specifier>const</specifier> <block>{<return>return <expr><name>dirIndex_</name></expr>;</return>}</block>
  <specifier>static</specifier> <name>void</name> <call><name>dirName</name><argument_list>(<argument><expr><specifier>const</specifier> <name>dir_t</name><operator>&amp;</operator> <name>dir</name></expr></argument>, <argument><expr><name>char</name><operator>*</operator> <name>name</name></expr></argument>)</argument_list></call></expr>;
  <comment type="block" format="doxygen">/** \return The total number of bytes in a file or directory. */</comment>
  <expr><name>uint32_t</name> <macro><name>fileSize</name><argument_list>(<argument>void</argument>)</argument_list></macro> <specifier>const</specifier> <block>{<return>return <expr><name>fileSize_</name></expr>;</return>}</block>
  <comment type="block" format="doxygen">/** \return The first cluster number for a file or directory. */</comment>
  <name>uint32_t</name> <macro><name>firstCluster</name><argument_list>(<argument>void</argument>)</argument_list></macro> <specifier>const</specifier> <block>{<return>return <expr><name>firstCluster_</name></expr>;</return>}</block>
  <comment type="block" format="doxygen">/** \return True if this is a SdFile for a directory else false. */</comment>
  <name>uint8_t</name> <macro><name>isDir</name><argument_list>(<argument>void</argument>)</argument_list></macro> <specifier>const</specifier> <block>{<return>return <expr><name>type_</name> <operator>&gt;=</operator> <name>FAT_FILE_TYPE_MIN_DIR</name></expr>;</return>}</block>
  <comment type="block" format="doxygen">/** \return True if this is a SdFile for a file else false. */</comment>
  <name>uint8_t</name> <macro><name>isFile</name><argument_list>(<argument>void</argument>)</argument_list></macro> <specifier>const</specifier> <block>{<return>return <expr><name>type_</name> <operator>==</operator> <name>FAT_FILE_TYPE_NORMAL</name></expr>;</return>}</block>
  <comment type="block" format="doxygen">/** \return True if this is a SdFile for an open file/directory else false. */</comment>
  <name>uint8_t</name> <macro><name>isOpen</name><argument_list>(<argument>void</argument>)</argument_list></macro> <specifier>const</specifier> <block>{<return>return <expr><name>type_</name> <operator>!=</operator> <name>FAT_FILE_TYPE_CLOSED</name></expr>;</return>}</block>
  <comment type="block" format="doxygen">/** \return True if this is a SdFile for a subdirectory else false. */</comment>
  <name>uint8_t</name> <macro><name>isSubDir</name><argument_list>(<argument>void</argument>)</argument_list></macro> <specifier>const</specifier> <block>{<return>return <expr><name>type_</name> <operator>==</operator> <name>FAT_FILE_TYPE_SUBDIR</name></expr>;</return>}</block>
  <comment type="block" format="doxygen">/** \return True if this is a SdFile for the root directory. */</comment>
  <name>uint8_t</name> <macro><name>isRoot</name><argument_list>(<argument>void</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
    <return>return <expr><name>type_</name> <operator>==</operator> <name>FAT_FILE_TYPE_ROOT16</name> <operator>||</operator> <name>type_</name> <operator>==</operator> <name>FAT_FILE_TYPE_ROOT32</name></expr>;</return>
  }</block>
  <name>void</name> <macro><name>ls</name><argument_list>(<argument>uint8_t flags = <literal type="number">0</literal></argument>, <argument>uint8_t indent = <literal type="number">0</literal></argument>)</argument_list></macro></expr>;
  <expr><name>uint8_t</name> <call><name>makeDir</name><argument_list>(<argument><expr><name>SdFile</name><operator>*</operator> <name>dir</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>dirName</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>uint8_t</name> <macro><name>open</name><argument_list>(<argument>SdFile* dirFile</argument>, <argument>uint16_t index</argument>, <argument>uint8_t oflag</argument>)</argument_list></macro></expr>;
  <expr><name>uint8_t</name> <macro><name>open</name><argument_list>(<argument>SdFile* dirFile</argument>, <argument>const char* fileName</argument>, <argument>uint8_t oflag</argument>)</argument_list></macro></expr>;

  <expr><name>uint8_t</name> <call><name>openRoot</name><argument_list>(<argument><expr><name>SdVolume</name><operator>*</operator> <name>vol</name></expr></argument>)</argument_list></call></expr>;
  <expr><specifier>static</specifier> <name>void</name> <macro><name>printDirName</name><argument_list>(<argument>const dir_t&amp; dir</argument>, <argument>uint8_t width</argument>)</argument_list></macro></expr>;
  <expr><specifier>static</specifier> <name>void</name> <macro><name>printFatDate</name><argument_list>(<argument>uint16_t fatDate</argument>)</argument_list></macro></expr>;
  <expr><specifier>static</specifier> <name>void</name> <macro><name>printFatTime</name><argument_list>(<argument>uint16_t fatTime</argument>)</argument_list></macro></expr>;
  <expr><specifier>static</specifier> <name>void</name> <macro><name>printTwoDigits</name><argument_list>(<argument>uint8_t v</argument>)</argument_list></macro></expr>;
  <comment type="block" format="doxygen">/**
   * Read the next byte from a file.
   *
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */</comment>
  <expr><name>int16_t</name> <macro><name>read</name><argument_list>(<argument>void</argument>)</argument_list></macro> <block>{
    <expr><name>uint8_t</name> <name>b</name></expr>;
    <return>return <expr><ternary><condition><expr><call><name>read</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name>b</name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
  }</block>
  <name>int16_t</name> <macro><name>read</name><argument_list>(<argument>void* buf</argument>, <argument>uint16_t nbyte</argument>)</argument_list></macro></expr>;
  <expr><name>int8_t</name> <call><name>readDir</name><argument_list>(<argument><expr><name>dir_t</name><operator>*</operator> <name>dir</name></expr></argument>)</argument_list></call></expr>;
  <expr><specifier>static</specifier> <name>uint8_t</name> <call><name>remove</name><argument_list>(<argument><expr><name>SdFile</name><operator>*</operator> <name>dirFile</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>fileName</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>uint8_t</name> <call><name>remove</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;
  <comment type="block" format="doxygen">/** Set the file's current position to zero. */</comment>
  <expr><name>void</name> <macro><name>rewind</name><argument_list>(<argument>void</argument>)</argument_list></macro> <block>{
    <expr><name>curPosition_</name> <operator>=</operator> <name>curCluster_</name> <operator>=</operator> <literal type="number">0</literal></expr>;
  }</block>
  <name>uint8_t</name> <call><name>rmDir</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>uint8_t</name> <call><name>rmRfStar</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;
  <comment type="block" format="doxygen">/** Set the files position to current position + \a pos. See seekSet(). */</comment>
  <expr><name>uint8_t</name> <macro><name>seekCur</name><argument_list>(<argument>uint32_t pos</argument>)</argument_list></macro> <block>{
    <return>return <expr><call><name>seekSet</name><argument_list>(<argument><expr><name>curPosition_</name> <operator>+</operator> <name>pos</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block>
  <comment type="block" format="doxygen">/**
   *  Set the files current position to end of file.  Useful to position
   *  a file for append. See seekSet().
   */</comment>
  <name>uint8_t</name> <macro><name>seekEnd</name><argument_list>(<argument>void</argument>)</argument_list></macro> <block>{<return>return <expr><call><name>seekSet</name><argument_list>(<argument><expr><name>fileSize_</name></expr></argument>)</argument_list></call></expr>;</return>}</block>
  <name>uint8_t</name> <macro><name>seekSet</name><argument_list>(<argument>uint32_t pos</argument>)</argument_list></macro></expr>;
  <comment type="block" format="doxygen">/**
   * Use unbuffered reads to access this file.  Used with Wave
   * Shield ISR.  Used with Sd2Card::partialBlockRead() in WaveRP.
   *
   * Not recommended for normal applications.
   */</comment>
  <expr><name>void</name> <macro><name>setUnbufferedRead</name><argument_list>(<argument>void</argument>)</argument_list></macro> <block>{
    <if_stmt><if>if <condition>(<expr><call><name>isFile</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags_</name> <operator>|=</operator> <name>F_FILE_UNBUFFERED_READ</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  }</block>
  <name>uint8_t</name> <macro><name>timestamp</name><argument_list>(<argument>uint8_t flag</argument>, <argument>uint16_t year</argument>, <argument>uint8_t month</argument>, <argument>uint8_t day</argument>,
          <argument>uint8_t hour</argument>, <argument>uint8_t minute</argument>, <argument>uint8_t second</argument>)</argument_list></macro></expr>;
  <expr><name>uint8_t</name> <call><name>sync</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;
  <comment type="block" format="doxygen">/** Type of this SdFile.  You should use isFile() or isDir() instead of type()
   * if possible.
   *
   * \return The file or directory type.
   */</comment>
  <expr><name>uint8_t</name> <macro><name>type</name><argument_list>(<argument>void</argument>)</argument_list></macro> <specifier>const</specifier> <block>{<return>return <expr><name>type_</name></expr>;</return>}</block>
  <name>uint8_t</name> <macro><name>truncate</name><argument_list>(<argument>uint32_t size</argument>)</argument_list></macro></expr>;
  <comment type="block" format="doxygen">/** \return Unbuffered read flag. */</comment>
  <expr><name>uint8_t</name> <macro><name>unbufferedRead</name><argument_list>(<argument>void</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
    <return>return <expr><name>flags_</name> <operator>&amp;</operator> <name>F_FILE_UNBUFFERED_READ</name></expr>;</return>
  }</block>
  <comment type="block" format="doxygen">/** \return SdVolume that contains this file. */</comment>
  <name>SdVolume</name><operator>*</operator> <macro><name>volume</name><argument_list>(<argument>void</argument>)</argument_list></macro> <specifier>const</specifier> <block>{<return>return <expr><name>vol_</name></expr>;</return>}</block>
  <name>size_t</name> <macro><name>write</name><argument_list>(<argument>uint8_t b</argument>)</argument_list></macro></expr>;
  <expr><name>size_t</name> <macro><name>write</name><argument_list>(<argument>const void* buf</argument>, <argument>uint16_t nbyte</argument>)</argument_list></macro></expr>;
  <expr><name>size_t</name> <call><name>write</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>str</name></expr></argument>)</argument_list></call></expr>;
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AVR__</name></cpp:ifdef>
  <expr><name>void</name> <macro><name>write_P</name><argument_list>(<argument>PGM_P str</argument>)</argument_list></macro></expr>;
  <expr><name>void</name> <macro><name>writeln_P</name><argument_list>(<argument>PGM_P str</argument>)</argument_list></macro></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="line">//------------------------------------------------------------------------------</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ALLOW_DEPRECATED_FUNCTIONS</name></expr></cpp:if>
<comment type="line">// Deprecated functions  - suppress cpplint warnings with NOLINT comment</comment>
  <comment type="block" format="doxygen">/** \deprecated Use:
   * uint8_t SdFile::contiguousRange(uint32_t* bgnBlock, uint32_t* endBlock);
   */</comment>
  <expr><name>uint8_t</name> <macro><name>contiguousRange</name><argument_list>(<argument>uint32_t&amp; bgnBlock</argument>, <argument>uint32_t&amp; endBlock</argument>)</argument_list></macro> <block>{  <comment type="line">// NOLINT</comment>
    <return>return <expr><call><name>contiguousRange</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bgnBlock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endBlock</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block>
 <comment type="block" format="doxygen">/** \deprecated Use:
   * uint8_t SdFile::createContiguous(SdFile* dirFile,
   *   const char* fileName, uint32_t size)
   */</comment>
  <name>uint8_t</name> <macro><name>createContiguous</name><argument_list>(<argument>SdFile&amp; dirFile</argument>,  <comment type="line">// NOLINT</comment>
    <argument>const char* fileName</argument>, <argument>uint32_t size</argument>)</argument_list></macro> <block>{
    <return>return <expr><call><name>createContiguous</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dirFile</name></expr></argument>, <argument><expr><name>fileName</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block>

  <comment type="block" format="doxygen">/**
   * \deprecated Use:
   * static void SdFile::dateTimeCallback(
   *   void (*dateTime)(uint16_t* date, uint16_t* time));
   */</comment>
  <specifier>static</specifier> <name>void</name> <macro><name>dateTimeCallback</name><argument_list>(
    <argument>void (*dateTime)(uint16_t&amp; date, uint16_t&amp; time)</argument>)</argument_list></macro> <block>{  <comment type="line">// NOLINT</comment>
    <expr><name>oldDateTime_</name> <operator>=</operator> <name>dateTime</name></expr>;
    <expr><name>dateTime_</name> <operator>=</operator> <ternary><condition><expr><name>dateTime</name></expr> ?</condition><then> <expr><name>oldToNew</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;
  }</block>
  <comment type="block" format="doxygen">/** \deprecated Use: uint8_t SdFile::dirEntry(dir_t* dir); */</comment>
  <name>uint8_t</name> <macro><name>dirEntry</name><argument_list>(<argument>dir_t&amp; dir</argument>)</argument_list></macro> <block>{<return>return <expr><call><name>dirEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dir</name></expr></argument>)</argument_list></call></expr>;</return>}</block>  <comment type="line">// NOLINT</comment>
  <comment type="block" format="doxygen">/** \deprecated Use:
   * uint8_t SdFile::makeDir(SdFile* dir, const char* dirName);
   */</comment>
  <name>uint8_t</name> <macro><name>makeDir</name><argument_list>(<argument>SdFile&amp; dir</argument>, <argument>const char* dirName</argument>)</argument_list></macro> <block>{  <comment type="line">// NOLINT</comment>
    <return>return <expr><call><name>makeDir</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dir</name></expr></argument>, <argument><expr><name>dirName</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block>
  <comment type="block" format="doxygen">/** \deprecated Use:
   * uint8_t SdFile::open(SdFile* dirFile, const char* fileName, uint8_t oflag);
   */</comment>
  <name>uint8_t</name> <macro><name>open</name><argument_list>(<argument>SdFile&amp; dirFile</argument>, <comment type="line">// NOLINT</comment>
    <argument>const char* fileName</argument>, <argument>uint8_t oflag</argument>)</argument_list></macro> <block>{
    <return>return <expr><call><name>open</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dirFile</name></expr></argument>, <argument><expr><name>fileName</name></expr></argument>, <argument><expr><name>oflag</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block>
  <comment type="block" format="doxygen">/** \deprecated  Do not use in new apps */</comment>
  <name>uint8_t</name> <macro><name>open</name><argument_list>(<argument>SdFile&amp; dirFile</argument>, <argument>const char* fileName</argument>)</argument_list></macro> <block>{  <comment type="line">// NOLINT</comment>
    <return>return <expr><call><name>open</name><argument_list>(<argument><expr><name>dirFile</name></expr></argument>, <argument><expr><name>fileName</name></expr></argument>, <argument><expr><name>O_RDWR</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block>
  <comment type="block" format="doxygen">/** \deprecated Use:
   * uint8_t SdFile::open(SdFile* dirFile, uint16_t index, uint8_t oflag);
   */</comment>
  <name>uint8_t</name> <macro><name>open</name><argument_list>(<argument>SdFile&amp; dirFile</argument>, <argument>uint16_t index</argument>, <argument>uint8_t oflag</argument>)</argument_list></macro> <block>{  <comment type="line">// NOLINT</comment>
    <return>return <expr><call><name>open</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dirFile</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>oflag</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block>
  <comment type="block" format="doxygen">/** \deprecated Use: uint8_t SdFile::openRoot(SdVolume* vol); */</comment>
  <name>uint8_t</name> <macro><name>openRoot</name><argument_list>(<argument>SdVolume&amp; vol</argument>)</argument_list></macro> <block>{<return>return <expr><call><name>openRoot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vol</name></expr></argument>)</argument_list></call></expr>;</return>}</block>  <comment type="line">// NOLINT</comment>

  <comment type="block" format="doxygen">/** \deprecated Use: int8_t SdFile::readDir(dir_t* dir); */</comment>
  <name>int8_t</name> <macro><name>readDir</name><argument_list>(<argument>dir_t&amp; dir</argument>)</argument_list></macro> <block>{<return>return <expr><call><name>readDir</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dir</name></expr></argument>)</argument_list></call></expr>;</return>}</block>  <comment type="line">// NOLINT</comment>
  <comment type="block" format="doxygen">/** \deprecated Use:
   * static uint8_t SdFile::remove(SdFile* dirFile, const char* fileName);
   */</comment>
  <specifier>static</specifier> <name>uint8_t</name> <macro><name>remove</name><argument_list>(<argument>SdFile&amp; dirFile</argument>, <argument>const char* fileName</argument>)</argument_list></macro> <block>{  <comment type="line">// NOLINT</comment>
    <return>return <expr><call><name>remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dirFile</name></expr></argument>, <argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block>
<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// rest are private</comment>
 <name>private</name><operator>:</operator>
  <specifier>static</specifier> <call><call><name>void</name> <argument_list>(<argument><expr><operator>*</operator><name>oldDateTime_</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>uint16_t</name><operator>&amp;</operator> <name>date</name></expr></argument>, <argument><expr><name>uint16_t</name><operator>&amp;</operator> <name>time</name></expr></argument>)</argument_list></call></expr>;  <comment type="line">// NOLINT</comment>
  <expr><specifier>static</specifier> <name>void</name> <macro><name>oldToNew</name><argument_list>(<argument>uint16_t* date</argument>, <argument>uint16_t* time</argument>)</argument_list></macro> <block>{
    <expr><name>uint16_t</name> <name>d</name></expr>;
    <expr><name>uint16_t</name> <name>t</name></expr>;
    <expr><call><name>oldDateTime_</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;
    <expr><operator>*</operator><name>date</name> <operator>=</operator> <name>d</name></expr>;
    <expr><operator>*</operator><name>time</name> <operator>=</operator> <name>t</name></expr>;
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="line">// ALLOW_DEPRECATED_FUNCTIONS</comment>
 <name>private</name><operator>:</operator>
  <comment type="line">// bits defined in flags_</comment>
  <comment type="line">// should be 0XF</comment>
  <specifier>static</specifier> <name>uint8_t</name> <specifier>const</specifier> <name>F_OFLAG</name> <operator>=</operator> <operator>(</operator><name>O_ACCMODE</name> <operator>|</operator> <name>O_APPEND</name> <operator>|</operator> <name>O_SYNC</name><operator>)</operator></expr>;
  <comment type="line">// available bits</comment>
  <expr><specifier>static</specifier> <name>uint8_t</name> <specifier>const</specifier> <name>F_UNUSED</name> <operator>=</operator> <literal type="number">0X30</literal></expr>;
  <comment type="line">// use unbuffered SD read</comment>
  <expr><specifier>static</specifier> <name>uint8_t</name> <specifier>const</specifier> <name>F_FILE_UNBUFFERED_READ</name> <operator>=</operator> <literal type="number">0X40</literal></expr>;
  <comment type="line">// sync of directory entry required</comment>
  <expr><specifier>static</specifier> <name>uint8_t</name> <specifier>const</specifier> <name>F_FILE_DIR_DIRTY</name> <operator>=</operator> <literal type="number">0X80</literal></expr>;

<comment type="line">// make sure F_OFLAG is ok</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><operator>(</operator><name>F_UNUSED</name> <operator>|</operator> <name>F_FILE_UNBUFFERED_READ</name> <operator>|</operator> <name>F_FILE_DIR_DIRTY</name><operator>)</operator> <operator>&amp;</operator> <name>F_OFLAG</name><operator>)</operator></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> flags_ bits conflict</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="line">// flags_ bits</comment>

  <comment type="line">// private data</comment>
  <expr><name>uint8_t</name>   <name>flags_</name></expr>;         <comment type="line">// See above for definition of flags_ bits</comment>
  <expr><name>uint8_t</name>   <name>type_</name></expr>;          <comment type="line">// type of file see above for values</comment>
  <expr><name>uint32_t</name>  <name>curCluster_</name></expr>;    <comment type="line">// cluster for current file position</comment>
  <expr><name>uint32_t</name>  <name>curPosition_</name></expr>;   <comment type="line">// current file position in bytes from beginning</comment>
  <expr><name>uint32_t</name>  <name>dirBlock_</name></expr>;      <comment type="line">// SD block that contains directory entry for file</comment>
  <expr><name>uint8_t</name>   <name>dirIndex_</name></expr>;      <comment type="line">// index of entry in dirBlock 0 &lt;= dirIndex_ &lt;= 0XF</comment>
  <expr><name>uint32_t</name>  <name>fileSize_</name></expr>;      <comment type="line">// file size in bytes</comment>
  <expr><name>uint32_t</name>  <name>firstCluster_</name></expr>;  <comment type="line">// first cluster of file</comment>
  <expr><name>SdVolume</name><operator>*</operator> <name>vol_</name></expr>;           <comment type="line">// volume where file is located</comment>

  <comment type="line">// private functions</comment>
  <expr><name>uint8_t</name> <call><name>addCluster</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>uint8_t</name> <call><name>addDirCluster</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>dir_t</name><operator>*</operator> <macro><name>cacheDirEntry</name><argument_list>(<argument>uint8_t action</argument>)</argument_list></macro></expr>;
  <expr><specifier>static</specifier> <call><call><name>void</name> <argument_list>(<argument><expr><operator>*</operator><name>dateTime_</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>uint16_t</name><operator>*</operator> <name>date</name></expr></argument>, <argument><expr><name>uint16_t</name><operator>*</operator> <name>time</name></expr></argument>)</argument_list></call></expr>;
  <expr><specifier>static</specifier> <name>uint8_t</name> <call><name>make83Name</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>str</name></expr></argument>, <argument><expr><name>uint8_t</name><operator>*</operator> <name>name</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>uint8_t</name> <macro><name>openCachedEntry</name><argument_list>(<argument>uint8_t cacheIndex</argument>, <argument>uint8_t oflags</argument>)</argument_list></macro></expr>;
  <expr><name>dir_t</name><operator>*</operator> <call><name>readDirCache</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>
<comment type="line">//==============================================================================</comment>
<comment type="line">// SdVolume class</comment>
<comment type="block" format="doxygen">/**
 * \brief Cache for an SD data block
 */</comment>
<union>union <name>cache_t</name> <block>{
           <comment type="block" format="doxygen">/** Used to access cached file data blocks. */</comment>
  <decl_stmt><decl><type><name>uint8_t</name></type>  <name><name>data</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>;</decl_stmt>
           <comment type="block" format="doxygen">/** Used to access cached FAT16 entries. */</comment>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name><name>fat16</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
           <comment type="block" format="doxygen">/** Used to access cached FAT32 entries. */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name><name>fat32</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
           <comment type="block" format="doxygen">/** Used to access cached directory entries. */</comment>
  <decl_stmt><decl><type><name>dir_t</name></type>    <name><name>dir</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
           <comment type="block" format="doxygen">/** Used to access a cached MasterBoot Record. */</comment>
  <decl_stmt><decl><type><name>mbr_t</name></type>    <name>mbr</name></decl>;</decl_stmt>
           <comment type="block" format="doxygen">/** Used to access to a cached FAT boot sector. */</comment>
  <decl_stmt><decl><type><name>fbs_t</name></type>    <name>fbs</name></decl>;</decl_stmt>
}</block>;</union>
<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="block" format="doxygen">/**
 * \class SdVolume
 * \brief Access FAT16 and FAT32 volumes on SD and SDHC cards.
 */</comment>
<decl_stmt><decl><type><name>class</name></type> <name>SdVolume</name> <block>{<block_content>
 <label><name>public</name>:</label>
  <comment type="block" format="doxygen">/** Create an instance of SdVolume */</comment>
  <expr_stmt><expr><call><name>SdVolume</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call> <operator>:</operator><call><name>allocSearchStart_</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>fatType_</name><argument_list>(<argument><literal type="number">0</literal></argument>)</argument_list></macro> <expr><block>{}</block>
  <comment type="block" format="doxygen">/** Clear the cache and returns a pointer to the cache.  Used by the WaveRP
   *  recorder to do raw write to the SD card.  Not for normal apps.
   */</comment>
  <specifier>static</specifier> <name>uint8_t</name><operator>*</operator> <macro><name>cacheClear</name><argument_list>(<argument>void</argument>)</argument_list></macro> <block>{
    <expr><call><name>cacheFlush</name><argument_list>()</argument_list></call></expr>;
    <expr><name>cacheBlockNumber_</name> <operator>=</operator> <literal type="number">0XFFFFFFFF</literal></expr>;
    <return>return <expr><name><name>cacheBuffer_</name><operator>.</operator><name>data</name></name></expr>;</return>
  }</block></expr></expr_stmt>
  <comment type="block" format="doxygen">/**
   * Initialize a FAT volume.  Try partition one first then try super
   * floppy format.
   *
   * \param[in] dev The Sd2Card where the volume is located.
   *
   * \return The value one, true, is returned for success and
   * the value zero, false, is returned for failure.  Reasons for
   * failure include not finding a valid partition, not finding a valid
   * FAT file system or an I/O error.
   */</comment>
  <function><type><name>uint8_t</name></type> <name>init</name><parameter_list>(<parameter><decl><type><name>Sd2Card</name><modifier>*</modifier></type> <name>dev</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><ternary><condition><expr><call><name>init</name><argument_list>(<argument><expr><name>dev</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><call><name>init</name><argument_list>(<argument><expr><name>dev</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return></block_content>}</block></function>
  <function_decl><type><name>uint8_t</name></type> <name>init</name><parameter_list>(<parameter><decl><type><name>Sd2Card</name><modifier>*</modifier></type> <name>dev</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>part</name></decl></parameter>)</parameter_list>;</function_decl>

  <comment type="line">// inline functions that return volume info</comment>
  <comment type="block" format="doxygen">/** \return The volume's cluster size in blocks. */</comment>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>blocksPerCluster</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list> const <block>{<block_content><return>return <expr><name>blocksPerCluster_</name></expr>;</return></block_content>}</block></decl></decl_stmt>
  <comment type="block" format="doxygen">/** \return The number of blocks in one FAT. */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>blocksPerFat</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list>  const <block>{<block_content><return>return <expr><name>blocksPerFat_</name></expr>;</return></block_content>}</block></decl></decl_stmt>
  <comment type="block" format="doxygen">/** \return The total number of clusters in the volume. */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>clusterCount</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list> const <block>{<block_content><return>return <expr><name>clusterCount_</name></expr>;</return></block_content>}</block></decl></decl_stmt>
  <comment type="block" format="doxygen">/** \return The shift count required to multiply by blocksPerCluster. */</comment>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>clusterSizeShift</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list> const <block>{<block_content><return>return <expr><name>clusterSizeShift_</name></expr>;</return></block_content>}</block></decl></decl_stmt>
  <comment type="block" format="doxygen">/** \return The logical block number for the start of file data. */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>dataStartBlock</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list> const <block>{<block_content><return>return <expr><name>dataStartBlock_</name></expr>;</return></block_content>}</block></decl></decl_stmt>
  <comment type="block" format="doxygen">/** \return The number of FAT structures on the volume. */</comment>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>fatCount</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list> const <block>{<block_content><return>return <expr><name>fatCount_</name></expr>;</return></block_content>}</block></decl></decl_stmt>
  <comment type="block" format="doxygen">/** \return The logical block number for the start of the first FAT. */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>fatStartBlock</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list> const <block>{<block_content><return>return <expr><name>fatStartBlock_</name></expr>;</return></block_content>}</block></decl></decl_stmt>
  <comment type="block" format="doxygen">/** \return The FAT type of the volume. Values are 12, 16 or 32. */</comment>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>fatType</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list> const <block>{<block_content><return>return <expr><name>fatType_</name></expr>;</return></block_content>}</block></decl></decl_stmt>
  <comment type="block" format="doxygen">/** \return The number of entries in the root directory for FAT16 volumes. */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>rootDirEntryCount</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list> const <block>{<block_content><return>return <expr><name>rootDirEntryCount_</name></expr>;</return></block_content>}</block></decl></decl_stmt>
  <comment type="block" format="doxygen">/** \return The logical block number for the start of the root directory
       on FAT16 volumes or the first cluster number on FAT32 volumes. */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>rootDirStart</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list> const <block>{<block_content><return>return <expr><name>rootDirStart_</name></expr>;</return></block_content>}</block></decl></decl_stmt>
  <comment type="block" format="doxygen">/** return a pointer to the Sd2Card object for this volume */</comment>
  <function><type><specifier>static</specifier> <name>Sd2Card</name><modifier>*</modifier></type> <name>sdCard</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content><return>return <expr><name>sdCard_</name></expr>;</return></block_content>}</block></function>
<comment type="line">//------------------------------------------------------------------------------</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ALLOW_DEPRECATED_FUNCTIONS</name></expr></cpp:if>
  <comment type="line">// Deprecated functions  - suppress cpplint warnings with NOLINT comment</comment>
  <comment type="block" format="doxygen">/** \deprecated Use: uint8_t SdVolume::init(Sd2Card* dev); */</comment>
  <function><type><name>uint8_t</name></type> <name>init</name><parameter_list>(<parameter><decl><type><name>Sd2Card</name><modifier>&amp;</modifier></type> <name>dev</name></decl></parameter>)</parameter_list> <block>{<block_content><return>return <expr><call><name>init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dev</name></expr></argument>)</argument_list></call></expr>;</return></block_content>}</block></function>  <comment type="line">// NOLINT</comment>

  <comment type="block" format="doxygen">/** \deprecated Use: uint8_t SdVolume::init(Sd2Card* dev, uint8_t vol); */</comment>
  <function><type><name>uint8_t</name></type> <name>init</name><parameter_list>(<parameter><decl><type><name>Sd2Card</name><modifier>&amp;</modifier></type> <name>dev</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>part</name></decl></parameter>)</parameter_list> <block>{<block_content>  <comment type="line">// NOLINT</comment>
    <return>return <expr><call><name>init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dev</name></expr></argument>, <argument><expr><name>part</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="line">// ALLOW_DEPRECATED_FUNCTIONS</comment>
<comment type="line">//------------------------------------------------------------------------------</comment>
  <label><name>private</name>:</label>
  <comment type="line">// Allow SdFile access to SdVolume private data.</comment>
  <decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>SdFile</name></decl>;</decl_stmt>

  <comment type="line">// value for action argument in cacheRawBlock to indicate read from cache</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <name>uint8_t</name> <specifier>const</specifier></type> <name>CACHE_FOR_READ</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <comment type="line">// value for action argument in cacheRawBlock to indicate cache dirty</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <name>uint8_t</name> <specifier>const</specifier></type> <name>CACHE_FOR_WRITE</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>static</specifier> <name>cache_t</name></type> <name>cacheBuffer_</name></decl>;</decl_stmt>        <comment type="line">// 512 byte cache for device blocks</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <name>uint32_t</name></type> <name>cacheBlockNumber_</name></decl>;</decl_stmt>  <comment type="line">// Logical number of block in the cache</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <name>Sd2Card</name><modifier>*</modifier></type> <name>sdCard_</name></decl>;</decl_stmt>            <comment type="line">// Sd2Card object for cache</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <name>uint8_t</name></type> <name>cacheDirty_</name></decl>;</decl_stmt>         <comment type="line">// cacheFlush() will write block if true</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <name>uint32_t</name></type> <name>cacheMirrorBlock_</name></decl>;</decl_stmt>  <comment type="line">// block number for mirror FAT</comment>
<comment type="line">//</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>allocSearchStart_</name></decl>;</decl_stmt>   <comment type="line">// start cluster for alloc search</comment>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>blocksPerCluster_</name></decl>;</decl_stmt>    <comment type="line">// cluster size in blocks</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>blocksPerFat_</name></decl>;</decl_stmt>       <comment type="line">// FAT size in blocks</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>clusterCount_</name></decl>;</decl_stmt>       <comment type="line">// clusters in one FAT</comment>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>clusterSizeShift_</name></decl>;</decl_stmt>    <comment type="line">// shift to convert cluster count to block count</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>dataStartBlock_</name></decl>;</decl_stmt>     <comment type="line">// first data block number</comment>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>fatCount_</name></decl>;</decl_stmt>            <comment type="line">// number of FATs on volume</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>fatStartBlock_</name></decl>;</decl_stmt>      <comment type="line">// start block for first FAT</comment>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>fatType_</name></decl>;</decl_stmt>             <comment type="line">// volume type (12, 16, OR 32)</comment>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>rootDirEntryCount_</name></decl>;</decl_stmt>  <comment type="line">// number of entries in FAT16 root dir</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>rootDirStart_</name></decl>;</decl_stmt>       <comment type="line">// root start block for FAT16, cluster for FAT32</comment>
  <comment type="line">//----------------------------------------------------------------------------</comment>
  <function_decl><type><name>uint8_t</name></type> <name>allocContiguous</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>curCluster</name></decl></parameter>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>blockOfCluster</name><argument_list>(<argument><expr><name>uint32_t</name> <name>position</name></expr></argument>)</argument_list> const <block>{<block_content>
          <return>return <expr><operator>(</operator><name>position</name> <operator>&gt;&gt;</operator> <literal type="number">9</literal><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>blocksPerCluster_</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return></block_content>}</block></decl></decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>clusterStartBlock</name><argument_list>(<argument><expr><name>uint32_t</name> <name>cluster</name></expr></argument>)</argument_list> const <block>{<block_content>
           <return>return <expr><name>dataStartBlock_</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>cluster</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>clusterSizeShift_</name><operator>)</operator></expr>;</return></block_content>}</block></decl></decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>blockNumber</name><argument_list>(<argument><expr><name>uint32_t</name> <name>cluster</name></expr></argument>, <argument><expr><name>uint32_t</name> <name>position</name></expr></argument>)</argument_list> const <block>{<block_content>
           <return>return <expr><call><name>clusterStartBlock</name><argument_list>(<argument><expr><name>cluster</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>blockOfCluster</name><argument_list>(<argument><expr><name>position</name></expr></argument>)</argument_list></call></expr>;</return></block_content>}</block></decl></decl_stmt>
  <function_decl><type><specifier>static</specifier> <name>uint8_t</name></type> <name>cacheFlush</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>static</specifier> <name>uint8_t</name></type> <name>cacheRawBlock</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>blockNumber</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>action</name></decl></parameter>)</parameter_list>;</function_decl>
  <function><type><specifier>static</specifier> <name>void</name></type> <name>cacheSetDirty</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content><expr_stmt><expr><name>cacheDirty_</name> <operator>|=</operator> <name>CACHE_FOR_WRITE</name></expr>;</expr_stmt></block_content>}</block></function>
  <function_decl><type><specifier>static</specifier> <name>uint8_t</name></type> <name>cacheZeroBlock</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>blockNumber</name></decl></parameter>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>chainSize</name><argument_list>(<argument><expr><name>uint32_t</name> <name>beginCluster</name></expr></argument>, <argument><expr><name>uint32_t</name><operator>*</operator> <name>size</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>fatGet</name><argument_list>(<argument><expr><name>uint32_t</name> <name>cluster</name></expr></argument>, <argument><expr><name>uint32_t</name><operator>*</operator> <name>value</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
  <function_decl><type><name>uint8_t</name></type> <name>fatPut</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>cluster</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>value</name></decl></parameter>)</parameter_list>;</function_decl>
  <function><type><name>uint8_t</name></type> <name>fatPutEOC</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>cluster</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>fatPut</name><argument_list>(<argument><expr><name>cluster</name></expr></argument>, <argument><expr><literal type="number">0x0FFFFFFF</literal></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>
  <function_decl><type><name>uint8_t</name></type> <name>freeChain</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>cluster</name></decl></parameter>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>isEOC</name><argument_list>(<argument><expr><name>uint32_t</name> <name>cluster</name></expr></argument>)</argument_list> const <block>{<block_content>
    <return>return  <expr><name>cluster</name> <operator>&gt;=</operator> <operator>(</operator><ternary><condition><expr><name>fatType_</name> <operator>==</operator> <literal type="number">16</literal></expr> ?</condition><then> <expr><name>FAT16EOC_MIN</name></expr> </then><else>: <expr><name>FAT32EOC_MIN</name></expr></else></ternary><operator>)</operator></expr>;</return>
  </block_content>}</block></decl></decl_stmt>
  <function><type><name>uint8_t</name></type> <name>readBlock</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>block</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name><name>sdCard_</name><operator>-&gt;</operator><name>readBlock</name></name><argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</return></block_content>}</block></function>
  <function><type><name>uint8_t</name></type> <name>readData</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>block</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>offset</name></decl></parameter>,
    <parameter><decl><type><name>uint16_t</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <return>return <expr><call><name><name>sdCard_</name><operator>-&gt;</operator><name>readData</name></name><argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>
  <function><type><name>uint8_t</name></type> <name>writeBlock</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>block</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>dst</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name><name>sdCard_</name><operator>-&gt;</operator><name>writeBlock</name></name><argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="line">// SdFat_h</comment>
</unit>
