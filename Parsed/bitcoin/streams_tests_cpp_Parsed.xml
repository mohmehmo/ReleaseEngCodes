<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C++" filename="/home/mmm/Projects/bitcoin/src/test/streams_tests.cpp"><comment type="line">// Copyright (c) 2012-2019 The Bitcoin Core developers</comment>
<comment type="line">// Distributed under the MIT software license, see the accompanying</comment>
<comment type="line">// file COPYING or http://www.opensource.org/licenses/mit-license.php.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;streams.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;test/util/setup_common.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;boost/test/unit_test.hpp&gt;</cpp:file></cpp:include>

<macro><name>BOOST_FIXTURE_TEST_SUITE</name><argument_list>(<argument>streams_tests</argument>, <argument>BasicTestingSetup</argument>)</argument_list></macro>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>streams_vector_writer</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>a</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>b</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>bytes</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">3</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>vch</name></decl>;</decl_stmt>

    <comment type="line">// Each test runs twice. Serializing a second time at the same starting</comment>
    <comment type="line">// point should yield the same results, even if the first test grew the</comment>
    <comment type="line">// vector.</comment>

    <expr_stmt><expr><call><name>CVectorWriter</name><argument_list>(<argument><expr><name>SER_NETWORK</name></expr></argument>, <argument><expr><name>INIT_PROTO_VERSION</name></expr></argument>, <argument><expr><name>vch</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>(</operator><name>vch</name> <operator>==</operator> <call><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name><argument_list>{<argument><expr><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>}</block></expr></argument>}</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CVectorWriter</name><argument_list>(<argument><expr><name>SER_NETWORK</name></expr></argument>, <argument><expr><name>INIT_PROTO_VERSION</name></expr></argument>, <argument><expr><name>vch</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>(</operator><name>vch</name> <operator>==</operator> <call><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name><argument_list>{<argument><expr><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>}</block></expr></argument>}</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>vch</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>CVectorWriter</name><argument_list>(<argument><expr><name>SER_NETWORK</name></expr></argument>, <argument><expr><name>INIT_PROTO_VERSION</name></expr></argument>, <argument><expr><name>vch</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>(</operator><name>vch</name> <operator>==</operator> <call><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name><argument_list>{<argument><expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>}</block></expr></argument>}</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CVectorWriter</name><argument_list>(<argument><expr><name>SER_NETWORK</name></expr></argument>, <argument><expr><name>INIT_PROTO_VERSION</name></expr></argument>, <argument><expr><name>vch</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>(</operator><name>vch</name> <operator>==</operator> <call><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name><argument_list>{<argument><expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>}</block></expr></argument>}</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>vch</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>vch</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CVectorWriter</name><argument_list>(<argument><expr><name>SER_NETWORK</name></expr></argument>, <argument><expr><name>INIT_PROTO_VERSION</name></expr></argument>, <argument><expr><name>vch</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>(</operator><name>vch</name> <operator>==</operator> <call><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name><argument_list>{<argument><expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></argument>}</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CVectorWriter</name><argument_list>(<argument><expr><name>SER_NETWORK</name></expr></argument>, <argument><expr><name>INIT_PROTO_VERSION</name></expr></argument>, <argument><expr><name>vch</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>(</operator><name>vch</name> <operator>==</operator> <call><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name><argument_list>{<argument><expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></argument>}</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>vch</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>vch</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CVectorWriter</name><argument_list>(<argument><expr><name>SER_NETWORK</name></expr></argument>, <argument><expr><name>INIT_PROTO_VERSION</name></expr></argument>, <argument><expr><name>vch</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>(</operator><name>vch</name> <operator>==</operator> <call><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name><argument_list>{<argument><expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>}</block></expr></argument>}</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CVectorWriter</name><argument_list>(<argument><expr><name>SER_NETWORK</name></expr></argument>, <argument><expr><name>INIT_PROTO_VERSION</name></expr></argument>, <argument><expr><name>vch</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>(</operator><name>vch</name> <operator>==</operator> <call><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name><argument_list>{<argument><expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>}</block></expr></argument>}</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>vch</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>vch</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CVectorWriter</name><argument_list>(<argument><expr><name>SER_NETWORK</name></expr></argument>, <argument><expr><name>INIT_PROTO_VERSION</name></expr></argument>, <argument><expr><name>vch</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>(</operator><name>vch</name> <operator>==</operator> <call><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name><argument_list>{<argument><expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>}</block></expr></argument>}</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CVectorWriter</name><argument_list>(<argument><expr><name>SER_NETWORK</name></expr></argument>, <argument><expr><name>INIT_PROTO_VERSION</name></expr></argument>, <argument><expr><name>vch</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>(</operator><name>vch</name> <operator>==</operator> <call><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name><argument_list>{<argument><expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>}</block></expr></argument>}</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>vch</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>CVectorWriter</name><argument_list>(<argument><expr><name>SER_NETWORK</name></expr></argument>, <argument><expr><name>INIT_PROTO_VERSION</name></expr></argument>, <argument><expr><name>vch</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>(</operator><name>vch</name> <operator>==</operator> <call><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name><argument_list>{<argument><expr><block>{<expr><literal type="number">3</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>}</block></expr></argument>}</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CVectorWriter</name><argument_list>(<argument><expr><name>SER_NETWORK</name></expr></argument>, <argument><expr><name>INIT_PROTO_VERSION</name></expr></argument>, <argument><expr><name>vch</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>(</operator><name>vch</name> <operator>==</operator> <call><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name><argument_list>{<argument><expr><block>{<expr><literal type="number">3</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>}</block></expr></argument>}</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>vch</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>vch</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CVectorWriter</name><argument_list>(<argument><expr><name>SER_NETWORK</name></expr></argument>, <argument><expr><name>INIT_PROTO_VERSION</name></expr></argument>, <argument><expr><name>vch</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>(</operator><name>vch</name> <operator>==</operator> <call><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name><argument_list>{<argument><expr><block>{<expr><literal type="number">8</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">2</literal></expr>}</block></expr></argument>}</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CVectorWriter</name><argument_list>(<argument><expr><name>SER_NETWORK</name></expr></argument>, <argument><expr><name>INIT_PROTO_VERSION</name></expr></argument>, <argument><expr><name>vch</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>(</operator><name>vch</name> <operator>==</operator> <call><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name><argument_list>{<argument><expr><block>{<expr><literal type="number">8</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">2</literal></expr>}</block></expr></argument>}</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>vch</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>streams_vector_reader</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>vch</name> <init>= <expr><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">255</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>}</block></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>VectorReader</name></type> <name>reader</name><argument_list>(<argument><expr><name>SER_NETWORK</name></expr></argument>, <argument><expr><name>INIT_PROTO_VERSION</name></expr></argument>, <argument><expr><name>vch</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>reader</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>reader</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Read a single byte as an unsigned char.</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>a</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>reader</name> <operator>&gt;&gt;</operator> <name>a</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>reader</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>reader</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Read a single byte as a signed char.</comment>
    <decl_stmt><decl><type><name>signed</name> <name>char</name></type> <name>b</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>reader</name> <operator>&gt;&gt;</operator> <name>b</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>reader</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>reader</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Read a 4 bytes as an unsigned int.</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>reader</name> <operator>&gt;&gt;</operator> <name>c</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">100992003</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// 3,4,5,6 in little-endian base-256</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>reader</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>reader</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Reading after end of byte vector throws an error.</comment>
    <decl_stmt><decl><type><name>signed</name> <name>int</name></type> <name>d</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_THROW</name><argument_list>(<argument><expr><name>reader</name> <operator>&gt;&gt;</operator> <name>d</name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>ios_base</name><operator>::</operator><name>failure</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Read a 4 bytes as a signed int from the beginning of the buffer.</comment>
    <decl_stmt><decl><type><name>VectorReader</name></type> <name>new_reader</name><argument_list>(<argument><expr><name>SER_NETWORK</name></expr></argument>, <argument><expr><name>INIT_PROTO_VERSION</name></expr></argument>, <argument><expr><name>vch</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><name>new_reader</name> <operator>&gt;&gt;</operator> <name>d</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">67370753</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// 1,255,3,4 in little-endian base-256</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>new_reader</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>new_reader</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Reading after end of byte vector throws an error even if the reader is</comment>
    <comment type="line">// not totally empty.</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK_THROW</name><argument_list>(<argument><expr><name>new_reader</name> <operator>&gt;&gt;</operator> <name>d</name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>ios_base</name><operator>::</operator><name>failure</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>bitstream_reader_writer</argument>)</argument_list></macro>
<block>{<block_content>
    <function_decl><type><name>CDataStream</name></type> <name>data</name><parameter_list>(<parameter><decl><type><name>SER_NETWORK</name></type></decl></parameter>, <parameter><decl><type><name>INIT_PROTO_VERSION</name></type></decl></parameter>)</parameter_list>;</function_decl>

    <function_decl><type><name><name>BitStreamWriter</name><argument_list type="generic">&lt;<argument><expr><name>CDataStream</name></expr></argument>&gt;</argument_list></name></type> <name>bit_writer</name><parameter_list>(<parameter><decl><type><name>data</name></type></decl></parameter>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name><name>bit_writer</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>bit_writer</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>bit_writer</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>bit_writer</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><literal type="number">11</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>bit_writer</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>bit_writer</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>bit_writer</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>bit_writer</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><literal type="number">30497</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>bit_writer</name><operator>.</operator><name>Flush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <function_decl><type><name>CDataStream</name></type> <name>data_copy</name><parameter_list>(<parameter><decl><type><name>data</name></type></decl></parameter>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>serialized_int1</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>data</name> <operator>&gt;&gt;</operator> <name>serialized_int1</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>serialized_int1</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><literal type="number">0x7700C35A</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// NOTE: Serialized as LE</comment>
    <decl_stmt><decl><type><name>uint16_t</name></type> <name>serialized_int2</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>data</name> <operator>&gt;&gt;</operator> <name>serialized_int2</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>serialized_int2</name></expr></argument>, <argument><expr><operator>(</operator><name>uint16_t</name><operator>)</operator><literal type="number">0x1072</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// NOTE: Serialized as LE</comment>

    <function_decl><type><name><name>BitStreamReader</name><argument_list type="generic">&lt;<argument><expr><name>CDataStream</name></expr></argument>&gt;</argument_list></name></type> <name>bit_reader</name><parameter_list>(<parameter><decl><type><name>data_copy</name></type></decl></parameter>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>bit_reader</name><operator>.</operator><name>Read</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>bit_reader</name><operator>.</operator><name>Read</name></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>bit_reader</name><operator>.</operator><name>Read</name></name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>bit_reader</name><operator>.</operator><name>Read</name></name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>bit_reader</name><operator>.</operator><name>Read</name></name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>bit_reader</name><operator>.</operator><name>Read</name></name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>bit_reader</name><operator>.</operator><name>Read</name></name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>bit_reader</name><operator>.</operator><name>Read</name></name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">30497</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_THROW</name><argument_list>(<argument><expr><call><name><name>bit_reader</name><operator>.</operator><name>Read</name></name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>ios_base</name><operator>::</operator><name>failure</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>streams_serializedata_xor</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name></type> <name>in</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name></type> <name>expected_xor</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>key</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CDataStream</name></type> <name>ds</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>

    <comment type="line">// Degenerate case</comment>

    <expr_stmt><expr><call><name><name>key</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><literal type="char">'\x00'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>key</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><literal type="char">'\x00'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>ds</name><operator>.</operator><name>Xor</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(
            <argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><call><name><name>expected_xor</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>expected_xor</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><call><name><name>ds</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>ds</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>in</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><literal type="char">'\x0f'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>in</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><literal type="char">'\xf0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>expected_xor</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><literal type="char">'\xf0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>expected_xor</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><literal type="char">'\x0f'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Single character key</comment>

    <expr_stmt><expr><call><name><name>ds</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>ds</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>ds</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>in</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>in</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>key</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>key</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><literal type="char">'\xff'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>ds</name><operator>.</operator><name>Xor</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(
            <argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><call><name><name>expected_xor</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>expected_xor</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><call><name><name>ds</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>ds</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Multi character key</comment>

    <expr_stmt><expr><call><name><name>in</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>expected_xor</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>in</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><literal type="char">'\xf0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>in</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><literal type="char">'\x0f'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>expected_xor</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><literal type="char">'\x0f'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>expected_xor</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><literal type="char">'\x00'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>ds</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>ds</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>ds</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>in</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>in</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>key</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>key</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><literal type="char">'\xff'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>key</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><literal type="char">'\x0f'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>ds</name><operator>.</operator><name>Xor</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(
            <argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><call><name><name>expected_xor</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>expected_xor</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><call><name><name>ds</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>ds</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>streams_buffered_file</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name>FILE</name><modifier>*</modifier></type> <name>file</name> <init>= <expr><call><name><name>fsbridge</name><operator>::</operator><name>fopen</name></name><argument_list>(<argument><expr><literal type="string">"streams_test_tmp"</literal></expr></argument>, <argument><expr><literal type="string">"w+b"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// The value at each offset is the offset.</comment>
    <for>for <control>(<init><decl><type><name>uint8_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">40</literal></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><operator>&amp;</operator><name>j</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>rewind</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// The buffer size (second arg) must be greater than the rewind</comment>
    <comment type="line">// amount (third arg).</comment>
    <try>try <block>{<block_content>
        <decl_stmt><decl><type><name>CBufferedFile</name></type> <name>bfbad</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="number">25</literal></expr></argument>, <argument><expr><literal type="number">25</literal></expr></argument>, <argument><expr><literal type="number">222</literal></expr></argument>, <argument><expr><literal type="number">333</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>exception</name></name><modifier>&amp;</modifier></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>strstr</name><argument_list>(<argument><expr><call><name><name>e</name><operator>.</operator><name>what</name></name><argument_list>()</argument_list></call></expr></argument>,
                        <argument><expr><literal type="string">"Rewind limit must be less than buffer size"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></catch></try>

    <comment type="line">// The buffer is 25 bytes, allow rewinding 10 bytes.</comment>
    <decl_stmt><decl><type><name>CBufferedFile</name></type> <name>bf</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="number">25</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><literal type="number">222</literal></expr></argument>, <argument><expr><literal type="number">333</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>bf</name><operator>.</operator><name>eof</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// These two members have no functional effect.</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>bf</name><operator>.</operator><name>GetType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">222</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>bf</name><operator>.</operator><name>GetVersion</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">333</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>uint8_t</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>bf</name> <operator>&gt;&gt;</operator> <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bf</name> <operator>&gt;&gt;</operator> <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// After reading bytes 0 and 1, we're positioned at 2.</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>bf</name><operator>.</operator><name>GetPos</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Rewind to offset 0, ok (within the 10 byte window).</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>bf</name><operator>.</operator><name>SetPos</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bf</name> <operator>&gt;&gt;</operator> <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// We can go forward to where we've been, but beyond may fail.</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>bf</name><operator>.</operator><name>SetPos</name></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bf</name> <operator>&gt;&gt;</operator> <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// If you know the maximum number of bytes that should be</comment>
    <comment type="line">// read to deserialize the variable, you can limit the read</comment>
    <comment type="line">// extent. The current file offset is 3, so the following</comment>
    <comment type="line">// SetLimit() allows zero bytes to be read.</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>bf</name><operator>.</operator><name>SetLimit</name></name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <try>try <block>{<block_content>
        <expr_stmt><expr><name>bf</name> <operator>&gt;&gt;</operator> <name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>exception</name></name><modifier>&amp;</modifier></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>strstr</name><argument_list>(<argument><expr><call><name><name>e</name><operator>.</operator><name>what</name></name><argument_list>()</argument_list></call></expr></argument>,
                        <argument><expr><literal type="string">"Read attempted past buffer limit"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></catch></try>
    <comment type="line">// The default argument removes the limit completely.</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>bf</name><operator>.</operator><name>SetLimit</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// The read position should still be at 3 (no change).</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>bf</name><operator>.</operator><name>GetPos</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Read from current offset, 3, forward until position 10.</comment>
    <for>for <control>(<init><decl><type><name>uint8_t</name></type> <name>j</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name>bf</name> <operator>&gt;&gt;</operator> <name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>bf</name><operator>.</operator><name>GetPos</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// We're guaranteed (just barely) to be able to rewind to zero.</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>bf</name><operator>.</operator><name>SetPos</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>bf</name><operator>.</operator><name>GetPos</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bf</name> <operator>&gt;&gt;</operator> <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// We can set the position forward again up to the farthest</comment>
    <comment type="line">// into the stream we've been, but no farther. (Attempting</comment>
    <comment type="line">// to go farther may succeed, but it's not guaranteed.)</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>bf</name><operator>.</operator><name>SetPos</name></name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bf</name> <operator>&gt;&gt;</operator> <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>bf</name><operator>.</operator><name>GetPos</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Now it's only guaranteed that we can rewind to offset 1</comment>
    <comment type="line">// (current read position, 11, minus rewind amount, 10).</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>bf</name><operator>.</operator><name>SetPos</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>bf</name><operator>.</operator><name>GetPos</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bf</name> <operator>&gt;&gt;</operator> <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// We can stream into large variables, even larger than</comment>
    <comment type="line">// the buffer size.</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>bf</name><operator>.</operator><name>SetPos</name></name><argument_list>(<argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>a</name><index>[<expr><literal type="number">40</literal> <operator>-</operator> <literal type="number">11</literal></expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><name>bf</name> <operator>&gt;&gt;</operator> <name>a</name></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>uint8_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">11</literal> <operator>+</operator> <name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>bf</name><operator>.</operator><name>GetPos</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">40</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// We've read the entire file, the next read should throw.</comment>
    <try>try <block>{<block_content>
        <expr_stmt><expr><name>bf</name> <operator>&gt;&gt;</operator> <name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>exception</name></name><modifier>&amp;</modifier></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>strstr</name><argument_list>(<argument><expr><call><name><name>e</name><operator>.</operator><name>what</name></name><argument_list>()</argument_list></call></expr></argument>,
                        <argument><expr><literal type="string">"CBufferedFile::Fill: end of file"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></catch></try>
    <comment type="line">// Attempting to read beyond the end sets the EOF indicator.</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>bf</name><operator>.</operator><name>eof</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Still at offset 40, we can go back 10, to 30.</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>bf</name><operator>.</operator><name>GetPos</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">40</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>bf</name><operator>.</operator><name>SetPos</name></name><argument_list>(<argument><expr><literal type="number">30</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bf</name> <operator>&gt;&gt;</operator> <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">30</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>bf</name><operator>.</operator><name>GetPos</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">31</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// We're too far to rewind to position zero.</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>bf</name><operator>.</operator><name>SetPos</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// But we should now be positioned at least as far back as allowed</comment>
    <comment type="line">// by the rewind window (relative to our farthest read position, 40).</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>bf</name><operator>.</operator><name>GetPos</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <literal type="number">30</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// We can explicitly close the file, or the destructor will do it.</comment>
    <expr_stmt><expr><call><name><name>bf</name><operator>.</operator><name>fclose</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>fs</name><operator>::</operator><name>remove</name></name><argument_list>(<argument><expr><literal type="string">"streams_test_tmp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>streams_buffered_file_rand</argument>)</argument_list></macro>
<block>{<block_content>
    <comment type="line">// Make this test deterministic.</comment>
    <expr_stmt><expr><call><name>SeedInsecureRand</name><argument_list>(<argument><expr><name><name>SeedRand</name><operator>::</operator><name>ZEROS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><decl><type><name>int</name></type> <name>rep</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>rep</name> <operator>&lt;</operator> <literal type="number">50</literal></expr>;</condition> <incr><expr><operator>++</operator><name>rep</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>FILE</name><modifier>*</modifier></type> <name>file</name> <init>= <expr><call><name><name>fsbridge</name><operator>::</operator><name>fopen</name></name><argument_list>(<argument><expr><literal type="string">"streams_test_tmp"</literal></expr></argument>, <argument><expr><literal type="string">"w+b"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>fileSize</name> <init>= <expr><call><name>InsecureRandRange</name><argument_list>(<argument><expr><literal type="number">256</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>uint8_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>fileSize</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>rewind</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>size_t</name></type> <name>bufSize</name> <init>= <expr><call><name>InsecureRandRange</name><argument_list>(<argument><expr><literal type="number">300</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>rewindSize</name> <init>= <expr><call><name>InsecureRandRange</name><argument_list>(<argument><expr><name>bufSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CBufferedFile</name></type> <name>bf</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>bufSize</name></expr></argument>, <argument><expr><name>rewindSize</name></expr></argument>, <argument><expr><literal type="number">222</literal></expr></argument>, <argument><expr><literal type="number">333</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>currentPos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>maxPos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>step</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>step</name> <operator>&lt;</operator> <literal type="number">100</literal></expr>;</condition> <incr><expr><operator>++</operator><name>step</name></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>currentPos</name> <operator>&gt;=</operator> <name>fileSize</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>

            <comment type="line">// We haven't read to the end of the file yet.</comment>
            <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>bf</name><operator>.</operator><name>eof</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>bf</name><operator>.</operator><name>GetPos</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>currentPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Pretend the file consists of a series of objects of varying</comment>
            <comment type="line">// sizes; the boundaries of the objects can interact arbitrarily</comment>
            <comment type="line">// with the CBufferFile's internal buffer. These first three</comment>
            <comment type="line">// cases simulate objects of various sizes (1, 2, 5 bytes).</comment>
            <switch>switch <condition>(<expr><call><name>InsecureRandRange</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <case>case <expr><literal type="number">0</literal></expr>:</case> <block>{<block_content>
                <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>currentPos</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name>fileSize</name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name><name>bf</name><operator>.</operator><name>SetLimit</name></name><argument_list>(<argument><expr><name>currentPos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>bf</name> <operator>&gt;&gt;</operator> <name>a</name></expr>;</expr_stmt>
                <for>for <control>(<init><decl><type><name>uint8_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
                    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>currentPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>currentPos</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></for>
                <break>break;</break>
            </block_content>}</block>
            <case>case <expr><literal type="number">1</literal></expr>:</case> <block>{<block_content>
                <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>currentPos</name> <operator>+</operator> <literal type="number">2</literal> <operator>&gt;</operator> <name>fileSize</name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name><name>bf</name><operator>.</operator><name>SetLimit</name></name><argument_list>(<argument><expr><name>currentPos</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>bf</name> <operator>&gt;&gt;</operator> <name>a</name></expr>;</expr_stmt>
                <for>for <control>(<init><decl><type><name>uint8_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
                    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>currentPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>currentPos</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></for>
                <break>break;</break>
            </block_content>}</block>
            <case>case <expr><literal type="number">2</literal></expr>:</case> <block>{<block_content>
                <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>a</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>currentPos</name> <operator>+</operator> <literal type="number">5</literal> <operator>&gt;</operator> <name>fileSize</name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name><name>bf</name><operator>.</operator><name>SetLimit</name></name><argument_list>(<argument><expr><name>currentPos</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>bf</name> <operator>&gt;&gt;</operator> <name>a</name></expr>;</expr_stmt>
                <for>for <control>(<init><decl><type><name>uint8_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
                    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>currentPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>currentPos</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></for>
                <break>break;</break>
            </block_content>}</block>
            <case>case <expr><literal type="number">3</literal></expr>:</case> <block>{<block_content>
                <comment type="line">// Find a byte value (that is at or ahead of the current position).</comment>
                <decl_stmt><decl><type><name>size_t</name></type> <name>find</name> <init>= <expr><name>currentPos</name> <operator>+</operator> <call><name>InsecureRandRange</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>find</name> <operator>&gt;=</operator> <name>fileSize</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>find</name> <operator>=</operator> <name>fileSize</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name><name>bf</name><operator>.</operator><name>FindByte</name></name><argument_list>(<argument><expr><cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name>find</name></expr></argument>)</argument_list></cast></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// The value at each offset is the offset.</comment>
                <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>bf</name><operator>.</operator><name>GetPos</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>find</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>currentPos</name> <operator>=</operator> <name>find</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name><name>bf</name><operator>.</operator><name>SetLimit</name></name><argument_list>(<argument><expr><name>currentPos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>uint8_t</name></type> <name>i</name></decl>;</decl_stmt>
                <expr_stmt><expr><name>bf</name> <operator>&gt;&gt;</operator> <name>i</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>currentPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>currentPos</name><operator>++</operator></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
            <case>case <expr><literal type="number">4</literal></expr>:</case> <block>{<block_content>
                <decl_stmt><decl><type><name>size_t</name></type> <name>requestPos</name> <init>= <expr><call><name>InsecureRandRange</name><argument_list>(<argument><expr><name>maxPos</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type> <name>okay</name> <init>= <expr><call><name><name>bf</name><operator>.</operator><name>SetPos</name></name><argument_list>(<argument><expr><name>requestPos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <comment type="line">// The new position may differ from the requested position</comment>
                <comment type="line">// because we may not be able to rewind beyond the rewind</comment>
                <comment type="line">// window, and we may not be able to move forward beyond the</comment>
                <comment type="line">// farthest position we've reached so far.</comment>
                <expr_stmt><expr><name>currentPos</name> <operator>=</operator> <call><name><name>bf</name><operator>.</operator><name>GetPos</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>okay</name></expr></argument>, <argument><expr><name>currentPos</name> <operator>==</operator> <name>requestPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// Check that we can position within the rewind window.</comment>
                <if_stmt><if>if <condition>(<expr><name>requestPos</name> <operator>&lt;=</operator> <name>maxPos</name> <operator>&amp;&amp;</operator>
                    <name>maxPos</name> <operator>&gt;</operator> <name>rewindSize</name> <operator>&amp;&amp;</operator>
                    <name>requestPos</name> <operator>&gt;=</operator> <name>maxPos</name> <operator>-</operator> <name>rewindSize</name></expr>)</condition> <block>{<block_content>
                    <comment type="line">// We requested a position within the rewind window.</comment>
                    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name>okay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block>
            </block_content>}</block></switch>
            <if_stmt><if>if <condition>(<expr><name>maxPos</name> <operator>&lt;</operator> <name>currentPos</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>maxPos</name> <operator>=</operator> <name>currentPos</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name><name>fs</name><operator>::</operator><name>remove</name></name><argument_list>(<argument><expr><literal type="string">"streams_test_tmp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_SUITE_END</name><argument_list>()</argument_list></macro>
</unit>
