<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/mmm/Projects/bitcoin/src/tinyformat.h"><comment type="line">// tinyformat.h</comment>
<comment type="line">// Copyright (C) 2011, Chris Foster [chris42f (at) gmail (d0t) com]</comment>
<comment type="line">//</comment>
<comment type="line">// Boost Software License - Version 1.0</comment>
<comment type="line">//</comment>
<comment type="line">// Permission is hereby granted, free of charge, to any person or organization</comment>
<comment type="line">// obtaining a copy of the software and accompanying documentation covered by</comment>
<comment type="line">// this license (the "Software") to use, reproduce, display, distribute,</comment>
<comment type="line">// execute, and transmit the Software, and to prepare derivative works of the</comment>
<comment type="line">// Software, and to permit third-parties to whom the Software is furnished to</comment>
<comment type="line">// do so, all subject to the following:</comment>
<comment type="line">//</comment>
<comment type="line">// The copyright notices in the Software and this entire statement, including</comment>
<comment type="line">// the above license grant, this restriction and the following disclaimer,</comment>
<comment type="line">// must be included in all copies of the Software, in whole or in part, and</comment>
<comment type="line">// all derivative works of the Software, unless such copies or derivative</comment>
<comment type="line">// works are solely in the form of machine-executable object code generated by</comment>
<comment type="line">// a source language processor.</comment>
<comment type="line">//</comment>
<comment type="line">// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</comment>
<comment type="line">// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</comment>
<comment type="line">// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT</comment>
<comment type="line">// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE</comment>
<comment type="line">// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,</comment>
<comment type="line">// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER</comment>
<comment type="line">// DEALINGS IN THE SOFTWARE.</comment>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// Tinyformat: A minimal type safe printf replacement</comment>
<comment type="line">//</comment>
<comment type="line">// tinyformat.h is a type safe printf replacement library in a single C++</comment>
<comment type="line">// header file.  Design goals include:</comment>
<comment type="line">//</comment>
<comment type="line">// * Type safety and extensibility for user defined types.</comment>
<comment type="line">// * C99 printf() compatibility, to the extent possible using std::ostream</comment>
<comment type="line">// * Simplicity and minimalism.  A single header file to include and distribute</comment>
<comment type="line">//   with your projects.</comment>
<comment type="line">// * Augment rather than replace the standard stream formatting mechanism</comment>
<comment type="line">// * C++98 support, with optional C++11 niceties</comment>
<comment type="line">//</comment>
<comment type="line">//</comment>
<comment type="line">// Main interface example usage</comment>
<comment type="line">// ----------------------------</comment>
<comment type="line">//</comment>
<comment type="line">// To print a date to std::cout:</comment>
<comment type="line">//</comment>
<comment type="line">//   std::string weekday = "Wednesday";</comment>
<comment type="line">//   const char* month = "July";</comment>
<comment type="line">//   size_t day = 27;</comment>
<comment type="line">//   long hour = 14;</comment>
<comment type="line">//   int min = 44;</comment>
<comment type="line">//</comment>
<comment type="line">//   tfm::printf("%s, %s %d, %.2d:%.2d\n", weekday, month, day, hour, min);</comment>
<comment type="line">//</comment>
<comment type="line">// The strange types here emphasize the type safety of the interface; it is</comment>
<comment type="line">// possible to print a std::string using the "%s" conversion, and a</comment>
<comment type="line">// size_t using the "%d" conversion.  A similar result could be achieved</comment>
<comment type="line">// using either of the tfm::format() functions.  One prints on a user provided</comment>
<comment type="line">// stream:</comment>
<comment type="line">//</comment>
<comment type="line">//   tfm::format(std::cerr, "%s, %s %d, %.2d:%.2d\n",</comment>
<comment type="line">//               weekday, month, day, hour, min);</comment>
<comment type="line">//</comment>
<comment type="line">// The other returns a std::string:</comment>
<comment type="line">//</comment>
<comment type="line">//   std::string date = tfm::format("%s, %s %d, %.2d:%.2d\n",</comment>
<comment type="line">//                                  weekday, month, day, hour, min);</comment>
<comment type="line">//   std::cout &lt;&lt; date;</comment>
<comment type="line">//</comment>
<comment type="line">// These are the three primary interface functions.  There is also a</comment>
<comment type="line">// convenience function printfln() which appends a newline to the usual result</comment>
<comment type="line">// of printf() for super simple logging.</comment>
<comment type="line">//</comment>
<comment type="line">//</comment>
<comment type="line">// User defined format functions</comment>
<comment type="line">// -----------------------------</comment>
<comment type="line">//</comment>
<comment type="line">// Simulating variadic templates in C++98 is pretty painful since it requires</comment>
<comment type="line">// writing out the same function for each desired number of arguments.  To make</comment>
<comment type="line">// this bearable tinyformat comes with a set of macros which are used</comment>
<comment type="line">// internally to generate the API, but which may also be used in user code.</comment>
<comment type="line">//</comment>
<comment type="line">// The three macros TINYFORMAT_ARGTYPES(n), TINYFORMAT_VARARGS(n) and</comment>
<comment type="line">// TINYFORMAT_PASSARGS(n) will generate a list of n argument types,</comment>
<comment type="line">// type/name pairs and argument names respectively when called with an integer</comment>
<comment type="line">// n between 1 and 16.  We can use these to define a macro which generates the</comment>
<comment type="line">// desired user defined function with n arguments.  To generate all 16 user</comment>
<comment type="line">// defined function bodies, use the macro TINYFORMAT_FOREACH_ARGNUM.  For an</comment>
<comment type="line">// example, see the implementation of printf() at the end of the source file.</comment>
<comment type="line">//</comment>
<comment type="line">// Sometimes it's useful to be able to pass a list of format arguments through</comment>
<comment type="line">// to a non-template function.  The FormatList class is provided as a way to do</comment>
<comment type="line">// this by storing the argument list in a type-opaque way.  Continuing the</comment>
<comment type="line">// example from above, we construct a FormatList using makeFormatList():</comment>
<comment type="line">//</comment>
<comment type="line">//   FormatListRef formatList = tfm::makeFormatList(weekday, month, day, hour, min);</comment>
<comment type="line">//</comment>
<comment type="line">// The format list can now be passed into any non-template function and used</comment>
<comment type="line">// via a call to the vformat() function:</comment>
<comment type="line">//</comment>
<comment type="line">//   tfm::vformat(std::cout, "%s, %s %d, %.2d:%.2d\n", formatList);</comment>
<comment type="line">//</comment>
<comment type="line">//</comment>
<comment type="line">// Additional API information</comment>
<comment type="line">// --------------------------</comment>
<comment type="line">//</comment>
<comment type="line">// Error handling: Define TINYFORMAT_ERROR to customize the error handling for</comment>
<comment type="line">// format strings which are unsupported or have the wrong number of format</comment>
<comment type="line">// specifiers (calls assert() by default).</comment>
<comment type="line">//</comment>
<comment type="line">// User defined types: Uses operator&lt;&lt; for user defined types by default.</comment>
<comment type="line">// Overload formatValue() for more control.</comment>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>TINYFORMAT_H_INCLUDED</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_H_INCLUDED</name></cpp:macro></cpp:define>

<decl_stmt><decl><type><name>namespace</name></type> <name>tinyformat</name> <block>{<block_content/>}</block></decl></decl_stmt>
<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// Config section.  Customize to your liking!</comment>

<comment type="line">// Namespace alias to encourage brevity</comment>
<decl_stmt><decl><type><name>namespace</name></type> <name>tfm</name> <init>= <expr><name>tinyformat</name></expr></init></decl>;</decl_stmt>

<comment type="line">// Error handling; calls assert() by default.</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_ERROR</name><parameter_list>(<parameter><type><name>reasonString</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>throw tinyformat::format_error(reasonString)</cpp:value></cpp:define>

<comment type="line">// Define for C++11 variadic templates which make the code shorter &amp; more</comment>
<comment type="line">// general.  If you don't define this, C++11 support is autodetected below.</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_USE_VARIADIC_TEMPLATES</name></cpp:macro></cpp:define>


<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// Implementation details.</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;algorithm&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;iostream&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sstream&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdexcept&gt;</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>TINYFORMAT_ERROR</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_ERROR</name><parameter_list>(<parameter><type><name>reason</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>assert(0 &amp;&amp; reason)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>TINYFORMAT_USE_VARIADIC_TEMPLATES</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>TINYFORMAT_NO_VARIADIC_TEMPLATES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:ifdef>#   <cpp:directive>ifdef</cpp:directive> <name>__GXX_EXPERIMENTAL_CXX0X__</name></cpp:ifdef>
<cpp:define>#       <cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_USE_VARIADIC_TEMPLATES</name></cpp:macro></cpp:define>
<cpp:endif>#   <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GLIBCXX__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>__GLIBCXX__</name> <operator>&lt;</operator> <literal type="number">20080201</literal></expr></cpp:if>
<comment type="line">//  std::showpos is broken on old libstdc++ as provided with OSX.  See</comment>
<comment type="line">//  http://gcc.gnu.org/ml/libstdc++/2007-11/msg00075.html</comment>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__APPLE__</name></cpp:ifdef>
<comment type="line">// Workaround OSX linker warning: Xcode uses different default symbol</comment>
<comment type="line">// visibilities for static libs vs executables (see issue #25)</comment>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_HIDDEN</name></cpp:macro> <cpp:value>__attribute__((visibility("hidden")))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_HIDDEN</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>namespace</name></type> <name>tinyformat</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>format_error</name><range>: <expr><name>public</name> <name>std</name><operator>::</operator><name>runtime_error</name>
<block>{
<expr><name>public</name><operator>:</operator>
    <name>explicit</name> <call><name>format_error</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>what</name></expr></argument>)</argument_list></call><operator>:</operator> <name>std</name><operator>::</operator><macro><name>runtime_error</name><argument_list>(<argument>what</argument>)</argument_list></macro> <block>{
    }</block></expr>
}</block></expr></range></decl>;</decl_stmt>

<comment type="line">//------------------------------------------------------------------------------</comment>
<decl_stmt><decl><type><name>namespace</name></type> <name>detail</name> <block>{<block_content>

<comment type="line">// Test whether type T1 is convertible to type T2</comment>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T1</name></expr><operator>,</operator> <expr><name>typename</name> <name>T2</name><operator>&gt;</operator>
struct <name>is_convertible</name>
<block>{
    <expr><name>private</name><operator>:</operator>
        <comment type="line">// two types of different size</comment>
        struct <name>fail</name> <block>{ <expr><name>char</name> <name><name>dummy</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>; }</block></expr>;
        struct <expr><name>succeed</name> <block>{ <expr><name>char</name> <name>dummy</name></expr>; }</block></expr>;
        <comment type="line">// Try to convert a T1 to a T2 by plugging into tryConvert</comment>
        <expr><specifier>static</specifier> <name>fail</name> <call><name>tryConvert</name><argument_list>(<argument><expr><operator>...</operator></expr></argument>)</argument_list></call></expr>;
        <expr><specifier>static</specifier> <name>succeed</name> <call><name>tryConvert</name><argument_list>(<argument><expr><specifier>const</specifier> <name>T2</name><operator>&amp;</operator></expr></argument>)</argument_list></call></expr>;
        <expr><specifier>static</specifier> <specifier>const</specifier> <name>T1</name><operator>&amp;</operator> <call><name>makeT1</name><argument_list>()</argument_list></call></expr>;
    <expr><name>public</name><operator>:</operator>
<cpp:ifdef>#       <cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
        <comment type="line">// Disable spurious loss of precision warnings in tryConvert(makeT1())</comment>
<cpp:pragma>#       <cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>push</name><name>)</name></cpp:pragma>
<cpp:pragma>#       <cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name><name>:</name><name>4244</name><name>)</name></cpp:pragma>
<cpp:pragma>#       <cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name><name>:</name><name>4267</name><name>)</name></cpp:pragma>
<cpp:endif>#       <cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="line">// Standard trick: the (...) version of tryConvert will be chosen from</comment>
        <comment type="line">// the overload set only if the version taking a T2 doesn't match.</comment>
        <comment type="line">// Then we compare the sizes of the return types to check which</comment>
        <comment type="line">// function matched.  Very neat, in a disgusting kind of way :)</comment>
        <specifier>static</specifier> <specifier>const</specifier> <name>bool</name> <name>value</name> <operator>=</operator>
            <sizeof>sizeof<argument_list>(<argument><expr><call><name>tryConvert</name><argument_list>(<argument><expr><call><name>makeT1</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>succeed</name></expr></argument>)</argument_list></sizeof></expr>;
<cpp:ifdef>#       <cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
<cpp:pragma>#       <cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>pop</name><name>)</name></cpp:pragma>
<cpp:endif>#       <cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr>;</expr_stmt>


<comment type="line">// Detect when a type is not a wchar_t string</comment>
<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T</name><operator>&gt;</operator> struct <name>is_wchar</name> <block>{ <typedef>typedef <type><name>int</name></type> <name>tinyformat_wchar_is_not_supported</name>;</typedef> }</block></expr></expr_stmt><empty_stmt>;</empty_stmt>
<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>is_wchar</name><argument_list type="generic">&lt;<argument><expr><name>wchar_t</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{}</block></expr>;</expr_stmt>
<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>is_wchar</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>wchar_t</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{}</block></expr>;</expr_stmt>
<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><name>int</name> <name>n</name><operator>&gt;</operator> struct <name><name>is_wchar</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name><name>wchar_t</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>&gt;</argument_list></name> <block>{}</block></expr>;</expr_stmt>
<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><name>int</name> <name>n</name><operator>&gt;</operator> struct <name><name>is_wchar</name><argument_list type="generic">&lt;<argument><expr><name><name>wchar_t</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>&gt;</argument_list></name> <block>{}</block></expr>;</expr_stmt>


<comment type="line">// Format the value by casting to type fmtT.  This default implementation</comment>
<comment type="line">// should never be called.</comment>
<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T</name></expr><operator>,</operator> <expr><name>typename</name> <name>fmtT</name></expr><operator>,</operator> <expr><name>bool</name> <name>convertible</name> <operator>=</operator> <name><name>is_convertible</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>fmtT</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name><operator>&gt;</operator>
struct <name>formatValueAsType</name>
<block>{
    <expr><specifier>static</specifier> <name>void</name> <macro><name>invoke</name><argument_list>(<argument>std::ostream&amp;</argument> <comment type="block">/*out*/</comment>, <argument>const T&amp;</argument> <comment type="block">/*value*/</comment>)</argument_list></macro> <block>{ <expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>; }</block></expr>
}</block></expr>;</expr_stmt>
<comment type="line">// Specialized version for types that can actually be converted to fmtT, as</comment>
<comment type="line">// indicated by the "convertible" template parameter.</comment>
<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T</name></expr><operator>,</operator> <expr><name>typename</name> <name>fmtT</name><operator>&gt;</operator>
struct <name><name>formatValueAsType</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>,<argument><expr><name>fmtT</name></expr></argument>,<argument><expr><name>true</name></expr></argument>&gt;</argument_list></name>
<block>{
    <expr><specifier>static</specifier> <name>void</name> <macro><name>invoke</name><argument_list>(<argument>std::ostream&amp; out</argument>, <argument>const T&amp; value</argument>)</argument_list></macro>
        <block>{ <expr><name>out</name> <operator>&lt;&lt;</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>fmtT</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>; }</block></expr>
}</block></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND</name></cpp:ifdef>
<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T</name></expr><operator>,</operator> <expr><name>bool</name> <name>convertible</name> <operator>=</operator> <name><name>is_convertible</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>int</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name><operator>&gt;</operator>
struct <name>formatZeroIntegerWorkaround</name>
<block>{
    <expr><specifier>static</specifier> <name>bool</name> <macro><name>invoke</name><argument_list>(<argument>std::ostream&amp;</argument> <comment type="block">/**/</comment>, <argument>const T&amp;</argument> <comment type="block">/**/</comment>)</argument_list></macro> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
}</expr>;
<expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
struct <name><name>formatZeroIntegerWorkaround</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>,<argument><expr><name>true</name></expr></argument>&gt;</argument_list></name>
<block>{
    <expr><specifier>static</specifier> <name>bool</name> <macro><name>invoke</name><argument_list>(<argument>std::ostream&amp; out</argument>, <argument>const T&amp; value</argument>)</argument_list></macro>
    <block>{
        <if_stmt><if>if <condition>(<expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name><name>out</name><operator>.</operator><name>flags</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>showpos</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>out</name> <operator>&lt;&lt;</operator> <literal type="string">"+0"</literal></expr>;</expr_stmt>
            <return>return <expr><name>true</name></expr>;</return>
        <expr_stmt/>}</block_content>
        return false</block><empty_stmt>;</empty_stmt></if></if_stmt>
    }</block>
}</expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND</comment>

<comment type="line">// Convert an arbitrary type to integer.  The version with convertible=false</comment>
<comment type="line">// throws an error.</comment>
<expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>bool</name> <name>convertible</name> <operator>=</operator> <name><name>is_convertible</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>,<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name>
struct <name>convertToInt</name>
<block>{
    <expr><specifier>static</specifier> <name>int</name> <macro><name>invoke</name><argument_list>(<argument>const T&amp;</argument> <comment type="block">/*value*/</comment>)</argument_list></macro>
    <block>{
        <expr><call><name>TINYFORMAT_ERROR</name><argument_list>(<argument><expr><literal type="string">"tinyformat: Cannot convert from argument type to "</literal>
                         <literal type="string">"integer for use as variable width or precision"</literal></expr></argument>)</argument_list></call></expr>;
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    }</block>
}</expr>;
<comment type="line">// Specialization for convertToInt when conversion is possible</comment>
<expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
struct <name><name>convertToInt</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>,<argument><expr><name>true</name></expr></argument>&gt;</argument_list></name>
<block>{
    <expr><specifier>static</specifier> <name>int</name> <macro><name>invoke</name><argument_list>(<argument>const T&amp; value</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
}</expr>;

<comment type="line">// Format at most ntrunc characters to the given stream.</comment>
<expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>void</name> <macro><name>formatTruncated</name><argument_list>(<argument>std::ostream&amp; out</argument>, <argument>const T&amp; value</argument>, <argument>int ntrunc</argument>)</argument_list></macro>
<block>{
    <expr><name>std</name><operator>::</operator><name>ostringstream</name> <name>tmp</name></expr>;
    <expr><name>tmp</name> <operator>&lt;&lt;</operator> <name>value</name></expr>;
    <expr><name>std</name><operator>::</operator><name>string</name> <name>result</name> <operator>=</operator> <call><name><name>tmp</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr>;
    <expr><call><name><name>out</name><operator>.</operator><name>write</name></name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>std</name><operator>::</operator><name>min</name><operator>)</operator><operator>(</operator><name>ntrunc</name><operator>,</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;
}</block>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR</name><parameter_list>(<parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro>       \
<cpp:value>inline void formatTruncated(std::ostream&amp; out, type* value, int ntrunc) \
{                                                           \
    std::streamsize len = 0;                                \
    while(len &lt; ntrunc &amp;&amp; value[len] != 0)                  \
        ++len;                                              \
    out.write(value, len);                                  \
}</cpp:value></cpp:define>
<comment type="line">// Overload for const char* and char*.  Could overload for signed &amp; unsigned</comment>
<comment type="line">// char too, but these are technically unneeded for printf compatibility.</comment>
<macro><name>TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR</name><argument_list>(<argument>const char</argument>)</argument_list></macro>
<macro><name>TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR</name><argument_list>(<argument>char</argument>)</argument_list></macro></expr>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR</name></cpp:undef>

}</block> <comment type="line">// namespace detail</comment>


<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// Variable formatting functions.  May be overridden for user-defined types if</comment>
<comment type="line">// desired.</comment>


<comment type="line" format="doxygen">/// Format a value into a stream, delegating to operator&lt;&lt; by default.</comment>
<comment type="line" format="doxygen">///</comment>
<comment type="line" format="doxygen">/// Users may override this for their own types.  When this function is called,</comment>
<comment type="line" format="doxygen">/// the stream flags will have been modified according to the format string.</comment>
<comment type="line" format="doxygen">/// The format specification is provided in the range [fmtBegin, fmtEnd).  For</comment>
<comment type="line" format="doxygen">/// truncating conversions, ntrunc is set to the desired maximum number of</comment>
<comment type="line" format="doxygen">/// characters, for example "%.7s" calls formatValue with ntrunc = 7.</comment>
<comment type="line" format="doxygen">///</comment>
<comment type="line" format="doxygen">/// By default, formatValue() uses the usual stream insertion operator</comment>
<comment type="line" format="doxygen">/// operator&lt;&lt; to format the type T, with special cases for the %c and %p</comment>
<comment type="line" format="doxygen">/// conversions.</comment>
<name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>void</name> <macro><name>formatValue</name><argument_list>(<argument>std::ostream&amp; out</argument>, <argument>const char*</argument> <comment type="block">/*fmtBegin*/</comment>,
                        <argument>const char* fmtEnd</argument>, <argument>int ntrunc</argument>, <argument>const T&amp; value</argument>)</argument_list></macro>
<block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>TINYFORMAT_ALLOW_WCHAR_STRINGS</name></cpp:ifndef>
    <comment type="line">// Since we don't support printing of wchar_t using "%ls", make it fail at</comment>
    <comment type="line">// compile time in preference to printing as a void* at runtime.</comment>
    <typedef>typedef <expr_stmt><expr><name>typename</name> <name>detail</name><operator>::</operator><name><name>is_wchar</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>tinyformat_wchar_is_not_supported</name> <name>DummyType</name></expr>;</expr_stmt></typedef>
    <operator>(</operator><name>void</name><operator>)</operator> <call><name>DummyType</name><argument_list>()</argument_list></call></block></expr>; <comment type="line">// avoid unused type warning with gcc-4.8</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="line">// The mess here is to support the %c and %p conversions: if these</comment>
    <comment type="line">// conversions are active we try to convert the type to a char or const</comment>
    <comment type="line">// void* respectively and format that instead of the value itself.  For the</comment>
    <comment type="line">// %p conversion it's important to avoid dereferencing the pointer, which</comment>
    <comment type="line">// could otherwise lead to a crash when printing a dangling (const char*).</comment>
    <expr><specifier>const</specifier> <name>bool</name> <name>canConvertToChar</name> <operator>=</operator> <name>detail</name><operator>::</operator><name><name>is_convertible</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>,<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr>;
    <expr><specifier>const</specifier> <name>bool</name> <name>canConvertToVoidPtr</name> <operator>=</operator> <name>detail</name><operator>::</operator><name><name>is_convertible</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>void</name><operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr>;
    <if_stmt><if>if<condition>(<expr><name>canConvertToChar</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>fmtEnd</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'c'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>detail</name><operator>::</operator><name><name>formatValueAsType</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>char</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>invoke</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if<condition>(<expr><name>canConvertToVoidPtr</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>fmtEnd</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'p'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>detail</name><operator>::</operator><name><name>formatValueAsType</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>void</name><operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>invoke</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND</name></cpp:ifdef>
    <if type="elseif">else if<condition>(<expr><name>detail</name><operator>::</operator><name><name>formatZeroIntegerWorkaround</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>invoke</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/**/</comment><empty_stmt>;</empty_stmt></block_content></block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if type="elseif">else if<condition>(<expr><name>ntrunc</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// Take care not to overread C strings in truncating conversions like</comment>
        <comment type="line">// "%.4s" where at most 4 characters may be read.</comment>
        <expr_stmt><expr><name>detail</name><operator>::</operator><call><name>formatTruncated</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>ntrunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt/>}</block_content>
    else
        out &lt;&lt; value</block><empty_stmt>;</empty_stmt></if></if_stmt>
}</block>


<comment type="line">// Overloaded version for char types to support printing as an integer</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_DEFINE_FORMATVALUE_CHAR</name><parameter_list>(<parameter><type><name>charType</name></type></parameter>)</parameter_list></cpp:macro>                  \
<cpp:value>inline void formatValue(std::ostream&amp; out, const char* <comment type="block">/*fmtBegin*/</comment>,  \
                        const char* fmtEnd, int <comment type="block">/**/</comment>, charType value) \
{                                                                     \
    switch(*(fmtEnd-1))                                               \
    {                                                                 \
        case 'u': case 'd': case 'i': case 'o': case 'X': case 'x':   \
            out &lt;&lt; static_cast&lt;int&gt;(value); break;                    \
        default:                                                      \
            out &lt;&lt; value;                   break;                    \
    }                                                                 \
}</cpp:value></cpp:define>
<comment type="line">// per 3.9.1: char, signed char and unsigned char are all distinct types</comment>
<macro><name>TINYFORMAT_DEFINE_FORMATVALUE_CHAR</name><argument_list>(<argument>char</argument>)</argument_list></macro>
<macro><name>TINYFORMAT_DEFINE_FORMATVALUE_CHAR</name><argument_list>(<argument>signed char</argument>)</argument_list></macro>
<macro><name>TINYFORMAT_DEFINE_FORMATVALUE_CHAR</name><argument_list>(<argument>unsigned char</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TINYFORMAT_DEFINE_FORMATVALUE_CHAR</name></cpp:undef>


<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// Tools for emulating variadic templates in C++98.  The basic idea here is</comment>
<comment type="line">// stolen from the boost preprocessor metaprogramming library and cut down to</comment>
<comment type="line">// be just general enough for what we need.</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_ARGTYPES</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>TINYFORMAT_ARGTYPES_ ## n</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_VARARGS</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>TINYFORMAT_VARARGS_ ## n</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>TINYFORMAT_PASSARGS_ ## n</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_TAIL</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>TINYFORMAT_PASSARGS_TAIL_ ## n</cpp:value></cpp:define>

<comment type="line">// To keep it as transparent as possible, the macros below have been generated</comment>
<comment type="line">// using python via the excellent cog.py code generation script.  This avoids</comment>
<comment type="line">// the need for a bunch of complex (but more general) preprocessor tricks as</comment>
<comment type="line">// used in boost.preprocessor.</comment>
<comment type="line">//</comment>
<comment type="line">// To rerun the code generation in place, use `cog.py -r tinyformat.h`</comment>
<comment type="line">// (see http://nedbatchelder.com/code/cog).  Alternatively you can just create</comment>
<comment type="line">// extra versions by hand.</comment>

<comment type="block">/*[[[cog
maxParams = 16

def makeCommaSepLists(lineTemplate, elemTemplate, startInd=1):
    for j in range(startInd,maxParams+1):
        list = ', '.join([elemTemplate % {'i':i} for i in range(startInd,j+1)])
        cog.outl(lineTemplate % {'j':j, 'list':list})

makeCommaSepLists('#define TINYFORMAT_ARGTYPES_%(j)d %(list)s',
                  'class T%(i)d')

cog.outl()
makeCommaSepLists('#define TINYFORMAT_VARARGS_%(j)d %(list)s',
                  'const T%(i)d&amp; v%(i)d')

cog.outl()
makeCommaSepLists('#define TINYFORMAT_PASSARGS_%(j)d %(list)s', 'v%(i)d')

cog.outl()
cog.outl('#define TINYFORMAT_PASSARGS_TAIL_1')
makeCommaSepLists('#define TINYFORMAT_PASSARGS_TAIL_%(j)d , %(list)s',
                  'v%(i)d', startInd = 2)

cog.outl()
cog.outl('#define TINYFORMAT_FOREACH_ARGNUM(m) \\\n    ' +
         ' '.join(['m(%d)' % (j,) for j in range(1,maxParams+1)]))
]]]*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_ARGTYPES_1</name></cpp:macro> <cpp:value>class T1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_ARGTYPES_2</name></cpp:macro> <cpp:value>class T1, class T2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_ARGTYPES_3</name></cpp:macro> <cpp:value>class T1, class T2, class T3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_ARGTYPES_4</name></cpp:macro> <cpp:value>class T1, class T2, class T3, class T4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_ARGTYPES_5</name></cpp:macro> <cpp:value>class T1, class T2, class T3, class T4, class T5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_ARGTYPES_6</name></cpp:macro> <cpp:value>class T1, class T2, class T3, class T4, class T5, class T6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_ARGTYPES_7</name></cpp:macro> <cpp:value>class T1, class T2, class T3, class T4, class T5, class T6, class T7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_ARGTYPES_8</name></cpp:macro> <cpp:value>class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_ARGTYPES_9</name></cpp:macro> <cpp:value>class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_ARGTYPES_10</name></cpp:macro> <cpp:value>class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_ARGTYPES_11</name></cpp:macro> <cpp:value>class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_ARGTYPES_12</name></cpp:macro> <cpp:value>class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_ARGTYPES_13</name></cpp:macro> <cpp:value>class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_ARGTYPES_14</name></cpp:macro> <cpp:value>class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_ARGTYPES_15</name></cpp:macro> <cpp:value>class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_ARGTYPES_16</name></cpp:macro> <cpp:value>class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_VARARGS_1</name></cpp:macro> <cpp:value>const T1&amp; v1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_VARARGS_2</name></cpp:macro> <cpp:value>const T1&amp; v1, const T2&amp; v2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_VARARGS_3</name></cpp:macro> <cpp:value>const T1&amp; v1, const T2&amp; v2, const T3&amp; v3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_VARARGS_4</name></cpp:macro> <cpp:value>const T1&amp; v1, const T2&amp; v2, const T3&amp; v3, const T4&amp; v4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_VARARGS_5</name></cpp:macro> <cpp:value>const T1&amp; v1, const T2&amp; v2, const T3&amp; v3, const T4&amp; v4, const T5&amp; v5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_VARARGS_6</name></cpp:macro> <cpp:value>const T1&amp; v1, const T2&amp; v2, const T3&amp; v3, const T4&amp; v4, const T5&amp; v5, const T6&amp; v6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_VARARGS_7</name></cpp:macro> <cpp:value>const T1&amp; v1, const T2&amp; v2, const T3&amp; v3, const T4&amp; v4, const T5&amp; v5, const T6&amp; v6, const T7&amp; v7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_VARARGS_8</name></cpp:macro> <cpp:value>const T1&amp; v1, const T2&amp; v2, const T3&amp; v3, const T4&amp; v4, const T5&amp; v5, const T6&amp; v6, const T7&amp; v7, const T8&amp; v8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_VARARGS_9</name></cpp:macro> <cpp:value>const T1&amp; v1, const T2&amp; v2, const T3&amp; v3, const T4&amp; v4, const T5&amp; v5, const T6&amp; v6, const T7&amp; v7, const T8&amp; v8, const T9&amp; v9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_VARARGS_10</name></cpp:macro> <cpp:value>const T1&amp; v1, const T2&amp; v2, const T3&amp; v3, const T4&amp; v4, const T5&amp; v5, const T6&amp; v6, const T7&amp; v7, const T8&amp; v8, const T9&amp; v9, const T10&amp; v10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_VARARGS_11</name></cpp:macro> <cpp:value>const T1&amp; v1, const T2&amp; v2, const T3&amp; v3, const T4&amp; v4, const T5&amp; v5, const T6&amp; v6, const T7&amp; v7, const T8&amp; v8, const T9&amp; v9, const T10&amp; v10, const T11&amp; v11</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_VARARGS_12</name></cpp:macro> <cpp:value>const T1&amp; v1, const T2&amp; v2, const T3&amp; v3, const T4&amp; v4, const T5&amp; v5, const T6&amp; v6, const T7&amp; v7, const T8&amp; v8, const T9&amp; v9, const T10&amp; v10, const T11&amp; v11, const T12&amp; v12</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_VARARGS_13</name></cpp:macro> <cpp:value>const T1&amp; v1, const T2&amp; v2, const T3&amp; v3, const T4&amp; v4, const T5&amp; v5, const T6&amp; v6, const T7&amp; v7, const T8&amp; v8, const T9&amp; v9, const T10&amp; v10, const T11&amp; v11, const T12&amp; v12, const T13&amp; v13</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_VARARGS_14</name></cpp:macro> <cpp:value>const T1&amp; v1, const T2&amp; v2, const T3&amp; v3, const T4&amp; v4, const T5&amp; v5, const T6&amp; v6, const T7&amp; v7, const T8&amp; v8, const T9&amp; v9, const T10&amp; v10, const T11&amp; v11, const T12&amp; v12, const T13&amp; v13, const T14&amp; v14</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_VARARGS_15</name></cpp:macro> <cpp:value>const T1&amp; v1, const T2&amp; v2, const T3&amp; v3, const T4&amp; v4, const T5&amp; v5, const T6&amp; v6, const T7&amp; v7, const T8&amp; v8, const T9&amp; v9, const T10&amp; v10, const T11&amp; v11, const T12&amp; v12, const T13&amp; v13, const T14&amp; v14, const T15&amp; v15</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_VARARGS_16</name></cpp:macro> <cpp:value>const T1&amp; v1, const T2&amp; v2, const T3&amp; v3, const T4&amp; v4, const T5&amp; v5, const T6&amp; v6, const T7&amp; v7, const T8&amp; v8, const T9&amp; v9, const T10&amp; v10, const T11&amp; v11, const T12&amp; v12, const T13&amp; v13, const T14&amp; v14, const T15&amp; v15, const T16&amp; v16</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_1</name></cpp:macro> <cpp:value>v1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_2</name></cpp:macro> <cpp:value>v1, v2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_3</name></cpp:macro> <cpp:value>v1, v2, v3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_4</name></cpp:macro> <cpp:value>v1, v2, v3, v4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_5</name></cpp:macro> <cpp:value>v1, v2, v3, v4, v5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_6</name></cpp:macro> <cpp:value>v1, v2, v3, v4, v5, v6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_7</name></cpp:macro> <cpp:value>v1, v2, v3, v4, v5, v6, v7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_8</name></cpp:macro> <cpp:value>v1, v2, v3, v4, v5, v6, v7, v8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_9</name></cpp:macro> <cpp:value>v1, v2, v3, v4, v5, v6, v7, v8, v9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_10</name></cpp:macro> <cpp:value>v1, v2, v3, v4, v5, v6, v7, v8, v9, v10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_11</name></cpp:macro> <cpp:value>v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_12</name></cpp:macro> <cpp:value>v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_13</name></cpp:macro> <cpp:value>v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_14</name></cpp:macro> <cpp:value>v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_15</name></cpp:macro> <cpp:value>v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_16</name></cpp:macro> <cpp:value>v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_TAIL_1</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_TAIL_2</name></cpp:macro> <cpp:value>, v2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_TAIL_3</name></cpp:macro> <cpp:value>, v2, v3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_TAIL_4</name></cpp:macro> <cpp:value>, v2, v3, v4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_TAIL_5</name></cpp:macro> <cpp:value>, v2, v3, v4, v5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_TAIL_6</name></cpp:macro> <cpp:value>, v2, v3, v4, v5, v6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_TAIL_7</name></cpp:macro> <cpp:value>, v2, v3, v4, v5, v6, v7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_TAIL_8</name></cpp:macro> <cpp:value>, v2, v3, v4, v5, v6, v7, v8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_TAIL_9</name></cpp:macro> <cpp:value>, v2, v3, v4, v5, v6, v7, v8, v9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_TAIL_10</name></cpp:macro> <cpp:value>, v2, v3, v4, v5, v6, v7, v8, v9, v10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_TAIL_11</name></cpp:macro> <cpp:value>, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_TAIL_12</name></cpp:macro> <cpp:value>, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_TAIL_13</name></cpp:macro> <cpp:value>, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_TAIL_14</name></cpp:macro> <cpp:value>, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_TAIL_15</name></cpp:macro> <cpp:value>, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_PASSARGS_TAIL_16</name></cpp:macro> <cpp:value>, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_FOREACH_ARGNUM</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>m(1) m(2) m(3) m(4) m(5) m(6) m(7) m(8) m(9) m(10) m(11) m(12) m(13) m(14) m(15) m(16)</cpp:value></cpp:define>
<comment type="line">//[[[end]]]</comment>



<name>namespace</name> <name>detail</name> <block>{

<comment type="line">// Type-opaque holder for an argument to format(), with associated actions on</comment>
<comment type="line">// the type held as explicit function pointers.  This allows FormatArg's for</comment>
<comment type="line">// each argument to be allocated as a homogenous array inside FormatList</comment>
<comment type="line">// whereas a naive implementation based on inheritance does not.</comment>
<expr><name>class</name> <name>FormatArg</name>
<block>{
    <expr><name>public</name><operator>:</operator>
        <call><name>FormatArg</name><argument_list>()</argument_list></call>
             <operator>:</operator> <call><name>m_value</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>,
             <expr><call><name>m_formatImpl</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>,
             <macro><name>m_toIntImpl</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro>
         <expr><block>{ }</block>

        <name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
        <name>explicit</name> <call><name>FormatArg</name><argument_list>(<argument><expr><specifier>const</specifier> <name>T</name><operator>&amp;</operator> <name>value</name></expr></argument>)</argument_list></call>
            <operator>:</operator> <call><name>m_value</name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>void</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
            <expr><call><name>m_formatImpl</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>formatImpl</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument>)</argument_list></call></expr>,
            <macro><name>m_toIntImpl</name><argument_list>(<argument>&amp;toIntImpl&lt;T&gt;</argument>)</argument_list></macro>
        <expr><block>{ }</block>

        <name>void</name> <macro><name>format</name><argument_list>(<argument>std::ostream&amp; out</argument>, <argument>const char* fmtBegin</argument>,
                    <argument>const char* fmtEnd</argument>, <argument>int ntrunc</argument>)</argument_list></macro> <specifier>const</specifier>
        <block>{
            <expr><call><name>assert</name><argument_list>(<argument><expr><name>m_value</name></expr></argument>)</argument_list></call></expr>;
            <expr><call><name>assert</name><argument_list>(<argument><expr><name>m_formatImpl</name></expr></argument>)</argument_list></call></expr>;
            <expr><call><name>m_formatImpl</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>fmtBegin</name></expr></argument>, <argument><expr><name>fmtEnd</name></expr></argument>, <argument><expr><name>ntrunc</name></expr></argument>, <argument><expr><name>m_value</name></expr></argument>)</argument_list></call></expr>;
        }</block>

        <name>int</name> <macro><name>toInt</name><argument_list>()</argument_list></macro> <specifier>const</specifier>
        <block>{
            <expr><call><name>assert</name><argument_list>(<argument><expr><name>m_value</name></expr></argument>)</argument_list></call></expr>;
            <expr><call><name>assert</name><argument_list>(<argument><expr><name>m_toIntImpl</name></expr></argument>)</argument_list></call></expr>;
            <return>return <expr><call><name>m_toIntImpl</name><argument_list>(<argument><expr><name>m_value</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block>

    <name>private</name><operator>:</operator>
        <name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
        <name>TINYFORMAT_HIDDEN</name> <specifier>static</specifier> <name>void</name> <macro><name>formatImpl</name><argument_list>(<argument>std::ostream&amp; out</argument>, <argument>const char* fmtBegin</argument>,
                        <argument>const char* fmtEnd</argument>, <argument>int ntrunc</argument>, <argument>const void* value</argument>)</argument_list></macro>
        <block>{
            <expr><call><name>formatValue</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>fmtBegin</name></expr></argument>, <argument><expr><name>fmtEnd</name></expr></argument>, <argument><expr><name>ntrunc</name></expr></argument>, <argument><expr><operator>*</operator><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>T</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
        }</block>

        <name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
        <name>TINYFORMAT_HIDDEN</name> <specifier>static</specifier> <name>int</name> <macro><name>toIntImpl</name><argument_list>(<argument>const void* value</argument>)</argument_list></macro>
        <block>{
            <return>return <expr><name><name>convertToInt</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>invoke</name><argument_list>(<argument><expr><operator>*</operator><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>T</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block>

        <specifier>const</specifier> <name>void</name><operator>*</operator> <name>m_value</name></expr>;
        <macro><name>void</name> <argument_list>(<argument>*m_formatImpl</argument>)</argument_list></macro><expr><operator>(</operator><name>std</name><operator>::</operator><name>ostream</name><operator>&amp;</operator> <name>out</name><operator>,</operator> <specifier>const</specifier> <name>char</name><operator>*</operator> <name>fmtBegin</name><operator>,</operator>
                             <specifier>const</specifier> <name>char</name><operator>*</operator> <name>fmtEnd</name><operator>,</operator> <name>int</name> <name>ntrunc</name><operator>,</operator> <specifier>const</specifier> <name>void</name><operator>*</operator> <name>value</name><operator>)</operator></expr>;
        <expr><call><call><name>int</name> <argument_list>(<argument><expr><operator>*</operator><name>m_toIntImpl</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><specifier>const</specifier> <name>void</name><operator>*</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;


<comment type="line">// Parse and return an integer from the string c, as atoi()</comment>
<comment type="line">// On return, c is set to one past the end of the integer.</comment>
<expr><specifier>inline</specifier> <name>int</name> <macro><name>parseIntAndAdvance</name><argument_list>(<argument>const char*&amp; c</argument>)</argument_list></macro>
<block>{
    <expr><name>int</name> <name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;
    <for>for<control>(<init>;</init><condition><expr><operator>*</operator><name>c</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>c</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>;</condition> <incr><expr><operator>++</operator><name>c</name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">10</literal><operator>*</operator><name>i</name> <operator>+</operator> <operator>(</operator><operator>*</operator><name>c</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></for></block></expr>
    <return>return <expr><name>i</name></expr>;</return>
}</block>

<comment type="line">// Print literal part of format string and return next format spec</comment>
<comment type="line">// position.</comment>
<comment type="line">//</comment>
<comment type="line">// Skips over any occurrences of '%%', printing a literal '%' to the</comment>
<comment type="line">// output.  The position of the first % character of the next</comment>
<comment type="line">// nontrivial format spec is returned, or the end of string.</comment>
<specifier>inline</specifier> <specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>printFormatStringLiteral</name><argument_list>(<argument>std::ostream&amp; out</argument>, <argument>const char* fmt</argument>)</argument_list></macro>
<block>{
    <expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>c</name> <operator>=</operator> <name>fmt</name></expr>;
    <for>for<control>(<init>;</init><condition>;</condition> <incr><expr><operator>++</operator><name>c</name></expr></incr>)</control>
    <block>{<block_content>
        <switch>switch<condition>(<expr><operator>*</operator><name>c</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><literal type="char">'\0'</literal></expr>:</case>
                <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>write</name></name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>c</name> <operator>-</operator> <name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>c</name></expr>;</return>
            <case>case <expr><literal type="char">'%'</literal></expr>:</case>
                <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>write</name></name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>c</name> <operator>-</operator> <name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if<condition>(<expr><operator>*</operator><operator>(</operator><name>c</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="char">'%'</literal></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>c</name></expr>;</return></block_content></block></if></if_stmt>
                <comment type="line">// for "%%", tack trailing % onto next literal section.</comment>
                <expr_stmt><expr><name>fmt</name> <operator>=</operator> <operator>++</operator><name>c</name></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <break>break;</break>
        <expr_stmt/>}</block_content>
    }
}


<comment type="line">// Parse a format string and set the stream state accordingly.</comment>
<comment type="line">//</comment>
<comment type="line">// The format mini-language recognized here is meant to be the one from C99,</comment>
<comment type="line">// with the form "%[flags][width][.precision][length]type".</comment>
<comment type="line">//</comment>
<comment type="line">// Formatting options which can't be natively represented using the ostream</comment>
<comment type="line">// state are returned in spacePadPositive (for space padded positive numbers)</comment>
<comment type="line">// and ntrunc (for truncating conversions).  argIndex is incremented if</comment>
<comment type="line">// necessary to pull out variable width and precision.  The function returns a</comment>
<comment type="line">// pointer to the character after the end of the current format spec.</comment>
<namespace><specifier>inline</specifier> const <name>char</name>* <name>streamStateFromFormat</name>(<name>std</name>::<name>ostream</name>&amp; <name>out</name><operator>,</operator> <name>bool</name>&amp; <name>spacePadPositive</name><operator>,</operator>
                                         <name>int</name>&amp; <name>ntrunc</name><operator>,</operator> const <name>char</name>* <name>fmtStart</name><operator>,</operator>
                                         const <name>detail</name>::<name>FormatArg</name>* <name>formatters</name><operator>,</operator>
                                         <name>int</name>&amp; <name>argIndex</name><operator>,</operator> <name>int</name> <name>numFormatters</name></namespace></block></switch>)</block_content>
<block>{<block_content>
    <if_stmt><if>if<condition>(<expr><operator>*</operator><name>fmtStart</name> <operator>!=</operator> <literal type="char">'%'</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>TINYFORMAT_ERROR</name><argument_list>(<argument><expr><literal type="string">"tinyformat: Not enough conversion specifiers in format string"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>fmtStart</name></expr>;</return>
    <expr_stmt/>}</block_content>
    <comment type="line">// Reset stream state to defaults.</comment>
    out.width(0</block></if></if_stmt>)</block_content></block></block><empty_stmt>;</empty_stmt></for>
    <call><name><name>out</name><operator>.</operator><name>precision</name></name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></block></expr>;
    <expr><call><name><name>out</name><operator>.</operator><name>fill</name></name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;
    <comment type="line">// Reset most flags; ignore irrelevant unitbuf &amp; skipws.</comment>
    <expr><call><name><name>out</name><operator>.</operator><name>unsetf</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>adjustfield</name> <operator>|</operator> <name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>basefield</name> <operator>|</operator>
               <name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>floatfield</name> <operator>|</operator> <name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>showbase</name> <operator>|</operator> <name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>boolalpha</name> <operator>|</operator>
               <name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>showpoint</name> <operator>|</operator> <name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>showpos</name> <operator>|</operator> <name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>uppercase</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>bool</name> <name>precisionSet</name> <operator>=</operator> <name>false</name></expr>;
    <expr><name>bool</name> <name>widthSet</name> <operator>=</operator> <name>false</name></expr>;
    <expr><name>int</name> <name>widthExtra</name> <operator>=</operator> <literal type="number">0</literal></expr>;
    <expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>c</name> <operator>=</operator> <name>fmtStart</name> <operator>+</operator> <literal type="number">1</literal></expr>;
    <comment type="line">// 1) Parse flags</comment>
    <for>for<control>(<init>;</init><condition>;</condition> <incr><expr><operator>++</operator><name>c</name></expr></incr>)</control>
    <block>{<block_content>
        <switch>switch<condition>(<expr><operator>*</operator><name>c</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><literal type="char">'#'</literal></expr>:</case>
                <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>setf</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>showpoint</name> <operator>|</operator> <name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>showbase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            <case>case <expr><literal type="char">'0'</literal></expr>:</case>
                <comment type="line">// overridden by left alignment ('-' flag)</comment>
                <if_stmt><if>if<condition>(<expr><operator>!</operator><operator>(</operator><call><name><name>out</name><operator>.</operator><name>flags</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>left</name><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// Use internal padding so that numeric values are</comment>
                    <comment type="line">// formatted correctly, eg -00010 rather than 000-10</comment>
                    <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>fill</name></name><argument_list>(<argument><expr><literal type="char">'0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>setf</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>internal</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>adjustfield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt/>}</block_content>
                continue</block><empty_stmt>;</empty_stmt></if></if_stmt>
            <case>case <expr><literal type="char">'-'</literal></expr>:</case>
                <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>fill</name></name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>setf</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>left</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>adjustfield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            <case>case <expr><literal type="char">' '</literal></expr>:</case>
                <comment type="line">// overridden by show positive sign, '+' flag.</comment>
                <if_stmt><if>if<condition>(<expr><operator>!</operator><operator>(</operator><call><name><name>out</name><operator>.</operator><name>flags</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>showpos</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>spacePadPositive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <continue>continue;</continue>
            <case>case <expr><literal type="char">'+'</literal></expr>:</case>
                <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>setf</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>showpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>spacePadPositive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>widthExtra</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <continue>continue;</continue>
            <default>default:</default>
                <break>break;</break>
        <expr_stmt/>}</block_content>
        break</block><empty_stmt>;</empty_stmt></switch>
    <expr_stmt/>}</block_content>
    <comment type="line">// 2) Parse width</comment>
    if(*c &gt;= '0' &amp;&amp; *c &lt;= '9'</block></for>)
    <block>{
        <expr><name>widthSet</name> <operator>=</operator> <name>true</name></expr>;
        <expr><call><name><name>out</name><operator>.</operator><name>width</name></name><argument_list>(<argument><expr><call><name>parseIntAndAdvance</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    }</block></block></expr>
    <if_stmt><if>if<condition>(<expr><operator>*</operator><name>c</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>widthSet</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>width</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>(<expr><name>argIndex</name> <operator>&lt;</operator> <name>numFormatters</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>width</name> <operator>=</operator> <name><name>formatters</name><index>[<expr><name>argIndex</name><operator>++</operator></expr>]</index></name><operator>.</operator><call><name>toInt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>TINYFORMAT_ERROR</name><argument_list>(<argument><expr><literal type="string">"tinyformat: Not enough arguments to read variable width"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <if_stmt><if>if<condition>(<expr><name>width</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// negative widths correspond to '-' flag set</comment>
            <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>fill</name></name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>setf</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>left</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>adjustfield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>width</name> <operator>=</operator> <operator>-</operator><name>width</name></expr>;</expr_stmt>
        <expr_stmt/>}</block_content>
        out.width(width</block></if></if_stmt>)</block_content></block><empty_stmt>;</empty_stmt></if></if_stmt>
        <operator>++</operator><name>c</name></block></expr>;</expr_stmt>
    </block_content>}</block></decl></decl_stmt>
    <comment type="line">// 3) Parse precision</comment>
    <if_stmt><if>if<condition>(<expr><operator>*</operator><name>c</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>++</operator><name>c</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>precision</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>(<expr><operator>*</operator><name>c</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>++</operator><name>c</name></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name>argIndex</name> <operator>&lt;</operator> <name>numFormatters</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>precision</name> <operator>=</operator> <name><name>formatters</name><index>[<expr><name>argIndex</name><operator>++</operator></expr>]</index></name><operator>.</operator><call><name>toInt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>TINYFORMAT_ERROR</name><argument_list>(<argument><expr><literal type="string">"tinyformat: Not enough arguments to read variable precision"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><operator>*</operator><name>c</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>c</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>precision</name> <operator>=</operator> <call><name>parseIntAndAdvance</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if<condition>(<expr><operator>*</operator><name>c</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content> <comment type="line">// negative precisions ignored, treated as zero.</comment>
                <expr_stmt><expr><call><name>parseIntAndAdvance</name><argument_list>(<argument><expr><operator>++</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>precision</name></name><argument_list>(<argument><expr><name>precision</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>precisionSet</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="line">// 4) Ignore any C99 length modifier</comment>
    <while>while<condition>(<expr><operator>*</operator><name>c</name> <operator>==</operator> <literal type="char">'l'</literal> <operator>||</operator> <operator>*</operator><name>c</name> <operator>==</operator> <literal type="char">'h'</literal> <operator>||</operator> <operator>*</operator><name>c</name> <operator>==</operator> <literal type="char">'L'</literal> <operator>||</operator>
          <operator>*</operator><name>c</name> <operator>==</operator> <literal type="char">'j'</literal> <operator>||</operator> <operator>*</operator><name>c</name> <operator>==</operator> <literal type="char">'z'</literal> <operator>||</operator> <operator>*</operator><name>c</name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>++</operator><name>c</name></expr>;</expr_stmt></block_content></block></while>
    <comment type="line">// 5) We're up to the conversion specifier character.</comment>
    <comment type="line">// Set stream flags based on conversion specifier (thanks to the</comment>
    <comment type="line">// boost::format class for forging the way here).</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>intConversion</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <switch>switch<condition>(<expr><operator>*</operator><name>c</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><literal type="char">'u'</literal></expr>:</case> <case>case <expr><literal type="char">'d'</literal></expr>:</case> <case>case <expr><literal type="char">'i'</literal></expr>:</case>
            <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>setf</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>dec</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>basefield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>intConversion</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'o'</literal></expr>:</case>
            <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>setf</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>oct</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>basefield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>intConversion</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'X'</literal></expr>:</case>
            <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>setf</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>uppercase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// Falls through</comment>
        <case>case <expr><literal type="char">'x'</literal></expr>:</case> <case>case <expr><literal type="char">'p'</literal></expr>:</case>
            <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>setf</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>hex</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>basefield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>intConversion</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'E'</literal></expr>:</case>
            <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>setf</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>uppercase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// Falls through</comment>
        <case>case <expr><literal type="char">'e'</literal></expr>:</case>
            <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>setf</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>scientific</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>floatfield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>setf</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>dec</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>basefield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'F'</literal></expr>:</case>
            <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>setf</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>uppercase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// Falls through</comment>
        <case>case <expr><literal type="char">'f'</literal></expr>:</case>
            <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>setf</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>fixed</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>floatfield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'G'</literal></expr>:</case>
            <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>setf</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>uppercase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// Falls through</comment>
        <case>case <expr><literal type="char">'g'</literal></expr>:</case>
            <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>setf</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>dec</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>basefield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// As in boost::format, let stream decide float format.</comment>
            <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>flags</name></name><argument_list>(<argument><expr><call><name><name>out</name><operator>.</operator><name>flags</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>floatfield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'a'</literal></expr>:</case> <case>case <expr><literal type="char">'A'</literal></expr>:</case>
            <expr_stmt><expr><call><name>TINYFORMAT_ERROR</name><argument_list>(<argument><expr><literal type="string">"tinyformat: the %a and %A conversion specs "</literal>
                             <literal type="string">"are not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'c'</literal></expr>:</case>
            <comment type="line">// Handled as special case inside formatValue()</comment>
            <break>break;</break>
        <case>case <expr><literal type="char">'s'</literal></expr>:</case>
            <if_stmt><if>if<condition>(<expr><name>precisionSet</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>ntrunc</name> <operator>=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>out</name><operator>.</operator><name>precision</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="line">// Make %s print booleans as "true" and "false"</comment>
            <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>setf</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>boolalpha</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'n'</literal></expr>:</case>
            <comment type="line">// Not supported - will cause problems!</comment>
            <expr_stmt><expr><call><name>TINYFORMAT_ERROR</name><argument_list>(<argument><expr><literal type="string">"tinyformat: %n conversion spec not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'\0'</literal></expr>:</case>
            <expr_stmt><expr><call><name>TINYFORMAT_ERROR</name><argument_list>(<argument><expr><literal type="string">"tinyformat: Conversion spec incorrectly "</literal>
                             <literal type="string">"terminated by end of string"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>c</name></expr>;</return>
        <default>default:</default>
            <break>break;</break>
    </block_content>}</block></switch>
    <if_stmt><if>if<condition>(<expr><name>intConversion</name> <operator>&amp;&amp;</operator> <name>precisionSet</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>widthSet</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// "precision" for integers gives the minimum number of digits (to be</comment>
        <comment type="line">// padded with zeros on the left).  This isn't really supported by the</comment>
        <comment type="line">// iostreams, but we can approximately simulate it with the width if</comment>
        <comment type="line">// the width isn't otherwise used.</comment>
        <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>width</name></name><argument_list>(<argument><expr><call><name><name>out</name><operator>.</operator><name>precision</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>widthExtra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>setf</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>internal</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>adjustfield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>fill</name></name><argument_list>(<argument><expr><literal type="char">'0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>c</name><operator>+</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<comment type="line">//------------------------------------------------------------------------------</comment>
<decl_stmt><decl><type><specifier>inline</specifier> <name>void</name></type> <name>formatImpl</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>ostream</name><operator>&amp;</operator> <name>out</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>fmt</name></expr></argument>,
                       <argument><expr><specifier>const</specifier> <name>detail</name><operator>::</operator><name>FormatArg</name><operator>*</operator> <name>formatters</name></expr></argument>,
                       <argument><expr><name>int</name> <name>numFormatters</name></expr></argument>)</argument_list>
<block>{<block_content>
    <comment type="line">// Saved stream state</comment>
    <expr_stmt><expr><name>std</name><operator>::</operator><name>streamsize</name> <name>origWidth</name> <operator>=</operator> <call><name><name>out</name><operator>.</operator><name>width</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name>streamsize</name> <name>origPrecision</name> <operator>=</operator> <call><name><name>out</name><operator>.</operator><name>precision</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>fmtflags</name> <name>origFlags</name> <operator>=</operator> <call><name><name>out</name><operator>.</operator><name>flags</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>origFill</name> <init>= <expr><call><name><name>out</name><operator>.</operator><name>fill</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><decl><type><name>int</name></type> <name>argIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>argIndex</name> <operator>&lt;</operator> <name>numFormatters</name></expr>;</condition> <incr><expr><operator>++</operator><name>argIndex</name></expr></incr>)</control>
    <block>{<block_content>
        <comment type="line">// Parse the format string</comment>
        <expr_stmt><expr><name>fmt</name> <operator>=</operator> <call><name>printFormatStringLiteral</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>spacePadPositive</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>ntrunc</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>fmtEnd</name> <init>= <expr><call><name>streamStateFromFormat</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>spacePadPositive</name></expr></argument>, <argument><expr><name>ntrunc</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>,
                                                   <argument><expr><name>formatters</name></expr></argument>, <argument><expr><name>argIndex</name></expr></argument>, <argument><expr><name>numFormatters</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>argIndex</name> <operator>&gt;=</operator> <name>numFormatters</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Check args remain after reading any variable width/precision</comment>
            <expr_stmt><expr><call><name>TINYFORMAT_ERROR</name><argument_list>(<argument><expr><literal type="string">"tinyformat: Not enough format arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>FormatArg</name><modifier>&amp;</modifier></type> <name>arg</name> <init>= <expr><name><name>formatters</name><index>[<expr><name>argIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <comment type="line">// Format the arg into the stream.</comment>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><name>spacePadPositive</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>arg</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>fmtEnd</name></expr></argument>, <argument><expr><name>ntrunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// The following is a special case with no direct correspondence</comment>
            <comment type="line">// between stream formatting and the printf() behaviour.  Simulate</comment>
            <comment type="line">// it crudely by formatting into a temporary string stream and</comment>
            <comment type="line">// munging the resulting string.</comment>
            <expr_stmt><expr><name>std</name><operator>::</operator><name>ostringstream</name> <name>tmpStream</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>tmpStream</name><operator>.</operator><name>copyfmt</name></name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>tmpStream</name><operator>.</operator><name>setf</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>showpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>arg</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><name>tmpStream</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>fmtEnd</name></expr></argument>, <argument><expr><name>ntrunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>result</name> <operator>=</operator> <call><name><name>tmpStream</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// allocates... yuck.</comment>
            <for>for<control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>iend</name> <init>= <expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>iend</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
                <if_stmt><if>if<condition>(<expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
            <expr_stmt><expr><name>out</name> <operator>&lt;&lt;</operator> <name>result</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>fmt</name> <operator>=</operator> <name>fmtEnd</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="line">// Print remaining part of format string.</comment>
    <expr_stmt><expr><name>fmt</name> <operator>=</operator> <call><name>printFormatStringLiteral</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><operator>*</operator><name>fmt</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>TINYFORMAT_ERROR</name><argument_list>(<argument><expr><literal type="string">"tinyformat: Too many conversion specifiers in format string"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">// Restore stream state</comment>
    <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>width</name></name><argument_list>(<argument><expr><name>origWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>precision</name></name><argument_list>(<argument><expr><name>origPrecision</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>flags</name></name><argument_list>(<argument><expr><name>origFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>fill</name></name><argument_list>(<argument><expr><name>origFill</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

} <comment type="line">// namespace detail</comment>


<comment type="line" format="doxygen">/// List of template arguments format(), held in a type-opaque way.</comment>
<comment type="line" format="doxygen">///</comment>
<comment type="line" format="doxygen">/// A const reference to FormatList (typedef'd as FormatListRef) may be</comment>
<comment type="line" format="doxygen">/// conveniently used to pass arguments to non-template functions: All type</comment>
<comment type="line" format="doxygen">/// information has been stripped from the arguments, leaving just enough of a</comment>
<comment type="line" format="doxygen">/// common interface to perform formatting as required.</comment>
class <macro><name>FormatList</name></macro>
<block>{<block_content>
    <label><name>public</name>:</label>
        <macro><name>FormatList</name><argument_list>(<argument>detail::FormatArg* formatters</argument>, <argument>int N</argument>)</argument_list></macro>
            : <expr_stmt><expr><call><name>m_formatters</name><argument_list>(<argument><expr><name>formatters</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>m_N</name><argument_list>(<argument>N</argument>)</argument_list></macro> <expr><block>{ }</block>

        <name>friend</name> <name>void</name> <call><name>vformat</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>ostream</name><operator>&amp;</operator> <name>out</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>fmt</name></expr></argument>,
                            <argument><expr><specifier>const</specifier> <name>FormatList</name><operator>&amp;</operator> <name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <label><name>private</name>:</label>
        <expr_stmt><expr><specifier>const</specifier> <name>detail</name><operator>::</operator><name>FormatArg</name><operator>*</operator> <name>m_formatters</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>m_N</name></decl>;</decl_stmt>
</block_content>}</block><empty_stmt>;</empty_stmt>

<comment type="line" format="doxygen">/// Reference to type-opaque format list for passing to vformat()</comment>
<typedef>typedef <type><specifier>const</specifier> <name>FormatList</name><modifier>&amp;</modifier></type> <name>FormatListRef</name>;</typedef>


<decl_stmt><decl><type><name>namespace</name></type> <name>detail</name> <block>{<block_content>

<comment type="line">// Format list subclass with fixed storage to avoid dynamic allocation</comment>
<decl_stmt><decl><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>int</name> <name>N</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>FormatListN</name> <range>: <expr><name>public</name> <name>FormatList</name>
<block>{
    <expr><name>public</name><operator>:</operator>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TINYFORMAT_USE_VARIADIC_TEMPLATES</name></cpp:ifdef>
        <name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name><modifier>...</modifier> <name>Args</name></expr></argument>&gt;</argument_list></name>
        <name>explicit</name> <call><name>FormatListN</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Args</name><operator>&amp;</operator><operator>...</operator> <name>args</name></expr></argument>)</argument_list></call>
            <operator>:</operator> <call><name>FormatList</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>m_formatterStore</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>,
            <expr><name>m_formatterStore</name> <block>{ <expr><call><name>FormatArg</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call><operator>...</operator></expr> }</block>
        <block>{ <expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof type="pack">sizeof...<argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <name>N</name></expr></argument>, <argument><expr><literal type="string">"Number of args must be N"</literal></expr></argument>)</argument_list></call></expr>; }</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="line">// C++98 version</comment>
        <name>void</name> <macro><name>init</name><argument_list>(<argument>int</argument>)</argument_list></macro> <block>{}</block>
<cpp:define>#       <cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro>       \
                                                               \
        <cpp:value>template&lt;TINYFORMAT_ARGTYPES(n)&gt;                       \
        explicit FormatListN(TINYFORMAT_VARARGS(n))            \
            : FormatList(&amp;m_formatterStore[0], n)              \
        { assert(n == N); init(0, TINYFORMAT_PASSARGS(n)); }   \
                                                               \
        template&lt;TINYFORMAT_ARGTYPES(n)&gt;                       \
        void init(int i, TINYFORMAT_VARARGS(n))                \
        {                                                      \
            m_formatterStore[i] = FormatArg(v1);               \
            init(i+1 TINYFORMAT_PASSARGS_TAIL(n));             \
        }</cpp:value></cpp:define>

        <macro><name>TINYFORMAT_FOREACH_ARGNUM</name><argument_list>(<argument>TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR</argument>)</argument_list></macro>
<cpp:undef>#       <cpp:directive>undef</cpp:directive> <name>TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <name>private</name><operator>:</operator>
        <name>FormatArg</name> <name><name>m_formatterStore</name><index>[<expr><name>N</name></expr>]</index></name></expr>;
}</block></expr></range></decl>;</decl_stmt>

<comment type="line">// Special 0-arg version - MSVC says zero-sized C array in struct is nonstandard</comment>
<decl_stmt><decl><type><name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name> <name>class</name></type> <name><name>FormatListN</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal></expr></argument>&gt;</argument_list></name> <range>: <expr><name>public</name> <name>FormatList</name>
<block>{
    <expr><name>public</name><operator>:</operator> <call><name>FormatListN</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>FormatList</name><argument_list>(<argument><literal type="number">0</literal></argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro> <block>{}</block></expr>
}</block></expr></range></decl>;</decl_stmt>

</block_content>}</block></decl></decl_stmt> <comment type="line">// namespace detail</comment>


<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// Primary API functions</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TINYFORMAT_USE_VARIADIC_TEMPLATES</name></cpp:ifdef>

<comment type="line" format="doxygen">/// Make type-agnostic format list from list of template arguments.</comment>
<comment type="line" format="doxygen">///</comment>
<comment type="line" format="doxygen">/// The exact return type of this function is an implementation detail and</comment>
<comment type="line" format="doxygen">/// shouldn't be relied upon.  Instead it should be stored as a FormatListRef:</comment>
<comment type="line" format="doxygen">///</comment>
<comment type="line" format="doxygen">///   FormatListRef formatList = makeFormatList( /*...*/ );</comment>
<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name><modifier>...</modifier> <name>Args</name></expr></argument>&gt;</argument_list></name>
<name>detail</name><operator>::</operator><name>FormatListN</name><operator>&lt;</operator><sizeof type="pack">sizeof...<argument_list>(<argument><expr><name>Args</name></expr></argument>)</argument_list></sizeof><operator>&gt;</operator> <macro><name>makeFormatList</name><argument_list>(<argument>const Args&amp;... args</argument>)</argument_list></macro>
<block>{
    <return>return <expr><name>detail</name><operator>::</operator><name>FormatListN</name><operator>&lt;</operator><sizeof type="pack">sizeof...<argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></sizeof><operator>&gt;</operator><operator>(</operator><name>args</name><operator>...</operator><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="line">// C++98 version</comment>

<expr_stmt><expr><specifier>inline</specifier> <name>detail</name><operator>::</operator><name><name>FormatListN</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal></expr></argument>&gt;</argument_list></name> <macro><name>makeFormatList</name><argument_list>()</argument_list></macro>
<block>{
    <return>return <expr><name>detail</name><operator>::</operator><call><name><name>FormatListN</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_MAKE_MAKEFORMATLIST</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro>                     \
<cpp:value>template&lt;TINYFORMAT_ARGTYPES(n)&gt;                              \
detail::FormatListN&lt;n&gt; makeFormatList(TINYFORMAT_VARARGS(n))  \
{                                                             \
    return detail::FormatListN&lt;n&gt;(TINYFORMAT_PASSARGS(n));    \
}</cpp:value></cpp:define>
<macro><name>TINYFORMAT_FOREACH_ARGNUM</name><argument_list>(<argument>TINYFORMAT_MAKE_MAKEFORMATLIST</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TINYFORMAT_MAKE_MAKEFORMATLIST</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line" format="doxygen">/// Format list of arguments to the stream according to the given format string.</comment>
<comment type="line" format="doxygen">///</comment>
<comment type="line" format="doxygen">/// The name vformat() is chosen for the semantic similarity to vprintf(): the</comment>
<comment type="line" format="doxygen">/// list of format arguments is held in a single function argument.</comment>
<decl_stmt><decl><type><specifier>inline</specifier> <name>void</name></type> <name>vformat</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>ostream</name><operator>&amp;</operator> <name>out</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>fmt</name></expr></argument>, <argument><expr><name>FormatListRef</name> <name>list</name></expr></argument>)</argument_list>
<block>{<block_content>
    <expr_stmt><expr><name>detail</name><operator>::</operator><call><name>formatImpl</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name><name>list</name><operator>.</operator><name>m_formatters</name></name></expr></argument>, <argument><expr><name><name>list</name><operator>.</operator><name>m_N</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TINYFORMAT_USE_VARIADIC_TEMPLATES</name></cpp:ifdef>

<comment type="line" format="doxygen">/// Format list of arguments to the stream according to given format string.</comment>
<decl_stmt><decl><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name><modifier>...</modifier> <name>Args</name></expr></argument>&gt;</argument_list></name>
<name>void</name></type> <name>format</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>ostream</name><operator>&amp;</operator> <name>out</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>fmt</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Args</name><operator>&amp;</operator><operator>...</operator> <name>args</name></expr></argument>)</argument_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>vformat</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><call><name>makeFormatList</name><argument_list>(<argument><expr><name>args</name><operator>...</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<comment type="line" format="doxygen">/// Format list of arguments according to the given format string and return</comment>
<comment type="line" format="doxygen">/// the result as a string.</comment>
<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name><modifier>...</modifier> <name>Args</name></expr></argument>&gt;</argument_list></name>
<name>std</name><operator>::</operator><name>string</name> <macro><name>format</name><argument_list>(<argument>const char* fmt</argument>, <argument>const Args&amp;... args</argument>)</argument_list></macro>
<block>{
    <expr><name>std</name><operator>::</operator><name>ostringstream</name> <name>oss</name></expr>;
    <expr><call><name>format</name><argument_list>(<argument><expr><name>oss</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name><operator>...</operator></expr></argument>)</argument_list></call></expr>;
    <return>return <expr><call><name><name>oss</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<comment type="line" format="doxygen">/// Format list of arguments to std::cout, according to the given format string</comment>
<function><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name><modifier>...</modifier> <name>Args</name></expr></argument>&gt;</argument_list></name>
<name>void</name></type> <name>printf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>fmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Args</name><modifier>&amp;</modifier><modifier>...</modifier></type> <name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>format</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>cout</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name><operator>...</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name><modifier>...</modifier> <name>Args</name></expr></argument>&gt;</argument_list></name>
<name>void</name></type> <name>printfln</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>fmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Args</name><modifier>&amp;</modifier><modifier>...</modifier></type> <name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>format</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>cout</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name><operator>...</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name>cout</name> <operator>&lt;&lt;</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="line">// C++98 version</comment>

<decl_stmt><decl><type><specifier>inline</specifier> <name>void</name></type> <name>format</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>ostream</name><operator>&amp;</operator> <name>out</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>fmt</name></expr></argument>)</argument_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>vformat</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><call><name>makeFormatList</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><specifier>inline</specifier> <name>std</name><operator>::</operator><name>string</name> <macro><name>format</name><argument_list>(<argument>const char* fmt</argument>)</argument_list></macro>
<block>{
    <expr><name>std</name><operator>::</operator><name>ostringstream</name> <name>oss</name></expr>;
    <expr><call><name>format</name><argument_list>(<argument><expr><name>oss</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;
    <return>return <expr><call><name><name>oss</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><specifier>inline</specifier> <name>void</name></type> <name>printf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>fmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>format</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>cout</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>void</name></type> <name>printfln</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>fmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>format</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>cout</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name>cout</name> <operator>&lt;&lt;</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TINYFORMAT_MAKE_FORMAT_FUNCS</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro>                                   \
                                                                          \
<cpp:value>template&lt;TINYFORMAT_ARGTYPES(n)&gt;                                          \
void format(std::ostream&amp; out, const char* fmt, TINYFORMAT_VARARGS(n))    \
{                                                                         \
    vformat(out, fmt, makeFormatList(TINYFORMAT_PASSARGS(n)));            \
}                                                                         \
                                                                          \
template&lt;TINYFORMAT_ARGTYPES(n)&gt;                                          \
std::string format(const char* fmt, TINYFORMAT_VARARGS(n))                \
{                                                                         \
    std::ostringstream oss;                                               \
    format(oss, fmt, TINYFORMAT_PASSARGS(n));                             \
    return oss.str();                                                     \
}                                                                         \
                                                                          \
template&lt;TINYFORMAT_ARGTYPES(n)&gt;                                          \
void printf(const char* fmt, TINYFORMAT_VARARGS(n))                       \
{                                                                         \
    format(std::cout, fmt, TINYFORMAT_PASSARGS(n));                       \
}                                                                         \
                                                                          \
template&lt;TINYFORMAT_ARGTYPES(n)&gt;                                          \
void printfln(const char* fmt, TINYFORMAT_VARARGS(n))                     \
{                                                                         \
    format(std::cout, fmt, TINYFORMAT_PASSARGS(n));                       \
    std::cout &lt;&lt; '\n';                                                    \
}</cpp:value></cpp:define>

<macro><name>TINYFORMAT_FOREACH_ARGNUM</name><argument_list>(<argument>TINYFORMAT_MAKE_FORMAT_FUNCS</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TINYFORMAT_MAKE_FORMAT_FUNCS</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">// Added for Bitcoin Core</comment>
<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name><modifier>...</modifier> <name>Args</name></expr></argument>&gt;</argument_list></name>
<name>std</name><operator>::</operator><name>string</name> <macro><name>format</name><argument_list>(<argument>const std::string &amp;fmt</argument>, <argument>const Args&amp;... args</argument>)</argument_list></macro>
<block>{
    <expr><name>std</name><operator>::</operator><name>ostringstream</name> <name>oss</name></expr>;
    <expr><call><name>format</name><argument_list>(<argument><expr><name>oss</name></expr></argument>, <argument><expr><call><name><name>fmt</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>args</name><operator>...</operator></expr></argument>)</argument_list></call></expr>;
    <return>return <expr><call><name><name>oss</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

} <comment type="line">// namespace tinyformat</comment>

<comment type="block" format="doxygen">/** Format arguments and return the string or write to given std::ostream (see tinyformat::format doc for details) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>strprintf</name></cpp:macro> <cpp:value>tfm::format</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// TINYFORMAT_H_INCLUDED</comment>
</unit>
