<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/mmm/Projects/bitcoin/src/secp256k1/include/secp256k1.h"><cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SECP256K1_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_H</name></cpp:macro></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern <literal type="string">"C"</literal> <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>

<comment type="block">/* These rules specify the order of arguments in API calls:
 *
 * 1. Context pointers go first, followed by output arguments, combined
 *    output/input arguments, and finally input-only arguments.
 * 2. Array lengths always immediately the follow the argument whose length
 *    they describe, even if this violates rule 1.
 * 3. Within the OUT/OUTIN/IN groups, pointers to data that is typically generated
 *    later go first. This means: signatures, public nonces, private nonces,
 *    messages, public keys, secret keys, tweaks.
 * 4. Arguments that are not data pointers go last, from more complex to less
 *    complex: function pointers, algorithm names, messages, void pointers,
 *    counts, flags, booleans.
 * 5. Opaque data pointers follow the function pointer they are to be passed to.
 */</comment>

<comment type="block" format="doxygen">/** Opaque data structure that holds context information (precomputed tables etc.).
 *
 *  The purpose of context structures is to cache large precomputed data tables
 *  that are expensive to construct, and also to maintain the randomization data
 *  for blinding.
 *
 *  Do not create a new context object for each operation, as construction is
 *  far slower than all other API calls (~100 times slower than an ECDSA
 *  verification).
 *
 *  A constructed context can safely be used from multiple threads
 *  simultaneously, but API call that take a non-const pointer to a context
 *  need exclusive access to it. In particular this is the case for
 *  secp256k1_context_destroy and secp256k1_context_randomize.
 *
 *  Regarding randomization, either do it once at creation time (in which case
 *  you do not need any locking for the other calls), or use a read-write lock.
 */</comment>
<typedef>typedef <type><name><name>struct</name> <name>secp256k1_context_struct</name></name></type> <name>secp256k1_context</name>;</typedef>

<comment type="block" format="doxygen">/** Opaque data structure that holds rewriteable "scratch space"
 *
 *  The purpose of this structure is to replace dynamic memory allocations,
 *  because we target architectures where this may not be available. It is
 *  essentially a resizable (within specified parameters) block of bytes,
 *  which is initially created either by memory allocation or TODO as a pointer
 *  into some fixed rewritable space.
 *
 *  Unlike the context object, this cannot safely be shared between threads
 *  without additional synchronization logic.
 */</comment>
<typedef>typedef <type><name><name>struct</name> <name>secp256k1_scratch_space_struct</name></name></type> <name>secp256k1_scratch_space</name>;</typedef>

<comment type="block" format="doxygen">/** Opaque data structure that holds a parsed and valid public key.
 *
 *  The exact representation of data inside is implementation defined and not
 *  guaranteed to be portable between different platforms or versions. It is
 *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.
 *  If you need to convert to a format suitable for storage, transmission, or
 *  comparison, use secp256k1_ec_pubkey_serialize and secp256k1_ec_pubkey_parse.
 */</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>data</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>secp256k1_pubkey</name>;</typedef>

<comment type="block" format="doxygen">/** Opaque data structured that holds a parsed ECDSA signature.
 *
 *  The exact representation of data inside is implementation defined and not
 *  guaranteed to be portable between different platforms or versions. It is
 *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.
 *  If you need to convert to a format suitable for storage, transmission, or
 *  comparison, use the secp256k1_ecdsa_signature_serialize_* and
 *  secp256k1_ecdsa_signature_parse_* functions.
 */</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>data</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>secp256k1_ecdsa_signature</name>;</typedef>

<comment type="block" format="doxygen">/** A pointer to a function to deterministically generate a nonce.
 *
 * Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.
 * Out:     nonce32:   pointer to a 32-byte array to be filled by the function.
 * In:      msg32:     the 32-byte message hash being verified (will not be NULL)
 *          key32:     pointer to a 32-byte secret key (will not be NULL)
 *          algo16:    pointer to a 16-byte array describing the signature
 *                     algorithm (will be NULL for ECDSA for compatibility).
 *          data:      Arbitrary data pointer that is passed through.
 *          attempt:   how many iterations we have tried to find a nonce.
 *                     This will almost always be 0, but different attempt values
 *                     are required to result in a different nonce.
 *
 * Except for test cases, this function should compute some cryptographic hash of
 * the message, the algorithm, the key and the attempt.
 */</comment>
<typedef>typedef <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>secp256k1_nonce_function</name>)<parameter_list>(
    <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>nonce32</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>msg32</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>key32</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>algo16</name></decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>,
    <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>attempt</name></decl></parameter>
)</parameter_list>;</function_decl></typedef>

<cpp:if># <cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SECP256K1_GNUC_PREREQ</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call><operator>&amp;&amp;</operator><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC_MINOR__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_GNUC_PREREQ</name><parameter_list>(<parameter><type><name>_maj</name></type></parameter>,<parameter><type><name>_min</name></type></parameter>)</parameter_list></cpp:macro> \
 <cpp:value>((__GNUC__&lt;&lt;16)+__GNUC_MINOR__&gt;=((_maj)&lt;&lt;16)+(_min))</cpp:value></cpp:define>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_GNUC_PREREQ</name><parameter_list>(<parameter><type><name>_maj</name></type></parameter>,<parameter><type><name>_min</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if># <cpp:directive>if</cpp:directive> <expr><operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__STDC_VERSION__</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>__STDC_VERSION__</name> <operator>&lt;</operator> <literal type="number">199901L</literal><operator>)</operator> <operator>)</operator></expr></cpp:if>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><call><name>SECP256K1_GNUC_PREREQ</name><argument_list>(<argument><expr><literal type="number">2</literal><operator>,</operator><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_INLINE</name></cpp:macro> <cpp:value>__inline__</cpp:value></cpp:define>
<cpp:elif>#  <cpp:directive>elif</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:elif>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_INLINE</name></cpp:macro> <cpp:value>__inline</cpp:value></cpp:define>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_INLINE</name></cpp:macro></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_INLINE</name></cpp:macro> <cpp:value>inline</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SECP256K1_API</name></cpp:ifndef>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>SECP256K1_BUILD</name></cpp:ifdef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_API</name></cpp:macro> <cpp:value>__declspec(dllexport)</cpp:value></cpp:define>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_API</name></cpp:macro></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:elif># <cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SECP256K1_BUILD</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_API</name></cpp:macro> <cpp:value>__attribute__ ((visibility ("default")))</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_API</name></cpp:macro></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/**Warning attributes
  * NONNULL is not used if SECP256K1_BUILD is set to avoid the compiler optimizing out
  * some paranoid null checks. */</comment>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>SECP256K1_GNUC_PREREQ</name><argument_list>(<argument><expr><literal type="number">3</literal><operator>,</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_WARN_UNUSED_RESULT</name></cpp:macro> <cpp:value>__attribute__ ((__warn_unused_result__))</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_WARN_UNUSED_RESULT</name></cpp:macro></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SECP256K1_BUILD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>SECP256K1_GNUC_PREREQ</name><argument_list>(<argument><expr><literal type="number">3</literal><operator>,</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_ARG_NONNULL</name><parameter_list>(<parameter><type><name>_x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>__attribute__ ((__nonnull__(_x)))</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_ARG_NONNULL</name><parameter_list>(<parameter><type><name>_x</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/** All flags' lower 8 bits indicate what they're for. Do not use directly. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_FLAGS_TYPE_MASK</name></cpp:macro> <cpp:value>((1 &lt;&lt; 8) - 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_FLAGS_TYPE_CONTEXT</name></cpp:macro> <cpp:value>(1 &lt;&lt; 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_FLAGS_TYPE_COMPRESSION</name></cpp:macro> <cpp:value>(1 &lt;&lt; 1)</cpp:value></cpp:define>
<comment type="block" format="doxygen">/** The higher bits contain the actual data. Do not use directly. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_FLAGS_BIT_CONTEXT_VERIFY</name></cpp:macro> <cpp:value>(1 &lt;&lt; 8)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_FLAGS_BIT_CONTEXT_SIGN</name></cpp:macro> <cpp:value>(1 &lt;&lt; 9)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_FLAGS_BIT_COMPRESSION</name></cpp:macro> <cpp:value>(1 &lt;&lt; 8)</cpp:value></cpp:define>

<comment type="block" format="doxygen">/** Flags to pass to secp256k1_context_create. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_CONTEXT_VERIFY</name></cpp:macro> <cpp:value>(SECP256K1_FLAGS_TYPE_CONTEXT | SECP256K1_FLAGS_BIT_CONTEXT_VERIFY)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_CONTEXT_SIGN</name></cpp:macro> <cpp:value>(SECP256K1_FLAGS_TYPE_CONTEXT | SECP256K1_FLAGS_BIT_CONTEXT_SIGN)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_CONTEXT_NONE</name></cpp:macro> <cpp:value>(SECP256K1_FLAGS_TYPE_CONTEXT)</cpp:value></cpp:define>

<comment type="block" format="doxygen">/** Flag to pass to secp256k1_ec_pubkey_serialize and secp256k1_ec_privkey_export. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_EC_COMPRESSED</name></cpp:macro> <cpp:value>(SECP256K1_FLAGS_TYPE_COMPRESSION | SECP256K1_FLAGS_BIT_COMPRESSION)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_EC_UNCOMPRESSED</name></cpp:macro> <cpp:value>(SECP256K1_FLAGS_TYPE_COMPRESSION)</cpp:value></cpp:define>

<comment type="block" format="doxygen">/** Prefix byte used to tag various encoded curvepoints for specific purposes */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_TAG_PUBKEY_EVEN</name></cpp:macro> <cpp:value>0x02</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_TAG_PUBKEY_ODD</name></cpp:macro> <cpp:value>0x03</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_TAG_PUBKEY_UNCOMPRESSED</name></cpp:macro> <cpp:value>0x04</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_TAG_PUBKEY_HYBRID_EVEN</name></cpp:macro> <cpp:value>0x06</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_TAG_PUBKEY_HYBRID_ODD</name></cpp:macro> <cpp:value>0x07</cpp:value></cpp:define>

<comment type="block" format="doxygen">/** A simple secp256k1 context object with no precomputed tables. These are useful for
 *  type serialization/parsing functions which require a context object to maintain
 *  API consistency, but currently do not require expensive precomputations or dynamic
 *  allocations.
 */</comment>
<decl_stmt><decl><type><name>SECP256K1_API</name> <specifier>extern</specifier> <specifier>const</specifier> <name>secp256k1_context</name> <modifier>*</modifier></type><name>secp256k1_context_no_precomp</name></decl>;</decl_stmt>

<comment type="block" format="doxygen">/** Create a secp256k1 context object.
 *
 *  Returns: a newly created context object.
 *  In:      flags: which parts of the context to initialize.
 *
 *  See also secp256k1_context_randomize.
 */</comment>
<decl_stmt><decl><type><name>SECP256K1_API</name> <name>secp256k1_context</name><modifier>*</modifier></type> <name>secp256k1_context_create</name><argument_list>(
    <argument><expr><name>unsigned</name> <name>int</name> <name>flags</name></expr></argument>
)</argument_list> <name>SECP256K1_WARN_UNUSED_RESULT</name></decl>;</decl_stmt>

<comment type="block" format="doxygen">/** Copies a secp256k1 context object.
 *
 *  Returns: a newly created context object.
 *  Args:    ctx: an existing context to copy (cannot be NULL)
 */</comment>
<decl_stmt><decl><type><name>SECP256K1_API</name> <name>secp256k1_context</name><modifier>*</modifier></type> <name>secp256k1_context_clone</name><argument_list>(
    <argument><expr><specifier>const</specifier> <name>secp256k1_context</name><operator>*</operator> <name>ctx</name></expr></argument>
)</argument_list> <name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list> <name>SECP256K1_WARN_UNUSED_RESULT</name></decl>;</decl_stmt>

<comment type="block" format="doxygen">/** Destroy a secp256k1 context object.
 *
 *  The context pointer may not be used afterwards.
 *  Args:   ctx: an existing context to destroy (cannot be NULL)
 */</comment>
<function_decl><type><name>SECP256K1_API</name> <name>void</name></type> <name>secp256k1_context_destroy</name><parameter_list>(
    <parameter><decl><type><name>secp256k1_context</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>
)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/** Set a callback function to be called when an illegal argument is passed to
 *  an API call. It will only trigger for violations that are mentioned
 *  explicitly in the header.
 *
 *  The philosophy is that these shouldn't be dealt with through a
 *  specific return value, as calling code should not have branches to deal with
 *  the case that this code itself is broken.
 *
 *  On the other hand, during debug stage, one would want to be informed about
 *  such mistakes, and the default (crashing) may be inadvisable.
 *  When this callback is triggered, the API function called is guaranteed not
 *  to cause a crash, though its return value and output arguments are
 *  undefined.
 *
 *  Args: ctx:  an existing context object (cannot be NULL)
 *  In:   fun:  a pointer to a function to call when an illegal argument is
 *              passed to the API, taking a message and an opaque pointer
 *              (NULL restores a default handler that calls abort).
 *        data: the opaque pointer to pass to fun above.
 */</comment>
<function_decl><type><name>SECP256K1_API</name> <name>void</name></type> <name>secp256k1_context_set_illegal_callback</name><parameter_list>(
    <parameter><decl><type><name>secp256k1_context</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>,
    <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>fun</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>message</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>data</name></decl></parameter>)</parameter_list></function_decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>data</name></decl></parameter>
)</parameter_list> SECP256K1_ARG_NONNULL<parameter_list>(</parameter_list>1</function_decl>)</block_content></block><empty_stmt>;</empty_stmt></extern>

<comment type="block" format="doxygen">/** Set a callback function to be called when an internal consistency check
 *  fails. The default is crashing.
 *
 *  This can only trigger in case of a hardware failure, miscompilation,
 *  memory corruption, serious bug in the library, or other error would can
 *  otherwise result in undefined behaviour. It will not trigger due to mere
 *  incorrect usage of the API (see secp256k1_context_set_illegal_callback
 *  for that). After this callback returns, anything may happen, including
 *  crashing.
 *
 *  Args: ctx:  an existing context object (cannot be NULL)
 *  In:   fun:  a pointer to a function to call when an internal error occurs,
 *              taking a message and an opaque pointer (NULL restores a default
 *              handler that calls abort).
 *        data: the opaque pointer to pass to fun above.
 */</comment>
<function_decl><type><name>SECP256K1_API</name> <name>void</name></type> <name>secp256k1_context_set_error_callback</name><parameter_list>(
    <parameter><decl><type><name>secp256k1_context</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>,
    <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>fun</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>message</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>data</name></decl></parameter>)</parameter_list></function_decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>data</name></decl></parameter>
)</parameter_list> SECP256K1_ARG_NONNULL<parameter_list>(</parameter_list>1</function_decl>)<empty_stmt>;</empty_stmt>

<comment type="block" format="doxygen">/** Create a secp256k1 scratch space object.
 *
 *  Returns: a newly created scratch space.
 *  Args: ctx:  an existing context object (cannot be NULL)
 *  In:   max_size: maximum amount of memory to allocate
 */</comment>
<function_decl><type><name>SECP256K1_API</name> <name>SECP256K1_WARN_UNUSED_RESULT</name> <name>secp256k1_scratch_space</name><modifier>*</modifier></type> <name>secp256k1_scratch_space_create</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>secp256k1_context</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>max_size</name></decl></parameter>
)</parameter_list> SECP256K1_ARG_NONNULL<parameter_list>(</parameter_list>1</function_decl>)<empty_stmt>;</empty_stmt>

<comment type="block" format="doxygen">/** Destroy a secp256k1 scratch space.
 *
 *  The pointer may not be used afterwards.
 *  Args:   scratch: space to destroy
 */</comment>
<function_decl><type><name>SECP256K1_API</name> <name>void</name></type> <name>secp256k1_scratch_space_destroy</name><parameter_list>(
    <parameter><decl><type><name>secp256k1_scratch_space</name><modifier>*</modifier></type> <name>scratch</name></decl></parameter>
)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/** Parse a variable-length public key into the pubkey object.
 *
 *  Returns: 1 if the public key was fully valid.
 *           0 if the public key could not be parsed or is invalid.
 *  Args: ctx:      a secp256k1 context object.
 *  Out:  pubkey:   pointer to a pubkey object. If 1 is returned, it is set to a
 *                  parsed version of input. If not, its value is undefined.
 *  In:   input:    pointer to a serialized public key
 *        inputlen: length of the array pointed to by input
 *
 *  This function supports parsing compressed (33 bytes, header byte 0x02 or
 *  0x03), uncompressed (65 bytes, header byte 0x04), or hybrid (65 bytes, header
 *  byte 0x06 or 0x07) format public keys.
 */</comment>
<function_decl><type><name>SECP256K1_API</name> <name>SECP256K1_WARN_UNUSED_RESULT</name> <name>int</name></type> <name>secp256k1_ec_pubkey_parse</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>secp256k1_context</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>,
    <parameter><decl><type><name>secp256k1_pubkey</name><modifier>*</modifier></type> <name>pubkey</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>inputlen</name></decl></parameter>
)</parameter_list> SECP256K1_ARG_NONNULL<parameter_list>(</parameter_list>1</function_decl>) <macro><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><literal type="number">2</literal></argument>)</argument_list></macro> <expr_stmt><expr><call><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" format="doxygen">/** Serialize a pubkey object into a serialized byte sequence.
 *
 *  Returns: 1 always.
 *  Args:   ctx:        a secp256k1 context object.
 *  Out:    output:     a pointer to a 65-byte (if compressed==0) or 33-byte (if
 *                      compressed==1) byte array to place the serialized key
 *                      in.
 *  In/Out: outputlen:  a pointer to an integer which is initially set to the
 *                      size of output, and is overwritten with the written
 *                      size.
 *  In:     pubkey:     a pointer to a secp256k1_pubkey containing an
 *                      initialized public key.
 *          flags:      SECP256K1_EC_COMPRESSED if serialization should be in
 *                      compressed format, otherwise SECP256K1_EC_UNCOMPRESSED.
 */</comment>
<function_decl><type><name>SECP256K1_API</name> <name>int</name></type> <name>secp256k1_ec_pubkey_serialize</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>secp256k1_context</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>,
    <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>outputlen</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>secp256k1_pubkey</name><modifier>*</modifier></type> <name>pubkey</name></decl></parameter>,
    <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>
)</parameter_list> SECP256K1_ARG_NONNULL<parameter_list>(</parameter_list>1</function_decl>) <macro><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><literal type="number">2</literal></argument>)</argument_list></macro> <macro><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><literal type="number">3</literal></argument>)</argument_list></macro> <expr_stmt><expr><call><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" format="doxygen">/** Parse an ECDSA signature in compact (64 bytes) format.
 *
 *  Returns: 1 when the signature could be parsed, 0 otherwise.
 *  Args: ctx:      a secp256k1 context object
 *  Out:  sig:      a pointer to a signature object
 *  In:   input64:  a pointer to the 64-byte array to parse
 *
 *  The signature must consist of a 32-byte big endian R value, followed by a
 *  32-byte big endian S value. If R or S fall outside of [0..order-1], the
 *  encoding is invalid. R and S with value 0 are allowed in the encoding.
 *
 *  After the call, sig will always be initialized. If parsing failed or R or
 *  S are zero, the resulting sig value is guaranteed to fail validation for any
 *  message and public key.
 */</comment>
<function_decl><type><name>SECP256K1_API</name> <name>int</name></type> <name>secp256k1_ecdsa_signature_parse_compact</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>secp256k1_context</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>,
    <parameter><decl><type><name>secp256k1_ecdsa_signature</name><modifier>*</modifier></type> <name>sig</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>input64</name></decl></parameter>
)</parameter_list> SECP256K1_ARG_NONNULL<parameter_list>(</parameter_list>1</function_decl>) <macro><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><literal type="number">2</literal></argument>)</argument_list></macro> <expr_stmt><expr><call><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" format="doxygen">/** Parse a DER ECDSA signature.
 *
 *  Returns: 1 when the signature could be parsed, 0 otherwise.
 *  Args: ctx:      a secp256k1 context object
 *  Out:  sig:      a pointer to a signature object
 *  In:   input:    a pointer to the signature to be parsed
 *        inputlen: the length of the array pointed to be input
 *
 *  This function will accept any valid DER encoded signature, even if the
 *  encoded numbers are out of range.
 *
 *  After the call, sig will always be initialized. If parsing failed or the
 *  encoded numbers are out of range, signature validation with it is
 *  guaranteed to fail for every message and public key.
 */</comment>
<function_decl><type><name>SECP256K1_API</name> <name>int</name></type> <name>secp256k1_ecdsa_signature_parse_der</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>secp256k1_context</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>,
    <parameter><decl><type><name>secp256k1_ecdsa_signature</name><modifier>*</modifier></type> <name>sig</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>inputlen</name></decl></parameter>
)</parameter_list> SECP256K1_ARG_NONNULL<parameter_list>(</parameter_list>1</function_decl>) <macro><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><literal type="number">2</literal></argument>)</argument_list></macro> <expr_stmt><expr><call><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" format="doxygen">/** Serialize an ECDSA signature in DER format.
 *
 *  Returns: 1 if enough space was available to serialize, 0 otherwise
 *  Args:   ctx:       a secp256k1 context object
 *  Out:    output:    a pointer to an array to store the DER serialization
 *  In/Out: outputlen: a pointer to a length integer. Initially, this integer
 *                     should be set to the length of output. After the call
 *                     it will be set to the length of the serialization (even
 *                     if 0 was returned).
 *  In:     sig:       a pointer to an initialized signature object
 */</comment>
<function_decl><type><name>SECP256K1_API</name> <name>int</name></type> <name>secp256k1_ecdsa_signature_serialize_der</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>secp256k1_context</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>,
    <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>outputlen</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>secp256k1_ecdsa_signature</name><modifier>*</modifier></type> <name>sig</name></decl></parameter>
)</parameter_list> SECP256K1_ARG_NONNULL<parameter_list>(</parameter_list>1</function_decl>) <macro><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><literal type="number">2</literal></argument>)</argument_list></macro> <macro><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><literal type="number">3</literal></argument>)</argument_list></macro> <expr_stmt><expr><call><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" format="doxygen">/** Serialize an ECDSA signature in compact (64 byte) format.
 *
 *  Returns: 1
 *  Args:   ctx:       a secp256k1 context object
 *  Out:    output64:  a pointer to a 64-byte array to store the compact serialization
 *  In:     sig:       a pointer to an initialized signature object
 *
 *  See secp256k1_ecdsa_signature_parse_compact for details about the encoding.
 */</comment>
<function_decl><type><name>SECP256K1_API</name> <name>int</name></type> <name>secp256k1_ecdsa_signature_serialize_compact</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>secp256k1_context</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>,
    <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>output64</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>secp256k1_ecdsa_signature</name><modifier>*</modifier></type> <name>sig</name></decl></parameter>
)</parameter_list> SECP256K1_ARG_NONNULL<parameter_list>(</parameter_list>1</function_decl>) <macro><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><literal type="number">2</literal></argument>)</argument_list></macro> <expr_stmt><expr><call><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" format="doxygen">/** Verify an ECDSA signature.
 *
 *  Returns: 1: correct signature
 *           0: incorrect or unparseable signature
 *  Args:    ctx:       a secp256k1 context object, initialized for verification.
 *  In:      sig:       the signature being verified (cannot be NULL)
 *           msg32:     the 32-byte message hash being verified (cannot be NULL)
 *           pubkey:    pointer to an initialized public key to verify with (cannot be NULL)
 *
 * To avoid accepting malleable signatures, only ECDSA signatures in lower-S
 * form are accepted.
 *
 * If you need to accept ECDSA signatures from sources that do not obey this
 * rule, apply secp256k1_ecdsa_signature_normalize to the signature prior to
 * validation, but be aware that doing so results in malleable signatures.
 *
 * For details, see the comments for that function.
 */</comment>
<function_decl><type><name>SECP256K1_API</name> <name>SECP256K1_WARN_UNUSED_RESULT</name> <name>int</name></type> <name>secp256k1_ecdsa_verify</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>secp256k1_context</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>secp256k1_ecdsa_signature</name> <modifier>*</modifier></type><name>sig</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>msg32</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>secp256k1_pubkey</name> <modifier>*</modifier></type><name>pubkey</name></decl></parameter>
)</parameter_list> SECP256K1_ARG_NONNULL<parameter_list>(</parameter_list>1</function_decl>) <macro><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><literal type="number">2</literal></argument>)</argument_list></macro> <macro><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><literal type="number">3</literal></argument>)</argument_list></macro> <expr_stmt><expr><call><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" format="doxygen">/** Convert a signature to a normalized lower-S form.
 *
 *  Returns: 1 if sigin was not normalized, 0 if it already was.
 *  Args: ctx:    a secp256k1 context object
 *  Out:  sigout: a pointer to a signature to fill with the normalized form,
 *                or copy if the input was already normalized. (can be NULL if
 *                you're only interested in whether the input was already
 *                normalized).
 *  In:   sigin:  a pointer to a signature to check/normalize (cannot be NULL,
 *                can be identical to sigout)
 *
 *  With ECDSA a third-party can forge a second distinct signature of the same
 *  message, given a single initial signature, but without knowing the key. This
 *  is done by negating the S value modulo the order of the curve, 'flipping'
 *  the sign of the random point R which is not included in the signature.
 *
 *  Forgery of the same message isn't universally problematic, but in systems
 *  where message malleability or uniqueness of signatures is important this can
 *  cause issues. This forgery can be blocked by all verifiers forcing signers
 *  to use a normalized form.
 *
 *  The lower-S form reduces the size of signatures slightly on average when
 *  variable length encodings (such as DER) are used and is cheap to verify,
 *  making it a good choice. Security of always using lower-S is assured because
 *  anyone can trivially modify a signature after the fact to enforce this
 *  property anyway.
 *
 *  The lower S value is always between 0x1 and
 *  0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,
 *  inclusive.
 *
 *  No other forms of ECDSA malleability are known and none seem likely, but
 *  there is no formal proof that ECDSA, even with this additional restriction,
 *  is free of other malleability. Commonly used serialization schemes will also
 *  accept various non-unique encodings, so care should be taken when this
 *  property is required for an application.
 *
 *  The secp256k1_ecdsa_sign function will by default create signatures in the
 *  lower-S form, and secp256k1_ecdsa_verify will not accept others. In case
 *  signatures come from a system that cannot enforce this property,
 *  secp256k1_ecdsa_signature_normalize must be called before verification.
 */</comment>
<function_decl><type><name>SECP256K1_API</name> <name>int</name></type> <name>secp256k1_ecdsa_signature_normalize</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>secp256k1_context</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>,
    <parameter><decl><type><name>secp256k1_ecdsa_signature</name> <modifier>*</modifier></type><name>sigout</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>secp256k1_ecdsa_signature</name> <modifier>*</modifier></type><name>sigin</name></decl></parameter>
)</parameter_list> SECP256K1_ARG_NONNULL<parameter_list>(</parameter_list>1</function_decl>) <expr_stmt><expr><call><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" format="doxygen">/** An implementation of RFC6979 (using HMAC-SHA256) as nonce generation function.
 * If a data pointer is passed, it is assumed to be a pointer to 32 bytes of
 * extra entropy.
 */</comment>
<decl_stmt><decl><type><name>SECP256K1_API</name> <specifier>extern</specifier> <specifier>const</specifier> <name>secp256k1_nonce_function</name></type> <name>secp256k1_nonce_function_rfc6979</name></decl>;</decl_stmt>

<comment type="block" format="doxygen">/** A default safe nonce generation function (currently equal to secp256k1_nonce_function_rfc6979). */</comment>
<decl_stmt><decl><type><name>SECP256K1_API</name> <specifier>extern</specifier> <specifier>const</specifier> <name>secp256k1_nonce_function</name></type> <name>secp256k1_nonce_function_default</name></decl>;</decl_stmt>

<comment type="block" format="doxygen">/** Create an ECDSA signature.
 *
 *  Returns: 1: signature created
 *           0: the nonce generation function failed, or the private key was invalid.
 *  Args:    ctx:    pointer to a context object, initialized for signing (cannot be NULL)
 *  Out:     sig:    pointer to an array where the signature will be placed (cannot be NULL)
 *  In:      msg32:  the 32-byte message hash being signed (cannot be NULL)
 *           seckey: pointer to a 32-byte secret key (cannot be NULL)
 *           noncefp:pointer to a nonce generation function. If NULL, secp256k1_nonce_function_default is used
 *           ndata:  pointer to arbitrary data used by the nonce generation function (can be NULL)
 *
 * The created signature is always in lower-S form. See
 * secp256k1_ecdsa_signature_normalize for more details.
 */</comment>
<function_decl><type><name>SECP256K1_API</name> <name>int</name></type> <name>secp256k1_ecdsa_sign</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>secp256k1_context</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>,
    <parameter><decl><type><name>secp256k1_ecdsa_signature</name> <modifier>*</modifier></type><name>sig</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>msg32</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>seckey</name></decl></parameter>,
    <parameter><decl><type><name>secp256k1_nonce_function</name></type> <name>noncefp</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ndata</name></decl></parameter>
)</parameter_list> SECP256K1_ARG_NONNULL<parameter_list>(</parameter_list>1</function_decl>) <macro><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><literal type="number">2</literal></argument>)</argument_list></macro> <macro><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><literal type="number">3</literal></argument>)</argument_list></macro> <expr_stmt><expr><call><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" format="doxygen">/** Verify an ECDSA secret key.
 *
 *  Returns: 1: secret key is valid
 *           0: secret key is invalid
 *  Args:    ctx: pointer to a context object (cannot be NULL)
 *  In:      seckey: pointer to a 32-byte secret key (cannot be NULL)
 */</comment>
<function_decl><type><name>SECP256K1_API</name> <name>SECP256K1_WARN_UNUSED_RESULT</name> <name>int</name></type> <name>secp256k1_ec_seckey_verify</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>secp256k1_context</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>seckey</name></decl></parameter>
)</parameter_list> SECP256K1_ARG_NONNULL<parameter_list>(</parameter_list>1</function_decl>) <expr_stmt><expr><call><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" format="doxygen">/** Compute the public key for a secret key.
 *
 *  Returns: 1: secret was valid, public key stores
 *           0: secret was invalid, try again
 *  Args:   ctx:        pointer to a context object, initialized for signing (cannot be NULL)
 *  Out:    pubkey:     pointer to the created public key (cannot be NULL)
 *  In:     seckey:     pointer to a 32-byte private key (cannot be NULL)
 */</comment>
<function_decl><type><name>SECP256K1_API</name> <name>SECP256K1_WARN_UNUSED_RESULT</name> <name>int</name></type> <name>secp256k1_ec_pubkey_create</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>secp256k1_context</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>,
    <parameter><decl><type><name>secp256k1_pubkey</name> <modifier>*</modifier></type><name>pubkey</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>seckey</name></decl></parameter>
)</parameter_list> SECP256K1_ARG_NONNULL<parameter_list>(</parameter_list>1</function_decl>) <macro><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><literal type="number">2</literal></argument>)</argument_list></macro> <expr_stmt><expr><call><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" format="doxygen">/** Negates a private key in place.
 *
 *  Returns: 1 always
 *  Args:   ctx:        pointer to a context object
 *  In/Out: seckey:     pointer to the 32-byte private key to be negated (cannot be NULL)
 */</comment>
<function_decl><type><name>SECP256K1_API</name> <name>SECP256K1_WARN_UNUSED_RESULT</name> <name>int</name></type> <name>secp256k1_ec_privkey_negate</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>secp256k1_context</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>,
    <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>seckey</name></decl></parameter>
)</parameter_list> SECP256K1_ARG_NONNULL<parameter_list>(</parameter_list>1</function_decl>) <expr_stmt><expr><call><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" format="doxygen">/** Negates a public key in place.
 *
 *  Returns: 1 always
 *  Args:   ctx:        pointer to a context object
 *  In/Out: pubkey:     pointer to the public key to be negated (cannot be NULL)
 */</comment>
<function_decl><type><name>SECP256K1_API</name> <name>SECP256K1_WARN_UNUSED_RESULT</name> <name>int</name></type> <name>secp256k1_ec_pubkey_negate</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>secp256k1_context</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>,
    <parameter><decl><type><name>secp256k1_pubkey</name> <modifier>*</modifier></type><name>pubkey</name></decl></parameter>
)</parameter_list> SECP256K1_ARG_NONNULL<parameter_list>(</parameter_list>1</function_decl>) <expr_stmt><expr><call><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" format="doxygen">/** Tweak a private key by adding tweak to it.
 * Returns: 0 if the tweak was out of range (chance of around 1 in 2^128 for
 *          uniformly random 32-byte arrays, or if the resulting private key
 *          would be invalid (only when the tweak is the complement of the
 *          private key). 1 otherwise.
 * Args:    ctx:    pointer to a context object (cannot be NULL).
 * In/Out:  seckey: pointer to a 32-byte private key.
 * In:      tweak:  pointer to a 32-byte tweak.
 */</comment>
<function_decl><type><name>SECP256K1_API</name> <name>SECP256K1_WARN_UNUSED_RESULT</name> <name>int</name></type> <name>secp256k1_ec_privkey_tweak_add</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>secp256k1_context</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>,
    <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>seckey</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>tweak</name></decl></parameter>
)</parameter_list> SECP256K1_ARG_NONNULL<parameter_list>(</parameter_list>1</function_decl>) <macro><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><literal type="number">2</literal></argument>)</argument_list></macro> <expr_stmt><expr><call><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" format="doxygen">/** Tweak a public key by adding tweak times the generator to it.
 * Returns: 0 if the tweak was out of range (chance of around 1 in 2^128 for
 *          uniformly random 32-byte arrays, or if the resulting public key
 *          would be invalid (only when the tweak is the complement of the
 *          corresponding private key). 1 otherwise.
 * Args:    ctx:    pointer to a context object initialized for validation
 *                  (cannot be NULL).
 * In/Out:  pubkey: pointer to a public key object.
 * In:      tweak:  pointer to a 32-byte tweak.
 */</comment>
<function_decl><type><name>SECP256K1_API</name> <name>SECP256K1_WARN_UNUSED_RESULT</name> <name>int</name></type> <name>secp256k1_ec_pubkey_tweak_add</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>secp256k1_context</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>,
    <parameter><decl><type><name>secp256k1_pubkey</name> <modifier>*</modifier></type><name>pubkey</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>tweak</name></decl></parameter>
)</parameter_list> SECP256K1_ARG_NONNULL<parameter_list>(</parameter_list>1</function_decl>) <macro><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><literal type="number">2</literal></argument>)</argument_list></macro> <expr_stmt><expr><call><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" format="doxygen">/** Tweak a private key by multiplying it by a tweak.
 * Returns: 0 if the tweak was out of range (chance of around 1 in 2^128 for
 *          uniformly random 32-byte arrays, or equal to zero. 1 otherwise.
 * Args:   ctx:    pointer to a context object (cannot be NULL).
 * In/Out: seckey: pointer to a 32-byte private key.
 * In:     tweak:  pointer to a 32-byte tweak.
 */</comment>
<function_decl><type><name>SECP256K1_API</name> <name>SECP256K1_WARN_UNUSED_RESULT</name> <name>int</name></type> <name>secp256k1_ec_privkey_tweak_mul</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>secp256k1_context</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>,
    <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>seckey</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>tweak</name></decl></parameter>
)</parameter_list> SECP256K1_ARG_NONNULL<parameter_list>(</parameter_list>1</function_decl>) <macro><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><literal type="number">2</literal></argument>)</argument_list></macro> <expr_stmt><expr><call><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" format="doxygen">/** Tweak a public key by multiplying it by a tweak value.
 * Returns: 0 if the tweak was out of range (chance of around 1 in 2^128 for
 *          uniformly random 32-byte arrays, or equal to zero. 1 otherwise.
 * Args:    ctx:    pointer to a context object initialized for validation
 *                 (cannot be NULL).
 * In/Out:  pubkey: pointer to a public key obkect.
 * In:      tweak:  pointer to a 32-byte tweak.
 */</comment>
<function_decl><type><name>SECP256K1_API</name> <name>SECP256K1_WARN_UNUSED_RESULT</name> <name>int</name></type> <name>secp256k1_ec_pubkey_tweak_mul</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>secp256k1_context</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>,
    <parameter><decl><type><name>secp256k1_pubkey</name> <modifier>*</modifier></type><name>pubkey</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>tweak</name></decl></parameter>
)</parameter_list> SECP256K1_ARG_NONNULL<parameter_list>(</parameter_list>1</function_decl>) <macro><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><literal type="number">2</literal></argument>)</argument_list></macro> <expr_stmt><expr><call><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" format="doxygen">/** Updates the context randomization to protect against side-channel leakage.
 *  Returns: 1: randomization successfully updated or nothing to randomize
 *           0: error
 *  Args:    ctx:       pointer to a context object (cannot be NULL)
 *  In:      seed32:    pointer to a 32-byte random seed (NULL resets to initial state)
 *
 * While secp256k1 code is written to be constant-time no matter what secret
 * values are, it's possible that a future compiler may output code which isn't,
 * and also that the CPU may not emit the same radio frequencies or draw the same
 * amount power for all values.
 *
 * This function provides a seed which is combined into the blinding value: that
 * blinding value is added before each multiplication (and removed afterwards) so
 * that it does not affect function results, but shields against attacks which
 * rely on any input-dependent behaviour.
 *
 * This function has currently an effect only on contexts initialized for signing
 * because randomization is currently used only for signing. However, this is not
 * guaranteed and may change in the future. It is safe to call this function on
 * contexts not initialized for signing; then it will have no effect and return 1.
 *
 * You should call this after secp256k1_context_create or
 * secp256k1_context_clone, and may call this repeatedly afterwards.
 */</comment>
<function_decl><type><name>SECP256K1_API</name> <name>SECP256K1_WARN_UNUSED_RESULT</name> <name>int</name></type> <name>secp256k1_context_randomize</name><parameter_list>(
    <parameter><decl><type><name>secp256k1_context</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>seed32</name></decl></parameter>
)</parameter_list> SECP256K1_ARG_NONNULL<parameter_list>(</parameter_list>1</function_decl>)<empty_stmt>;</empty_stmt>

<comment type="block" format="doxygen">/** Add a number of public keys together.
 *  Returns: 1: the sum of the public keys is valid.
 *           0: the sum of the public keys is not valid.
 *  Args:   ctx:        pointer to a context object
 *  Out:    out:        pointer to a public key object for placing the resulting public key
 *                      (cannot be NULL)
 *  In:     ins:        pointer to array of pointers to public keys (cannot be NULL)
 *          n:          the number of public keys to add together (must be at least 1)
 */</comment>
<function_decl><type><name>SECP256K1_API</name> <name>SECP256K1_WARN_UNUSED_RESULT</name> <name>int</name></type> <name>secp256k1_ec_pubkey_combine</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>secp256k1_context</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>,
    <parameter><decl><type><name>secp256k1_pubkey</name> <modifier>*</modifier></type><name>out</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>secp256k1_pubkey</name> <modifier>*</modifier> <specifier>const</specifier> <modifier>*</modifier></type> <name>ins</name></decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>
)</parameter_list> SECP256K1_ARG_NONNULL<parameter_list>(</parameter_list>2</function_decl>) <expr_stmt><expr><call><name>SECP256K1_ARG_NONNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SECP256K1_H */</comment>
</unit>
