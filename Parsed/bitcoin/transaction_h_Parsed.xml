<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/mmm/Projects/bitcoin/src/primitives/transaction.h"><comment type="line">// Copyright (c) 2009-2010 Satoshi Nakamoto</comment>
<comment type="line">// Copyright (c) 2009-2018 The Bitcoin Core developers</comment>
<comment type="line">// Distributed under the MIT software license, see the accompanying</comment>
<comment type="line">// file COPYING or http://www.opensource.org/licenses/mit-license.php.</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>BITCOIN_PRIMITIVES_TRANSACTION_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITCOIN_PRIMITIVES_TRANSACTION_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;amount.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;script/script.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;serialize.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;uint256.h&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>SERIALIZE_TRANSACTION_NO_WITNESS</name> <init>= <expr><literal type="number">0x40000000</literal></expr></init></decl>;</decl_stmt>

<comment type="block" format="doxygen">/** An outpoint - a combination of a transaction hash and an index n into its vout */</comment>
<decl_stmt><decl><type><name>class</name></type> <name>COutPoint</name>
<block>{<block_content>
<label><name>public</name>:</label>
    <decl_stmt><decl><type><name>uint256</name></type> <name>hash</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>n</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>static</specifier> <name>constexpr</name> <name>uint32_t</name></type> <name>NULL_INDEX</name> <init>= <expr><name>std</name><operator>::</operator><name><name>numeric_limits</name><argument_list type="generic">&lt;<argument><expr><name>uint32_t</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>max</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>COutPoint</name><argument_list>()</argument_list></call><operator>:</operator> <macro><name>n</name><argument_list>(<argument>NULL_INDEX</argument>)</argument_list></macro> <block>{ }</block>
    <macro><name>COutPoint</name><argument_list>(<argument>const uint256&amp; hashIn</argument>, <argument>uint32_t nIn</argument>)</argument_list></macro><operator>:</operator> <call><name>hash</name><argument_list>(<argument><expr><name>hashIn</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>n</name><argument_list>(<argument>nIn</argument>)</argument_list></macro> <expr><block>{ }</block>

    <name>ADD_SERIALIZE_METHODS</name></expr>;</expr_stmt>

    <function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Stream</name></expr></argument>, <argument><expr><name>typename</name> <name>Operation</name></expr></argument>&gt;</argument_list></name>
    <specifier>inline</specifier> <name>void</name></type> <name>SerializationOp</name><parameter_list>(<parameter><decl><type><name>Stream</name><modifier>&amp;</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>Operation</name></type> <name>ser_action</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>READWRITE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>READWRITE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type> <name>SetNull</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name><name>hash</name><operator>.</operator><name>SetNull</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>n</name> <operator>=</operator> <name>NULL_INDEX</name></expr>;</expr_stmt> </block_content>}</block></function>
    <expr_stmt><expr><name>bool</name> <macro><name>IsNull</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><call><name><name>hash</name><operator>.</operator><name>IsNull</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <name>NULL_INDEX</name><operator>)</operator></expr>;</return> }</block></expr></expr_stmt>

    <expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>&lt;</operator><operator>(</operator><specifier>const</specifier> <name>COutPoint</name><operator>&amp;</operator> <name>a</name><operator>,</operator> <specifier>const</specifier> <name>COutPoint</name><operator>&amp;</operator> <name>b</name><operator>)</operator>
    <block>{
        <expr><name>int</name> <name>cmp</name> <operator>=</operator> <call><name><name>a</name><operator>.</operator><name>hash</name><operator>.</operator><name>Compare</name></name><argument_list>(<argument><expr><name><name>b</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;
        <return>return <expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>cmp</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>a</name><operator>.</operator><name>n</name></name> <operator>&lt;</operator> <name><name>b</name><operator>.</operator><name>n</name></name><operator>)</operator></expr>;</return>
    }</block></expr></expr_stmt>

    <expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name>COutPoint</name><operator>&amp;</operator> <name>a</name><operator>,</operator> <specifier>const</specifier> <name>COutPoint</name><operator>&amp;</operator> <name>b</name><operator>)</operator>
    <block>{
        <return>return <expr><operator>(</operator><name><name>a</name><operator>.</operator><name>hash</name></name> <operator>==</operator> <name><name>b</name><operator>.</operator><name>hash</name></name> <operator>&amp;&amp;</operator> <name><name>a</name><operator>.</operator><name>n</name></name> <operator>==</operator> <name><name>b</name><operator>.</operator><name>n</name></name><operator>)</operator></expr>;</return>
    }</block></expr></expr_stmt>

    <expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><specifier>const</specifier> <name>COutPoint</name><operator>&amp;</operator> <name>a</name><operator>,</operator> <specifier>const</specifier> <name>COutPoint</name><operator>&amp;</operator> <name>b</name><operator>)</operator>
    <block>{
        <return>return <expr><operator>!</operator><operator>(</operator><name>a</name> <operator>==</operator> <name>b</name><operator>)</operator></expr>;</return>
    }</block></expr></expr_stmt>

    <expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>ToString</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block" format="doxygen">/** An input of a transaction.  It contains the location of the previous
 * transaction's output that it claims and a signature that matches the
 * output's public key.
 */</comment>
<decl_stmt><decl><type><name>class</name></type> <name>CTxIn</name>
<block>{<block_content>
<label><name>public</name>:</label>
    <decl_stmt><decl><type><name>COutPoint</name></type> <name>prevout</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CScript</name></type> <name>scriptSig</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>nSequence</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CScriptWitness</name></type> <name>scriptWitness</name></decl>;</decl_stmt> <comment type="line" format="doxygen">//!&lt; Only serialized through CTransaction</comment>

    <comment type="block">/* Setting nSequence to this value for every input in a transaction
     * disables nLockTime. */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32_t</name></type> <name>SEQUENCE_FINAL</name> <init>= <expr><literal type="number">0xffffffff</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Below flags apply in the context of BIP 68*/</comment>
    <comment type="block">/* If this flag set, CTxIn::nSequence is NOT interpreted as a
     * relative lock-time. */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32_t</name></type> <name>SEQUENCE_LOCKTIME_DISABLE_FLAG</name> <init>= <expr><operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <literal type="number">31</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If CTxIn::nSequence encodes a relative lock-time and this flag
     * is set, the relative lock-time has units of 512 seconds,
     * otherwise it specifies blocks with a granularity of 1. */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32_t</name></type> <name>SEQUENCE_LOCKTIME_TYPE_FLAG</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">22</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If CTxIn::nSequence encodes a relative lock-time, this mask is
     * applied to extract that lock-time from the sequence field. */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32_t</name></type> <name>SEQUENCE_LOCKTIME_MASK</name> <init>= <expr><literal type="number">0x0000ffff</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* In order to use the same number of bits to encode roughly the
     * same wall-clock duration, and because blocks are naturally
     * limited to occur every 600s on average, the minimum granularity
     * for time-based relative lock-time is fixed at 512 seconds.
     * Converting from CTxIn::nSequence to seconds is performed by
     * multiplying by 512 = 2^9, or equivalently shifting up by
     * 9 bits. */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>SEQUENCE_LOCKTIME_GRANULARITY</name> <init>= <expr><literal type="number">9</literal></expr></init></decl>;</decl_stmt>

    <macro><name>CTxIn</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>nSequence</name> <operator>=</operator> <name>SEQUENCE_FINAL</name></expr>;</expr_stmt>
    </block_content>}</block>

    <function_decl><type><name>explicit</name></type> <name>CTxIn</name><parameter_list>(<parameter><decl><type><name>COutPoint</name></type> <name>prevoutIn</name></decl></parameter>, <parameter><decl><type><name>CScript</name></type> <name>scriptSigIn</name><init>=<expr><call><name>CScript</name><argument_list>()</argument_list></call></expr></init></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>nSequenceIn</name><init>=<expr><name>SEQUENCE_FINAL</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
    <macro><name>CTxIn</name><argument_list>(<argument>uint256 hashPrevTx</argument>, <argument>uint32_t nOut</argument>, <argument>CScript scriptSigIn=CScript()</argument>, <argument>uint32_t nSequenceIn=SEQUENCE_FINAL</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <expr_stmt><expr><name>ADD_SERIALIZE_METHODS</name></expr>;</expr_stmt>

    <function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Stream</name></expr></argument>, <argument><expr><name>typename</name> <name>Operation</name></expr></argument>&gt;</argument_list></name>
    <specifier>inline</specifier> <name>void</name></type> <name>SerializationOp</name><parameter_list>(<parameter><decl><type><name>Stream</name><modifier>&amp;</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>Operation</name></type> <name>ser_action</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>READWRITE</name><argument_list>(<argument><expr><name>prevout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>READWRITE</name><argument_list>(<argument><expr><name>scriptSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>READWRITE</name><argument_list>(<argument><expr><name>nSequence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name>CTxIn</name><operator>&amp;</operator> <name>a</name><operator>,</operator> <specifier>const</specifier> <name>CTxIn</name><operator>&amp;</operator> <name>b</name><operator>)</operator>
    <block>{
        <return>return <expr><operator>(</operator><name><name>a</name><operator>.</operator><name>prevout</name></name>   <operator>==</operator> <name><name>b</name><operator>.</operator><name>prevout</name></name> <operator>&amp;&amp;</operator>
                <name><name>a</name><operator>.</operator><name>scriptSig</name></name> <operator>==</operator> <name><name>b</name><operator>.</operator><name>scriptSig</name></name> <operator>&amp;&amp;</operator>
                <name><name>a</name><operator>.</operator><name>nSequence</name></name> <operator>==</operator> <name><name>b</name><operator>.</operator><name>nSequence</name></name><operator>)</operator></expr>;</return>
    }</block></expr></expr_stmt>

    <expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><specifier>const</specifier> <name>CTxIn</name><operator>&amp;</operator> <name>a</name><operator>,</operator> <specifier>const</specifier> <name>CTxIn</name><operator>&amp;</operator> <name>b</name><operator>)</operator>
    <block>{
        <return>return <expr><operator>!</operator><operator>(</operator><name>a</name> <operator>==</operator> <name>b</name><operator>)</operator></expr>;</return>
    }</block></expr></expr_stmt>

    <expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>ToString</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block" format="doxygen">/** An output of a transaction.  It contains the public key that the next input
 * must be able to sign with to claim it.
 */</comment>
<decl_stmt><decl><type><name>class</name></type> <name>CTxOut</name>
<block>{<block_content>
<label><name>public</name>:</label>
    <decl_stmt><decl><type><name>CAmount</name></type> <name>nValue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CScript</name></type> <name>scriptPubKey</name></decl>;</decl_stmt>

    <macro><name>CTxOut</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SetNull</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <macro><name>CTxOut</name><argument_list>(<argument>const CAmount&amp; nValueIn</argument>, <argument>CScript scriptPubKeyIn</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <expr_stmt><expr><name>ADD_SERIALIZE_METHODS</name></expr>;</expr_stmt>

    <function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Stream</name></expr></argument>, <argument><expr><name>typename</name> <name>Operation</name></expr></argument>&gt;</argument_list></name>
    <specifier>inline</specifier> <name>void</name></type> <name>SerializationOp</name><parameter_list>(<parameter><decl><type><name>Stream</name><modifier>&amp;</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>Operation</name></type> <name>ser_action</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>READWRITE</name><argument_list>(<argument><expr><name>nValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>READWRITE</name><argument_list>(<argument><expr><name>scriptPubKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type> <name>SetNull</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name>nValue</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>scriptPubKey</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <expr_stmt><expr><name>bool</name> <macro><name>IsNull</name><argument_list>()</argument_list></macro> <specifier>const</specifier>
    <block>{
        <return>return <expr><operator>(</operator><name>nValue</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
    }</block></expr></expr_stmt>

    <expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name>CTxOut</name><operator>&amp;</operator> <name>a</name><operator>,</operator> <specifier>const</specifier> <name>CTxOut</name><operator>&amp;</operator> <name>b</name><operator>)</operator>
    <block>{
        <return>return <expr><operator>(</operator><name><name>a</name><operator>.</operator><name>nValue</name></name>       <operator>==</operator> <name><name>b</name><operator>.</operator><name>nValue</name></name> <operator>&amp;&amp;</operator>
                <name><name>a</name><operator>.</operator><name>scriptPubKey</name></name> <operator>==</operator> <name><name>b</name><operator>.</operator><name>scriptPubKey</name></name><operator>)</operator></expr>;</return>
    }</block></expr></expr_stmt>

    <expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><specifier>const</specifier> <name>CTxOut</name><operator>&amp;</operator> <name>a</name><operator>,</operator> <specifier>const</specifier> <name>CTxOut</name><operator>&amp;</operator> <name>b</name><operator>)</operator>
    <block>{
        <return>return <expr><operator>!</operator><operator>(</operator><name>a</name> <operator>==</operator> <name>b</name><operator>)</operator></expr>;</return>
    }</block></expr></expr_stmt>

    <expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>ToString</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<struct_decl>struct <name>CMutableTransaction</name>;</struct_decl>

<comment type="block" format="doxygen">/**
 * Basic transaction serialization format:
 * - int32_t nVersion
 * - std::vector&lt;CTxIn&gt; vin
 * - std::vector&lt;CTxOut&gt; vout
 * - uint32_t nLockTime
 *
 * Extended transaction serialization format:
 * - int32_t nVersion
 * - unsigned char dummy = 0x00
 * - unsigned char flags (!= 0)
 * - std::vector&lt;CTxIn&gt; vin
 * - std::vector&lt;CTxOut&gt; vout
 * - if (flags &amp; 1):
 *   - CTxWitness wit;
 * - uint32_t nLockTime
 */</comment>
<function><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Stream</name></expr></argument>, <argument><expr><name>typename</name> <name>TxType</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>void</name></type> <name>UnserializeTransaction</name><parameter_list>(<parameter><decl><type><name>TxType</name><modifier>&amp;</modifier></type> <name>tx</name></decl></parameter>, <parameter><decl><type><name>Stream</name><modifier>&amp;</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>fAllowWitness</name> <init>= <expr><operator>!</operator><operator>(</operator><call><name><name>s</name><operator>.</operator><name>GetVersion</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>SERIALIZE_TRANSACTION_NO_WITNESS</name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>s</name> <operator>&gt;&gt;</operator> <name><name>tx</name><operator>.</operator><name>nVersion</name></name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>tx</name><operator>.</operator><name>vin</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>tx</name><operator>.</operator><name>vout</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Try to read the vin. In case the dummy is there, this will be read as an empty vector. */</comment>
    <expr_stmt><expr><name>s</name> <operator>&gt;&gt;</operator> <name><name>tx</name><operator>.</operator><name>vin</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>tx</name><operator>.</operator><name>vin</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>fAllowWitness</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* We read a dummy or an empty vin. */</comment>
        <expr_stmt><expr><name>s</name> <operator>&gt;&gt;</operator> <name>flags</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>s</name> <operator>&gt;&gt;</operator> <name><name>tx</name><operator>.</operator><name>vin</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>s</name> <operator>&gt;&gt;</operator> <name><name>tx</name><operator>.</operator><name>vout</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* We read a non-empty vin. Assume a normal vout follows. */</comment>
        <expr_stmt><expr><name>s</name> <operator>&gt;&gt;</operator> <name><name>tx</name><operator>.</operator><name>vout</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>fAllowWitness</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* The witness flag is present, and we support witnesses. */</comment>
        <expr_stmt><expr><name>flags</name> <operator>^=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>tx</name><operator>.</operator><name>vin</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><name>s</name> <operator>&gt;&gt;</operator> <name><name>tx</name><operator>.</operator><name>vin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>scriptWitness</name><operator>.</operator><name>stack</name></name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>tx</name><operator>.</operator><name>HasWitness</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="block">/* It's illegal to encode witnesses when all witness stacks are empty. */</comment>
            <expr_stmt><expr><name>throw</name> <name>std</name><operator>::</operator><name>ios_base</name><operator>::</operator><call><name>failure</name><argument_list>(<argument><expr><literal type="string">"Superfluous witness record"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>flags</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Unknown flag in the serialization */</comment>
        <expr_stmt><expr><name>throw</name> <name>std</name><operator>::</operator><name>ios_base</name><operator>::</operator><call><name>failure</name><argument_list>(<argument><expr><literal type="string">"Unknown transaction optional data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>s</name> <operator>&gt;&gt;</operator> <name><name>tx</name><operator>.</operator><name>nLockTime</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Stream</name></expr></argument>, <argument><expr><name>typename</name> <name>TxType</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>void</name></type> <name>SerializeTransaction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TxType</name><modifier>&amp;</modifier></type> <name>tx</name></decl></parameter>, <parameter><decl><type><name>Stream</name><modifier>&amp;</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>fAllowWitness</name> <init>= <expr><operator>!</operator><operator>(</operator><call><name><name>s</name><operator>.</operator><name>GetVersion</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>SERIALIZE_TRANSACTION_NO_WITNESS</name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>s</name> <operator>&lt;&lt;</operator> <name><name>tx</name><operator>.</operator><name>nVersion</name></name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <comment type="line">// Consistency check</comment>
    <if_stmt><if>if <condition>(<expr><name>fAllowWitness</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Check whether witnesses need to be serialized. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>tx</name><operator>.</operator><name>HasWitness</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>flags</name> <operator>|=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>flags</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Use extended format in case witnesses are to be serialized. */</comment>
        <expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CTxIn</name></expr></argument>&gt;</argument_list></name> <name>vinDummy</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>s</name> <operator>&lt;&lt;</operator> <name>vinDummy</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>s</name> <operator>&lt;&lt;</operator> <name>flags</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>s</name> <operator>&lt;&lt;</operator> <name><name>tx</name><operator>.</operator><name>vin</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>s</name> <operator>&lt;&lt;</operator> <name><name>tx</name><operator>.</operator><name>vout</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>tx</name><operator>.</operator><name>vin</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><name>s</name> <operator>&lt;&lt;</operator> <name><name>tx</name><operator>.</operator><name>vin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>scriptWitness</name><operator>.</operator><name>stack</name></name></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>s</name> <operator>&lt;&lt;</operator> <name><name>tx</name><operator>.</operator><name>nLockTime</name></name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/** The basic transaction that is broadcasted on the network and contained in
 * blocks.  A transaction can contain multiple inputs and outputs.
 */</comment>
<decl_stmt><decl><type><name>class</name></type> <name>CTransaction</name>
<block>{<block_content>
<label><name>public</name>:</label>
    <comment type="line">// Default transaction version.</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int32_t</name></type> <name>CURRENT_VERSION</name><init>=<expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

    <comment type="line">// Changing the default transaction version requires a two step process: first</comment>
    <comment type="line">// adapting relay policy by bumping MAX_STANDARD_VERSION, and then later date</comment>
    <comment type="line">// bumping the default CURRENT_VERSION at which point both CURRENT_VERSION and</comment>
    <comment type="line">// MAX_STANDARD_VERSION will be equal.</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int32_t</name></type> <name>MAX_STANDARD_VERSION</name><init>=<expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

    <comment type="line">// The local variables are made const to prevent unintended modification</comment>
    <comment type="line">// without updating the cached hash value. However, CTransaction is not</comment>
    <comment type="line">// actually immutable; deserialization and assignment are implemented,</comment>
    <comment type="line">// and bypass the constness. This is safe, as they update the entire</comment>
    <comment type="line">// structure, including the hash.</comment>
    <expr_stmt><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CTxIn</name></expr></argument>&gt;</argument_list></name> <name>vin</name></expr>;</expr_stmt>
    <expr_stmt><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CTxOut</name></expr></argument>&gt;</argument_list></name> <name>vout</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int32_t</name></type> <name>nVersion</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>nLockTime</name></decl>;</decl_stmt>

<label><name>private</name>:</label>
    <comment type="block" format="doxygen">/** Memory only. */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint256</name></type> <name>hash</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint256</name></type> <name>m_witness_hash</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>uint256</name> <macro><name>ComputeHash</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
    <expr_stmt><expr><name>uint256</name> <macro><name>ComputeWitnessHash</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<label><name>public</name>:</label>
    <comment type="block" format="doxygen">/** Construct a CTransaction that qualifies as IsNull() */</comment>
    <expr_stmt><expr><call><name>CTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block" format="doxygen">/** Convert a CMutableTransaction into a CTransaction. */</comment>
    <function_decl><type><name>explicit</name></type> <name>CTransaction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CMutableTransaction</name> <modifier>&amp;</modifier></type><name>tx</name></decl></parameter>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name>CTransaction</name><argument_list>(<argument><expr><name>CMutableTransaction</name> <operator>&amp;&amp;</operator><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Stream</name></expr></argument>&gt;</argument_list></name>
    <specifier>inline</specifier> <name>void</name></type> <name>Serialize</name><argument_list>(<argument><expr><name>Stream</name><operator>&amp;</operator> <name>s</name></expr></argument>)</argument_list> const <block>{<block_content>
        <expr_stmt><expr><call><name>SerializeTransaction</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></decl></decl_stmt>

    <comment type="block" format="doxygen">/** This deserializing constructor is provided instead of an Unserialize method.
     *  Unserialize is not possible, since it would require overwriting const fields. */</comment>
    <macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Stream</name><operator>&gt;</operator>
    <call><name>CTransaction</name><argument_list>(<argument><expr><name>deserialize_type</name></expr></argument>, <argument><expr><name>Stream</name><operator>&amp;</operator> <name>s</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>CTransaction</name><argument_list>(<argument>CMutableTransaction(deserialize, s)</argument>)</argument_list></macro> <block>{}</block>

    <name>bool</name> <macro><name>IsNull</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
        <return>return <expr><call><name><name>vin</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>vout</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></expr></expr_stmt>

    <expr_stmt><expr><specifier>const</specifier> <name>uint256</name><operator>&amp;</operator> <macro><name>GetHash</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>hash</name></expr>;</return> }</block></expr></expr_stmt>
    <expr_stmt><expr><specifier>const</specifier> <name>uint256</name><operator>&amp;</operator> <macro><name>GetWitnessHash</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>m_witness_hash</name></expr>;</return> }</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

    <comment type="line">// Return sum of txouts.</comment>
    <expr_stmt><expr><name>CAmount</name> <macro><name>GetValueOut</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
    <comment type="line">// GetValueIn() is a method on CCoinsViewCache, because</comment>
    <comment type="line">// inputs must be known to compute value in.</comment>

    <comment type="block" format="doxygen">/**
     * Get the total transaction size in bytes, including witness data.
     * "Total Size" defined in BIP141 and BIP144.
     * @return Total transaction size in bytes
     */</comment>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <macro><name>GetTotalSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

    <expr_stmt><expr><name>bool</name> <macro><name>IsCoinBase</name><argument_list>()</argument_list></macro> <specifier>const</specifier>
    <block>{
        <return>return <expr><operator>(</operator><call><name><name>vin</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>vin</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name><name>prevout</name><operator>.</operator><name>IsNull</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
    }</block></expr></expr_stmt>

    <expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name>CTransaction</name><operator>&amp;</operator> <name>a</name><operator>,</operator> <specifier>const</specifier> <name>CTransaction</name><operator>&amp;</operator> <name>b</name><operator>)</operator>
    <block>{
        <return>return <expr><name><name>a</name><operator>.</operator><name>hash</name></name> <operator>==</operator> <name><name>b</name><operator>.</operator><name>hash</name></name></expr>;</return>
    }</block></expr></expr_stmt>

    <expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><specifier>const</specifier> <name>CTransaction</name><operator>&amp;</operator> <name>a</name><operator>,</operator> <specifier>const</specifier> <name>CTransaction</name><operator>&amp;</operator> <name>b</name><operator>)</operator>
    <block>{
        <return>return <expr><name><name>a</name><operator>.</operator><name>hash</name></name> <operator>!=</operator> <name><name>b</name><operator>.</operator><name>hash</name></name></expr>;</return>
    }</block></expr></expr_stmt>

    <expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>ToString</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

    <expr_stmt><expr><name>bool</name> <macro><name>HasWitness</name><argument_list>()</argument_list></macro> <specifier>const</specifier>
    <block>{
        <for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>vin</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>vin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name><name>scriptWitness</name><operator>.</operator><name>IsNull</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>true</name></expr>;</return>
            <expr_stmt/>}</block_content>
        }
        return false</block><empty_stmt>;</empty_stmt></if></if_stmt>
    <expr_stmt/>}</block_content>
}</block><empty_stmt>;</empty_stmt></for>

<comment type="block" format="doxygen">/** A mutable version of CTransaction. */</comment>
struct <name>CMutableTransaction</name>
<block>{
    <expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CTxIn</name></expr></argument>&gt;</argument_list></name> <name>vin</name></expr>;
    <expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CTxOut</name></expr></argument>&gt;</argument_list></name> <name>vout</name></expr>;
    <expr><name>int32_t</name> <name>nVersion</name></expr>;
    <expr><name>uint32_t</name> <name>nLockTime</name></expr>;

    <expr><call><name>CMutableTransaction</name><argument_list>()</argument_list></call></expr>;
    <expr><name>explicit</name> <call><name>CMutableTransaction</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CTransaction</name><operator>&amp;</operator> <name>tx</name></expr></argument>)</argument_list></call></expr>;

    <expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Stream</name></expr></argument>&gt;</argument_list></name>
    <specifier>inline</specifier> <name>void</name> <macro><name>Serialize</name><argument_list>(<argument>Stream&amp; s</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
        <expr><call><name>SerializeTransaction</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;
    }</block>


    <name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Stream</name></expr></argument>&gt;</argument_list></name>
    <specifier>inline</specifier> <name>void</name> <macro><name>Unserialize</name><argument_list>(<argument>Stream&amp; s</argument>)</argument_list></macro> <block>{
        <expr><call><name>UnserializeTransaction</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;
    }</block>

    <name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Stream</name></expr></argument>&gt;</argument_list></name>
    <macro><name>CMutableTransaction</name><argument_list>(<argument>deserialize_type</argument>, <argument>Stream&amp; s</argument>)</argument_list></macro> <block>{
        <expr><call><name>Unserialize</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;
    }</block>

    <comment type="block" format="doxygen">/** Compute the hash of this CMutableTransaction. This is computed on the
     * fly, as opposed to GetHash() in CTransaction, which uses a cached result.
     */</comment>
    <name>uint256</name> <macro><name>GetHash</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

    <expr><name>bool</name> <macro><name>HasWitness</name><argument_list>()</argument_list></macro> <specifier>const</specifier>
    <block>{
        <for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>vin</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>vin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name><name>scriptWitness</name><operator>.</operator><name>IsNull</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>true</name></expr>;</return>
            <expr_stmt/>}</block_content>
        }
        return false</block><empty_stmt>;</empty_stmt></if></if_stmt>
    <expr_stmt/>}</block_content>
}</block><empty_stmt>;</empty_stmt></for></block></expr>

<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CTransaction</name></expr></argument>&gt;</argument_list></name> <name>CTransactionRef</name></expr>;</expr_stmt></typedef>
<specifier>static</specifier> <specifier>inline</specifier> <name>CTransactionRef</name> <macro><name>MakeTransactionRef</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>std</name><operator>::</operator><call><name><name>make_shared</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CTransaction</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Tx</name></expr></argument>&gt;</argument_list></name> <specifier>static</specifier> <specifier>inline</specifier> <name>CTransactionRef</name> <macro><name>MakeTransactionRef</name><argument_list>(<argument>Tx&amp;&amp; txIn</argument>)</argument_list></macro> <block>{ <return>return <expr><name>std</name><operator>::</operator><call><name><name>make_shared</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CTransaction</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name><name>forward</name><argument_list type="generic">&lt;<argument><expr><name>Tx</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>txIn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></block></block></expr></expr_stmt></block_content></block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// BITCOIN_PRIMITIVES_TRANSACTION_H</comment>
</unit>
