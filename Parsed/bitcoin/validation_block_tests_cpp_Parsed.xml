<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C++" filename="/home/mmm/Projects/bitcoin/src/test/validation_block_tests.cpp"><comment type="line">// Copyright (c) 2018-2019 The Bitcoin Core developers</comment>
<comment type="line">// Distributed under the MIT software license, see the accompanying</comment>
<comment type="line">// file COPYING or http://www.opensource.org/licenses/mit-license.php.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;boost/test/unit_test.hpp&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;chainparams.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;consensus/merkle.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;consensus/validation.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miner.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pow.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;random.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;script/standard.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;test/util/setup_common.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;validation.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;validationinterface.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;thread&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>V_OP_TRUE</name><argument_list>{<argument><expr><name>OP_TRUE</name></expr></argument>}</argument_list></decl>;</decl_stmt>

<macro><name>BOOST_FIXTURE_TEST_SUITE</name><argument_list>(<argument>validation_block_tests</argument>, <argument>RegTestingSetup</argument>)</argument_list></macro>

<struct>struct <name>TestSubscriber</name> <super_list>: <super><specifier>public</specifier> <name>CValidationInterface</name></super></super_list> <block>{<public type="default">
    <decl_stmt><decl><type><name>uint256</name></type> <name>m_expected_tip</name></decl>;</decl_stmt>

    <constructor><specifier>explicit</specifier> <name>TestSubscriber</name><parameter_list>(<parameter><decl><type><name>uint256</name></type> <name>tip</name></decl></parameter>)</parameter_list> <member_init_list>: <call><name>m_expected_tip</name><argument_list>(<argument><expr><name>tip</name></expr></argument>)</argument_list></call> </member_init_list><block>{<block_content/>}</block></constructor>

    <function><type><name>void</name></type> <name>UpdatedBlockTip</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CBlockIndex</name><modifier>*</modifier></type> <name>pindexNew</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CBlockIndex</name><modifier>*</modifier></type> <name>pindexFork</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fInitialDownload</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>m_expected_tip</name></expr></argument>, <argument><expr><call><name><name>pindexNew</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type> <name>BlockConnected</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CBlock</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>block</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CBlockIndex</name><modifier>*</modifier></type> <name>pindex</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CTransactionRef</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>txnConflicted</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>m_expected_tip</name></expr></argument>, <argument><expr><name><name>block</name><operator>-&gt;</operator><name>hashPrevBlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>m_expected_tip</name></expr></argument>, <argument><expr><call><name><name>pindex</name><operator>-&gt;</operator><name>pprev</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>m_expected_tip</name> <operator>=</operator> <call><name><name>block</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type> <name>BlockDisconnected</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CBlock</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>block</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CBlockIndex</name><modifier>*</modifier></type> <name>pindex</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>m_expected_tip</name></expr></argument>, <argument><expr><call><name><name>block</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>m_expected_tip</name></expr></argument>, <argument><expr><call><name><name>pindex</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>m_expected_tip</name> <operator>=</operator> <name><name>block</name><operator>-&gt;</operator><name>hashPrevBlock</name></name></expr>;</expr_stmt>
    </block_content>}</block></function>
</public>}</block>;</struct>

<function><type><name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CBlock</name></expr></argument>&gt;</argument_list></name></type> <name>Block</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint256</name><modifier>&amp;</modifier></type> <name>prev_hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>uint64_t</name></type> <name>time</name> <init>= <expr><call><name>Params</name><argument_list>()</argument_list></call><operator>.</operator><call><name>GenesisBlock</name><argument_list>()</argument_list></call><operator>.</operator><name>nTime</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>CScript</name></type> <name>pubKey</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pubKey</name> <operator>&lt;&lt;</operator> <name>i</name><operator>++</operator> <operator>&lt;&lt;</operator> <name>OP_TRUE</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>ptemplate</name> <init>= <expr><call><name>BlockAssembler</name><argument_list>(<argument><expr><call><name>Params</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>CreateNewBlock</name><argument_list>(<argument><expr><name>pubKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>pblock</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>make_shared</name><argument_list type="generic">&lt;<argument><expr><name>CBlock</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>ptemplate</name><operator>-&gt;</operator><name>block</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pblock</name><operator>-&gt;</operator><name>hashPrevBlock</name></name> <operator>=</operator> <name>prev_hash</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pblock</name><operator>-&gt;</operator><name>nTime</name></name> <operator>=</operator> <operator>++</operator><name>time</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>pubKey</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <decl_stmt><decl><type><name>WitnessV0ScriptHash</name></type> <name>witness_program</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>CSHA256</name><argument_list>()</argument_list></call><operator>.</operator><call><name>Write</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>V_OP_TRUE</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name><name>V_OP_TRUE</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>Finalize</name><argument_list>(<argument><expr><call><name><name>witness_program</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pubKey</name> <operator>&lt;&lt;</operator> <name>OP_0</name> <operator>&lt;&lt;</operator> <call><name>ToByteVector</name><argument_list>(<argument><expr><name>witness_program</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="line">// Make the coinbase transaction with two outputs:</comment>
    <comment type="line">// One zero-value one that has a unique pubkey to make sure that blocks at the same height can have a different hash</comment>
    <comment type="line">// Another one that has the coinbase reward in a P2WSH with OP_TRUE as witness program to make it easy to spend</comment>
    <decl_stmt><decl><type><name>CMutableTransaction</name></type> <name>txCoinbase</name><argument_list>(<argument><expr><operator>*</operator><name><name>pblock</name><operator>-&gt;</operator><name>vtx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>txCoinbase</name><operator>.</operator><name>vout</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>txCoinbase</name><operator>.</operator><name>vout</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>scriptPubKey</name> <operator>=</operator> <name>pubKey</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>txCoinbase</name><operator>.</operator><name>vout</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>nValue</name> <operator>=</operator> <name><name>txCoinbase</name><operator>.</operator><name>vout</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>nValue</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>txCoinbase</name><operator>.</operator><name>vout</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>nValue</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>txCoinbase</name><operator>.</operator><name>vin</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name><name>scriptWitness</name><operator>.</operator><name>SetNull</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pblock</name><operator>-&gt;</operator><name>vtx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>MakeTransactionRef</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>txCoinbase</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>pblock</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CBlock</name></expr></argument>&gt;</argument_list></name></type> <name>FinalizeBlock</name><parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CBlock</name></expr></argument>&gt;</argument_list></name></type> <name>pblock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// For LookupBlockIndex</comment>
    <expr_stmt><expr><call><name>GenerateCoinbaseCommitment</name><argument_list>(<argument><expr><operator>*</operator><name>pblock</name></expr></argument>, <argument><expr><call><name>LookupBlockIndex</name><argument_list>(<argument><expr><name><name>pblock</name><operator>-&gt;</operator><name>hashPrevBlock</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>Params</name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetConsensus</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pblock</name><operator>-&gt;</operator><name>hashMerkleRoot</name></name> <operator>=</operator> <call><name>BlockMerkleRoot</name><argument_list>(<argument><expr><operator>*</operator><name>pblock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>!</operator><call><name>CheckProofOfWork</name><argument_list>(<argument><expr><call><name><name>pblock</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>pblock</name><operator>-&gt;</operator><name>nBits</name></name></expr></argument>, <argument><expr><call><name>Params</name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetConsensus</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>++</operator><operator>(</operator><name><name>pblock</name><operator>-&gt;</operator><name>nNonce</name></name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>pblock</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// construct a valid block</comment>
<function><type><name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CBlock</name></expr></argument>&gt;</argument_list></name></type> <name>GoodBlock</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint256</name><modifier>&amp;</modifier></type> <name>prev_hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>FinalizeBlock</name><argument_list>(<argument><expr><call><name>Block</name><argument_list>(<argument><expr><name>prev_hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// construct an invalid block (but with a valid header)</comment>
<function><type><name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CBlock</name></expr></argument>&gt;</argument_list></name></type> <name>BadBlock</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint256</name><modifier>&amp;</modifier></type> <name>prev_hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>auto</name></type> <name>pblock</name> <init>= <expr><call><name>Block</name><argument_list>(<argument><expr><name>prev_hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>CMutableTransaction</name></type> <name>coinbase_spend</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>coinbase_spend</name><operator>.</operator><name>vin</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>CTxIn</name><argument_list>(<argument><expr><call><name>COutPoint</name><argument_list>(<argument><expr><name><name>pblock</name><operator>-&gt;</operator><name>vtx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><call><name>GetHash</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>CScript</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>coinbase_spend</name><operator>.</operator><name>vout</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name><name>pblock</name><operator>-&gt;</operator><name>vtx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>vout</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>CTransactionRef</name></type> <name>tx</name> <init>= <expr><call><name>MakeTransactionRef</name><argument_list>(<argument><expr><name>coinbase_spend</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>pblock</name><operator>-&gt;</operator><name>vtx</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>ret</name> <init>= <expr><call><name>FinalizeBlock</name><argument_list>(<argument><expr><name>pblock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>BuildChain</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint256</name><modifier>&amp;</modifier></type> <name>root</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>invalid_rate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>branch_rate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>max_size</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CBlock</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>blocks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>height</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name><name>blocks</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>max_size</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>gen_invalid</name> <init>= <expr><call><name>InsecureRandRange</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>invalid_rate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>gen_fork</name> <init>= <expr><call><name>InsecureRandRange</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>branch_rate</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CBlock</name></expr></argument>&gt;</argument_list></name></type> <name>pblock</name> <init>= <expr><ternary><condition><expr><name>gen_invalid</name></expr> ?</condition><then> <expr><call><name>BadBlock</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>GoodBlock</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>blocks</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>pblock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>gen_invalid</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>BuildChain</name><argument_list>(<argument><expr><call><name><name>pblock</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>height</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>invalid_rate</name></expr></argument>, <argument><expr><name>branch_rate</name></expr></argument>, <argument><expr><name>max_size</name></expr></argument>, <argument><expr><name>blocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>gen_fork</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>blocks</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>GoodBlock</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BuildChain</name><argument_list>(<argument><expr><call><name><name>blocks</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>GetHash</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>height</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>invalid_rate</name></expr></argument>, <argument><expr><name>branch_rate</name></expr></argument>, <argument><expr><name>max_size</name></expr></argument>, <argument><expr><name>blocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>processnewblock_signals_ordering</argument>)</argument_list></macro>
<block>{<block_content>
    <comment type="line">// build a large-ish chain that's likely to have some forks</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CBlock</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>blocks</name></decl>;</decl_stmt>
    <while>while <condition>(<expr><call><name><name>blocks</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">50</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>blocks</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BuildChain</name><argument_list>(<argument><expr><call><name>Params</name><argument_list>()</argument_list></call><operator>.</operator><call><name>GenesisBlock</name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetHash</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><literal type="number">500</literal></expr></argument>, <argument><expr><name>blocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <decl_stmt><decl><type><name>bool</name></type> <name>ignored</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BlockValidationState</name></type> <name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CBlockHeader</name></expr></argument>&gt;</argument_list></name></type> <name>headers</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>std</name><operator>::</operator><name>transform</name></name><argument_list>(<argument><expr><call><name><name>blocks</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>blocks</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>back_inserter</name></name><argument_list>(<argument><expr><name>headers</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><lambda><capture>[]</capture><parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CBlock</name></expr></argument>&gt;</argument_list></name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name><name>b</name><operator>-&gt;</operator><name>GetBlockHeader</name></name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Process all the headers so we understand the toplogy of the chain</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ProcessNewBlockHeaders</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>Params</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Connect the genesis block and drain any outstanding events</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ProcessNewBlock</name><argument_list>(<argument><expr><call><name>Params</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>make_shared</name><argument_list type="generic">&lt;<argument><expr><name>CBlock</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>Params</name><argument_list>()</argument_list></call><operator>.</operator><call><name>GenesisBlock</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ignored</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SyncWithValidationInterfaceQueue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// subscribe to events (this subscriber will validate event ordering)</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CBlockIndex</name><modifier>*</modifier></type> <name>initial_tip</name> <init>= <expr><literal type="null">nullptr</literal></expr></init></decl>;</decl_stmt>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>initial_tip</name> <operator>=</operator> <call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Tip</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <decl_stmt><decl><type><name>TestSubscriber</name></type> <name>sub</name><argument_list>(<argument><expr><call><name><name>initial_tip</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>RegisterValidationInterface</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// create a bunch of threads that repeatedly process a block generated above at random</comment>
    <comment type="line">// this will create parallelism and randomness inside validation - the ValidationInterface</comment>
    <comment type="line">// will subscribe to events generated during block validation and assert on ordering invariance</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>thread</name></name></expr></argument>&gt;</argument_list></name></type> <name>threads</name></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>threads</name><operator>.</operator><name>emplace_back</name></name><argument_list>(<argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier><name>blocks</name></argument>]</capture><parameter_list>()</parameter_list> <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name> <name>ignored</name></type></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>FastRandomContext</name> <name>insecure</name></type></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name> <name>i</name> = 0</type></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">1000</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>auto</name> <name>block</name> = <name><name>blocks</name><index>[<expr><call><name><name>insecure</name><operator>.</operator><name>randrange</name></name><argument_list>(<argument><expr><call><name><name>blocks</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>]</index></name></type></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>ProcessNewBlock</name><argument_list>(<argument><expr><call><name>Params</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ignored</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>

            <comment type="line">// to make sure that eventually we process the full chain - do it here</comment>
            <for>for <control>(<init><decl><type><name>auto</name> <name>block</name> : <name>blocks</name></type></decl></init>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>block</name><operator>-&gt;</operator><name>vtx</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>bool</name> <name>processed</name> = <name>ProcessNewBlock</name>(<name>Params</name>(</type></decl>)<operator>,</operator> block<operator>,</operator> true<operator>,</operator> &amp;ignored</decl_stmt>)</block_content></block><empty_stmt>;</empty_stmt></if></if_stmt>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>processed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></lambda></expr></argument></argument_list></call></expr></expr_stmt>
        </block_content>}</block></for>)</block_content></block><empty_stmt>;</empty_stmt>
    }

    for <expr_stmt><expr><operator>(</operator><name>auto</name><operator>&amp;</operator> <name>t</name> <operator>:</operator> <name>threads</name><operator>)</operator> <block>{
        <expr><call><name><name>t</name><operator>.</operator><name>join</name></name><argument_list>()</argument_list></call></expr>;
    }</block></expr></expr_stmt>
    <while>while <condition>(<expr><call><name>GetMainSignals</name><argument_list>()</argument_list></call><operator>.</operator><call><name>CallbacksPending</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>MilliSleep</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>UnregisterValidationInterface</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name><name>sub</name><operator>.</operator><name>m_expected_tip</name></name></expr></argument>, <argument><expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Tip</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>GetBlockHash</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}

<comment type="block" format="doxygen">/**
 * Test that mempool updates happen atomically with reorgs.
 *
 * This prevents RPC clients, among others, from retrieving immediately-out-of-date mempool data
 * during large reorgs.
 *
 * The test verifies this by creating a chain of `num_txs` blocks, matures their coinbases, and then
 * submits txns spending from their coinbase to the mempool. A fork chain is then processed,
 * invalidating the txns and evicting them from the mempool.
 *
 * We verify that the mempool updates atomically by polling it continuously
 * from another thread during the reorg and checking that its size only changes
 * once. The size changing exactly once indicates that the polling thread's
 * view of the mempool is either consistent with the chain state before reorg,
 * or consistent with the chain state after the reorg, and not just consistent
 * with some intermediate state during the reorg.
 */</comment>
BOOST_AUTO_TEST_CASE<expr_stmt><expr><operator>(</operator><name>mempool_locks_reorg</name><operator>)</operator>
<block>{
    <expr><name>bool</name> <name>ignored</name></expr>;
    <expr><name>auto</name> <name>ProcessBlock</name> <operator>=</operator> <lambda><capture>[<argument><modifier>&amp;</modifier><name>ignored</name></argument>]</capture><parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CBlock</name></expr></argument>&gt;</argument_list></name></type> <name>block</name></decl></parameter>)</parameter_list> -&gt; <type><name>bool</name></type> <block>{<block_content>
        <return>return <expr><call><name>ProcessNewBlock</name><argument_list>(<argument><expr><call><name>Params</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>block</name></expr></argument>, <comment type="block">/* fForceProcessing */</comment> <argument><expr><literal type="boolean">true</literal></expr></argument>, <comment type="block">/* fNewBlock */</comment> <argument><expr><operator>&amp;</operator><name>ignored</name></expr></argument>)</argument_list></call></expr>;</return>
    <expr_stmt/></block_content></block></lambda></expr>}</block></expr>;</expr_stmt>

    <comment type="line">// Process all mined blocks</comment>
    <expr_stmt><expr><call><name>BOOST_REQUIRE</name><argument_list>(<argument><expr><call><name>ProcessBlock</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>make_shared</name><argument_list type="generic">&lt;<argument><expr><name>CBlock</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>Params</name><argument_list>()</argument_list></call><operator>.</operator><call><name>GenesisBlock</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>last_mined</name> <init>= <expr><call><name>GoodBlock</name><argument_list>(<argument><expr><call><name>Params</name><argument_list>()</argument_list></call><operator>.</operator><call><name>GenesisBlock</name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetHash</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_REQUIRE</name><argument_list>(<argument><expr><call><name>ProcessBlock</name><argument_list>(<argument><expr><name>last_mined</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Run the test multiple times</comment>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>test_runs</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</init> <condition><expr><name>test_runs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>test_runs</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>last_mined</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Tip</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>GetBlockHash</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Later on split from here</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint256</name></type> <name>split_hash</name><argument_list>{<argument><expr><name><name>last_mined</name><operator>-&gt;</operator><name>hashPrevBlock</name></name></expr></argument>}</argument_list></decl>;</decl_stmt>

        <comment type="line">// Create a bunch of transactions to spend the miner rewards of the</comment>
        <comment type="line">// most recent blocks</comment>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CTransactionRef</name></expr></argument>&gt;</argument_list></name></type> <name>txs</name></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>num_txs</name> <init>= <expr><literal type="number">22</literal></expr></init></decl>;</init> <condition><expr><name>num_txs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>num_txs</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>CMutableTransaction</name></type> <name>mtx</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>mtx</name><operator>.</operator><name>vin</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>CTxIn</name><argument_list>{<argument><expr><call><name>COutPoint</name><argument_list>{<argument><expr><name><name>last_mined</name><operator>-&gt;</operator><name>vtx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><call><name>GetHash</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>}</argument_list></call></expr></argument>, <argument><expr><macro><name>CScript</name></macro><block>{}</block></expr></argument>}</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mtx</name><operator>.</operator><name>vin</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name><name>scriptWitness</name><operator>.</operator><name>stack</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>V_OP_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>mtx</name><operator>.</operator><name>vout</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name><name>last_mined</name><operator>-&gt;</operator><name>vtx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>vout</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mtx</name><operator>.</operator><name>vout</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>nValue</name> <operator>-=</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>txs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>MakeTransactionRef</name><argument_list>(<argument><expr><name>mtx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>last_mined</name> <operator>=</operator> <call><name>GoodBlock</name><argument_list>(<argument><expr><call><name><name>last_mined</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>BOOST_REQUIRE</name><argument_list>(<argument><expr><call><name>ProcessBlock</name><argument_list>(<argument><expr><name>last_mined</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="line">// Mature the inputs of the txs</comment>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>COINBASE_MATURITY</name></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><name>last_mined</name> <operator>=</operator> <call><name>GoodBlock</name><argument_list>(<argument><expr><call><name><name>last_mined</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>BOOST_REQUIRE</name><argument_list>(<argument><expr><call><name>ProcessBlock</name><argument_list>(<argument><expr><name>last_mined</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="line">// Mine a reorg (and hold it back) before adding the txs to the mempool</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint256</name></type> <name>tip_init</name><argument_list>{<argument><expr><macro><name>last_mined</name></macro><operator>-&gt;</operator><macro><name>GetHash</name><argument_list>()</argument_list></macro></expr></argument>}</argument_list></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CBlock</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>reorg</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>last_mined</name> <operator>=</operator> <call><name>GoodBlock</name><argument_list>(<argument><expr><name>split_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>reorg</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>last_mined</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>size_t</name></type> <name>j</name> <init>= <expr><name>COINBASE_MATURITY</name> <operator>+</operator> <call><name><name>txs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><name>last_mined</name> <operator>=</operator> <call><name>GoodBlock</name><argument_list>(<argument><expr><call><name><name>last_mined</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>reorg</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>last_mined</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="line">// Add the txs to the tx pool</comment>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>TxValidationState</name></type> <name>state</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>list</name><argument_list type="generic">&lt;<argument><expr><name>CTransactionRef</name></expr></argument>&gt;</argument_list></name></type> <name>plTxnReplaced</name></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>tx</name> <range>: <expr><name>txs</name></expr></range></decl></init>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name>BOOST_REQUIRE</name><argument_list>(<argument><expr><call><name>AcceptToMemoryPool</name><argument_list>(
                    <argument><expr><operator>*</operator><name><name>m_node</name><operator>.</operator><name>mempool</name></name></expr></argument>,
                    <argument><expr><name>state</name></expr></argument>,
                    <argument><expr><name>tx</name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>plTxnReplaced</name></expr></argument>,
                    <comment type="block">/* bypass_limits */</comment> <argument><expr><literal type="boolean">false</literal></expr></argument>,
                    <comment type="block">/* nAbsurdFee */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block>

        <comment type="line">// Check that all txs are in the pool</comment>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>m_node</name><operator>.</operator><name>mempool</name><operator>-&gt;</operator><name>cs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>m_node</name><operator>.</operator><name>mempool</name><operator>-&gt;</operator><name>mapTx</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>txs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <comment type="line">// Run a thread that simulates an RPC caller that is polling while</comment>
        <comment type="line">// validation is doing a reorg</comment>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>thread</name></name></type> <name>rpc_thread</name><argument_list>{<argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>()</parameter_list> <block>{<block_content>
            <comment type="line">// This thread is checking that the mempool either contains all of</comment>
            <comment type="line">// the transactions invalidated by the reorg, or none of them, and</comment>
            <comment type="line">// not some intermediate amount.</comment>
            <while>while <condition>(<expr><literal type="boolean">true</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>m_node</name><operator>.</operator><name>mempool</name><operator>-&gt;</operator><name>cs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>m_node</name><operator>.</operator><name>mempool</name><operator>-&gt;</operator><name>mapTx</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <comment type="line">// We are done with the reorg</comment>
                    <break>break;</break>
                <expr_stmt/>}</block_content>
                <comment type="line">// Internally, we might be in the middle of the reorg, but</comment>
                <comment type="line">// externally the reorg to the most-proof-of-work chain should</comment>
                <comment type="line">// be atomic. So the caller assumes that the returned mempool</comment>
                <comment type="line">// is consistent. That is, it has all txs that were there</comment>
                <comment type="line">// before the reorg.</comment>
                assert(m_node.mempool-&gt;mapTx.size(</block></if></if_stmt>)</block_content> == txs.size(</block></while>)</block_content></block></lambda></expr></argument>)</argument_list></decl>;</decl_stmt>
                <continue>continue;</continue>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// We are done with the reorg, so the tip must have changed</comment>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tip_init</name> <operator>!=</operator> <call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Tip</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>GetBlockHash</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }}<empty_stmt>;</empty_stmt>

        <comment type="line">// Submit the reorg in this thread to invalidate and remove the txs from the tx pool</comment>
        <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>b</name> <range>: <expr><name>reorg</name></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>ProcessBlock</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <comment type="line">// Check that the reorg was eventually successful</comment>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>last_mined</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Tip</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>GetBlockHash</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// We can join the other thread, which returns when the reorg was successful</comment>
        <expr_stmt><expr><call><name><name>rpc_thread</name><operator>.</operator><name>join</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }
}
<macro><name>BOOST_AUTO_TEST_SUITE_END</name><argument_list>()</argument_list></macro>
</unit>
