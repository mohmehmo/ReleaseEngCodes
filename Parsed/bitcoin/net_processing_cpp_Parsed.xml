<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C++" filename="/home/mmm/Projects/bitcoin/src/net_processing.cpp"><comment type="line">// Copyright (c) 2009-2010 Satoshi Nakamoto</comment>
<comment type="line">// Copyright (c) 2009-2018 The Bitcoin Core developers</comment>
<comment type="line">// Distributed under the MIT software license, see the accompanying</comment>
<comment type="line">// file COPYING or http://www.opensource.org/licenses/mit-license.php.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;net_processing.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;addrman.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;banman.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;blockencodings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;chainparams.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;consensus/validation.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;hash.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;validation.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;merkleblock.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netmessagemaker.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netbase.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;policy/fees.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;policy/policy.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;primitives/block.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;primitives/transaction.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;random.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;reverse_iterator.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;scheduler.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;tinyformat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;txmempool.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/system.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/strencodings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/validation.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;memory&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> <cpp:literal>"Bitcoin cannot be compiled without assertions."</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/** Expiration time for orphan transactions in seconds */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>constexpr</specifier> <name>int64_t</name></type> <name>ORPHAN_TX_EXPIRE_TIME</name> <init>= <expr><literal type="number">20</literal> <operator>*</operator> <literal type="number">60</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** Minimum time between orphan transactions expire time checks in seconds */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>constexpr</specifier> <name>int64_t</name></type> <name>ORPHAN_TX_EXPIRE_INTERVAL</name> <init>= <expr><literal type="number">5</literal> <operator>*</operator> <literal type="number">60</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** How long to cache transactions in mapRelay for normal relay */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>constexpr</specifier> <name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>seconds</name></name></type> <name>RELAY_TX_CACHE_TIME</name><argument_list>{<argument><expr><literal type="number">15</literal> <operator>*</operator> <literal type="number">60</literal></expr></argument>}</argument_list></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** Headers download timeout expressed in microseconds
 *  Timeout = base + per_header * (expected number of headers) */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>constexpr</specifier> <name>int64_t</name></type> <name>HEADERS_DOWNLOAD_TIMEOUT_BASE</name> <init>= <expr><literal type="number">15</literal> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">1000000</literal></expr></init></decl>;</decl_stmt> <comment type="line">// 15 minutes</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>constexpr</specifier> <name>int64_t</name></type> <name>HEADERS_DOWNLOAD_TIMEOUT_PER_HEADER</name> <init>= <expr><literal type="number">1000</literal></expr></init></decl>;</decl_stmt> <comment type="line">// 1ms/header</comment>
<comment type="block" format="doxygen">/** Protect at least this many outbound peers from disconnection due to slow/
 * behind headers chain.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>constexpr</specifier> <name>int32_t</name></type> <name>MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** Timeout for (unprotected) outbound peers to sync to our chainwork, in seconds */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>constexpr</specifier> <name>int64_t</name></type> <name>CHAIN_SYNC_TIMEOUT</name> <init>= <expr><literal type="number">20</literal> <operator>*</operator> <literal type="number">60</literal></expr></init></decl>;</decl_stmt> <comment type="line">// 20 minutes</comment>
<comment type="block" format="doxygen">/** How frequently to check for stale tips, in seconds */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>constexpr</specifier> <name>int64_t</name></type> <name>STALE_CHECK_INTERVAL</name> <init>= <expr><literal type="number">10</literal> <operator>*</operator> <literal type="number">60</literal></expr></init></decl>;</decl_stmt> <comment type="line">// 10 minutes</comment>
<comment type="block" format="doxygen">/** How frequently to check for extra outbound peers and disconnect, in seconds */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>constexpr</specifier> <name>int64_t</name></type> <name>EXTRA_PEER_CHECK_INTERVAL</name> <init>= <expr><literal type="number">45</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** Minimum time an outbound-peer-eviction candidate must be connected for, in order to evict, in seconds */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>constexpr</specifier> <name>int64_t</name></type> <name>MINIMUM_CONNECT_TIME</name> <init>= <expr><literal type="number">30</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** SHA256("main address relay")[0:8] */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>constexpr</specifier> <name>uint64_t</name></type> <name>RANDOMIZER_ID_ADDRESS_RELAY</name> <init>= <expr><literal type="number">0x3cac0035b5866b90ULL</literal></expr></init></decl>;</decl_stmt>
<comment type="line" format="doxygen">/// Age after which a stale block will no longer be served if requested as</comment>
<comment type="line" format="doxygen">/// protection against fingerprinting. Set to one month, denominated in seconds.</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>constexpr</specifier> <name>int</name></type> <name>STALE_RELAY_AGE_LIMIT</name> <init>= <expr><literal type="number">30</literal> <operator>*</operator> <literal type="number">24</literal> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">60</literal></expr></init></decl>;</decl_stmt>
<comment type="line" format="doxygen">/// Age after which a block is considered historical for purposes of rate</comment>
<comment type="line" format="doxygen">/// limiting block relay. Set to one week, denominated in seconds.</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>constexpr</specifier> <name>int</name></type> <name>HISTORICAL_BLOCK_AGE</name> <init>= <expr><literal type="number">7</literal> <operator>*</operator> <literal type="number">24</literal> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">60</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** Maximum number of in-flight transactions from a peer */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>constexpr</specifier> <name>int32_t</name></type> <name>MAX_PEER_TX_IN_FLIGHT</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** Maximum number of announced transactions from a peer */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>constexpr</specifier> <name>int32_t</name></type> <name>MAX_PEER_TX_ANNOUNCEMENTS</name> <init>= <expr><literal type="number">2</literal> <operator>*</operator> <name>MAX_INV_SZ</name></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** How many microseconds to delay requesting transactions from inbound peers */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>constexpr</specifier> <name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>microseconds</name></name></type> <name>INBOUND_PEER_TX_DELAY</name><argument_list>{<argument><expr><macro><name>std</name></macro><name><operator>::</operator><name>chrono</name><operator>::</operator><name>seconds</name></name><block>{<expr><literal type="number">2</literal></expr>}</block></expr></argument>}</argument_list></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** How long to wait (in microseconds) before downloading a transaction from an additional peer */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>constexpr</specifier> <name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>microseconds</name></name></type> <name>GETDATA_TX_INTERVAL</name><argument_list>{<argument><expr><macro><name>std</name></macro><name><operator>::</operator><name>chrono</name><operator>::</operator><name>seconds</name></name><block>{<expr><literal type="number">60</literal></expr>}</block></expr></argument>}</argument_list></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** Maximum delay (in microseconds) for transaction requests to avoid biasing some peers over others. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>constexpr</specifier> <name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>microseconds</name></name></type> <name>MAX_GETDATA_RANDOM_DELAY</name><argument_list>{<argument><expr><macro><name>std</name></macro><name><operator>::</operator><name>chrono</name><operator>::</operator><name>seconds</name></name><block>{<expr><literal type="number">2</literal></expr>}</block></expr></argument>}</argument_list></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** How long to wait (in microseconds) before expiring an in-flight getdata request to a peer */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>constexpr</specifier> <name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>microseconds</name></name></type> <name>TX_EXPIRY_INTERVAL</name><argument_list>{<argument><expr><name>GETDATA_TX_INTERVAL</name> <operator>*</operator> <literal type="number">10</literal></expr></argument>}</argument_list></decl>;</decl_stmt>
<assert type="static">static_assert<argument_list>(<argument><expr><name>INBOUND_PEER_TX_DELAY</name> <operator>&gt;=</operator> <name>MAX_GETDATA_RANDOM_DELAY</name></expr></argument>,
<argument><expr><literal type="string">"To preserve security, MAX_GETDATA_RANDOM_DELAY should not exceed INBOUND_PEER_DELAY"</literal></expr></argument>)</argument_list>;</assert>
<comment type="block" format="doxygen">/** Limit to avoid sending big packets. Not used in processing incoming GETDATA for compatibility */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>MAX_GETDATA_SZ</name> <init>= <expr><literal type="number">1000</literal></expr></init></decl>;</decl_stmt>


<struct>struct <name>COrphanTx</name> <block>{<public type="default">
    <comment type="line">// When modifying, adapt the copy of this definition in tests/DoS_tests.</comment>
    <decl_stmt><decl><type><name>CTransactionRef</name></type> <name>tx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NodeId</name></type> <name>fromPeer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>nTimeExpire</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>list_pos</name></decl>;</decl_stmt>
</public>}</block>;</struct>
<decl_stmt><decl><type><name>CCriticalSection</name></type> <name>g_cs_orphans</name></decl>;</decl_stmt>
<function_decl><type><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>, <argument><expr><name>COrphanTx</name></expr></argument>&gt;</argument_list></name> <name>mapOrphanTransactions</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>g_cs_orphans</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>EraseOrphansFor</name><parameter_list>(<parameter><decl><type><name>NodeId</name></type> <name>peer</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/** Increase a node's misbehavior score. */</comment>
<decl_stmt><decl><type><name>void</name></type> <name>Misbehaving</name><argument_list>(<argument><expr><name>NodeId</name> <name>nodeid</name></expr></argument>, <argument><expr><name>int</name> <name>howmuch</name></expr></argument>, <argument><expr><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><operator>&amp;</operator> <name>message</name><operator>=</operator><literal type="string">""</literal></expr></argument>)</argument_list> <name>EXCLUSIVE_LOCKS_REQUIRED</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<comment type="block" format="doxygen">/** Average delay between local address broadcasts in seconds. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>constexpr</specifier> <name>unsigned</name> <name>int</name></type> <name>AVG_LOCAL_ADDRESS_BROADCAST_INTERVAL</name> <init>= <expr><literal type="number">24</literal> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">60</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** Average delay between peer address broadcasts in seconds. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>AVG_ADDRESS_BROADCAST_INTERVAL</name> <init>= <expr><literal type="number">30</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** Average delay between trickled inventory transmissions in seconds.
 *  Blocks and whitelisted receivers bypass this, outbound peers get half this delay. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>INVENTORY_BROADCAST_INTERVAL</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** Maximum number of inventory items to send per transmission.
 *  Limits the impact of low-fee transaction floods. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>constexpr</specifier> <name>unsigned</name> <name>int</name></type> <name>INVENTORY_BROADCAST_MAX</name> <init>= <expr><literal type="number">7</literal> <operator>*</operator> <name>INVENTORY_BROADCAST_INTERVAL</name></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** Average delay between feefilter broadcasts in seconds. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>constexpr</specifier> <name>unsigned</name> <name>int</name></type> <name>AVG_FEEFILTER_BROADCAST_INTERVAL</name> <init>= <expr><literal type="number">10</literal> <operator>*</operator> <literal type="number">60</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** Maximum feefilter broadcast delay after significant change. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>constexpr</specifier> <name>unsigned</name> <name>int</name></type> <name>MAX_FEEFILTER_CHANGE_DELAY</name> <init>= <expr><literal type="number">5</literal> <operator>*</operator> <literal type="number">60</literal></expr></init></decl>;</decl_stmt>

<comment type="line">// Internal stuff</comment>
<namespace>namespace <block>{
    <comment type="block" format="doxygen">/** Number of nodes with fSyncStarted. */</comment>
    <function_decl><type><name>int</name> <name>nSyncStarted</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_main</name></type></decl></parameter>)</parameter_list> = <literal type="number">0</literal>;</function_decl>

    <comment type="block" format="doxygen">/**
     * Sources of received blocks, saved to be able punish them when processing
     * happens afterwards.
     * Set mapBlockSource[hash].second to false if the node should not be
     * punished if the block is invalid.
     */</comment>
    <function_decl><type><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>NodeId</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>mapBlockSource</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_main</name></type></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="block" format="doxygen">/**
     * Filter for transactions that were recently rejected by
     * AcceptToMemoryPool. These are not rerequested until the chain tip
     * changes, at which point the entire filter is reset.
     *
     * Without this filter we'd be re-requesting txs from each of our peers,
     * increasing bandwidth consumption considerably. For instance, with 100
     * peers, half of which relay a tx we don't accept, that might be a 50x
     * bandwidth increase. A flooding attacker attempting to roll-over the
     * filter using minimum-sized, 60byte, transactions might manage to send
     * 1000/sec if we have fast peers, so we pick 120,000 to give our peers a
     * two minute window to send invs to us.
     *
     * Decreasing the false positive rate is fairly cheap, so we pick one in a
     * million to make it highly unlikely for users to have issues with this
     * filter.
     *
     * Memory used: 1.3 MB
     */</comment>
    <function_decl><type><name><name>std</name><operator>::</operator><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CRollingBloomFilter</name></expr></argument>&gt;</argument_list></name> <name>recentRejects</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_main</name></type></decl></parameter>)</parameter_list>;</function_decl>
    <function_decl><type><name>uint256</name> <name>hashRecentRejectsChainTip</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_main</name></type></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="block" format="doxygen">/** Blocks that are in flight, and that are in the queue to be downloaded. */</comment>
    <struct>struct <name>QueuedBlock</name> <block>{<public type="default">
        <decl_stmt><decl><type><name>uint256</name></type> <name>hash</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>CBlockIndex</name><modifier>*</modifier></type> <name>pindex</name></decl>;</decl_stmt>                               <comment type="line" format="doxygen">//!&lt; Optional.</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>fValidatedHeaders</name></decl>;</decl_stmt>                                  <comment type="line" format="doxygen">//!&lt; Whether this block has validated headers at the time of request.</comment>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PartiallyDownloadedBlock</name></expr></argument>&gt;</argument_list></name></type> <name>partialBlock</name></decl>;</decl_stmt>  <comment type="line" format="doxygen">//!&lt; Optional, used for CMPCTBLOCK downloads</comment>
    </public>}</block>;</struct>
    <function_decl><type><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>NodeId</name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>list</name><argument_list type="generic">&lt;<argument><expr><name>QueuedBlock</name></expr></argument>&gt;</argument_list><operator>::</operator><name>iterator</name></name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name> <name>mapBlocksInFlight</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_main</name></type></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="block" format="doxygen">/** Stack of nodes which we have set to announce using compact blocks */</comment>
    <function_decl><type><name><name>std</name><operator>::</operator><name>list</name><argument_list type="generic">&lt;<argument><expr><name>NodeId</name></expr></argument>&gt;</argument_list></name> <name>lNodesAnnouncingHeaderAndIDs</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_main</name></type></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="block" format="doxygen">/** Number of preferable block download peers. */</comment>
    <function_decl><type><name>int</name> <name>nPreferredDownload</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_main</name></type></decl></parameter>)</parameter_list> = <literal type="number">0</literal>;</function_decl>

    <comment type="block" format="doxygen">/** Number of peers from which we're downloading blocks. */</comment>
    <function_decl><type><name>int</name> <name>nPeersWithValidatedDownloads</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_main</name></type></decl></parameter>)</parameter_list> = <literal type="number">0</literal>;</function_decl>

    <comment type="block" format="doxygen">/** Number of outbound peers with m_chain_sync.m_protect. */</comment>
    <function_decl><type><name>int</name> <name>g_outbound_peers_with_protect_from_disconnect</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_main</name></type></decl></parameter>)</parameter_list> = <literal type="number">0</literal>;</function_decl>

    <comment type="block" format="doxygen">/** When our tip was last updated. */</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>atomic</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name></type> <name>g_last_tip_update</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>

    <comment type="block" format="doxygen">/** Relay map */</comment>
    <typedef>typedef <type><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>, <argument><expr><name>CTransactionRef</name></expr></argument>&gt;</argument_list></name></type> <name>MapRelay</name>;</typedef>
    <function_decl><type><name>MapRelay</name> <name>mapRelay</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_main</name></type></decl></parameter>)</parameter_list>;</function_decl>
    <comment type="block" format="doxygen">/** Expiration-time ordered list of (expire time, relay map entry) pairs. */</comment>
    <function_decl><type><name><name>std</name><operator>::</operator><name>deque</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>, <argument><expr><name><name>MapRelay</name><operator>::</operator><name>iterator</name></name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>vRelayExpiration</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_main</name></type></decl></parameter>)</parameter_list>;</function_decl>

    <struct>struct <name>IteratorComparator</name>
    <block>{<public type="default">
        <function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>I</name></parameter>&gt;</parameter_list></template>
        <type><name>bool</name></type> <name>operator<name>()</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>I</name><modifier>&amp;</modifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>I</name><modifier>&amp;</modifier></type> <name>b</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
        <block>{<block_content>
            <return>return <expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>a</name><operator>)</operator> <operator>&lt;</operator> <operator>&amp;</operator><operator>(</operator><operator>*</operator><name>b</name><operator>)</operator></expr>;</return>
        </block_content>}</block></function>
    </public>}</block>;</struct>
    <function_decl><type><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>COutPoint</name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>, <argument><expr><name>COrphanTx</name></expr></argument>&gt;</argument_list><operator>::</operator><name>iterator</name></name></expr></argument>, <argument><expr><name>IteratorComparator</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>mapOrphanTransactionsByPrev</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>g_cs_orphans</name></type></decl></parameter>)</parameter_list>;</function_decl>

    <function_decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>, <argument><expr><name>COrphanTx</name></expr></argument>&gt;</argument_list><operator>::</operator><name>iterator</name></name></expr></argument>&gt;</argument_list></name> <name>g_orphan_list</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>g_cs_orphans</name></type></decl></parameter>)</parameter_list>;</function_decl> <comment type="line" format="doxygen">//! For random eviction</comment>

    <function_decl><type><specifier>static</specifier> <name>size_t</name> <name>vExtraTxnForCompactIt</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>g_cs_orphans</name></type></decl></parameter>)</parameter_list> = <literal type="number">0</literal>;</function_decl>
    <function_decl><type><specifier>static</specifier> <name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>, <argument><expr><name>CTransactionRef</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>vExtraTxnForCompact</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>g_cs_orphans</name></type></decl></parameter>)</parameter_list>;</function_decl>
}</block></namespace> <comment type="line">// namespace</comment>

<namespace>namespace <block>{
<comment type="block" format="doxygen">/**
 * Maintain validation-specific state about nodes, protected by cs_main, instead
 * by CNode's own locks. This simplifies asynchronous operation, where
 * processing of incoming data is done after the ProcessMessage call returns,
 * and we're no longer holding the node's locks.
 */</comment>
<struct>struct <name>CNodeState</name> <block>{<public type="default">
    <comment type="line" format="doxygen">//! The peer's address</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CService</name></type> <name>address</name></decl>;</decl_stmt>
    <comment type="line" format="doxygen">//! Whether we have a fully established connection.</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>fCurrentlyConnected</name></decl>;</decl_stmt>
    <comment type="line" format="doxygen">//! Accumulated misbehaviour score for this peer.</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nMisbehavior</name></decl>;</decl_stmt>
    <comment type="line" format="doxygen">//! Whether this peer should be disconnected and banned (unless whitelisted).</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>fShouldBan</name></decl>;</decl_stmt>
    <comment type="line" format="doxygen">//! String name of this peer (debugging/logging purposes).</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name></type> <name>name</name></decl>;</decl_stmt>
    <comment type="line" format="doxygen">//! The best known block we know this peer has announced.</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CBlockIndex</name> <modifier>*</modifier></type><name>pindexBestKnownBlock</name></decl>;</decl_stmt>
    <comment type="line" format="doxygen">//! The hash of the last unknown block this peer has announced.</comment>
    <decl_stmt><decl><type><name>uint256</name></type> <name>hashLastUnknownBlock</name></decl>;</decl_stmt>
    <comment type="line" format="doxygen">//! The last full block we both have.</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CBlockIndex</name> <modifier>*</modifier></type><name>pindexLastCommonBlock</name></decl>;</decl_stmt>
    <comment type="line" format="doxygen">//! The best header we have sent our peer.</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CBlockIndex</name> <modifier>*</modifier></type><name>pindexBestHeaderSent</name></decl>;</decl_stmt>
    <comment type="line" format="doxygen">//! Length of current-streak of unconnecting headers announcements</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nUnconnectingHeaders</name></decl>;</decl_stmt>
    <comment type="line" format="doxygen">//! Whether we've started headers synchronization with this peer.</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>fSyncStarted</name></decl>;</decl_stmt>
    <comment type="line" format="doxygen">//! When to potentially disconnect peer for stalling headers download</comment>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>nHeadersSyncTimeout</name></decl>;</decl_stmt>
    <comment type="line" format="doxygen">//! Since when we're stalling block download progress (in microseconds), or 0.</comment>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>nStallingSince</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>list</name><argument_list type="generic">&lt;<argument><expr><name>QueuedBlock</name></expr></argument>&gt;</argument_list></name></type> <name>vBlocksInFlight</name></decl>;</decl_stmt>
    <comment type="line" format="doxygen">//! When the first entry in vBlocksInFlight started downloading. Don't care when vBlocksInFlight is empty.</comment>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>nDownloadingSince</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nBlocksInFlight</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nBlocksInFlightValidHeaders</name></decl>;</decl_stmt>
    <comment type="line" format="doxygen">//! Whether we consider this a preferred download peer.</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>fPreferredDownload</name></decl>;</decl_stmt>
    <comment type="line" format="doxygen">//! Whether this peer wants invs or headers (when possible) for block announcements.</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>fPreferHeaders</name></decl>;</decl_stmt>
    <comment type="line" format="doxygen">//! Whether this peer wants invs or cmpctblocks (when possible) for block announcements.</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>fPreferHeaderAndIDs</name></decl>;</decl_stmt>
    <comment type="block" format="doxygen">/**
      * Whether this peer will send us cmpctblocks if we request them.
      * This is not used to gate request logic, as we really only care about fSupportsDesiredCmpctVersion,
      * but is used as a flag to "lock in" the version of compact blocks (fWantsCmpctWitness) we send.
      */</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>fProvidesHeaderAndIDs</name></decl>;</decl_stmt>
    <comment type="line" format="doxygen">//! Whether this peer can give us witnesses</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>fHaveWitness</name></decl>;</decl_stmt>
    <comment type="line" format="doxygen">//! Whether this peer wants witnesses in cmpctblocks/blocktxns</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>fWantsCmpctWitness</name></decl>;</decl_stmt>
    <comment type="block" format="doxygen">/**
     * If we've announced NODE_WITNESS to this peer: whether the peer sends witnesses in cmpctblocks/blocktxns,
     * otherwise: whether this peer sends non-witnesses in cmpctblocks/blocktxns.
     */</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>fSupportsDesiredCmpctVersion</name></decl>;</decl_stmt>

    <comment type="block" format="doxygen">/** State used to enforce CHAIN_SYNC_TIMEOUT
      * Only in effect for outbound, non-manual, full-relay connections, with
      * m_protect == false
      * Algorithm: if a peer's best known block has less work than our tip,
      * set a timeout CHAIN_SYNC_TIMEOUT seconds in the future:
      *   - If at timeout their best known block now has more work than our tip
      *     when the timeout was set, then either reset the timeout or clear it
      *     (after comparing against our current tip's work)
      *   - If at timeout their best known block still has less work than our
      *     tip did when the timeout was set, then send a getheaders message,
      *     and set a shorter timeout, HEADERS_RESPONSE_TIME seconds in future.
      *     If their best known block is still behind when that new timeout is
      *     reached, disconnect.
      */</comment>
    <struct>struct <name>ChainSyncTimeoutState</name> <block>{<public type="default">
        <comment type="line" format="doxygen">//! A timeout used for checking whether our peer has sufficiently synced</comment>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>m_timeout</name></decl>;</decl_stmt>
        <comment type="line" format="doxygen">//! A header with the work we require on our peer's chain</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>CBlockIndex</name> <modifier>*</modifier></type> <name>m_work_header</name></decl>;</decl_stmt>
        <comment type="line" format="doxygen">//! After timeout is reached, set to true after sending getheaders</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>m_sent_getheaders</name></decl>;</decl_stmt>
        <comment type="line" format="doxygen">//! Whether this peer is protected from disconnection due to a bad/slow chain</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>m_protect</name></decl>;</decl_stmt>
    </public>}</block>;</struct>

    <decl_stmt><decl><type><name>ChainSyncTimeoutState</name></type> <name>m_chain_sync</name></decl>;</decl_stmt>

    <comment type="line" format="doxygen">//! Time of last new block announcement</comment>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>m_last_block_announcement</name></decl>;</decl_stmt>

    <comment type="block">/*
     * State associated with transaction download.
     *
     * Tx download algorithm:
     *
     *   When inv comes in, queue up (process_time, txid) inside the peer's
     *   CNodeState (m_tx_process_time) as long as m_tx_announced for the peer
     *   isn't too big (MAX_PEER_TX_ANNOUNCEMENTS).
     *
     *   The process_time for a transaction is set to nNow for outbound peers,
     *   nNow + 2 seconds for inbound peers. This is the time at which we'll
     *   consider trying to request the transaction from the peer in
     *   SendMessages(). The delay for inbound peers is to allow outbound peers
     *   a chance to announce before we request from inbound peers, to prevent
     *   an adversary from using inbound connections to blind us to a
     *   transaction (InvBlock).
     *
     *   When we call SendMessages() for a given peer,
     *   we will loop over the transactions in m_tx_process_time, looking
     *   at the transactions whose process_time &lt;= nNow. We'll request each
     *   such transaction that we don't have already and that hasn't been
     *   requested from another peer recently, up until we hit the
     *   MAX_PEER_TX_IN_FLIGHT limit for the peer. Then we'll update
     *   g_already_asked_for for each requested txid, storing the time of the
     *   GETDATA request. We use g_already_asked_for to coordinate transaction
     *   requests amongst our peers.
     *
     *   For transactions that we still need but we have already recently
     *   requested from some other peer, we'll reinsert (process_time, txid)
     *   back into the peer's m_tx_process_time at the point in the future at
     *   which the most recent GETDATA request would time out (ie
     *   GETDATA_TX_INTERVAL + the request time stored in g_already_asked_for).
     *   We add an additional delay for inbound peers, again to prefer
     *   attempting download from outbound peers first.
     *   We also add an extra small random delay up to 2 seconds
     *   to avoid biasing some peers over others. (e.g., due to fixed ordering
     *   of peer processing in ThreadMessageHandler).
     *
     *   When we receive a transaction from a peer, we remove the txid from the
     *   peer's m_tx_in_flight set and from their recently announced set
     *   (m_tx_announced).  We also clear g_already_asked_for for that entry, so
     *   that if somehow the transaction is not accepted but also not added to
     *   the reject filter, then we will eventually redownload from other
     *   peers.
     */</comment>
    <struct>struct <name>TxDownloadState</name> <block>{<public type="default">
        <comment type="block">/* Track when to attempt download of announced transactions (process
         * time in micros -&gt; txid)
         */</comment>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>multimap</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>microseconds</name></name></expr></argument>, <argument><expr><name>uint256</name></expr></argument>&gt;</argument_list></name></type> <name>m_tx_process_time</name></decl>;</decl_stmt>

        <comment type="line" format="doxygen">//! Store all the transactions a peer has recently announced</comment>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>&gt;</argument_list></name></type> <name>m_tx_announced</name></decl>;</decl_stmt>

        <comment type="line" format="doxygen">//! Store transactions which were requested by us, with timestamp</comment>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>microseconds</name></name></expr></argument>&gt;</argument_list></name></type> <name>m_tx_in_flight</name></decl>;</decl_stmt>

        <comment type="line" format="doxygen">//! Periodically check for stuck getdata requests</comment>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>microseconds</name></name></type> <name>m_check_expiry_timer</name><argument_list>{<argument><expr><literal type="number">0</literal></expr></argument>}</argument_list></decl>;</decl_stmt>
    </public>}</block>;</struct>

    <decl_stmt><decl><type><name>TxDownloadState</name></type> <name>m_tx_download</name></decl>;</decl_stmt>

    <comment type="line" format="doxygen">//! Whether this peer is an inbound connection</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>m_is_inbound</name></decl>;</decl_stmt>

    <comment type="line" format="doxygen">//! Whether this peer is a manual connection</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>m_is_manual_connection</name></decl>;</decl_stmt>

    <macro><name>CNodeState</name><argument_list>(<argument>CAddress addrIn</argument>, <argument>std::string addrNameIn</argument>, <argument>bool is_inbound</argument>, <argument>bool is_manual</argument>)</argument_list></macro> :
        <macro><name>address</name><argument_list>(<argument>addrIn</argument>)</argument_list></macro><operator>,</operator> <macro><name>name</name><argument_list>(<argument>std::move(addrNameIn)</argument>)</argument_list></macro><operator>,</operator> <macro><name>m_is_inbound</name><argument_list>(<argument>is_inbound</argument>)</argument_list></macro><operator>,</operator>
        <macro><name>m_is_manual_connection</name> <argument_list>(<argument>is_manual</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>fCurrentlyConnected</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>nMisbehavior</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>fShouldBan</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>pindexBestKnownBlock</name> <operator>=</operator> <literal type="null">nullptr</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>hashLastUnknownBlock</name><operator>.</operator><name>SetNull</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pindexLastCommonBlock</name> <operator>=</operator> <literal type="null">nullptr</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>pindexBestHeaderSent</name> <operator>=</operator> <literal type="null">nullptr</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>nUnconnectingHeaders</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>fSyncStarted</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>nHeadersSyncTimeout</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>nStallingSince</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>nDownloadingSince</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>nBlocksInFlight</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>nBlocksInFlightValidHeaders</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>fPreferredDownload</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>fPreferHeaders</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>fPreferHeaderAndIDs</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>fProvidesHeaderAndIDs</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>fHaveWitness</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>fWantsCmpctWitness</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>fSupportsDesiredCmpctVersion</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>m_chain_sync</name> <operator>=</operator> <block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="null">nullptr</literal></expr>, <expr><literal type="boolean">false</literal></expr>, <expr><literal type="boolean">false</literal></expr> }</block></expr>;</expr_stmt>
        <expr_stmt><expr><name>m_last_block_announcement</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block>
</public>}</block>;</struct>

<comment type="line">// Keeps track of the time (in microseconds) when transactions were requested last time</comment>
<function_decl><type><name><name>limitedmap</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>microseconds</name></name></expr></argument>&gt;</argument_list></name> <name>g_already_asked_for</name> <name>GUARDED_BY</name></type>(<name>cs_main</name>)<parameter_list>(<parameter><decl><type><name>MAX_INV_SZ</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/** Map maintaining per-node state. */</comment>
<function_decl><type><specifier>static</specifier> <name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>NodeId</name></expr></argument>, <argument><expr><name>CNodeState</name></expr></argument>&gt;</argument_list></name> <name>mapNodeState</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_main</name></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>CNodeState</name> <modifier>*</modifier></type><name>State</name><argument_list>(<argument><expr><name>NodeId</name> <name>pnode</name></expr></argument>)</argument_list> <name>EXCLUSIVE_LOCKS_REQUIRED</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list> <argument_list>{
    <argument><expr><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>NodeId</name></expr></argument>, <argument><expr><name>CNodeState</name></expr></argument>&gt;</argument_list><operator>::</operator><name>iterator</name></name> <name>it</name> <operator>=</operator> <call><name><name>mapNodeState</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>pnode</name></expr></argument>)</argument_list></call></expr></argument>;
    if <argument><expr><operator>(</operator><name>it</name> <operator>==</operator> <call><name><name>mapNodeState</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>
        <return>return <expr><literal type="null">nullptr</literal></expr>;</return></argument_list></decl></decl_stmt>
    <return>return <expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>second</name></name></expr>;</return>
}</block></namespace>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>UpdatePreferredDownload</name><argument_list>(<argument><expr><name>CNode</name><operator>*</operator> <name>node</name></expr></argument>, <argument><expr><name>CNodeState</name><operator>*</operator> <name>state</name></expr></argument>)</argument_list> <name>EXCLUSIVE_LOCKS_REQUIRED</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list>
<argument_list>{
    <argument><expr><name>nPreferredDownload</name> <operator>-=</operator> <name><name>state</name><operator>-&gt;</operator><name>fPreferredDownload</name></name></expr></argument>;

    <comment type="line">// Whether this node should be marked as a preferred download node.</comment>
    <argument><expr><name><name>state</name><operator>-&gt;</operator><name>fPreferredDownload</name></name> <operator>=</operator> <operator>(</operator><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>fInbound</name></name> <operator>||</operator> <call><name><name>node</name><operator>-&gt;</operator><name>HasPermission</name></name><argument_list>(<argument><expr><name>PF_NOBAN</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>fOneShot</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>fClient</name></name></expr></argument>;

    <argument><expr><name>nPreferredDownload</name> <operator>+=</operator> <name><name>state</name><operator>-&gt;</operator><name>fPreferredDownload</name></name></expr></argument>;
}</argument_list>

static <name>void</name> <name>PushNodeVersion</name><argument_list>(<argument><expr><name>CNode</name> <operator>*</operator><name>pnode</name></expr></argument>, <argument><expr><name>CConnman</name><operator>*</operator> <name>connman</name></expr></argument>, <argument><expr><name>int64_t</name> <name>nTime</name></expr></argument>)</argument_list>
<argument_list>{
    <comment type="line">// Note that pnode-&gt;GetLocalServices() is a reflection of the local</comment>
    <comment type="line">// services we were offering when the CNode object was created for this</comment>
    <comment type="line">// peer.</comment>
    <argument><expr><name>ServiceFlags</name> <name>nLocalNodeServices</name> <operator>=</operator> <call><name><name>pnode</name><operator>-&gt;</operator><name>GetLocalServices</name></name><argument_list>()</argument_list></call></expr></argument>;
    <argument><expr><name>uint64_t</name> <name>nonce</name> <operator>=</operator> <call><name><name>pnode</name><operator>-&gt;</operator><name>GetLocalNonce</name></name><argument_list>()</argument_list></call></expr></argument>;
    <argument><expr><name>int</name> <name>nNodeStartingHeight</name> <operator>=</operator> <call><name><name>pnode</name><operator>-&gt;</operator><name>GetMyStartingHeight</name></name><argument_list>()</argument_list></call></expr></argument>;
    <argument><expr><name>NodeId</name> <name>nodeid</name> <operator>=</operator> <call><name><name>pnode</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>;
    <argument><expr><name>CAddress</name> <name>addr</name> <operator>=</operator> <name><name>pnode</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>;

    <argument><expr><name>CAddress</name> <name>addrYou</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><call><name><name>addr</name><operator>.</operator><name>IsRoutable</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsProxy</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>addr</name></expr> </then><else>: <expr><call><name>CAddress</name><argument_list>(<argument><expr><call><name>CService</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>nServices</name></name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>;
    <argument><expr><name>CAddress</name> <name>addrMe</name> <operator>=</operator> <call><name>CAddress</name><argument_list>(<argument><expr><call><name>CService</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nLocalNodeServices</name></expr></argument>)</argument_list></call></expr></argument>;

    <argument><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pnode</name></expr></argument>, <argument><expr><call><name>CNetMsgMaker</name><argument_list>(<argument><expr><name>INIT_PROTO_VERSION</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>Make</name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>VERSION</name></name></expr></argument>, <argument><expr><name>PROTOCOL_VERSION</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name>nLocalNodeServices</name></expr></argument>, <argument><expr><name>nTime</name></expr></argument>, <argument><expr><name>addrYou</name></expr></argument>, <argument><expr><name>addrMe</name></expr></argument>,
            <argument><expr><name>nonce</name></expr></argument>, <argument><expr><name>strSubVersion</name></expr></argument>, <argument><expr><name>nNodeStartingHeight</name></expr></argument>, <argument><expr><name><operator>::</operator><name>g_relay_txes</name></name> <operator>&amp;&amp;</operator> <name><name>pnode</name><operator>-&gt;</operator><name>m_tx_relay</name></name> <operator>!=</operator> <literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>;

    if <argument><expr><operator>(</operator><name>fLogIPs</name><operator>)</operator> <block>{
        <expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"send version message: version %d, blocks=%d, us=%s, them=%s, peer=%d\n"</literal></expr></argument>, <argument><expr><name>PROTOCOL_VERSION</name></expr></argument>, <argument><expr><name>nNodeStartingHeight</name></expr></argument>, <argument><expr><call><name><name>addrMe</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>addrYou</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;
    }</block></expr></argument> <if_stmt><else>else <expr_stmt><expr><block>{
        <expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"send version message: version %d, blocks=%d, us=%s, peer=%d\n"</literal></expr></argument>, <argument><expr><name>PROTOCOL_VERSION</name></expr></argument>, <argument><expr><name>nNodeStartingHeight</name></expr></argument>, <argument><expr><call><name><name>addrMe</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;
    }</block>
}

<comment type="line">// Returns a bool indicating whether we requested this block.</comment>
<comment type="line">// Also used if a block was /not/ received and timed out or started with another peer</comment>
<specifier>static</specifier> <name>bool</name> <macro><name>MarkBlockAsReceived</name><argument_list>(<argument>const uint256&amp; hash</argument>)</argument_list></macro> <macro><name>EXCLUSIVE_LOCKS_REQUIRED</name><argument_list>(<argument>cs_main</argument>)</argument_list></macro> <block>{
    <expr><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>NodeId</name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>list</name><argument_list type="generic">&lt;<argument><expr><name>QueuedBlock</name></expr></argument>&gt;</argument_list><operator>::</operator><name>iterator</name></name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list><operator>::</operator><name>iterator</name></name> <name>itInFlight</name> <operator>=</operator> <call><name><name>mapBlocksInFlight</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</block></expr></expr_stmt></else></if_stmt></argument_list></decl></decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>itInFlight</name> <operator>!=</operator> <call><name><name>mapBlocksInFlight</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>CNodeState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><call><name>State</name><argument_list>(<argument><expr><name><name>itInFlight</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>first</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>state</name> <operator>!=</operator> <literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nBlocksInFlightValidHeaders</name></name> <operator>-=</operator> <name><name>itInFlight</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>second</name><operator>-&gt;</operator><name>fValidatedHeaders</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>nBlocksInFlightValidHeaders</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>itInFlight</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>second</name><operator>-&gt;</operator><name>fValidatedHeaders</name></name></expr>)</condition> <block>{<block_content>
            <comment type="line">// Last validated block on the queue was received.</comment>
            <expr_stmt><expr><name>nPeersWithValidatedDownloads</name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>state</name><operator>-&gt;</operator><name>vBlocksInFlight</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>itInFlight</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>second</name></name></expr>)</condition> <block>{<block_content>
            <comment type="line">// First block on the queue was received, update the start download time for the next one</comment>
            <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nDownloadingSince</name></name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>max</name></name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>nDownloadingSince</name></name></expr></argument>, <argument><expr><call><name>GetTimeMicros</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>state</name><operator>-&gt;</operator><name>vBlocksInFlight</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name><name>itInFlight</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>second</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nBlocksInFlight</name></name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nStallingSince</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mapBlocksInFlight</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>itInFlight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
}

<comment type="line">// returns false, still setting pit, if the block was already in flight from the same peer</comment>
<comment type="line">// pit will only be valid as long as the same cs_main lock is being held</comment>
static <decl_stmt><decl><type><name>bool</name></type> <name>MarkBlockAsInFlight</name><argument_list>(<argument><expr><name>NodeId</name> <name>nodeid</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>uint256</name><operator>&amp;</operator> <name>hash</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CBlockIndex</name><operator>*</operator> <name>pindex</name> <operator>=</operator> <literal type="null">nullptr</literal></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>list</name><argument_list type="generic">&lt;<argument><expr><name>QueuedBlock</name></expr></argument>&gt;</argument_list><operator>::</operator><name>iterator</name></name><operator>*</operator><operator>*</operator> <name>pit</name> <operator>=</operator> <literal type="null">nullptr</literal></expr></argument>)</argument_list> <name>EXCLUSIVE_LOCKS_REQUIRED</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list> <argument_list>{
    <argument><expr><name>CNodeState</name> <operator>*</operator><name>state</name> <operator>=</operator> <call><name>State</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr></argument>;
    <argument><expr><call><name>assert</name><argument_list>(<argument><expr><name>state</name> <operator>!=</operator> <literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr></argument>;

    <comment type="line">// Short-circuit most stuff in case it is from the same node</comment>
    <argument><expr><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>NodeId</name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>list</name><argument_list type="generic">&lt;<argument><expr><name>QueuedBlock</name></expr></argument>&gt;</argument_list><operator>::</operator><name>iterator</name></name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list><operator>::</operator><name>iterator</name></name> <name>itInFlight</name> <operator>=</operator> <call><name><name>mapBlocksInFlight</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>;
    if <argument><expr><operator>(</operator><name>itInFlight</name> <operator>!=</operator> <call><name><name>mapBlocksInFlight</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>itInFlight</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>first</name></name> <operator>==</operator> <name>nodeid</name><operator>)</operator> <block>{
        <if_stmt><if>if <condition>(<expr><name>pit</name></expr>)</condition> <expr_stmt><expr><block>{
            <expr><operator>*</operator><name>pit</name> <operator>=</operator> <operator>&amp;</operator><name><name>itInFlight</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>second</name></name></expr>;
        }</block></expr></expr_stmt></if></if_stmt>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    }</block>

    <comment type="line">// Make sure it's not listed somewhere already.</comment>
    <call><name>MarkBlockAsReceived</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>;

    <argument><expr><name><name>std</name><operator>::</operator><name>list</name><argument_list type="generic">&lt;<argument><expr><name>QueuedBlock</name></expr></argument>&gt;</argument_list><operator>::</operator><name>iterator</name></name> <name>it</name> <operator>=</operator> <call><name><name>state</name><operator>-&gt;</operator><name>vBlocksInFlight</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>state</name><operator>-&gt;</operator><name>vBlocksInFlight</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>,
            <argument><expr><block>{<expr><name>hash</name></expr>, <expr><name>pindex</name></expr>, <expr><name>pindex</name> <operator>!=</operator> <literal type="null">nullptr</literal></expr>, <macro><name>std</name></macro><expr><name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PartiallyDownloadedBlock</name></expr></argument>&gt;</argument_list></name></name><operator>(</operator><ternary><condition><expr><name>pit</name></expr> ?</condition><then> <expr><operator>new</operator> <call><name>PartiallyDownloadedBlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mempool</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="null">nullptr</literal></expr></else></ternary><operator>)</operator></expr>}</block></expr></argument>)</argument_list></call></expr></argument>;
    <argument><expr><name><name>state</name><operator>-&gt;</operator><name>nBlocksInFlight</name></name><operator>++</operator></expr></argument>;
    <argument><expr><name><name>state</name><operator>-&gt;</operator><name>nBlocksInFlightValidHeaders</name></name> <operator>+=</operator> <name><name>it</name><operator>-&gt;</operator><name>fValidatedHeaders</name></name></expr></argument>;
    if <argument><expr><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>nBlocksInFlight</name></name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator> <block>{
        <comment type="line">// We're starting a block download (batch) from this peer.</comment>
        <expr><name><name>state</name><operator>-&gt;</operator><name>nDownloadingSince</name></name> <operator>=</operator> <call><name>GetTimeMicros</name><argument_list>()</argument_list></call></expr>;
    }</block></expr></argument>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>nBlocksInFlightValidHeaders</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>pindex</name> <operator>!=</operator> <literal type="null">nullptr</literal></expr>)</condition> <expr_stmt><expr><block>{
        <expr><name>nPeersWithValidatedDownloads</name><operator>++</operator></expr>;
    }</block>
    <name>itInFlight</name> <operator>=</operator> <call><name><name>mapBlocksInFlight</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>, <argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><name>first</name></expr>;</expr_stmt></if></if_stmt></argument_list></decl></decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>pit</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>pit</name> <operator>=</operator> <operator>&amp;</operator><name><name>itInFlight</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>second</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
}

<comment type="block" format="doxygen">/** Check whether the last unknown block a peer advertised is not yet known. */</comment>
static <decl_stmt><decl><type><name>void</name></type> <name>ProcessBlockAvailability</name><argument_list>(<argument><expr><name>NodeId</name> <name>nodeid</name></expr></argument>)</argument_list> <name>EXCLUSIVE_LOCKS_REQUIRED</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list> <argument_list>{
    <argument><expr><name>CNodeState</name> <operator>*</operator><name>state</name> <operator>=</operator> <call><name>State</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr></argument>;
    <argument><expr><call><name>assert</name><argument_list>(<argument><expr><name>state</name> <operator>!=</operator> <literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr></argument>;

    if <argument><expr><operator>(</operator><operator>!</operator><call><name><name>state</name><operator>-&gt;</operator><name>hashLastUnknownBlock</name><operator>.</operator><name>IsNull</name></name><argument_list>()</argument_list></call><operator>)</operator> <block>{
        <expr><specifier>const</specifier> <name>CBlockIndex</name><operator>*</operator> <name>pindex</name> <operator>=</operator> <call><name>LookupBlockIndex</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>hashLastUnknownBlock</name></name></expr></argument>)</argument_list></call></expr>;
        <if_stmt><if>if <condition>(<expr><name>pindex</name> <operator>&amp;&amp;</operator> <name><name>pindex</name><operator>-&gt;</operator><name>nChainWork</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <expr_stmt><expr><block>{
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>pindexBestKnownBlock</name></name> <operator>==</operator> <literal type="null">nullptr</literal> <operator>||</operator> <name><name>pindex</name><operator>-&gt;</operator><name>nChainWork</name></name> <operator>&gt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>pindexBestKnownBlock</name><operator>-&gt;</operator><name>nChainWork</name></name></expr>)</condition> <expr_stmt><expr><block>{
                <expr><name><name>state</name><operator>-&gt;</operator><name>pindexBestKnownBlock</name></name> <operator>=</operator> <name>pindex</name></expr>;
            }</block>
            <call><name><name>state</name><operator>-&gt;</operator><name>hashLastUnknownBlock</name><operator>.</operator><name>SetNull</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></if></if_stmt>
        }</block>
    }
}

<comment type="block" format="doxygen">/** Update tracking information about which blocks a peer is assumed to have. */</comment>
<specifier>static</specifier> <name>void</name> <macro><name>UpdateBlockAvailability</name><argument_list>(<argument>NodeId nodeid</argument>, <argument>const uint256 &amp;hash</argument>)</argument_list></macro> <macro><name>EXCLUSIVE_LOCKS_REQUIRED</name><argument_list>(<argument>cs_main</argument>)</argument_list></macro> <block>{
    <expr><name>CNodeState</name> <operator>*</operator><name>state</name> <operator>=</operator> <call><name>State</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;
    <call><name>assert</name><argument_list>(<argument><expr><name>state</name> <operator>!=</operator> <literal type="null">nullptr</literal></expr></argument>)</argument_list></call></block></expr>;</expr_stmt></if></if_stmt>

    <call><name>ProcessBlockAvailability</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></block></expr></argument>;

    <argument><expr><specifier>const</specifier> <name>CBlockIndex</name><operator>*</operator> <name>pindex</name> <operator>=</operator> <call><name>LookupBlockIndex</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>;
    if <argument><expr><operator>(</operator><name>pindex</name> <operator>&amp;&amp;</operator> <name><name>pindex</name><operator>-&gt;</operator><name>nChainWork</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <block>{
        <comment type="line">// An actually better block was announced.</comment>
        <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>pindexBestKnownBlock</name></name> <operator>==</operator> <literal type="null">nullptr</literal> <operator>||</operator> <name><name>pindex</name><operator>-&gt;</operator><name>nChainWork</name></name> <operator>&gt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>pindexBestKnownBlock</name><operator>-&gt;</operator><name>nChainWork</name></name></expr>)</condition> <expr_stmt><expr><block>{
            <expr><name><name>state</name><operator>-&gt;</operator><name>pindexBestKnownBlock</name></name> <operator>=</operator> <name>pindex</name></expr>;
        }</block>
    }</expr></expr_stmt></if> <else>else <expr_stmt><expr><block>{
        <comment type="line">// An unknown block was announced; just assume that the latest one is the best one.</comment>
        <expr><name><name>state</name><operator>-&gt;</operator><name>hashLastUnknownBlock</name></name> <operator>=</operator> <name>hash</name></expr>;
    }</block>
}

<comment type="block" format="doxygen">/**
 * When a peer sends us a valid block, instruct it to announce blocks to us
 * using CMPCTBLOCK if possible by adding its nodeid to the end of
 * lNodesAnnouncingHeaderAndIDs, and keeping that list under a certain size by
 * removing the first element if necessary.
 */</comment>
<specifier>static</specifier> <name>void</name> <macro><name>MaybeSetPeerAsAnnouncingHeaderAndIDs</name><argument_list>(<argument>NodeId nodeid</argument>, <argument>CConnman* connman</argument>)</argument_list></macro> <macro><name>EXCLUSIVE_LOCKS_REQUIRED</name><argument_list>(<argument>cs_main</argument>)</argument_list></macro>
<block>{
    <expr><call><name>AssertLockHeld</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;
    <name>CNodeState</name><operator>*</operator> <name>nodestate</name> <operator>=</operator> <call><name>State</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt></else></if_stmt></block></expr></argument>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>nodestate</name> <operator>||</operator> <operator>!</operator><name><name>nodestate</name><operator>-&gt;</operator><name>fSupportsDesiredCmpctVersion</name></name></expr>)</condition> <expr_stmt><expr><block>{
        <comment type="line">// Never ask from peers who can't provide witnesses.</comment>
        <return>return;</return>
    }</block></expr></expr_stmt></if></if_stmt></argument_list></decl></decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>nodestate</name><operator>-&gt;</operator><name>fProvidesHeaderAndIDs</name></name></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><decl><type><name><name>std</name><operator>::</operator><name>list</name><argument_list type="generic">&lt;<argument><expr><name>NodeId</name></expr></argument>&gt;</argument_list><operator>::</operator><name>iterator</name></name></type> <name>it</name> <init>= <expr><call><name><name>lNodesAnnouncingHeaderAndIDs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>it</name> <operator>!=</operator> <call><name><name>lNodesAnnouncingHeaderAndIDs</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>it</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>it</name> <operator>==</operator> <name>nodeid</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>lNodesAnnouncingHeaderAndIDs</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>lNodesAnnouncingHeaderAndIDs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>ForNode</name></name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>, <argument><expr><lambda><capture>[<argument><name>connman</name></argument>]</capture><parameter_list>(<parameter><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pfrom</name></decl></parameter>)</parameter_list><block>{<block_content>
            <expr_stmt><expr><call><name>AssertLockHeld</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>uint64_t</name> <name>nCMPCTBLOCKVersion</name> = (<name><name>pfrom</name><operator>-&gt;</operator><name>GetLocalServices</name></name>(</type></decl>) &amp; NODE_WITNESS</decl_stmt>)</block_content> ? 2 : 1</block></lambda></expr></argument>;</argument_list></call></expr></expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>lNodesAnnouncingHeaderAndIDs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
                <comment type="line">// As per BIP152, we only get 3 of our peers to announce</comment>
                <comment type="line">// blocks using compact encodings.</comment>
                <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>ForNode</name></name><argument_list>(<argument><expr><call><name><name>lNodesAnnouncingHeaderAndIDs</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><lambda><capture>[<argument><name>connman</name></argument>, <argument><name>nCMPCTBLOCKVersion</name></argument>]</capture><parameter_list>(<parameter><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnodeStop</name></decl></parameter>)</parameter_list><block>{<block_content>
                    <expr_stmt><expr><call><name>AssertLockHeld</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pnodeStop</name></expr></argument>, <argument><expr><call><name>CNetMsgMaker</name><argument_list>(<argument><expr><call><name><name>pnodeStop</name><operator>-&gt;</operator><name>GetSendVersion</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>Make</name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>SENDCMPCT</name></name></expr></argument>, <comment type="block">/*fAnnounceUsingCMPCTBLOCK=*/</comment><argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name>nCMPCTBLOCKVersion</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>lNodesAnnouncingHeaderAndIDs</name><operator>.</operator><name>pop_front</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name>CNetMsgMaker</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetSendVersion</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>Make</name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>SENDCMPCT</name></name></expr></argument>, <comment type="block">/*fAnnounceUsingCMPCTBLOCK=*/</comment><argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><name>nCMPCTBLOCKVersion</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>lNodesAnnouncingHeaderAndIDs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>)<empty_stmt>;</empty_stmt>
    }
}

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>TipMayBeStale</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>Consensus</name><operator>::</operator><name>Params</name></name> <operator>&amp;</operator><name>consensusParams</name></expr></argument>)</argument_list> <name>EXCLUSIVE_LOCKS_REQUIRED</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list>
<argument_list>{
    <argument><expr><call><name>AssertLockHeld</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr></argument>;
    if <argument><expr><operator>(</operator><name>g_last_tip_update</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <block>{
        <expr><name>g_last_tip_update</name> <operator>=</operator> <call><name>GetTime</name><argument_list>()</argument_list></call></expr>;
    }</block></expr></argument>
    <return>return <expr><name>g_last_tip_update</name> <operator>&lt;</operator> <call><name>GetTime</name><argument_list>()</argument_list></call> <operator>-</operator> <name><name>consensusParams</name><operator>.</operator><name>nPowTargetSpacing</name></name> <operator>*</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name><name>mapBlocksInFlight</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return></argument_list></decl></decl_stmt>
}

static <decl_stmt><decl><type><name>bool</name></type> <name>CanDirectFetch</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>Consensus</name><operator>::</operator><name>Params</name></name> <operator>&amp;</operator><name>consensusParams</name></expr></argument>)</argument_list> <name>EXCLUSIVE_LOCKS_REQUIRED</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list>
<argument_list>{
    return <argument><expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Tip</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>GetBlockTime</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <call><name>GetAdjustedTime</name><argument_list>()</argument_list></call> <operator>-</operator> <name><name>consensusParams</name><operator>.</operator><name>nPowTargetSpacing</name></name> <operator>*</operator> <literal type="number">20</literal></expr></argument>;
}</argument_list>

static <name>bool</name> <name>PeerHasHeader</name><argument_list>(<argument><expr><name>CNodeState</name> <operator>*</operator><name>state</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CBlockIndex</name> <operator>*</operator><name>pindex</name></expr></argument>)</argument_list> <name>EXCLUSIVE_LOCKS_REQUIRED</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list>
<argument_list>{
    if <argument><expr><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>pindexBestKnownBlock</name></name> <operator>&amp;&amp;</operator> <name>pindex</name> <operator>==</operator> <call><name><name>state</name><operator>-&gt;</operator><name>pindexBestKnownBlock</name><operator>-&gt;</operator><name>GetAncestor</name></name><argument_list>(<argument><expr><name><name>pindex</name><operator>-&gt;</operator><name>nHeight</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return></argument_list></decl></decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>pindexBestHeaderSent</name></name> <operator>&amp;&amp;</operator> <name>pindex</name> <operator>==</operator> <call><name><name>state</name><operator>-&gt;</operator><name>pindexBestHeaderSent</name><operator>-&gt;</operator><name>GetAncestor</name></name><argument_list>(<argument><expr><name><name>pindex</name><operator>-&gt;</operator><name>nHeight</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
}

<comment type="block" format="doxygen">/** Update pindexLastCommonBlock and add not-in-flight missing successors to vBlocks, until it has
 *  at most count entries. */</comment>
static <decl_stmt><decl><type><name>void</name></type> <name>FindNextBlocksToDownload</name><argument_list>(<argument><expr><name>NodeId</name> <name>nodeid</name></expr></argument>, <argument><expr><name>unsigned</name> <name>int</name> <name>count</name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CBlockIndex</name><operator>*</operator></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>vBlocks</name></expr></argument>, <argument><expr><name>NodeId</name><operator>&amp;</operator> <name>nodeStaller</name></expr></argument>, <argument><expr><specifier>const</specifier> <name><name>Consensus</name><operator>::</operator><name>Params</name></name><operator>&amp;</operator> <name>consensusParams</name></expr></argument>)</argument_list> <name>EXCLUSIVE_LOCKS_REQUIRED</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list>
<argument_list>{
    if <argument><expr><operator>(</operator><name>count</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>
        <return>return;</return></argument_list></decl></decl_stmt>

    <expr_stmt><expr><call><name><name>vBlocks</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>vBlocks</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>CNodeState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><call><name>State</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>state</name> <operator>!=</operator> <literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Make sure pindexBestKnownBlock is up to date, we'll need it.</comment>
    <expr_stmt><expr><call><name>ProcessBlockAvailability</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>pindexBestKnownBlock</name></name> <operator>==</operator> <literal type="null">nullptr</literal> <operator>||</operator> <name><name>state</name><operator>-&gt;</operator><name>pindexBestKnownBlock</name><operator>-&gt;</operator><name>nChainWork</name></name> <operator>&lt;</operator> <call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Tip</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>nChainWork</name> <operator>||</operator> <name><name>state</name><operator>-&gt;</operator><name>pindexBestKnownBlock</name><operator>-&gt;</operator><name>nChainWork</name></name> <operator>&lt;</operator> <name>nMinimumChainWork</name></expr>)</condition> <block>{<block_content>
        <comment type="line">// This peer has nothing interesting.</comment>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>pindexLastCommonBlock</name></name> <operator>==</operator> <literal type="null">nullptr</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// Bootstrap quickly by guessing a parent of our best tip is the forking point.</comment>
        <comment type="line">// Guessing wrong in either direction is not a problem.</comment>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>pindexLastCommonBlock</name></name> <operator>=</operator> <call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><index>[<expr><call><name><name>std</name><operator>::</operator><name>min</name></name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>pindexBestKnownBlock</name><operator>-&gt;</operator><name>nHeight</name></name></expr></argument>, <argument><expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Height</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>]</index></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// If the peer reorganized, our previous pindexLastCommonBlock may not be an ancestor</comment>
    <comment type="line">// of its current tip anymore. Go back enough to fix that.</comment>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>pindexLastCommonBlock</name></name> <operator>=</operator> <call><name>LastCommonAncestor</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>pindexLastCommonBlock</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>pindexBestKnownBlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>pindexLastCommonBlock</name></name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>pindexBestKnownBlock</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CBlockIndex</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>vToFetch</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CBlockIndex</name> <modifier>*</modifier></type><name>pindexWalk</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>pindexLastCommonBlock</name></name></expr></init></decl>;</decl_stmt>
    <comment type="line">// Never fetch further than the best block we know the peer has, or more than BLOCK_DOWNLOAD_WINDOW + 1 beyond the last</comment>
    <comment type="line">// linked block we have in common with this peer. The +1 is so we can detect stalling, namely if we would be able to</comment>
    <comment type="line">// download that next block if the window were 1 larger.</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nWindowEnd</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>pindexLastCommonBlock</name><operator>-&gt;</operator><name>nHeight</name></name> <operator>+</operator> <name>BLOCK_DOWNLOAD_WINDOW</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nMaxHeight</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>min</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>pindexBestKnownBlock</name><operator>-&gt;</operator><name>nHeight</name></name></expr></argument>, <argument><expr><name>nWindowEnd</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NodeId</name></type> <name>waitingfor</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name><name>pindexWalk</name><operator>-&gt;</operator><name>nHeight</name></name> <operator>&lt;</operator> <name>nMaxHeight</name></expr>)</condition> <block>{<block_content>
        <comment type="line">// Read up to 128 (or more, if more blocks than that are needed) successors of pindexWalk (towards</comment>
        <comment type="line">// pindexBestKnownBlock) into vToFetch. We fetch 128, because CBlockIndex::GetAncestor may be as expensive</comment>
        <comment type="line">// as iterating over ~100 CBlockIndex* entries anyway.</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>nToFetch</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>min</name></name><argument_list>(<argument><expr><name>nMaxHeight</name> <operator>-</operator> <name><name>pindexWalk</name><operator>-&gt;</operator><name>nHeight</name></name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>max</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>count</name> <operator>-</operator> <call><name><name>vBlocks</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>vToFetch</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><name>nToFetch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pindexWalk</name> <operator>=</operator> <call><name><name>state</name><operator>-&gt;</operator><name>pindexBestKnownBlock</name><operator>-&gt;</operator><name>GetAncestor</name></name><argument_list>(<argument><expr><name><name>pindexWalk</name><operator>-&gt;</operator><name>nHeight</name></name> <operator>+</operator> <name>nToFetch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>vToFetch</name><index>[<expr><name>nToFetch</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>pindexWalk</name></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><name>nToFetch</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><name><name>vToFetch</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>vToFetch</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>pprev</name></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="line">// Iterate over those blocks in vToFetch (in forward direction), adding the ones that</comment>
        <comment type="line">// are not yet downloaded and not in flight to vBlocks. In the meantime, update</comment>
        <comment type="line">// pindexLastCommonBlock as long as all ancestors are already downloaded, or if it's</comment>
        <comment type="line">// already part of our chain (and therefore don't need it even if pruned).</comment>
        <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CBlockIndex</name><modifier>*</modifier></type> <name>pindex</name> <range>: <expr><name>vToFetch</name></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pindex</name><operator>-&gt;</operator><name>IsValid</name></name><argument_list>(<argument><expr><name>BLOCK_VALID_TREE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <comment type="line">// We consider the chain that this peer is on invalid.</comment>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>State</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fHaveWitness</name> <operator>&amp;&amp;</operator> <call><name>IsWitnessEnabled</name><argument_list>(<argument><expr><name><name>pindex</name><operator>-&gt;</operator><name>pprev</name></name></expr></argument>, <argument><expr><name>consensusParams</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <comment type="line">// We wouldn't download this block or its descendants from this peer.</comment>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>pindex</name><operator>-&gt;</operator><name>nStatus</name></name> <operator>&amp;</operator> <name>BLOCK_HAVE_DATA</name> <operator>||</operator> <call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Contains</name><argument_list>(<argument><expr><name>pindex</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>pindex</name><operator>-&gt;</operator><name>HaveTxsDownloaded</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>pindexLastCommonBlock</name></name> <operator>=</operator> <name>pindex</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>mapBlocksInFlight</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><call><name><name>pindex</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <comment type="line">// The block is not already downloaded, and not yet in flight.</comment>
                <if_stmt><if>if <condition>(<expr><name><name>pindex</name><operator>-&gt;</operator><name>nHeight</name></name> <operator>&gt;</operator> <name>nWindowEnd</name></expr>)</condition> <block>{<block_content>
                    <comment type="line">// We reached the end of the window.</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>vBlocks</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>waitingfor</name> <operator>!=</operator> <name>nodeid</name></expr>)</condition> <block>{<block_content>
                        <comment type="line">// We aren't able to fetch anything, but we would be if the download window was one larger.</comment>
                        <expr_stmt><expr><name>nodeStaller</name> <operator>=</operator> <name>waitingfor</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <return>return;</return>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name><name>vBlocks</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>pindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>vBlocks</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>count</name></expr>)</condition> <block>{<block_content>
                    <return>return;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>waitingfor</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <comment type="line">// This is the first already-in-flight block.</comment>
                <expr_stmt><expr><name>waitingfor</name> <operator>=</operator> <name><name>mapBlocksInFlight</name><index>[<expr><call><name><name>pindex</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call></expr>]</index></name><operator>.</operator><name>first</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></while>
}

void <macro><name>EraseTxRequest</name><argument_list>(<argument>const uint256&amp; txid</argument>)</argument_list></macro> <macro><name>EXCLUSIVE_LOCKS_REQUIRED</name><argument_list>(<argument>cs_main</argument>)</argument_list></macro>
<block>{<block_content>
    <expr_stmt><expr><call><name><name>g_already_asked_for</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>txid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>microseconds</name></name></type> <name>GetTxRequestTime</name><argument_list>(<argument><expr><specifier>const</specifier> <name>uint256</name><operator>&amp;</operator> <name>txid</name></expr></argument>)</argument_list> <name>EXCLUSIVE_LOCKS_REQUIRED</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list>
<argument_list>{
    <argument><expr><name>auto</name> <name>it</name> <operator>=</operator> <call><name><name>g_already_asked_for</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>txid</name></expr></argument>)</argument_list></call></expr></argument>;
    if <argument><expr><operator>(</operator><name>it</name> <operator>!=</operator> <call><name><name>g_already_asked_for</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call><operator>)</operator> <block>{
        <return>return <expr><name><name>it</name><operator>-&gt;</operator><name>second</name></name></expr>;</return>
    }</block></expr></argument>
    <return>return <expr><block>{}</block></expr>;</return></argument_list></decl></decl_stmt>
}

void <macro><name>UpdateTxRequestTime</name><argument_list>(<argument>const uint256&amp; txid</argument>, <argument>std::chrono::microseconds request_time</argument>)</argument_list></macro> <macro><name>EXCLUSIVE_LOCKS_REQUIRED</name><argument_list>(<argument>cs_main</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name>auto</name></type> <name>it</name> <init>= <expr><call><name><name>g_already_asked_for</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>txid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>it</name> <operator>==</operator> <call><name><name>g_already_asked_for</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>g_already_asked_for</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><name>txid</name></expr></argument>, <argument><expr><name>request_time</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name><name>g_already_asked_for</name><operator>.</operator><name>update</name></name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><name>request_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block>

<decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>microseconds</name></name></type> <name>CalculateTxGetDataTime</name><argument_list>(<argument><expr><specifier>const</specifier> <name>uint256</name><operator>&amp;</operator> <name>txid</name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>microseconds</name></name> <name>current_time</name></expr></argument>, <argument><expr><name>bool</name> <name>use_inbound_delay</name></expr></argument>)</argument_list> <name>EXCLUSIVE_LOCKS_REQUIRED</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list>
<argument_list>{
    <argument><expr><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>microseconds</name></name> <name>process_time</name></expr></argument>;
    <argument><expr><specifier>const</specifier> <name>auto</name> <name>last_request_time</name> <operator>=</operator> <call><name>GetTxRequestTime</name><argument_list>(<argument><expr><name>txid</name></expr></argument>)</argument_list></call></expr></argument>;
    <comment type="line">// First time requesting this tx</comment>
    if <argument><expr><operator>(</operator><call><name><name>last_request_time</name><operator>.</operator><name>count</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <block>{
        <expr><name>process_time</name> <operator>=</operator> <name>current_time</name></expr>;
    }</block></expr></argument> <if_stmt><else>else <expr_stmt><expr><block>{
        <comment type="line">// Randomize the delay to avoid biasing some peers over others (such as due to</comment>
        <comment type="line">// fixed ordering of peer processing in ThreadMessageHandler)</comment>
        <expr><name>process_time</name> <operator>=</operator> <name>last_request_time</name> <operator>+</operator> <name>GETDATA_TX_INTERVAL</name> <operator>+</operator> <call><name>GetRandMicros</name><argument_list>(<argument><expr><name>MAX_GETDATA_RANDOM_DELAY</name></expr></argument>)</argument_list></call></expr>;
    }</block></expr></expr_stmt></else></if_stmt></argument_list></decl></decl_stmt>

    <comment type="line">// We delay processing announcements from inbound peers</comment>
    <if_stmt><if>if <condition>(<expr><name>use_inbound_delay</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>process_time</name> <operator>+=</operator> <name>INBOUND_PEER_TX_DELAY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>process_time</name></expr>;</return>
}

void <macro><name>RequestTx</name><argument_list>(<argument>CNodeState* state</argument>, <argument>const uint256&amp; txid</argument>, <argument>std::chrono::microseconds current_time</argument>)</argument_list></macro> <macro><name>EXCLUSIVE_LOCKS_REQUIRED</name><argument_list>(<argument>cs_main</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>CNodeState</name><operator>::</operator><name>TxDownloadState</name></name><modifier>&amp;</modifier></type> <name>peer_download_state</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>m_tx_download</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>peer_download_state</name><operator>.</operator><name>m_tx_announced</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>MAX_PEER_TX_ANNOUNCEMENTS</name> <operator>||</operator>
            <call><name><name>peer_download_state</name><operator>.</operator><name>m_tx_process_time</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>MAX_PEER_TX_ANNOUNCEMENTS</name> <operator>||</operator>
            <call><name><name>peer_download_state</name><operator>.</operator><name>m_tx_announced</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>txid</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="line">// Too many queued announcements from this peer, or we already have</comment>
        <comment type="line">// this announcement</comment>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name><name>peer_download_state</name><operator>.</operator><name>m_tx_announced</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>txid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Calculate the time to try requesting this transaction. Use</comment>
    <comment type="line">// fPreferredDownload as a proxy for outbound peers.</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>process_time</name> <init>= <expr><call><name>CalculateTxGetDataTime</name><argument_list>(<argument><expr><name>txid</name></expr></argument>, <argument><expr><name>current_time</name></expr></argument>, <argument><expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>fPreferredDownload</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name><name>peer_download_state</name><operator>.</operator><name>m_tx_process_time</name><operator>.</operator><name>emplace</name></name><argument_list>(<argument><expr><name>process_time</name></expr></argument>, <argument><expr><name>txid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

} <comment type="line">// namespace</comment>

<comment type="line">// This function is used for testing the stale tip eviction logic, see</comment>
<comment type="line">// denialofservice_tests.cpp</comment>
void <macro><name>UpdateLastBlockAnnounceTime</name><argument_list>(<argument>NodeId node</argument>, <argument>int64_t time_in_seconds</argument>)</argument_list></macro>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>CNodeState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><call><name>State</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>state</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>m_last_block_announcement</name></name> <operator>=</operator> <name>time_in_seconds</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>

<comment type="line">// Returns true for outbound peers, excluding manual connections, feelers, and</comment>
<comment type="line">// one-shots.</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>IsOutboundDisconnectionCandidate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>!</operator><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>fInbound</name></name> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>m_manual_connection</name></name> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>fFeeler</name></name> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>fOneShot</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>PeerLogicValidation</name><operator>::</operator><name>InitializeNode</name></name><parameter_list>(<parameter><decl><type><name>CNode</name> <modifier>*</modifier></type><name>pnode</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>CAddress</name></type> <name>addr</name> <init>= <expr><name><name>pnode</name><operator>-&gt;</operator><name>addr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>addrName</name> <init>= <expr><call><name><name>pnode</name><operator>-&gt;</operator><name>GetAddrName</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NodeId</name></type> <name>nodeid</name> <init>= <expr><call><name><name>pnode</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mapNodeState</name><operator>.</operator><name>emplace_hint</name></name><argument_list>(<argument><expr><call><name><name>mapNodeState</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>piecewise_construct</name></name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>forward_as_tuple</name></name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>forward_as_tuple</name></name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>addrName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>fInbound</name></name></expr></argument>, <argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>m_manual_connection</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>pnode</name><operator>-&gt;</operator><name>fInbound</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PushNodeVersion</name><argument_list>(<argument><expr><name>pnode</name></expr></argument>, <argument><expr><name>connman</name></expr></argument>, <argument><expr><call><name>GetTime</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>PeerLogicValidation</name><operator>::</operator><name>FinalizeNode</name></name><parameter_list>(<parameter><decl><type><name>NodeId</name></type> <name>nodeid</name></decl></parameter>, <parameter><decl><type><name>bool</name><modifier>&amp;</modifier></type> <name>fUpdateConnectionTime</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name>fUpdateConnectionTime</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>CNodeState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><call><name>State</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>state</name> <operator>!=</operator> <literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>fSyncStarted</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>nSyncStarted</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>nMisbehavior</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>fCurrentlyConnected</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>fUpdateConnectionTime</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><decl><type><specifier>const</specifier> <name>QueuedBlock</name><modifier>&amp;</modifier></type> <name>entry</name> <range>: <expr><name><name>state</name><operator>-&gt;</operator><name>vBlocksInFlight</name></name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>mapBlocksInFlight</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>EraseOrphansFor</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nPreferredDownload</name> <operator>-=</operator> <name><name>state</name><operator>-&gt;</operator><name>fPreferredDownload</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nPeersWithValidatedDownloads</name> <operator>-=</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>nBlocksInFlightValidHeaders</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nPeersWithValidatedDownloads</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>g_outbound_peers_with_protect_from_disconnect</name> <operator>-=</operator> <name><name>state</name><operator>-&gt;</operator><name>m_chain_sync</name><operator>.</operator><name>m_protect</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>g_outbound_peers_with_protect_from_disconnect</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>mapNodeState</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name><name>mapNodeState</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="line">// Do a consistency check after the last peer is removed.</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>mapBlocksInFlight</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nPreferredDownload</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nPeersWithValidatedDownloads</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>g_outbound_peers_with_protect_from_disconnect</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"Cleared nodestate for peer=%d\n"</literal></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>GetNodeStateStats</name><parameter_list>(<parameter><decl><type><name>NodeId</name></type> <name>nodeid</name></decl></parameter>, <parameter><decl><type><name>CNodeStateStats</name> <modifier>&amp;</modifier></type><name>stats</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>CNodeState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><call><name>State</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <literal type="null">nullptr</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>stats</name><operator>.</operator><name>nMisbehavior</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>nMisbehavior</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stats</name><operator>.</operator><name>nSyncHeight</name></name> <operator>=</operator> <ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>pindexBestKnownBlock</name></name></expr> ?</condition><then> <expr><name><name>state</name><operator>-&gt;</operator><name>pindexBestKnownBlock</name><operator>-&gt;</operator><name>nHeight</name></name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stats</name><operator>.</operator><name>nCommonHeight</name></name> <operator>=</operator> <ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>pindexLastCommonBlock</name></name></expr> ?</condition><then> <expr><name><name>state</name><operator>-&gt;</operator><name>pindexLastCommonBlock</name><operator>-&gt;</operator><name>nHeight</name></name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <name>QueuedBlock</name><modifier>&amp;</modifier></type> <name>queue</name> <range>: <expr><name><name>state</name><operator>-&gt;</operator><name>vBlocksInFlight</name></name></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>queue</name><operator>.</operator><name>pindex</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>stats</name><operator>.</operator><name>vHeightInFlight</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name><name>queue</name><operator>.</operator><name>pindex</name><operator>-&gt;</operator><name>nHeight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<comment type="line" format="doxygen">//////////////////////////////////////////////////////////////////////////////</comment>
<comment type="line">//</comment>
<comment type="line">// mapOrphanTransactions</comment>
<comment type="line">//</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>AddToCompactExtraTransactions</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CTransactionRef</name><operator>&amp;</operator> <name>tx</name></expr></argument>)</argument_list> <name>EXCLUSIVE_LOCKS_REQUIRED</name><argument_list>(<argument><expr><name>g_cs_orphans</name></expr></argument>)</argument_list>
<argument_list>{
    <argument><expr><name>size_t</name> <name>max_extra_txn</name> <operator>=</operator> <call><name><name>gArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-blockreconstructionextratxn"</literal></expr></argument>, <argument><expr><name>DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN</name></expr></argument>)</argument_list></call></expr></argument>;
    if <argument><expr><operator>(</operator><name>max_extra_txn</name> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>
        <return>return;</return></argument_list></decl></decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>vExtraTxnForCompact</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name><name>vExtraTxnForCompact</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><name>max_extra_txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>vExtraTxnForCompact</name><index>[<expr><name>vExtraTxnForCompactIt</name></expr>]</index></name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><call><name><name>tx</name><operator>-&gt;</operator><name>GetWitnessHash</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>vExtraTxnForCompactIt</name> <operator>=</operator> <operator>(</operator><name>vExtraTxnForCompactIt</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>max_extra_txn</name></expr>;</expr_stmt>
}

bool <macro><name>AddOrphanTx</name><argument_list>(<argument>const CTransactionRef&amp; tx</argument>, <argument>NodeId peer</argument>)</argument_list></macro> <macro><name>EXCLUSIVE_LOCKS_REQUIRED</name><argument_list>(<argument>g_cs_orphans</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint256</name><modifier>&amp;</modifier></type> <name>hash</name> <init>= <expr><call><name><name>tx</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>mapOrphanTransactions</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// Ignore big transactions, to avoid a</comment>
    <comment type="line">// send-big-orphans memory exhaustion attack. If a peer has a legitimate</comment>
    <comment type="line">// large transaction with a missing parent then we assume</comment>
    <comment type="line">// it will rebroadcast it later, after the parent transaction(s)</comment>
    <comment type="line">// have been mined or received.</comment>
    <comment type="line">// 100 orphans, each of which is at most 100,000 bytes big is</comment>
    <comment type="line">// at most 10 megabytes of orphans and somewhat more byprev index (in the worst case):</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>sz</name> <init>= <expr><call><name>GetTransactionWeight</name><argument_list>(<argument><expr><operator>*</operator><name>tx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&gt;</operator> <name>MAX_STANDARD_TX_WEIGHT</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>MEMPOOL</name></name></expr></argument>, <argument><expr><literal type="string">"ignoring large orphan tx (size: %u, hash: %s)\n"</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><call><name><name>hash</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>ret</name> <init>= <expr><call><name><name>mapOrphanTransactions</name><operator>.</operator><name>emplace</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>COrphanTx</name><argument_list>{<argument><expr><name>tx</name></expr></argument>, <argument><expr><name>peer</name></expr></argument>, <argument><expr><call><name>GetTime</name><argument_list>()</argument_list></call> <operator>+</operator> <name>ORPHAN_TX_EXPIRE_TIME</name></expr></argument>, <argument><expr><macro><name>g_orphan_list</name></macro><operator>.</operator><macro><name>size</name><argument_list>()</argument_list></macro></expr></argument>}</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ret</name><operator>.</operator><name>second</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>g_orphan_list</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name><name>ret</name><operator>.</operator><name>first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CTxIn</name><modifier>&amp;</modifier></type> <name>txin</name> <range>: <expr><name><name>tx</name><operator>-&gt;</operator><name>vin</name></name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>mapOrphanTransactionsByPrev</name><index>[<expr><name><name>txin</name><operator>.</operator><name>prevout</name></name></expr>]</index></name><operator>.</operator><call><name>insert</name><argument_list>(<argument><expr><name><name>ret</name><operator>.</operator><name>first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>AddToCompactExtraTransactions</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>MEMPOOL</name></name></expr></argument>, <argument><expr><literal type="string">"stored orphan tx %s (mapsz %u outsz %u)\n"</literal></expr></argument>, <argument><expr><call><name><name>hash</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>,
             <argument><expr><call><name><name>mapOrphanTransactions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>mapOrphanTransactionsByPrev</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block>

<decl_stmt><decl><type><name>int</name> <specifier>static</specifier></type> <name>EraseOrphanTx</name><argument_list>(<argument><expr><name>uint256</name> <name>hash</name></expr></argument>)</argument_list> <name>EXCLUSIVE_LOCKS_REQUIRED</name><argument_list>(<argument><expr><name>g_cs_orphans</name></expr></argument>)</argument_list>
<argument_list>{
    <argument><expr><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>, <argument><expr><name>COrphanTx</name></expr></argument>&gt;</argument_list><operator>::</operator><name>iterator</name></name> <name>it</name> <operator>=</operator> <call><name><name>mapOrphanTransactions</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>;
    if <argument><expr><operator>(</operator><name>it</name> <operator>==</operator> <call><name><name>mapOrphanTransactions</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>
        <return>return <expr><literal type="number">0</literal></expr>;</return></argument_list></decl></decl_stmt>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CTxIn</name><modifier>&amp;</modifier></type> <name>txin</name> <range>: <expr><name><name>it</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>tx</name><operator>-&gt;</operator><name>vin</name></name></expr></range></decl></init>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>itPrev</name> <init>= <expr><call><name><name>mapOrphanTransactionsByPrev</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name><name>txin</name><operator>.</operator><name>prevout</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>itPrev</name> <operator>==</operator> <call><name><name>mapOrphanTransactionsByPrev</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name><name>itPrev</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>itPrev</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>mapOrphanTransactionsByPrev</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>itPrev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <decl_stmt><decl><type><name>size_t</name></type> <name>old_pos</name> <init>= <expr><name><name>it</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>list_pos</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>g_orphan_list</name><index>[<expr><name>old_pos</name></expr>]</index></name> <operator>==</operator> <name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>old_pos</name> <operator>+</operator> <literal type="number">1</literal> <operator>!=</operator> <call><name><name>g_orphan_list</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="line">// Unless we're deleting the last entry in g_orphan_list, move the last</comment>
        <comment type="line">// entry to the position we're deleting.</comment>
        <decl_stmt><decl><type><name>auto</name></type> <name>it_last</name> <init>= <expr><call><name><name>g_orphan_list</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>g_orphan_list</name><index>[<expr><name>old_pos</name></expr>]</index></name> <operator>=</operator> <name>it_last</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>it_last</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>list_pos</name></name> <operator>=</operator> <name>old_pos</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name><name>g_orphan_list</name><operator>.</operator><name>pop_back</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>mapOrphanTransactions</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
}

void <macro><name>EraseOrphansFor</name><argument_list>(<argument>NodeId peer</argument>)</argument_list></macro>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>g_cs_orphans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nErased</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>, <argument><expr><name>COrphanTx</name></expr></argument>&gt;</argument_list><operator>::</operator><name>iterator</name></name></type> <name>iter</name> <init>= <expr><call><name><name>mapOrphanTransactions</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>iter</name> <operator>!=</operator> <call><name><name>mapOrphanTransactions</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>, <argument><expr><name>COrphanTx</name></expr></argument>&gt;</argument_list><operator>::</operator><name>iterator</name></name></type> <name>maybeErase</name> <init>= <expr><name>iter</name><operator>++</operator></expr></init></decl>;</decl_stmt> <comment type="line">// increment to avoid iterator becoming invalid</comment>
        <if_stmt><if>if <condition>(<expr><name><name>maybeErase</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>fromPeer</name></name> <operator>==</operator> <name>peer</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>nErased</name> <operator>+=</operator> <call><name>EraseOrphanTx</name><argument_list>(<argument><expr><call><name><name>maybeErase</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>tx</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><name>nErased</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>MEMPOOL</name></name></expr></argument>, <argument><expr><literal type="string">"Erased %d orphan tx from peer=%d\n"</literal></expr></argument>, <argument><expr><name>nErased</name></expr></argument>, <argument><expr><name>peer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>


<function><type><name>unsigned</name> <name>int</name></type> <name>LimitOrphanTxSize</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nMaxOrphans</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>g_cs_orphans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nEvicted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>int64_t</name></type> <name>nNextSweep</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>nNow</name> <init>= <expr><call><name>GetTime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>nNextSweep</name> <operator>&lt;=</operator> <name>nNow</name></expr>)</condition> <block>{<block_content>
        <comment type="line">// Sweep out expired orphan pool entries:</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>nErased</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>nMinExpTime</name> <init>= <expr><name>nNow</name> <operator>+</operator> <name>ORPHAN_TX_EXPIRE_TIME</name> <operator>-</operator> <name>ORPHAN_TX_EXPIRE_INTERVAL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>, <argument><expr><name>COrphanTx</name></expr></argument>&gt;</argument_list><operator>::</operator><name>iterator</name></name></type> <name>iter</name> <init>= <expr><call><name><name>mapOrphanTransactions</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>iter</name> <operator>!=</operator> <call><name><name>mapOrphanTransactions</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>, <argument><expr><name>COrphanTx</name></expr></argument>&gt;</argument_list><operator>::</operator><name>iterator</name></name></type> <name>maybeErase</name> <init>= <expr><name>iter</name><operator>++</operator></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>maybeErase</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>nTimeExpire</name></name> <operator>&lt;=</operator> <name>nNow</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>nErased</name> <operator>+=</operator> <call><name>EraseOrphanTx</name><argument_list>(<argument><expr><call><name><name>maybeErase</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>tx</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>nMinExpTime</name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>min</name></name><argument_list>(<argument><expr><name><name>maybeErase</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>nTimeExpire</name></name></expr></argument>, <argument><expr><name>nMinExpTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>
        <comment type="line">// Sweep again 5 minutes after the next entry that expires in order to batch the linear scan.</comment>
        <expr_stmt><expr><name>nNextSweep</name> <operator>=</operator> <name>nMinExpTime</name> <operator>+</operator> <name>ORPHAN_TX_EXPIRE_INTERVAL</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nErased</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>MEMPOOL</name></name></expr></argument>, <argument><expr><literal type="string">"Erased %d orphan tx due to expiration\n"</literal></expr></argument>, <argument><expr><name>nErased</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>FastRandomContext</name></type> <name>rng</name></decl>;</decl_stmt>
    <while>while <condition>(<expr><call><name><name>mapOrphanTransactions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>nMaxOrphans</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// Evict a random orphan:</comment>
        <decl_stmt><decl><type><name>size_t</name></type> <name>randompos</name> <init>= <expr><call><name><name>rng</name><operator>.</operator><name>randrange</name></name><argument_list>(<argument><expr><call><name><name>g_orphan_list</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>EraseOrphanTx</name><argument_list>(<argument><expr><name><name>g_orphan_list</name><index>[<expr><name>randompos</name></expr>]</index></name><operator>-&gt;</operator><name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>++</operator><name>nEvicted</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>nEvicted</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Mark a misbehaving peer to be banned depending upon the value of `-banscore`.
 */</comment>
<decl_stmt><decl><type><name>void</name></type> <name>Misbehaving</name><argument_list>(<argument><expr><name>NodeId</name> <name>pnode</name></expr></argument>, <argument><expr><name>int</name> <name>howmuch</name></expr></argument>, <argument><expr><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><operator>&amp;</operator> <name>message</name></expr></argument>)</argument_list> <name>EXCLUSIVE_LOCKS_REQUIRED</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list>
<argument_list>{
    if <argument><expr><operator>(</operator><name>howmuch</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>
        <return>return;</return></argument_list></decl></decl_stmt>

    <decl_stmt><decl><type><name>CNodeState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><call><name>State</name><argument_list>(<argument><expr><name>pnode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <literal type="null">nullptr</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nMisbehavior</name></name> <operator>+=</operator> <name>howmuch</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>banscore</name> <init>= <expr><call><name><name>gArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-banscore"</literal></expr></argument>, <argument><expr><name>DEFAULT_BANSCORE_THRESHOLD</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>message_prefixed</name> <init>= <expr><ternary><condition><expr><call><name><name>message</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><operator>(</operator><literal type="string">": "</literal> <operator>+</operator> <name>message</name><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>nMisbehavior</name></name> <operator>&gt;=</operator> <name>banscore</name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>nMisbehavior</name></name> <operator>-</operator> <name>howmuch</name> <operator>&lt;</operator> <name>banscore</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"%s: %s peer=%d (%d -&gt; %d) BAN THRESHOLD EXCEEDED%s\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>pnode</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>nMisbehavior</name></name><operator>-</operator><name>howmuch</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>nMisbehavior</name></name></expr></argument>, <argument><expr><name>message_prefixed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>fShouldBan</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"%s: %s peer=%d (%d -&gt; %d)%s\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>pnode</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>nMisbehavior</name></name><operator>-</operator><name>howmuch</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>nMisbehavior</name></name></expr></argument>, <argument><expr><name>message_prefixed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
}

<comment type="block" format="doxygen">/**
 * Returns true if the given validation state result may result in a peer
 * banning/disconnecting us. We use this to determine which unaccepted
 * transactions from a whitelisted peer that we can safely relay.
 */</comment>
static <function><type><name>bool</name></type> <name>TxRelayMayResultInDisconnect</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TxValidationState</name><modifier>&amp;</modifier></type> <name>state</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name><name>state</name><operator>.</operator><name>GetResult</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>TxValidationResult</name><operator>::</operator><name>TX_CONSENSUS</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Potentially ban a node based on the contents of a BlockValidationState object
 *
 * @param[in] via_compact_block: this bool is passed in because net_processing should
 * punish peers differently depending on whether the data was provided in a compact
 * block message or not. If the compact block had a valid header, but contained invalid
 * txs, the peer should not be punished. See BIP 152.
 *
 * @return Returns true if the peer was punished (probably disconnected)
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>MaybePunishNodeForBlock</name><parameter_list>(<parameter><decl><type><name>NodeId</name></type> <name>nodeid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BlockValidationState</name><modifier>&amp;</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>via_compact_block</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>message</name> <init>= <expr><literal type="string">""</literal></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
    <switch>switch <condition>(<expr><call><name><name>state</name><operator>.</operator><name>GetResult</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name><name>BlockValidationResult</name><operator>::</operator><name>BLOCK_RESULT_UNSET</name></name></expr>:</case>
        <break>break;</break>
    <comment type="line">// The node is providing invalid data:</comment>
    <case>case <expr><name><name>BlockValidationResult</name><operator>::</operator><name>BLOCK_CONSENSUS</name></name></expr>:</case>
    <case>case <expr><name><name>BlockValidationResult</name><operator>::</operator><name>BLOCK_MUTATED</name></name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>via_compact_block</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Misbehaving</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
    <case>case <expr><name><name>BlockValidationResult</name><operator>::</operator><name>BLOCK_CACHED_INVALID</name></name></expr>:</case>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>CNodeState</name> <modifier>*</modifier></type><name>node_state</name> <init>= <expr><call><name>State</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>node_state</name> <operator>==</operator> <literal type="null">nullptr</literal></expr>)</condition> <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Ban outbound (but not inbound) peers if on an invalid chain.</comment>
            <comment type="line">// Exempt HB compact block peers and manual connections.</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>via_compact_block</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>node_state</name><operator>-&gt;</operator><name>m_is_inbound</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>node_state</name><operator>-&gt;</operator><name>m_is_manual_connection</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>Misbehaving</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        </block_content>}</block>
    <case>case <expr><name><name>BlockValidationResult</name><operator>::</operator><name>BLOCK_INVALID_HEADER</name></name></expr>:</case>
    <case>case <expr><name><name>BlockValidationResult</name><operator>::</operator><name>BLOCK_CHECKPOINT</name></name></expr>:</case>
    <case>case <expr><name><name>BlockValidationResult</name><operator>::</operator><name>BLOCK_INVALID_PREV</name></name></expr>:</case>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Misbehaving</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    <comment type="line">// Conflicting (but not necessarily invalid) data or different policy:</comment>
    <case>case <expr><name><name>BlockValidationResult</name><operator>::</operator><name>BLOCK_MISSING_PREV</name></name></expr>:</case>
        <block>{<block_content>
            <comment type="line">// TODO: Handle this much more gracefully (10 DoS points is super arbitrary)</comment>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Misbehaving</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    <case>case <expr><name><name>BlockValidationResult</name><operator>::</operator><name>BLOCK_RECENT_CONSENSUS_CHANGE</name></name></expr>:</case>
    <case>case <expr><name><name>BlockValidationResult</name><operator>::</operator><name>BLOCK_TIME_FUTURE</name></name></expr>:</case>
        <break>break;</break>
    </block_content>}</block></switch>
    <if_stmt><if>if <condition>(<expr><name>message</name> <operator>!=</operator> <literal type="string">""</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"peer=%d: %s\n"</literal></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Potentially ban a node based on the contents of a TxValidationState object
 *
 * @return Returns true if the peer was punished (probably disconnected)
 *
 * Changes here may need to be reflected in TxRelayMayResultInDisconnect().
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>MaybePunishNodeForTx</name><parameter_list>(<parameter><decl><type><name>NodeId</name></type> <name>nodeid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TxValidationState</name><modifier>&amp;</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>message</name> <init>= <expr><literal type="string">""</literal></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
    <switch>switch <condition>(<expr><call><name><name>state</name><operator>.</operator><name>GetResult</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name><name>TxValidationResult</name><operator>::</operator><name>TX_RESULT_UNSET</name></name></expr>:</case>
        <break>break;</break>
    <comment type="line">// The node is providing invalid data:</comment>
    <case>case <expr><name><name>TxValidationResult</name><operator>::</operator><name>TX_CONSENSUS</name></name></expr>:</case>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Misbehaving</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block>
    <comment type="line">// Conflicting (but not necessarily invalid) data or different policy:</comment>
    <case>case <expr><name><name>TxValidationResult</name><operator>::</operator><name>TX_RECENT_CONSENSUS_CHANGE</name></name></expr>:</case>
    <case>case <expr><name><name>TxValidationResult</name><operator>::</operator><name>TX_NOT_STANDARD</name></name></expr>:</case>
    <case>case <expr><name><name>TxValidationResult</name><operator>::</operator><name>TX_MISSING_INPUTS</name></name></expr>:</case>
    <case>case <expr><name><name>TxValidationResult</name><operator>::</operator><name>TX_PREMATURE_SPEND</name></name></expr>:</case>
    <case>case <expr><name><name>TxValidationResult</name><operator>::</operator><name>TX_WITNESS_MUTATED</name></name></expr>:</case>
    <case>case <expr><name><name>TxValidationResult</name><operator>::</operator><name>TX_CONFLICT</name></name></expr>:</case>
    <case>case <expr><name><name>TxValidationResult</name><operator>::</operator><name>TX_MEMPOOL_POLICY</name></name></expr>:</case>
        <break>break;</break>
    </block_content>}</block></switch>
    <if_stmt><if>if <condition>(<expr><name>message</name> <operator>!=</operator> <literal type="string">""</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"peer=%d: %s\n"</literal></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
</block_content>}</block></function>







<comment type="line" format="doxygen">//////////////////////////////////////////////////////////////////////////////</comment>
<comment type="line">//</comment>
<comment type="line">// blockchain -&gt; download logic notification</comment>
<comment type="line">//</comment>

<comment type="line">// To prevent fingerprinting attacks, only send blocks/headers outside of the</comment>
<comment type="line">// active chain if they are no more than a month older (both in time, and in</comment>
<comment type="line">// best equivalent proof of work) than the best header chain we know about and</comment>
<comment type="line">// we fully-validated them at some point.</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>BlockRequestAllowed</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CBlockIndex</name><operator>*</operator> <name>pindex</name></expr></argument>, <argument><expr><specifier>const</specifier> <name><name>Consensus</name><operator>::</operator><name>Params</name></name><operator>&amp;</operator> <name>consensusParams</name></expr></argument>)</argument_list> <name>EXCLUSIVE_LOCKS_REQUIRED</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list>
<argument_list>{
    <argument><expr><call><name>AssertLockHeld</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr></argument>;
    if <argument><expr><operator>(</operator><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Contains</name><argument_list>(<argument><expr><name>pindex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument> <return>return <expr><literal type="boolean">true</literal></expr>;</return></argument_list></decl></decl_stmt>
    <return>return <expr><call><name><name>pindex</name><operator>-&gt;</operator><name>IsValid</name></name><argument_list>(<argument><expr><name>BLOCK_VALID_SCRIPTS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>pindexBestHeader</name> <operator>!=</operator> <literal type="null">nullptr</literal><operator>)</operator> <operator>&amp;&amp;</operator>
        <operator>(</operator><call><name><name>pindexBestHeader</name><operator>-&gt;</operator><name>GetBlockTime</name></name><argument_list>()</argument_list></call> <operator>-</operator> <call><name><name>pindex</name><operator>-&gt;</operator><name>GetBlockTime</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>STALE_RELAY_AGE_LIMIT</name><operator>)</operator> <operator>&amp;&amp;</operator>
        <operator>(</operator><call><name>GetBlockProofEquivalentTime</name><argument_list>(<argument><expr><operator>*</operator><name>pindexBestHeader</name></expr></argument>, <argument><expr><operator>*</operator><name>pindex</name></expr></argument>, <argument><expr><operator>*</operator><name>pindexBestHeader</name></expr></argument>, <argument><expr><name>consensusParams</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>STALE_RELAY_AGE_LIMIT</name><operator>)</operator></expr>;</return>
}

PeerLogicValidation<expr_stmt><expr><call><name><operator>::</operator><name>PeerLogicValidation</name></name><argument_list>(<argument><expr><name>CConnman</name><operator>*</operator> <name>connmanIn</name></expr></argument>, <argument><expr><name>BanMan</name><operator>*</operator> <name>banman</name></expr></argument>, <argument><expr><name>CScheduler</name><operator>&amp;</operator> <name>scheduler</name></expr></argument>)</argument_list></call>
    <operator>:</operator> <call><name>connman</name><argument_list>(<argument><expr><name>connmanIn</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>m_banman</name><argument_list>(<argument><expr><name>banman</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>m_stale_tip_check_time</name><argument_list>(<argument><literal type="number">0</literal></argument>)</argument_list></macro>
<expr><block>{
    <comment type="line">// Initialize global variables that cannot be constructed at startup.</comment>
    <expr><call><name><name>recentRejects</name><operator>.</operator><name>reset</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>CRollingBloomFilter</name><argument_list>(<argument><expr><literal type="number">120000</literal></expr></argument>, <argument><expr><literal type="number">0.000001</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;

    <expr><specifier>const</specifier> <name><name>Consensus</name><operator>::</operator><name>Params</name></name><operator>&amp;</operator> <name>consensusParams</name> <operator>=</operator> <call><name>Params</name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetConsensus</name><argument_list>()</argument_list></call></expr>;
    <comment type="line">// Stale tip checking and peer eviction are on two different timers, but we</comment>
    <comment type="line">// don't want them to get out of sync due to drift in the scheduler, so we</comment>
    <comment type="line">// combine them in one function and schedule at the quicker (peer-eviction)</comment>
    <comment type="line">// timer.</comment>
    <assert type="static">static_assert<argument_list>(<argument><expr><name>EXTRA_PEER_CHECK_INTERVAL</name> <operator>&lt;</operator> <name>STALE_CHECK_INTERVAL</name></expr></argument>, <argument><expr><literal type="string">"peer eviction timer should be less than stale tip check timer"</literal></expr></argument>)</argument_list>;</assert>
    <call><name><name>scheduler</name><operator>.</operator><name>scheduleEvery</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>bind</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>PeerLogicValidation</name><operator>::</operator><name>CheckForStaleTipAndEvictPeers</name></name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name>consensusParams</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>EXTRA_PEER_CHECK_INTERVAL</name> <operator>*</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
}

<comment type="block" format="doxygen">/**
 * Evict orphan txn pool entries (EraseOrphanTx) based on a newly connected
 * block. Also save the time of the last tip update.
 */</comment>
void <macro><name>PeerLogicValidation</name></macro><expr_stmt><expr><name><operator>::</operator><name>BlockConnected</name></name><operator>(</operator><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CBlock</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>pblock</name><operator>,</operator> <specifier>const</specifier> <name>CBlockIndex</name><operator>*</operator> <name>pindex</name><operator>,</operator> <specifier>const</specifier> <name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CTransactionRef</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>vtxConflicted</name><operator>)</operator> <block>{
    <expr><call><name>LOCK</name><argument_list>(<argument><expr><name>g_cs_orphans</name></expr></argument>)</argument_list></call></expr>;

    <expr><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>&gt;</argument_list></name> <name>vOrphanErase</name></expr>;

    <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CTransactionRef</name><modifier>&amp;</modifier></type> <name>ptx</name> <range>: <expr><name><name>pblock</name><operator>-&gt;</operator><name>vtx</name></name></expr></range></decl></init>)</control> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>CTransaction</name><modifier>&amp;</modifier></type> <name>tx</name> <init>= <expr><operator>*</operator><name>ptx</name></expr></init></decl>;</decl_stmt>

        <comment type="line">// Which orphan pool entries must we evict?</comment>
        <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>txin</name> <range>: <expr><name><name>tx</name><operator>.</operator><name>vin</name></name></expr></range></decl></init>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>auto</name></type> <name>itByPrev</name> <init>= <expr><call><name><name>mapOrphanTransactionsByPrev</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name><name>txin</name><operator>.</operator><name>prevout</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>itByPrev</name> <operator>==</operator> <call><name><name>mapOrphanTransactionsByPrev</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <for>for <control>(<init><decl><type><name>auto</name></type> <name>mi</name> <init>= <expr><call><name><name>itByPrev</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>mi</name> <operator>!=</operator> <call><name><name>itByPrev</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>mi</name></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>CTransaction</name><modifier>&amp;</modifier></type> <name>orphanTx</name> <init>= <expr><operator>*</operator><name><operator>(</operator><operator>*</operator><name>mi</name><operator>)</operator><operator>-&gt;</operator><name><name>second</name><operator>.</operator><name>tx</name></name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>uint256</name><modifier>&amp;</modifier></type> <name>orphanHash</name> <init>= <expr><call><name><name>orphanTx</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>vOrphanErase</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>orphanHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt/></block_content></block></for></block_content></block></for></block_content></block></for>}</block></expr></expr_stmt>
        }
    }

    <comment type="line">// Erase orphan transactions included or precluded by this block</comment>
    <if_stmt><if>if <condition>(<expr><call><name><name>vOrphanErase</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nErased</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>const</specifier> <name>uint256</name><modifier>&amp;</modifier></type> <name>orphanHash</name> <range>: <expr><name>vOrphanErase</name></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><name>nErased</name> <operator>+=</operator> <call><name>EraseOrphanTx</name><argument_list>(<argument><expr><name>orphanHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>MEMPOOL</name></name></expr></argument>, <argument><expr><literal type="string">"Erased %d orphan tx included or conflicted by block\n"</literal></expr></argument>, <argument><expr><name>nErased</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>g_last_tip_update</name> <operator>=</operator> <call><name>GetTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}

<comment type="line">// All of the following cache a recent block, and are protected by cs_most_recent_block</comment>
static <decl_stmt><decl><type><name>CCriticalSection</name></type> <name>cs_most_recent_block</name></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CBlock</name></expr></argument>&gt;</argument_list></name> <name>most_recent_block</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_most_recent_block</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CBlockHeaderAndShortTxIDs</name></expr></argument>&gt;</argument_list></name> <name>most_recent_compact_block</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_most_recent_block</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint256</name> <name>most_recent_block_hash</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_most_recent_block</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name> <name>fWitnessesPresentInMostRecentCompactBlock</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_most_recent_block</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/**
 * Maintain state about the best-seen block and fast-announce a compact block
 * to compatible peers.
 */</comment>
<function><type><name>void</name></type> <name><name>PeerLogicValidation</name><operator>::</operator><name>NewPoWValidBlock</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CBlockIndex</name> <modifier>*</modifier></type><name>pindex</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CBlock</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>pblock</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CBlockHeaderAndShortTxIDs</name></expr></argument>&gt;</argument_list></name></type> <name>pcmpctblock</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>make_shared</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CBlockHeaderAndShortTxIDs</name></expr></argument>&gt;</argument_list></name> <argument_list>(<argument><expr><operator>*</operator><name>pblock</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CNetMsgMaker</name></type> <name>msgMaker</name><argument_list>(<argument><expr><name>PROTOCOL_VERSION</name></expr></argument>)</argument_list></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>nHighestFastAnnounce</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pindex</name><operator>-&gt;</operator><name>nHeight</name></name> <operator>&lt;=</operator> <name>nHighestFastAnnounce</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nHighestFastAnnounce</name> <operator>=</operator> <name><name>pindex</name><operator>-&gt;</operator><name>nHeight</name></name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>fWitnessEnabled</name> <init>= <expr><call><name>IsWitnessEnabled</name><argument_list>(<argument><expr><name><name>pindex</name><operator>-&gt;</operator><name>pprev</name></name></expr></argument>, <argument><expr><call><name>Params</name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetConsensus</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint256</name></type> <name>hashBlock</name><argument_list>(<argument><expr><call><name><name>pblock</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_most_recent_block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>most_recent_block_hash</name> <operator>=</operator> <name>hashBlock</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>most_recent_block</name> <operator>=</operator> <name>pblock</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>most_recent_compact_block</name> <operator>=</operator> <name>pcmpctblock</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>fWitnessesPresentInMostRecentCompactBlock</name> <operator>=</operator> <name>fWitnessEnabled</name></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>ForEachNode</name></name><argument_list>(<argument><expr><lambda><capture>[<argument><name>this</name></argument>, <argument><modifier>&amp;</modifier><name>pcmpctblock</name></argument>, <argument><name>pindex</name></argument>, <argument><modifier>&amp;</modifier><name>msgMaker</name></argument>, <argument><name>fWitnessEnabled</name></argument>, <argument><modifier>&amp;</modifier><name>hashBlock</name></argument>]</capture><parameter_list>(<parameter><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>AssertLockHeld</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// TODO: Avoid the repeated-serialization here</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pnode</name><operator>-&gt;</operator><name>nVersion</name></name> <operator>&lt;</operator> <name>INVALID_CB_NO_BAN_VERSION</name> <operator>||</operator> <name><name>pnode</name><operator>-&gt;</operator><name>fDisconnect</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>ProcessBlockAvailability</name><argument_list>(<argument><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>CNodeState</name> <modifier>&amp;</modifier><name>state</name> = <modifier>*</modifier><name>State</name>(<name><name>pnode</name><operator>-&gt;</operator><name>GetId</name></name>(</type></decl>)</decl_stmt>)</block_content></block></lambda></expr></argument>;
        <comment type="line">// If the peer has, or we announced to them the previous block already,</comment>
        <comment type="line">// but we don't think they have this one, go ahead and announce it</comment>
        if <argument><expr><operator>(</operator><name><name>state</name><operator>.</operator><name>fPreferHeaderAndIDs</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>fWitnessEnabled</name> <operator>||</operator> <name><name>state</name><operator>.</operator><name>fWantsCmpctWitness</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
                <operator>!</operator><call><name>PeerHasHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>pindex</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>PeerHasHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name><name>pindex</name><operator>-&gt;</operator><name>pprev</name></name></expr></argument>)</argument_list></call><operator>)</operator> <block>{

            <expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"%s sending header-and-ids %s to peer=%d\n"</literal></expr></argument>, <argument><expr><literal type="string">"PeerLogicValidation::NewPoWValidBlock"</literal></expr></argument>,
                    <argument><expr><call><name><name>hashBlock</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
            <expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pnode</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>CMPCTBLOCK</name></name></expr></argument>, <argument><expr><operator>*</operator><name>pcmpctblock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
            <expr><name><name>state</name><operator>.</operator><name>pindexBestHeaderSent</name></name> <operator>=</operator> <name>pindex</name></expr>;
        }</block></expr></argument></argument_list></call></expr></expr_stmt>
    </block_content>}</block></function>)<empty_stmt>;</empty_stmt>
}

<comment type="block" format="doxygen">/**
 * Update our best height and announce any block hashes which weren't previously
 * in ::ChainActive() to our peers.
 */</comment>
void <macro><name>PeerLogicValidation</name></macro><expr_stmt><expr><name><operator>::</operator><name>UpdatedBlockTip</name></name><operator>(</operator><specifier>const</specifier> <name>CBlockIndex</name> <operator>*</operator><name>pindexNew</name><operator>,</operator> <specifier>const</specifier> <name>CBlockIndex</name> <operator>*</operator><name>pindexFork</name><operator>,</operator> <name>bool</name> <name>fInitialDownload</name><operator>)</operator> <block>{
    <expr><specifier>const</specifier> <name>int</name> <name>nNewHeight</name> <operator>=</operator> <name><name>pindexNew</name><operator>-&gt;</operator><name>nHeight</name></name></expr>;
    <expr><call><name><name>connman</name><operator>-&gt;</operator><name>SetBestHeight</name></name><argument_list>(<argument><expr><name>nNewHeight</name></expr></argument>)</argument_list></call></expr>;

    <expr><call><name>SetServiceFlagsIBDCache</name><argument_list>(<argument><expr><operator>!</operator><name>fInitialDownload</name></expr></argument>)</argument_list></call></expr>;
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fInitialDownload</name></expr>)</condition> <block>{<block_content>
        <comment type="line">// Find the hashes of all blocks that weren't previously in the best chain.</comment>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>&gt;</argument_list></name></type> <name>vHashes</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>CBlockIndex</name> <modifier>*</modifier></type><name>pindexToAnnounce</name> <init>= <expr><name>pindexNew</name></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>pindexToAnnounce</name> <operator>!=</operator> <name>pindexFork</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>vHashes</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>pindexToAnnounce</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pindexToAnnounce</name> <operator>=</operator> <name><name>pindexToAnnounce</name><operator>-&gt;</operator><name>pprev</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>vHashes</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>MAX_BLOCKS_TO_ANNOUNCE</name></expr>)</condition> <block>{<block_content>
                <comment type="line">// Limit announcements in case of a huge reorganization.</comment>
                <comment type="line">// Rely on the peer's synchronization mechanism in that case.</comment>
                <break>break;</break>
            <expr_stmt/></block_content></block></if></if_stmt></block_content></block></while></block_content></block></if></if_stmt>}</block></expr></expr_stmt>
        }
        <comment type="line">// Relay inventory, but don't relay old inventory during initial block download.</comment>
        connman<expr_stmt><expr><operator>-&gt;</operator><call><name>ForEachNode</name><argument_list>(<argument><expr><lambda><capture>[<argument><name>nNewHeight</name></argument>, <argument><modifier>&amp;</modifier><name>vHashes</name></argument>]</capture><parameter_list>(<parameter><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>nNewHeight</name> <operator>&gt;</operator> <operator>(</operator><ternary><condition><expr><name><name>pnode</name><operator>-&gt;</operator><name>nStartingHeight</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><name><name>pnode</name><operator>-&gt;</operator><name>nStartingHeight</name></name> <operator>-</operator> <literal type="number">2000</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>)</condition> <block>{<block_content>
                <for>for <control>(<init><decl><type><specifier>const</specifier> <name>uint256</name><modifier>&amp;</modifier> <name>hash</name> : <name>reverse_iterate</name>(<name>vHashes</name></type></decl></init>)</control><block type="pseudo"><block_content><expr_stmt><expr/></expr_stmt></block_content></block></for></block_content></block></if></if_stmt></block_content></block></lambda></expr></argument>)</argument_list></call> <block>{
                    <expr><call><name><name>pnode</name><operator>-&gt;</operator><name>PushBlockHash</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;
                }</block></expr></expr_stmt>
            }
        })<empty_stmt>;</empty_stmt>
        <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>WakeMessageHandler</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }
}

<comment type="block" format="doxygen">/**
 * Handle invalid block rejection and consequent peer banning, maintain which
 * peers announce compact blocks.
 */</comment>
<function><type><name>void</name></type> <name><name>PeerLogicValidation</name><operator>::</operator><name>BlockChecked</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CBlock</name><modifier>&amp;</modifier></type> <name>block</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BlockValidationState</name><modifier>&amp;</modifier></type> <name>state</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>uint256</name></type> <name>hash</name><argument_list>(<argument><expr><call><name><name>block</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>NodeId</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list><operator>::</operator><name>iterator</name></name></type> <name>it</name> <init>= <expr><call><name><name>mapBlockSource</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// If the block failed validation, we know where it came from and we're still connected</comment>
    <comment type="line">// to that peer, maybe punish.</comment>
    <if_stmt><if>if <condition>(<expr><call><name><name>state</name><operator>.</operator><name>IsInvalid</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
        <name>it</name> <operator>!=</operator> <call><name><name>mapBlockSource</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
        <call><name>State</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>first</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>MaybePunishNodeForBlock</name><argument_list>(<comment type="block">/*nodeid=*/</comment> <argument><expr><name><name>it</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>first</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <comment type="block">/*via_compact_block=*/</comment> <argument><expr><operator>!</operator><name><name>it</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>second</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="line">// Check that:</comment>
    <comment type="line">// 1. The block is valid</comment>
    <comment type="line">// 2. We're not in initial block download</comment>
    <comment type="line">// 3. This is currently the best block we're aware of. We haven't updated</comment>
    <comment type="line">//    the tip yet so we have no way to check this directly here. Instead we</comment>
    <comment type="line">//    just check that there are currently no other blocks in flight.</comment>
    <if type="elseif">else if <condition>(<expr><call><name><name>state</name><operator>.</operator><name>IsValid</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
             <operator>!</operator><call><name><operator>::</operator><name>ChainstateActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>IsInitialBlockDownload</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
             <call><name><name>mapBlocksInFlight</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name><name>mapBlocksInFlight</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>it</name> <operator>!=</operator> <call><name><name>mapBlockSource</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>MaybeSetPeerAsAnnouncingHeaderAndIDs</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>first</name></name></expr></argument>, <argument><expr><name>connman</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>it</name> <operator>!=</operator> <call><name><name>mapBlockSource</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name><name>mapBlockSource</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="line" format="doxygen">//////////////////////////////////////////////////////////////////////////////</comment>
<comment type="line">//</comment>
<comment type="line">// Messages</comment>
<comment type="line">//</comment>


<decl_stmt><decl><type><name>bool</name> <specifier>static</specifier></type> <name>AlreadyHave</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CInv</name><operator>&amp;</operator> <name>inv</name></expr></argument>)</argument_list> <name>EXCLUSIVE_LOCKS_REQUIRED</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list>
<argument_list>{
    switch <argument><expr><operator>(</operator><name><name>inv</name><operator>.</operator><name>type</name></name><operator>)</operator>
    <block>{
    <case>case <expr><name>MSG_TX</name></expr>:</case>
    <case>case <expr><name>MSG_WITNESS_TX</name></expr>:</case>
        <expr><block>{
            <expr><call><name>assert</name><argument_list>(<argument><expr><name>recentRejects</name></expr></argument>)</argument_list></call></expr>;
            <if_stmt><if>if <condition>(<expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Tip</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>GetBlockHash</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>hashRecentRejectsChainTip</name></expr>)</condition>
            <expr_stmt><expr><block>{
                <comment type="line">// If the chain tip has changed previously rejected transactions</comment>
                <comment type="line">// might be now valid, e.g. due to a nLockTime'd tx becoming valid,</comment>
                <comment type="line">// or a double-spend. Reset the rejects filter and give those</comment>
                <comment type="line">// txs a second chance.</comment>
                <expr><name>hashRecentRejectsChainTip</name> <operator>=</operator> <call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Tip</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>GetBlockHash</name><argument_list>()</argument_list></call></expr>;
                <call><name><name>recentRejects</name><operator>-&gt;</operator><name>reset</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt></if></if_stmt>
            }</block>

            <block>{
                <expr><call><name>LOCK</name><argument_list>(<argument><expr><name>g_cs_orphans</name></expr></argument>)</argument_list></call></expr>;
                <if_stmt><if>if <condition>(<expr><call><name><name>mapOrphanTransactions</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name><name>inv</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>
            }</block>
            <specifier>const</specifier> <name>CCoinsViewCache</name><operator>&amp;</operator> <name>coins_cache</name> <operator>=</operator> <call><name><operator>::</operator><name>ChainstateActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>CoinsTip</name><argument_list>()</argument_list></call></expr>;

            <return>return <expr><call><name><name>recentRejects</name><operator>-&gt;</operator><name>contains</name></name><argument_list>(<argument><expr><name><name>inv</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
                   <call><name><name>mempool</name><operator>.</operator><name>exists</name></name><argument_list>(<argument><expr><name><name>inv</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
                   <call><name><name>coins_cache</name><operator>.</operator><name>HaveCoinInCache</name></name><argument_list>(<argument><expr><call><name>COutPoint</name><argument_list>(<argument><expr><name><name>inv</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <comment type="line">// Best effort: only try output 0 and 1</comment>
                   <call><name><name>coins_cache</name><operator>.</operator><name>HaveCoinInCache</name></name><argument_list>(<argument><expr><call><name>COutPoint</name><argument_list>(<argument><expr><name><name>inv</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></expr></argument>
    <case>case <expr><name>MSG_BLOCK</name></expr>:</case>
    case <argument><expr><name>MSG_WITNESS_BLOCK</name><operator>:</operator></expr></argument>
        <return>return <expr><call><name>LookupBlockIndex</name><argument_list>(<argument><expr><name><name>inv</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="null">nullptr</literal></expr>;</return></argument_list></decl></decl_stmt>
    }
    <comment type="line">// Don't know what it is, just say we already got one</comment>
    return <expr_stmt><expr><literal type="boolean">true</literal></expr>;</expr_stmt>
}

void <macro><name>RelayTransaction</name><argument_list>(<argument>const uint256&amp; txid</argument>, <argument>const CConnman&amp; connman</argument>)</argument_list></macro>
<block>{<block_content>
    <function_decl><type><name>CInv</name></type> <name>inv</name><parameter_list>(<parameter><decl><type><name>MSG_TX</name></type></decl></parameter>, <parameter><decl><type><name>txid</name></type></decl></parameter>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name><name>connman</name><operator>.</operator><name>ForEachNode</name></name><argument_list>(<argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier><name>inv</name></argument>]</capture><parameter_list>(<parameter><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>PushInventory</name></name><argument_list>(<argument><expr><name>inv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<function><type><specifier>static</specifier> <name>void</name></type> <name>RelayAddress</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CAddress</name><modifier>&amp;</modifier></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fReachable</name></decl></parameter>, <parameter><decl><type><name>CConnman</name><modifier>*</modifier></type> <name>connman</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nRelayNodes</name> <init>= <expr><ternary><condition><expr><name>fReachable</name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt> <comment type="line">// limited relaying of addresses outside our network(s)</comment>

    <comment type="line">// Relay to a limited number of other nodes</comment>
    <comment type="line">// Use deterministic randomness to send to the same nodes for 24 hours</comment>
    <comment type="line">// at a time so the m_addr_knowns of the chosen nodes prevent repeats</comment>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>hashAddr</name> <init>= <expr><call><name><name>addr</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CSipHasher</name></type> <name>hasher</name> <init>= <expr><call><name><name>connman</name><operator>-&gt;</operator><name>GetDeterministicRandomizer</name></name><argument_list>(<argument><expr><name>RANDOMIZER_ID_ADDRESS_RELAY</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>Write</name><argument_list>(<argument><expr><name>hashAddr</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>Write</name><argument_list>(<argument><expr><operator>(</operator><call><name>GetTime</name><argument_list>()</argument_list></call> <operator>+</operator> <name>hashAddr</name><operator>)</operator> <operator>/</operator> <operator>(</operator><literal type="number">24</literal><operator>*</operator><literal type="number">60</literal><operator>*</operator><literal type="number">60</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FastRandomContext</name></type> <name>insecure_rand</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>array</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>uint64_t</name></expr></argument>, <argument><expr><name>CNode</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type> <name>best</name><argument_list>{<argument><expr><block>{<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="null">nullptr</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="null">nullptr</literal></expr>}</block></expr>}</block></expr></argument>}</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nRelayNodes</name> <operator>&lt;=</operator> <call><name><name>best</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>sortfunc</name> <init>= <expr><lambda><capture>[<argument><modifier>&amp;</modifier><name>best</name></argument>, <argument><modifier>&amp;</modifier><name>hasher</name></argument>, <argument><name>nRelayNodes</name></argument>]</capture><parameter_list>(<parameter><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>pnode</name><operator>-&gt;</operator><name>nVersion</name></name> <operator>&gt;=</operator> <name>CADDR_TIME_VERSION</name> <operator>&amp;&amp;</operator> <call><name><name>pnode</name><operator>-&gt;</operator><name>IsAddrRelayPeer</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>uint64_t</name></type> <name>hashKey</name> <init>= <expr><call><name>CSipHasher</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>Write</name><argument_list>(<argument><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>Finalize</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nRelayNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                 <if_stmt><if>if <condition>(<expr><name>hashKey</name> <operator>&gt;</operator> <name><name>best</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>first</name></expr>)</condition> <block>{<block_content>
                     <expr_stmt><expr><call><name><name>std</name><operator>::</operator><name>copy</name></name><argument_list>(<argument><expr><call><name><name>best</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><call><name><name>best</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>nRelayNodes</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>best</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><name><name>best</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><name>hashKey</name></expr></argument>, <argument><expr><name>pnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <break>break;</break>
                 </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></lambda></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>pushfunc</name> <init>= <expr><lambda><capture>[<argument><modifier>&amp;</modifier><name>addr</name></argument>, <argument><modifier>&amp;</modifier><name>best</name></argument>, <argument><name>nRelayNodes</name></argument>, <argument><modifier>&amp;</modifier><name>insecure_rand</name></argument>]</capture> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nRelayNodes</name> <operator>&amp;&amp;</operator> <name><name>best</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>first</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><name><name>best</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name><name>second</name><operator>-&gt;</operator><name>PushAddress</name></name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>insecure_rand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></lambda></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>ForEachNodeThen</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>sortfunc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>pushfunc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <specifier>static</specifier></type> <name>ProcessGetBlockData</name><parameter_list>(<parameter><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pfrom</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CChainParams</name><modifier>&amp;</modifier></type> <name>chainparams</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CInv</name><modifier>&amp;</modifier></type> <name>inv</name></decl></parameter>, <parameter><decl><type><name>CConnman</name><modifier>*</modifier></type> <name>connman</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>send</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CBlock</name></expr></argument>&gt;</argument_list></name></type> <name>a_recent_block</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CBlockHeaderAndShortTxIDs</name></expr></argument>&gt;</argument_list></name></type> <name>a_recent_compact_block</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>fWitnessesPresentInARecentCompactBlock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>Consensus</name><operator>::</operator><name>Params</name></name><modifier>&amp;</modifier></type> <name>consensusParams</name> <init>= <expr><call><name><name>chainparams</name><operator>.</operator><name>GetConsensus</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_most_recent_block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>a_recent_block</name> <operator>=</operator> <name>most_recent_block</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>a_recent_compact_block</name> <operator>=</operator> <name>most_recent_compact_block</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>fWitnessesPresentInARecentCompactBlock</name> <operator>=</operator> <name>fWitnessesPresentInMostRecentCompactBlock</name></expr>;</expr_stmt>
    </block_content>}</block>

    <decl_stmt><decl><type><name>bool</name></type> <name>need_activate_chain</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>CBlockIndex</name><modifier>*</modifier></type> <name>pindex</name> <init>= <expr><call><name>LookupBlockIndex</name><argument_list>(<argument><expr><name><name>inv</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>pindex</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>pindex</name><operator>-&gt;</operator><name>HaveTxsDownloaded</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>pindex</name><operator>-&gt;</operator><name>IsValid</name></name><argument_list>(<argument><expr><name>BLOCK_VALID_SCRIPTS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                    <call><name><name>pindex</name><operator>-&gt;</operator><name>IsValid</name></name><argument_list>(<argument><expr><name>BLOCK_VALID_TREE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <comment type="line">// If we have the block and all of its parents, but have not yet validated it,</comment>
                <comment type="line">// we might be in the middle of connecting it (ie in the unlock of cs_main</comment>
                <comment type="line">// before ActivateBestChain but after AcceptBlock).</comment>
                <comment type="line">// In this case, we need to run ActivateBestChain prior to checking the relay</comment>
                <comment type="line">// conditions below.</comment>
                <expr_stmt><expr><name>need_activate_chain</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block> <comment type="line">// release cs_main before calling ActivateBestChain</comment>
    <if_stmt><if>if <condition>(<expr><name>need_activate_chain</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>BlockValidationState</name></type> <name>state</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ActivateBestChain</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>Params</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>a_recent_block</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"failed to activate chain (%s)\n"</literal></expr></argument>, <argument><expr><call><name>FormatStateMessage</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CBlockIndex</name><modifier>*</modifier></type> <name>pindex</name> <init>= <expr><call><name>LookupBlockIndex</name><argument_list>(<argument><expr><name><name>inv</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>pindex</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>send</name> <operator>=</operator> <call><name>BlockRequestAllowed</name><argument_list>(<argument><expr><name>pindex</name></expr></argument>, <argument><expr><name>consensusParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>send</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"%s: ignoring request from peer=%i for old block that isn't in the main chain\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CNetMsgMaker</name></type> <name>msgMaker</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetSendVersion</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <comment type="line">// disconnect node in case we have reached the outbound limit for serving historical blocks</comment>
    <comment type="line">// never disconnect whitelisted nodes</comment>
    <if_stmt><if>if <condition>(<expr><name>send</name> <operator>&amp;&amp;</operator> <call><name><name>connman</name><operator>-&gt;</operator><name>OutboundTargetReached</name></name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator> <operator>(</operator><operator>(</operator><name>pindexBestHeader</name> <operator>!=</operator> <literal type="null">nullptr</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name><name>pindexBestHeader</name><operator>-&gt;</operator><name>GetBlockTime</name></name><argument_list>()</argument_list></call> <operator>-</operator> <call><name><name>pindex</name><operator>-&gt;</operator><name>GetBlockTime</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>HISTORICAL_BLOCK_AGE</name><operator>)</operator><operator>)</operator> <operator>||</operator> <name><name>inv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>MSG_FILTERED_BLOCK</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>pfrom</name><operator>-&gt;</operator><name>HasPermission</name></name><argument_list>(<argument><expr><name>PF_NOBAN</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"historical block serving limit reached, disconnect peer=%d\n"</literal></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">//disconnect node</comment>
        <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>send</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="line">// Avoid leaking prune-height by never sending blocks below the NODE_NETWORK_LIMITED threshold</comment>
    <if_stmt><if>if <condition>(<expr><name>send</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>pfrom</name><operator>-&gt;</operator><name>HasPermission</name></name><argument_list>(<argument><expr><name>PF_NOBAN</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator>
            <operator>(</operator><operator>(</operator><operator>(</operator><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetLocalServices</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>NODE_NETWORK_LIMITED</name><operator>)</operator> <operator>==</operator> <name>NODE_NETWORK_LIMITED</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetLocalServices</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>NODE_NETWORK</name><operator>)</operator> <operator>!=</operator> <name>NODE_NETWORK</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Tip</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>nHeight</name> <operator>-</operator> <name><name>pindex</name><operator>-&gt;</operator><name>nHeight</name></name> <operator>&gt;</operator> <operator>(</operator><name>int</name><operator>)</operator><name>NODE_NETWORK_LIMITED_MIN_BLOCKS</name> <operator>+</operator> <literal type="number">2</literal> <comment type="block">/* add two blocks buffer extension for possible races */</comment><operator>)</operator> <operator>)</operator>
       <operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"Ignore block request below NODE_NETWORK_LIMITED threshold from peer=%d\n"</literal></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">//disconnect node and prevent it from stalling (would otherwise wait for the missing block)</comment>
        <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>send</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="line">// Pruned nodes may have deleted the block, so check whether</comment>
    <comment type="line">// it's available before trying to send.</comment>
    <if_stmt><if>if <condition>(<expr><name>send</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pindex</name><operator>-&gt;</operator><name>nStatus</name></name> <operator>&amp;</operator> <name>BLOCK_HAVE_DATA</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CBlock</name></expr></argument>&gt;</argument_list></name></type> <name>pblock</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>a_recent_block</name> <operator>&amp;&amp;</operator> <call><name><name>a_recent_block</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>pindex</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>pblock</name> <operator>=</operator> <name>a_recent_block</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>inv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>MSG_WITNESS_BLOCK</name></expr>)</condition> <block>{<block_content>
            <comment type="line">// Fast-path: in this case it is possible to serve the block directly from disk,</comment>
            <comment type="line">// as the network format matches the format on disk</comment>
            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>uint8_t</name></expr></argument>&gt;</argument_list></name></type> <name>block_data</name></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReadRawBlockFromDisk</name><argument_list>(<argument><expr><name>block_data</name></expr></argument>, <argument><expr><name>pindex</name></expr></argument>, <argument><expr><call><name><name>chainparams</name><operator>.</operator><name>MessageStart</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><literal type="string">"cannot load block from disk"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>BLOCK</name></name></expr></argument>, <argument><expr><call><name>MakeSpan</name><argument_list>(<argument><expr><name>block_data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// Don't set pblock as we've sent the block</comment>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="line">// Send block from disk</comment>
            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CBlock</name></expr></argument>&gt;</argument_list></name></type> <name>pblockRead</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>make_shared</name><argument_list type="generic">&lt;<argument><expr><name>CBlock</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReadBlockFromDisk</name><argument_list>(<argument><expr><operator>*</operator><name>pblockRead</name></expr></argument>, <argument><expr><name>pindex</name></expr></argument>, <argument><expr><name>consensusParams</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><literal type="string">"cannot load block from disk"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>pblock</name> <operator>=</operator> <name>pblockRead</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>pblock</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>inv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>MSG_BLOCK</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name>SERIALIZE_TRANSACTION_NO_WITNESS</name></expr></argument>, <argument><expr><name><name>NetMsgType</name><operator>::</operator><name>BLOCK</name></name></expr></argument>, <argument><expr><operator>*</operator><name>pblock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name><name>inv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>MSG_WITNESS_BLOCK</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>BLOCK</name></name></expr></argument>, <argument><expr><operator>*</operator><name>pblock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name><name>inv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>MSG_FILTERED_BLOCK</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>bool</name></type> <name>sendMerkleBlock</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>CMerkleBlock</name></type> <name>merkleBlock</name></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name></name> <operator>!=</operator> <literal type="null">nullptr</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>cs_filter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>pfilter</name></name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>sendMerkleBlock</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>merkleBlock</name> <operator>=</operator> <call><name>CMerkleBlock</name><argument_list>(<argument><expr><operator>*</operator><name>pblock</name></expr></argument>, <argument><expr><operator>*</operator><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>pfilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>sendMerkleBlock</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>MERKLEBLOCK</name></name></expr></argument>, <argument><expr><name>merkleBlock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="line">// CMerkleBlock just contains hashes, so also push any transactions in the block the client did not see</comment>
                    <comment type="line">// This avoids hurting performance by pointlessly requiring a round-trip</comment>
                    <comment type="line">// Note that there is currently no way for a node to request any single transactions we didn't send here -</comment>
                    <comment type="line">// they must either disconnect and retry or request the full block.</comment>
                    <comment type="line">// Thus, the protocol spec specified allows for us to provide duplicate txn here,</comment>
                    <comment type="line">// however we MUST always provide at least what the remote peer needs</comment>
                    <typedef>typedef <type><name><name>std</name><operator>::</operator><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>int</name></expr></argument>, <argument><expr><name>uint256</name></expr></argument>&gt;</argument_list></name></type> <name>PairType</name>;</typedef>
                    <for>for <control>(<init><decl><type><name>PairType</name><modifier>&amp;</modifier></type> <name>pair</name> <range>: <expr><name><name>merkleBlock</name><operator>.</operator><name>vMatchedTxn</name></name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name>SERIALIZE_TRANSACTION_NO_WITNESS</name></expr></argument>, <argument><expr><name><name>NetMsgType</name><operator>::</operator><name>TX</name></name></expr></argument>, <argument><expr><operator>*</operator><name><name>pblock</name><operator>-&gt;</operator><name>vtx</name><index>[<expr><name><name>pair</name><operator>.</operator><name>first</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
                </block_content>}</block></if></if_stmt>
                <comment type="line">// else</comment>
                    <comment type="line">// no response</comment>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>inv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>MSG_CMPCT_BLOCK</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// If a peer is asking for old blocks, we're almost guaranteed</comment>
                <comment type="line">// they won't have a useful mempool to match against a compact block,</comment>
                <comment type="line">// and we don't feel like constructing the object for them, so</comment>
                <comment type="line">// instead we respond with the full, non-compact block.</comment>
                <decl_stmt><decl><type><name>bool</name></type> <name>fPeerWantsWitness</name> <init>= <expr><call><name>State</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fWantsCmpctWitness</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>nSendFlags</name> <init>= <expr><ternary><condition><expr><name>fPeerWantsWitness</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>SERIALIZE_TRANSACTION_NO_WITNESS</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>CanDirectFetch</name><argument_list>(<argument><expr><name>consensusParams</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pindex</name><operator>-&gt;</operator><name>nHeight</name></name> <operator>&gt;=</operator> <call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Height</name><argument_list>()</argument_list></call> <operator>-</operator> <name>MAX_CMPCTBLOCK_DEPTH</name></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>fPeerWantsWitness</name> <operator>||</operator> <operator>!</operator><name>fWitnessesPresentInARecentCompactBlock</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>a_recent_compact_block</name> <operator>&amp;&amp;</operator> <call><name><name>a_recent_compact_block</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>pindex</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name>nSendFlags</name></expr></argument>, <argument><expr><name><name>NetMsgType</name><operator>::</operator><name>CMPCTBLOCK</name></name></expr></argument>, <argument><expr><operator>*</operator><name>a_recent_compact_block</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <decl_stmt><decl><type><name>CBlockHeaderAndShortTxIDs</name></type> <name>cmpctblock</name><argument_list>(<argument><expr><operator>*</operator><name>pblock</name></expr></argument>, <argument><expr><name>fPeerWantsWitness</name></expr></argument>)</argument_list></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name>nSendFlags</name></expr></argument>, <argument><expr><name><name>NetMsgType</name><operator>::</operator><name>CMPCTBLOCK</name></name></expr></argument>, <argument><expr><name>cmpctblock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name>nSendFlags</name></expr></argument>, <argument><expr><name><name>NetMsgType</name><operator>::</operator><name>BLOCK</name></name></expr></argument>, <argument><expr><operator>*</operator><name>pblock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Trigger the peer node to send a getblocks request for the next batch of inventory</comment>
        <if_stmt><if>if <condition>(<expr><name><name>inv</name><operator>.</operator><name>hash</name></name> <operator>==</operator> <name><name>pfrom</name><operator>-&gt;</operator><name>hashContinue</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Bypass PushInventory, this must send even if redundant,</comment>
            <comment type="line">// and we want it right after the last block so they don't</comment>
            <comment type="line">// wait for other stuff first.</comment>
            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CInv</name></expr></argument>&gt;</argument_list></name></type> <name>vInv</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>vInv</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>CInv</name><argument_list>(<argument><expr><name>MSG_BLOCK</name></expr></argument>, <argument><expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Tip</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>GetBlockHash</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>INV</name></name></expr></argument>, <argument><expr><name>vInv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>hashContinue</name><operator>.</operator><name>SetNull</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><name>void</name> <specifier>static</specifier></type> <name>ProcessGetData</name><argument_list>(<argument><expr><name>CNode</name><operator>*</operator> <name>pfrom</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CChainParams</name><operator>&amp;</operator> <name>chainparams</name></expr></argument>, <argument><expr><name>CConnman</name><operator>*</operator> <name>connman</name></expr></argument>, <argument><expr><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>atomic</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>interruptMsgProc</name></expr></argument>)</argument_list> <name>LOCKS_EXCLUDED</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list>
<argument_list>{
    <argument><expr><call><name>AssertLockNotHeld</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr></argument>;

    <argument><expr><name><name>std</name><operator>::</operator><name>deque</name><argument_list type="generic">&lt;<argument><expr><name>CInv</name></expr></argument>&gt;</argument_list><operator>::</operator><name>iterator</name></name> <name>it</name> <operator>=</operator> <call><name><name>pfrom</name><operator>-&gt;</operator><name>vRecvGetData</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>;
    <argument><expr><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CInv</name></expr></argument>&gt;</argument_list></name> <name>vNotFound</name></expr></argument>;
    <argument><expr><specifier>const</specifier> <name>CNetMsgMaker</name> <call><name>msgMaker</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetSendVersion</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>;

    <comment type="line">// Note that if we receive a getdata for a MSG_TX or MSG_WITNESS_TX from a</comment>
    <comment type="line">// block-relay-only outbound peer, we will stop processing further getdata</comment>
    <comment type="line">// messages from this peer (likely resulting in our peer eventually</comment>
    <comment type="line">// disconnecting us).</comment>
    if <argument><expr><operator>(</operator><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name></name> <operator>!=</operator> <literal type="null">nullptr</literal><operator>)</operator> <block>{
        <comment type="line">// mempool entries added before this time have likely expired from mapRelay</comment>
        <expr><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>seconds</name></name> <name>longlived_mempool_time</name> <operator>=</operator> <call><name><name>GetTime</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>seconds</name></name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>-</operator> <name>RELAY_TX_CACHE_TIME</name></expr>;
        <expr><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>seconds</name></name> <name>mempool_req</name> <operator>=</operator> <call><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>m_last_mempool_req</name><operator>.</operator><name>load</name></name><argument_list>()</argument_list></call></expr>;

        <expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;

        <while>while <condition>(<expr><name>it</name> <operator>!=</operator> <call><name><name>pfrom</name><operator>-&gt;</operator><name>vRecvGetData</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>it</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>MSG_TX</name> <operator>||</operator> <name><name>it</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>MSG_WITNESS_TX</name><operator>)</operator></expr>)</condition> <expr_stmt><expr><block>{
            <if_stmt><if>if <condition>(<expr><name>interruptMsgProc</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return;</return></block_content></block></if></if_stmt></block></expr></expr_stmt></while>
            <comment type="line">// Don't bother if send buffer is too full to respond anyway</comment>
            <if_stmt><if>if <condition>(<expr><name><name>pfrom</name><operator>-&gt;</operator><name>fPauseSend</name></name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>

            <specifier>const</specifier> <name>CInv</name> <operator>&amp;</operator><name>inv</name> <operator>=</operator> <operator>*</operator><name>it</name></block></expr></argument>;
            <argument><expr><name>it</name><operator>++</operator></expr></argument>;

            <comment type="line">// Send stream from relay memory</comment>
            <argument><expr><name>bool</name> <name>push</name> <operator>=</operator> <literal type="boolean">false</literal></expr></argument>;
            <argument><expr><name>auto</name> <name>mi</name> <operator>=</operator> <call><name><name>mapRelay</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name><name>inv</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr></argument>;
            <argument><expr><name>int</name> <name>nSendFlags</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>inv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>MSG_TX</name></expr> ?</condition><then> <expr><name>SERIALIZE_TRANSACTION_NO_WITNESS</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>;
            if <argument><expr><operator>(</operator><name>mi</name> <operator>!=</operator> <call><name><name>mapRelay</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call><operator>)</operator> <block>{
                <expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name>nSendFlags</name></expr></argument>, <argument><expr><name><name>NetMsgType</name><operator>::</operator><name>TX</name></name></expr></argument>, <argument><expr><operator>*</operator><name><name>mi</name><operator>-&gt;</operator><name>second</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
                <expr><name>push</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;
            }</block></expr></argument> <if_stmt><else>else <expr_stmt><expr><block>{
                <expr><name>auto</name> <name>txinfo</name> <operator>=</operator> <call><name><name>mempool</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><name><name>inv</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</block></expr></expr_stmt></else></if_stmt></argument_list></decl></decl_stmt>
                <comment type="line">// To protect privacy, do not answer getdata using the mempool when</comment>
                <comment type="line">// that TX couldn't have been INVed in reply to a MEMPOOL request,</comment>
                <comment type="line">// or when it's too recent to have expired from mapRelay.</comment>
                <if_stmt><if>if <condition>(<expr><name><name>txinfo</name><operator>.</operator><name>tx</name></name> <operator>&amp;&amp;</operator> <operator>(</operator>
                     <operator>(</operator><call><name><name>mempool_req</name><operator>.</operator><name>count</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>txinfo</name><operator>.</operator><name>m_time</name></name> <operator>&lt;=</operator> <name>mempool_req</name><operator>)</operator>
                      <operator>||</operator> <operator>(</operator><name><name>txinfo</name><operator>.</operator><name>m_time</name></name> <operator>&lt;=</operator> <name>longlived_mempool_time</name><operator>)</operator><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name>nSendFlags</name></expr></argument>, <argument><expr><name><name>NetMsgType</name><operator>::</operator><name>TX</name></name></expr></argument>, <argument><expr><operator>*</operator><name><name>txinfo</name><operator>.</operator><name>tx</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>push</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            }
            if <expr_stmt><expr><operator>(</operator><operator>!</operator><name>push</name><operator>)</operator> <block>{
                <expr><call><name><name>vNotFound</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>inv</name></expr></argument>)</argument_list></call></expr>;
            }</block></expr></expr_stmt>
        }
    } <comment type="line">// release cs_main</comment>

    <if_stmt><if>if <condition>(<expr><name>it</name> <operator>!=</operator> <call><name><name>pfrom</name><operator>-&gt;</operator><name>vRecvGetData</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pfrom</name><operator>-&gt;</operator><name>fPauseSend</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>CInv</name> <modifier>&amp;</modifier></type><name>inv</name> <init>= <expr><operator>*</operator><name>it</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>inv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>MSG_BLOCK</name> <operator>||</operator> <name><name>inv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>MSG_FILTERED_BLOCK</name> <operator>||</operator> <name><name>inv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>MSG_CMPCT_BLOCK</name> <operator>||</operator> <name><name>inv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>MSG_WITNESS_BLOCK</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>it</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ProcessGetBlockData</name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><name>chainparams</name></expr></argument>, <argument><expr><name>inv</name></expr></argument>, <argument><expr><name>connman</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Unknown types in the GetData stay in vRecvGetData and block any future</comment>
    <comment type="line">// message from this peer, see vRecvGetData check in ProcessMessages().</comment>
    <comment type="line">// Depending on future p2p changes, we might either drop unknown getdata on</comment>
    <comment type="line">// the floor or disconnect the peer.</comment>

    <expr_stmt><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>vRecvGetData</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>vRecvGetData</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>vNotFound</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="line">// Let the peer know that we didn't find what it asked for, so it doesn't</comment>
        <comment type="line">// have to wait around forever.</comment>
        <comment type="line">// SPV clients care about this message: it's needed when they are</comment>
        <comment type="line">// recursively walking the dependencies of relevant unconfirmed</comment>
        <comment type="line">// transactions. SPV clients want to do that because they want to know</comment>
        <comment type="line">// about (and store and rebroadcast and risk analyze) the dependencies</comment>
        <comment type="line">// of transactions relevant to them, without having to download the</comment>
        <comment type="line">// entire memory pool.</comment>
        <comment type="line">// Also, other nodes can use these messages to automatically request a</comment>
        <comment type="line">// transaction from some other peer that annnounced it, and stop</comment>
        <comment type="line">// waiting for us to respond.</comment>
        <comment type="line">// In normal operation, we often send NOTFOUND messages for parents of</comment>
        <comment type="line">// transactions that we relay; if a peer is missing a parent, they may</comment>
        <comment type="line">// assume we have them and request the parents from us.</comment>
        <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>NOTFOUND</name></name></expr></argument>, <argument><expr><name>vNotFound</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
}

static <decl_stmt><decl><type><name>uint32_t</name></type> <name>GetFetchFlags</name><argument_list>(<argument><expr><name>CNode</name><operator>*</operator> <name>pfrom</name></expr></argument>)</argument_list> <name>EXCLUSIVE_LOCKS_REQUIRED</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list> <argument_list>{
    <argument><expr><name>uint32_t</name> <name>nFetchFlags</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>;
    if <argument><expr><operator>(</operator><operator>(</operator><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetLocalServices</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>NODE_WITNESS</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>State</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fHaveWitness</name><operator>)</operator> <block>{
        <expr><name>nFetchFlags</name> <operator>|=</operator> <name>MSG_WITNESS_FLAG</name></expr>;
    }</block></expr></argument>
    <return>return <expr><name>nFetchFlags</name></expr>;</return></argument_list></decl></decl_stmt>
}

inline <function><type><name>void</name> <specifier>static</specifier></type> <name>SendBlockTransactions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CBlock</name><modifier>&amp;</modifier></type> <name>block</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BlockTransactionsRequest</name><modifier>&amp;</modifier></type> <name>req</name></decl></parameter>, <parameter><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pfrom</name></decl></parameter>, <parameter><decl><type><name>CConnman</name><modifier>*</modifier></type> <name>connman</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>BlockTransactions</name></type> <name>resp</name><argument_list>(<argument><expr><name>req</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>req</name><operator>.</operator><name>indexes</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>req</name><operator>.</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <call><name><name>block</name><operator>.</operator><name>vtx</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Misbehaving</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"Peer %d sent us a getblocktxn with out-of-bounds tx indices"</literal></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>resp</name><operator>.</operator><name>txn</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>block</name><operator>.</operator><name>vtx</name><index>[<expr><name><name>req</name><operator>.</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CNetMsgMaker</name></type> <name>msgMaker</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetSendVersion</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nSendFlags</name> <init>= <expr><ternary><condition><expr><call><name>State</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fWantsCmpctWitness</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>SERIALIZE_TRANSACTION_NO_WITNESS</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name>nSendFlags</name></expr></argument>, <argument><expr><name><name>NetMsgType</name><operator>::</operator><name>BLOCKTXN</name></name></expr></argument>, <argument><expr><name>resp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name> <specifier>static</specifier></type> <name>ProcessHeadersMessage</name><parameter_list>(<parameter><decl><type><name>CNode</name> <modifier>*</modifier></type><name>pfrom</name></decl></parameter>, <parameter><decl><type><name>CConnman</name> <modifier>*</modifier></type><name>connman</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CBlockHeader</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>headers</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CChainParams</name><modifier>&amp;</modifier></type> <name>chainparams</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>via_compact_block</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CNetMsgMaker</name></type> <name>msgMaker</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetSendVersion</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>nCount</name> <init>= <expr><call><name><name>headers</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>nCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// Nothing interesting. Stop asking this peers for more headers.</comment>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>received_new_header</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CBlockIndex</name> <modifier>*</modifier></type><name>pindexLast</name> <init>= <expr><literal type="null">nullptr</literal></expr></init></decl>;</decl_stmt>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>CNodeState</name> <modifier>*</modifier></type><name>nodestate</name> <init>= <expr><call><name>State</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// If this looks like it could be a block announcement (nCount &lt;</comment>
        <comment type="line">// MAX_BLOCKS_TO_ANNOUNCE), use special logic for handling headers that</comment>
        <comment type="line">// don't connect:</comment>
        <comment type="line">// - Send a getheaders message in response to try to connect the chain.</comment>
        <comment type="line">// - The peer can send up to MAX_UNCONNECTING_HEADERS in a row that</comment>
        <comment type="line">//   don't connect before giving DoS points</comment>
        <comment type="line">// - Once a headers message is received that is valid and does connect,</comment>
        <comment type="line">//   nUnconnectingHeaders gets reset back to 0.</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LookupBlockIndex</name><argument_list>(<argument><expr><name><name>headers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>hashPrevBlock</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>nCount</name> <operator>&lt;</operator> <name>MAX_BLOCKS_TO_ANNOUNCE</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>nodestate</name><operator>-&gt;</operator><name>nUnconnectingHeaders</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>GETHEADERS</name></name></expr></argument>, <argument><expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetLocator</name><argument_list>(<argument><expr><name>pindexBestHeader</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>uint256</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"received header %s: missing prev block %s, sending getheaders (%d) to end (peer=%d, nUnconnectingHeaders=%d)\n"</literal></expr></argument>,
                    <argument><expr><name><name>headers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>GetHash</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ToString</name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><name><name>headers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name><name>hashPrevBlock</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><name><name>pindexBestHeader</name><operator>-&gt;</operator><name>nHeight</name></name></expr></argument>,
                    <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>nodestate</name><operator>-&gt;</operator><name>nUnconnectingHeaders</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// Set hashLastUnknownBlock for this peer, so that if we</comment>
            <comment type="line">// eventually get the headers - even from a different peer -</comment>
            <comment type="line">// we can use this peer to download.</comment>
            <expr_stmt><expr><call><name>UpdateBlockAvailability</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>headers</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetHash</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>nodestate</name><operator>-&gt;</operator><name>nUnconnectingHeaders</name></name> <operator>%</operator> <name>MAX_UNCONNECTING_HEADERS</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>Misbehaving</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>uint256</name></type> <name>hashLastBlock</name></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CBlockHeader</name><modifier>&amp;</modifier></type> <name>header</name> <range>: <expr><name>headers</name></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>hashLastBlock</name><operator>.</operator><name>IsNull</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>header</name><operator>.</operator><name>hashPrevBlock</name></name> <operator>!=</operator> <name>hashLastBlock</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>Misbehaving</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>, <argument><expr><literal type="string">"non-continuous headers sequence"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>hashLastBlock</name> <operator>=</operator> <call><name><name>header</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="line">// If we don't have the last header, then they'll have given us</comment>
        <comment type="line">// something new (if these headers are valid).</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LookupBlockIndex</name><argument_list>(<argument><expr><name>hashLastBlock</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>received_new_header</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <decl_stmt><decl><type><name>BlockValidationState</name></type> <name>state</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ProcessNewBlockHeaders</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>chainparams</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pindexLast</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>state</name><operator>.</operator><name>IsInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>MaybePunishNodeForBlock</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>via_compact_block</name></expr></argument>, <argument><expr><literal type="string">"invalid header received"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>CNodeState</name> <modifier>*</modifier></type><name>nodestate</name> <init>= <expr><call><name>State</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>nodestate</name><operator>-&gt;</operator><name>nUnconnectingHeaders</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"peer=%d: resetting nUnconnectingHeaders (%d -&gt; 0)\n"</literal></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>nodestate</name><operator>-&gt;</operator><name>nUnconnectingHeaders</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>nodestate</name><operator>-&gt;</operator><name>nUnconnectingHeaders</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pindexLast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UpdateBlockAvailability</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pindexLast</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// From here, pindexBestKnownBlock should be guaranteed to be non-null,</comment>
        <comment type="line">// because it is set in UpdateBlockAvailability. Some nullptr checks</comment>
        <comment type="line">// are still present, however, as belt-and-suspenders.</comment>

        <if_stmt><if>if <condition>(<expr><name>received_new_header</name> <operator>&amp;&amp;</operator> <name><name>pindexLast</name><operator>-&gt;</operator><name>nChainWork</name></name> <operator>&gt;</operator> <call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Tip</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>nChainWork</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>nodestate</name><operator>-&gt;</operator><name>m_last_block_announcement</name></name> <operator>=</operator> <call><name>GetTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>nCount</name> <operator>==</operator> <name>MAX_HEADERS_RESULTS</name></expr>)</condition> <block>{<block_content>
            <comment type="line">// Headers message had its maximum size; the peer may have more headers.</comment>
            <comment type="line">// TODO: optimize: if pindexLast is an ancestor of ::ChainActive().Tip or pindexBestHeader, continue</comment>
            <comment type="line">// from there instead.</comment>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"more getheaders (%d) to end to peer=%d (startheight:%d)\n"</literal></expr></argument>, <argument><expr><name><name>pindexLast</name><operator>-&gt;</operator><name>nHeight</name></name></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>pfrom</name><operator>-&gt;</operator><name>nStartingHeight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>GETHEADERS</name></name></expr></argument>, <argument><expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetLocator</name><argument_list>(<argument><expr><name>pindexLast</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>uint256</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>bool</name></type> <name>fCanDirectFetch</name> <init>= <expr><call><name>CanDirectFetch</name><argument_list>(<argument><expr><call><name><name>chainparams</name><operator>.</operator><name>GetConsensus</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// If this set of headers is valid and ends in a block with at least as</comment>
        <comment type="line">// much work as our tip, download as much as possible.</comment>
        <if_stmt><if>if <condition>(<expr><name>fCanDirectFetch</name> <operator>&amp;&amp;</operator> <call><name><name>pindexLast</name><operator>-&gt;</operator><name>IsValid</name></name><argument_list>(<argument><expr><name>BLOCK_VALID_TREE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Tip</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>nChainWork</name> <operator>&lt;=</operator> <name><name>pindexLast</name><operator>-&gt;</operator><name>nChainWork</name></name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CBlockIndex</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>vToFetch</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>CBlockIndex</name> <modifier>*</modifier></type><name>pindexWalk</name> <init>= <expr><name>pindexLast</name></expr></init></decl>;</decl_stmt>
            <comment type="line">// Calculate all the blocks we'd need to switch to pindexLast, up to a limit.</comment>
            <while>while <condition>(<expr><name>pindexWalk</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Contains</name><argument_list>(<argument><expr><name>pindexWalk</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>vToFetch</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>MAX_BLOCKS_IN_TRANSIT_PER_PEER</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>pindexWalk</name><operator>-&gt;</operator><name>nStatus</name></name> <operator>&amp;</operator> <name>BLOCK_HAVE_DATA</name><operator>)</operator> <operator>&amp;&amp;</operator>
                        <operator>!</operator><call><name><name>mapBlocksInFlight</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><call><name><name>pindexWalk</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                        <operator>(</operator><operator>!</operator><call><name>IsWitnessEnabled</name><argument_list>(<argument><expr><name><name>pindexWalk</name><operator>-&gt;</operator><name>pprev</name></name></expr></argument>, <argument><expr><call><name><name>chainparams</name><operator>.</operator><name>GetConsensus</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>State</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fHaveWitness</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                    <comment type="line">// We don't have this block, and it's not yet in flight.</comment>
                    <expr_stmt><expr><call><name><name>vToFetch</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>pindexWalk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>pindexWalk</name> <operator>=</operator> <name><name>pindexWalk</name><operator>-&gt;</operator><name>pprev</name></name></expr>;</expr_stmt>
            </block_content>}</block></while>
            <comment type="line">// If pindexWalk still isn't on our main chain, we're looking at a</comment>
            <comment type="line">// very large reorg at a time we think we're close to caught up to</comment>
            <comment type="line">// the main chain -- this shouldn't really happen.  Bail out on the</comment>
            <comment type="line">// direct fetch and rely on parallel download instead.</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Contains</name><argument_list>(<argument><expr><name>pindexWalk</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"Large reorg, won't direct fetch to %s (%d)\n"</literal></expr></argument>,
                        <argument><expr><call><name><name>pindexLast</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ToString</name><argument_list>()</argument_list></call></expr></argument>,
                        <argument><expr><name><name>pindexLast</name><operator>-&gt;</operator><name>nHeight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CInv</name></expr></argument>&gt;</argument_list></name></type> <name>vGetData</name></decl>;</decl_stmt>
                <comment type="line">// Download as much as possible, from earliest to latest.</comment>
                <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CBlockIndex</name> <modifier>*</modifier></type><name>pindex</name> <range>: <expr><call><name>reverse_iterate</name><argument_list>(<argument><expr><name>vToFetch</name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>nodestate</name><operator>-&gt;</operator><name>nBlocksInFlight</name></name> <operator>&gt;=</operator> <name>MAX_BLOCKS_IN_TRANSIT_PER_PEER</name></expr>)</condition> <block>{<block_content>
                        <comment type="line">// Can't download any more from this peer</comment>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                    <decl_stmt><decl><type><name>uint32_t</name></type> <name>nFetchFlags</name> <init>= <expr><call><name>GetFetchFlags</name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>vGetData</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>CInv</name><argument_list>(<argument><expr><name>MSG_BLOCK</name> <operator>|</operator> <name>nFetchFlags</name></expr></argument>, <argument><expr><call><name><name>pindex</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>MarkBlockAsInFlight</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pindex</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"Requesting block %s from  peer=%d\n"</literal></expr></argument>,
                            <argument><expr><call><name><name>pindex</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ToString</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
                <if_stmt><if>if <condition>(<expr><call><name><name>vGetData</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"Downloading blocks toward %s (%d) via headers direct fetch\n"</literal></expr></argument>,
                            <argument><expr><call><name><name>pindexLast</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ToString</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>pindexLast</name><operator>-&gt;</operator><name>nHeight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>vGetData</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>nodestate</name><operator>-&gt;</operator><name>fSupportsDesiredCmpctVersion</name></name> <operator>&amp;&amp;</operator> <call><name><name>vGetData</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name><name>mapBlocksInFlight</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name><name>pindexLast</name><operator>-&gt;</operator><name>pprev</name><operator>-&gt;</operator><name>IsValid</name></name><argument_list>(<argument><expr><name>BLOCK_VALID_CHAIN</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <comment type="line">// In any case, we want to download using a compact block, not a regular one</comment>
                        <expr_stmt><expr><name><name>vGetData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CInv</name><argument_list>(<argument><expr><name>MSG_CMPCT_BLOCK</name></expr></argument>, <argument><expr><name><name>vGetData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>GETDATA</name></name></expr></argument>, <argument><expr><name>vGetData</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="line">// If we're in IBD, we want outbound peers that will serve us a useful</comment>
        <comment type="line">// chain. Disconnect peers that are on chains with insufficient work.</comment>
        <if_stmt><if>if <condition>(<expr><call><name><operator>::</operator><name>ChainstateActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>IsInitialBlockDownload</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>nCount</name> <operator>!=</operator> <name>MAX_HEADERS_RESULTS</name></expr>)</condition> <block>{<block_content>
            <comment type="line">// When nCount &lt; MAX_HEADERS_RESULTS, we know we have no more</comment>
            <comment type="line">// headers to fetch from this peer.</comment>
            <if_stmt><if>if <condition>(<expr><name><name>nodestate</name><operator>-&gt;</operator><name>pindexBestKnownBlock</name></name> <operator>&amp;&amp;</operator> <name><name>nodestate</name><operator>-&gt;</operator><name>pindexBestKnownBlock</name><operator>-&gt;</operator><name>nChainWork</name></name> <operator>&lt;</operator> <name>nMinimumChainWork</name></expr>)</condition> <block>{<block_content>
                <comment type="line">// This peer has too little work on their headers chain to help</comment>
                <comment type="line">// us sync -- disconnect if using an outbound slot (unless</comment>
                <comment type="line">// whitelisted or addnode).</comment>
                <comment type="line">// Note: We compare their tip to nMinimumChainWork (rather than</comment>
                <comment type="line">// ::ChainActive().Tip()) because we won't start block download</comment>
                <comment type="line">// until we have a headers chain that has at least</comment>
                <comment type="line">// nMinimumChainWork, even if a peer has a chain past our tip,</comment>
                <comment type="line">// as an anti-DoS measure.</comment>
                <if_stmt><if>if <condition>(<expr><call><name>IsOutboundDisconnectionCandidate</name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"Disconnecting outbound peer %d -- headers chain has insufficient work\n"</literal></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pfrom</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>&amp;&amp;</operator> <call><name>IsOutboundDisconnectionCandidate</name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>nodestate</name><operator>-&gt;</operator><name>pindexBestKnownBlock</name></name> <operator>!=</operator> <literal type="null">nullptr</literal> <operator>&amp;&amp;</operator> <name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name></name> <operator>!=</operator> <literal type="null">nullptr</literal></expr>)</condition> <block>{<block_content>
            <comment type="line">// If this is an outbound full-relay peer, check to see if we should protect</comment>
            <comment type="line">// it from the bad/lagging chain logic.</comment>
            <comment type="line">// Note that block-relay-only peers are already implicitly protected, so we</comment>
            <comment type="line">// only consider setting m_protect for the full-relay peers.</comment>
            <if_stmt><if>if <condition>(<expr><name>g_outbound_peers_with_protect_from_disconnect</name> <operator>&lt;</operator> <name>MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT</name> <operator>&amp;&amp;</operator> <name><name>nodestate</name><operator>-&gt;</operator><name>pindexBestKnownBlock</name><operator>-&gt;</operator><name>nChainWork</name></name> <operator>&gt;=</operator> <call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Tip</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>nChainWork</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>nodestate</name><operator>-&gt;</operator><name>m_chain_sync</name><operator>.</operator><name>m_protect</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"Protecting outbound peer=%d from eviction\n"</literal></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nodestate</name><operator>-&gt;</operator><name>m_chain_sync</name><operator>.</operator><name>m_protect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt><expr><operator>++</operator><name>g_outbound_peers_with_protect_from_disconnect</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>void</name> <specifier>static</specifier></type> <name>ProcessOrphanTx</name><argument_list>(<argument><expr><name>CConnman</name><operator>*</operator> <name>connman</name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>orphan_work_set</name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>list</name><argument_list type="generic">&lt;<argument><expr><name>CTransactionRef</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>removed_txn</name></expr></argument>)</argument_list> <name>EXCLUSIVE_LOCKS_REQUIRED</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>, <argument><expr><name>g_cs_orphans</name></expr></argument>)</argument_list>
<argument_list>{
    <argument><expr><call><name>AssertLockHeld</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr></argument>;
    <argument><expr><call><name>AssertLockHeld</name><argument_list>(<argument><expr><name>g_cs_orphans</name></expr></argument>)</argument_list></call></expr></argument>;
    <argument><expr><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>NodeId</name></expr></argument>&gt;</argument_list></name> <name>setMisbehaving</name></expr></argument>;
    <argument><expr><name>bool</name> <name>done</name> <operator>=</operator> <literal type="boolean">false</literal></expr></argument>;
    while <argument><expr><operator>(</operator><operator>!</operator><name>done</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>orphan_work_set</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call><operator>)</operator> <block>{
        <expr><specifier>const</specifier> <name>uint256</name> <name>orphanHash</name> <operator>=</operator> <operator>*</operator><call><name><name>orphan_work_set</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;
        <expr><call><name><name>orphan_work_set</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><call><name><name>orphan_work_set</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;

        <expr><name>auto</name> <name>orphan_it</name> <operator>=</operator> <call><name><name>mapOrphanTransactions</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>orphanHash</name></expr></argument>)</argument_list></call></expr>;
        <if_stmt><if>if <condition>(<expr><name>orphan_it</name> <operator>==</operator> <call><name><name>mapOrphanTransactions</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

        <specifier>const</specifier> <name>CTransactionRef</name> <name>porphanTx</name> <operator>=</operator> <name><name>orphan_it</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>tx</name></name></block></expr></argument>;
        <argument><expr><specifier>const</specifier> <name>CTransaction</name><operator>&amp;</operator> <name>orphanTx</name> <operator>=</operator> <operator>*</operator><name>porphanTx</name></expr></argument>;
        <argument><expr><name>NodeId</name> <name>fromPeer</name> <operator>=</operator> <name><name>orphan_it</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>fromPeer</name></name></expr></argument>;
        <comment type="line">// Use a new TxValidationState because orphans come from different peers (and we call</comment>
        <comment type="line">// MaybePunishNodeForTx based on the source peer from the orphan map, not based on the peer</comment>
        <comment type="line">// that relayed the previous transaction).</comment>
        <argument><expr><name>TxValidationState</name> <name>orphan_state</name></expr></argument>;

        if <argument><expr><operator>(</operator><call><name><name>setMisbehaving</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>fromPeer</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument> <continue>continue;</continue></argument_list></decl></decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>AcceptToMemoryPool</name><argument_list>(<argument><expr><name>mempool</name></expr></argument>, <argument><expr><name>orphan_state</name></expr></argument>, <argument><expr><name>porphanTx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>removed_txn</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument> <comment type="block">/* bypass_limits */</comment>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* nAbsurdFee */</comment>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>MEMPOOL</name></name></expr></argument>, <argument><expr><literal type="string">"   accepted orphan tx %s\n"</literal></expr></argument>, <argument><expr><call><name><name>orphanHash</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RelayTransaction</name><argument_list>(<argument><expr><name>orphanHash</name></expr></argument>, <argument><expr><operator>*</operator><name>connman</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>orphanTx</name><operator>.</operator><name>vout</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>auto</name></type> <name>it_by_prev</name> <init>= <expr><call><name><name>mapOrphanTransactionsByPrev</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><call><name>COutPoint</name><argument_list>(<argument><expr><name>orphanHash</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>it_by_prev</name> <operator>!=</operator> <call><name><name>mapOrphanTransactionsByPrev</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>elem</name> <range>: <expr><name><name>it_by_prev</name><operator>-&gt;</operator><name>second</name></name></expr></range></decl></init>)</control> <block>{<block_content>
                        <expr_stmt><expr><call><name><name>orphan_work_set</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>EraseOrphanTx</name><argument_list>(<argument><expr><name>orphanHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>done</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>orphan_state</name><operator>.</operator><name>GetResult</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name><name>TxValidationResult</name><operator>::</operator><name>TX_MISSING_INPUTS</name></name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>orphan_state</name><operator>.</operator><name>IsInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <comment type="line">// Punish peer that gave us an invalid orphan tx</comment>
                <if_stmt><if>if <condition>(<expr><call><name>MaybePunishNodeForTx</name><argument_list>(<argument><expr><name>fromPeer</name></expr></argument>, <argument><expr><name>orphan_state</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>setMisbehaving</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>fromPeer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>MEMPOOL</name></name></expr></argument>, <argument><expr><literal type="string">"   invalid orphan tx %s\n"</literal></expr></argument>, <argument><expr><call><name><name>orphanHash</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="line">// Has inputs but not accepted to mempool</comment>
            <comment type="line">// Probably non-standard or insufficient fee</comment>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>MEMPOOL</name></name></expr></argument>, <argument><expr><literal type="string">"   removed orphan tx %s\n"</literal></expr></argument>, <argument><expr><call><name><name>orphanHash</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>orphanTx</name><operator>.</operator><name>HasWitness</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>orphan_state</name><operator>.</operator><name>GetResult</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name><name>TxValidationResult</name><operator>::</operator><name>TX_WITNESS_MUTATED</name></name></expr>)</condition> <block>{<block_content>
                <comment type="line">// Do not use rejection cache for witness transactions or</comment>
                <comment type="line">// witness-stripped transactions, as they can have been malleated.</comment>
                <comment type="line">// See https://github.com/bitcoin/bitcoin/issues/8279 for details.</comment>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>recentRejects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>recentRejects</name><operator>-&gt;</operator><name>insert</name></name><argument_list>(<argument><expr><name>orphanHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>EraseOrphanTx</name><argument_list>(<argument><expr><name>orphanHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>done</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>mempool</name><operator>.</operator><name>check</name></name><argument_list>(<argument><expr><operator>&amp;</operator><call><name><operator>::</operator><name>ChainstateActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>CoinsTip</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }
}

<function><type><name>bool</name> <specifier>static</specifier></type> <name>ProcessMessage</name><parameter_list>(<parameter><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pfrom</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>strCommand</name></decl></parameter>, <parameter><decl><type><name>CDataStream</name><modifier>&amp;</modifier></type> <name>vRecv</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>nTimeReceived</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CChainParams</name><modifier>&amp;</modifier></type> <name>chainparams</name></decl></parameter>, <parameter><decl><type><name>CConnman</name><modifier>*</modifier></type> <name>connman</name></decl></parameter>, <parameter><decl><type><name>BanMan</name><modifier>*</modifier></type> <name>banman</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>atomic</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>interruptMsgProc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"received: %s (%u bytes) peer=%d\n"</literal></expr></argument>, <argument><expr><call><name>SanitizeString</name><argument_list>(<argument><expr><name>strCommand</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>vRecv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>gArgs</name><operator>.</operator><name>IsArgSet</name></name><argument_list>(<argument><expr><literal type="string">"-dropmessagestest"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>GetRand</name><argument_list>(<argument><expr><call><name><name>gArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-dropmessagestest"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"dropmessagestest DROPPING RECV MESSAGE\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>


    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetLocalServices</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>NODE_BLOOM</name><operator>)</operator> <operator>&amp;&amp;</operator>
              <operator>(</operator><name>strCommand</name> <operator>==</operator> <name><name>NetMsgType</name><operator>::</operator><name>FILTERLOAD</name></name> <operator>||</operator>
               <name>strCommand</name> <operator>==</operator> <name><name>NetMsgType</name><operator>::</operator><name>FILTERADD</name></name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>pfrom</name><operator>-&gt;</operator><name>nVersion</name></name> <operator>&gt;=</operator> <name>NO_BLOOM_VERSION</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Misbehaving</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>strCommand</name> <operator>==</operator> <name><name>NetMsgType</name><operator>::</operator><name>VERSION</name></name></expr>)</condition> <block>{<block_content>
        <comment type="line">// Each connection can only send one version message</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pfrom</name><operator>-&gt;</operator><name>nVersion</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Misbehaving</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>int64_t</name></type> <name>nTime</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CAddress</name></type> <name>addrMe</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CAddress</name></type> <name>addrFrom</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>nNonce</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>nServiceInt</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ServiceFlags</name></type> <name>nServices</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nVersion</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nSendVersion</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>cleanSubVer</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nStartingHeight</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>fRelay</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>vRecv</name> <operator>&gt;&gt;</operator> <name>nVersion</name> <operator>&gt;&gt;</operator> <name>nServiceInt</name> <operator>&gt;&gt;</operator> <name>nTime</name> <operator>&gt;&gt;</operator> <name>addrMe</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nSendVersion</name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>min</name></name><argument_list>(<argument><expr><name>nVersion</name></expr></argument>, <argument><expr><name>PROTOCOL_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nServices</name> <operator>=</operator> <call><name>ServiceFlags</name><argument_list>(<argument><expr><name>nServiceInt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pfrom</name><operator>-&gt;</operator><name>fInbound</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>SetServices</name></name><argument_list>(<argument><expr><name><name>pfrom</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>nServices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pfrom</name><operator>-&gt;</operator><name>fInbound</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pfrom</name><operator>-&gt;</operator><name>fFeeler</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pfrom</name><operator>-&gt;</operator><name>m_manual_connection</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>HasAllDesirableServiceFlags</name><argument_list>(<argument><expr><name>nServices</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"peer=%d does not offer the expected services (%08x offered, %08x expected); disconnecting\n"</literal></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nServices</name></expr></argument>, <argument><expr><call><name>GetDesirableServiceFlags</name><argument_list>(<argument><expr><name>nServices</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>nVersion</name> <operator>&lt;</operator> <name>MIN_PEER_PROTO_VERSION</name></expr>)</condition> <block>{<block_content>
            <comment type="line">// disconnect from peers older than this proto version</comment>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"peer=%d using obsolete version %i; disconnecting\n"</literal></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>vRecv</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>vRecv</name> <operator>&gt;&gt;</operator> <name>addrFrom</name> <operator>&gt;&gt;</operator> <name>nNonce</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>vRecv</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>strSubVer</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>vRecv</name> <operator>&gt;&gt;</operator> <call><name>LIMITED_STRING</name><argument_list>(<argument><expr><name>strSubVer</name></expr></argument>, <argument><expr><name>MAX_SUBVERSION_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>cleanSubVer</name> <operator>=</operator> <call><name>SanitizeString</name><argument_list>(<argument><expr><name>strSubVer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>vRecv</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>vRecv</name> <operator>&gt;&gt;</operator> <name>nStartingHeight</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>vRecv</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>vRecv</name> <operator>&gt;&gt;</operator> <name>fRelay</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="line">// Disconnect if we connected to ourself</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pfrom</name><operator>-&gt;</operator><name>fInbound</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>connman</name><operator>-&gt;</operator><name>CheckIncomingNonce</name></name><argument_list>(<argument><expr><name>nNonce</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"connected to self at %s, disconnecting\n"</literal></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pfrom</name><operator>-&gt;</operator><name>fInbound</name></name> <operator>&amp;&amp;</operator> <call><name><name>addrMe</name><operator>.</operator><name>IsRoutable</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>SeenLocal</name><argument_list>(<argument><expr><name>addrMe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Be shy and don't send version until we hear</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pfrom</name><operator>-&gt;</operator><name>fInbound</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PushNodeVersion</name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><name>connman</name></expr></argument>, <argument><expr><call><name>GetAdjustedTime</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name>CNetMsgMaker</name><argument_list>(<argument><expr><name>INIT_PROTO_VERSION</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>Make</name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>VERACK</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>nServices</name></name> <operator>=</operator> <name>nServices</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>SetAddrLocal</name></name><argument_list>(<argument><expr><name>addrMe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pfrom</name><operator>-&gt;</operator><name>cs_SubVer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>cleanSubVer</name></name> <operator>=</operator> <name>cleanSubVer</name></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>nStartingHeight</name></name> <operator>=</operator> <name>nStartingHeight</name></expr>;</expr_stmt>

        <comment type="line">// set nodes not relaying blocks and tx and not serving (parts) of the historical blockchain as "clients"</comment>
        <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>fClient</name></name> <operator>=</operator> <operator>(</operator><operator>!</operator><operator>(</operator><name>nServices</name> <operator>&amp;</operator> <name>NODE_NETWORK</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>nServices</name> <operator>&amp;</operator> <name>NODE_NETWORK_LIMITED</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

        <comment type="line">// set nodes not capable of serving the complete blockchain history as "limited nodes"</comment>
        <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>m_limited_node</name></name> <operator>=</operator> <operator>(</operator><operator>!</operator><operator>(</operator><name>nServices</name> <operator>&amp;</operator> <name>NODE_NETWORK</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>nServices</name> <operator>&amp;</operator> <name>NODE_NETWORK_LIMITED</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name></name> <operator>!=</operator> <literal type="null">nullptr</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>cs_filter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>fRelayTxes</name></name> <operator>=</operator> <name>fRelay</name></expr>;</expr_stmt> <comment type="line">// set to true after we get the first filter* message</comment>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Change version</comment>
        <expr_stmt><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>SetSendVersion</name></name><argument_list>(<argument><expr><name>nSendVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>nVersion</name></name> <operator>=</operator> <name>nVersion</name></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><operator>(</operator><name>nServices</name> <operator>&amp;</operator> <name>NODE_WITNESS</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>State</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fHaveWitness</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Potentially mark this peer as a preferred download peer.</comment>
        <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UpdatePreferredDownload</name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name>State</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pfrom</name><operator>-&gt;</operator><name>fInbound</name></name> <operator>&amp;&amp;</operator> <call><name><name>pfrom</name><operator>-&gt;</operator><name>IsAddrRelayPeer</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Advertise our address</comment>
            <if_stmt><if>if <condition>(<expr><name>fListen</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><operator>::</operator><name>ChainstateActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>IsInitialBlockDownload</name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>CAddress</name></type> <name>addr</name> <init>= <expr><call><name>GetLocalAddress</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pfrom</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetLocalServices</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>FastRandomContext</name></type> <name>insecure_rand</name></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>addr</name><operator>.</operator><name>IsRoutable</name></name><argument_list>()</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"ProcessMessages: advertising address %s\n"</literal></expr></argument>, <argument><expr><call><name><name>addr</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>PushAddress</name></name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>insecure_rand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>IsPeerAddrLocalGood</name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>addr</name><operator>.</operator><name>SetIP</name></name><argument_list>(<argument><expr><name>addrMe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"ProcessMessages: advertising address %s\n"</literal></expr></argument>, <argument><expr><call><name><name>addr</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>PushAddress</name></name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>insecure_rand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Get recent addresses</comment>
            <if_stmt><if>if <condition>(<expr><name><name>pfrom</name><operator>-&gt;</operator><name>fOneShot</name></name> <operator>||</operator> <name><name>pfrom</name><operator>-&gt;</operator><name>nVersion</name></name> <operator>&gt;=</operator> <name>CADDR_TIME_VERSION</name> <operator>||</operator> <call><name><name>connman</name><operator>-&gt;</operator><name>GetAddressCount</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">1000</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name>CNetMsgMaker</name><argument_list>(<argument><expr><name>nSendVersion</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>Make</name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>GETADDR</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>fGetAddr</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>MarkAddressGood</name></name><argument_list>(<argument><expr><name><name>pfrom</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>remoteAddr</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>fLogIPs</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>remoteAddr</name> <operator>=</operator> <literal type="string">", peeraddr="</literal> <operator>+</operator> <call><name><name>pfrom</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"receive version message: %s: version %d, blocks=%d, us=%s, peer=%d%s\n"</literal></expr></argument>,
                  <argument><expr><name>cleanSubVer</name></expr></argument>, <argument><expr><name><name>pfrom</name><operator>-&gt;</operator><name>nVersion</name></name></expr></argument>,
                  <argument><expr><name><name>pfrom</name><operator>-&gt;</operator><name>nStartingHeight</name></name></expr></argument>, <argument><expr><call><name><name>addrMe</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>,
                  <argument><expr><name>remoteAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>int64_t</name></type> <name>nTimeOffset</name> <init>= <expr><name>nTime</name> <operator>-</operator> <call><name>GetTime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>nTimeOffset</name></name> <operator>=</operator> <name>nTimeOffset</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AddTimeData</name><argument_list>(<argument><expr><name><name>pfrom</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>nTimeOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// If the peer is old enough to have the old alert system, send it the final alert.</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pfrom</name><operator>-&gt;</operator><name>nVersion</name></name> <operator>&lt;=</operator> <literal type="number">70012</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>CDataStream</name></type> <name>finalAlert</name><argument_list>(<argument><expr><call><name>ParseHex</name><argument_list>(<argument><expr><literal type="string">"60010000000000000000000000ffffff7f00000000ffffff7ffeffff7f01ffffff7f00000000ffffff7f00ffffff7f002f555247454e543a20416c657274206b657920636f6d70726f6d697365642c2075706772616465207265717569726564004630440220653febd6410f470f6bae11cad19c48413becb1ac2c17f908fd0fd53bdc3abd5202206d0e9c96fe88d4a0f01ed9dedae2b6f9e00da94cad0fecaae66ecf689bf71b50"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SER_NETWORK</name></expr></argument>, <argument><expr><name>PROTOCOL_VERSION</name></expr></argument>)</argument_list></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name>CNetMsgMaker</name><argument_list>(<argument><expr><name>nSendVersion</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>Make</name><argument_list>(<argument><expr><literal type="string">"alert"</literal></expr></argument>, <argument><expr><name>finalAlert</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Feeler connections exist only to verify if address is online.</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pfrom</name><operator>-&gt;</operator><name>fFeeler</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pfrom</name><operator>-&gt;</operator><name>fInbound</name></name> <operator>==</operator> <literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pfrom</name><operator>-&gt;</operator><name>nVersion</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// Must have a version message before anything else</comment>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Misbehaving</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// At this point, the outgoing message serialization version can't change.</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CNetMsgMaker</name></type> <name>msgMaker</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetSendVersion</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>strCommand</name> <operator>==</operator> <name><name>NetMsgType</name><operator>::</operator><name>VERACK</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>SetRecvVersion</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>min</name></name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>nVersion</name><operator>.</operator><name>load</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PROTOCOL_VERSION</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pfrom</name><operator>-&gt;</operator><name>fInbound</name></name></expr>)</condition> <block>{<block_content>
            <comment type="line">// Mark this node as currently connected, so we update its timestamp later.</comment>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>State</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fCurrentlyConnected</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"New outbound peer connected: version: %d, blocks=%d, peer=%d%s (%s)\n"</literal></expr></argument>,
                      <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>nVersion</name><operator>.</operator><name>load</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>pfrom</name><operator>-&gt;</operator><name>nStartingHeight</name></name></expr></argument>,
                      <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>fLogIPs</name></expr> ?</condition><then> <expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">", peeraddr=%s"</literal></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
                      <argument><expr><ternary><condition><expr><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name></name> <operator>==</operator> <literal type="null">nullptr</literal></expr> ?</condition><then> <expr><literal type="string">"block-relay"</literal></expr> </then><else>: <expr><literal type="string">"full-relay"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pfrom</name><operator>-&gt;</operator><name>nVersion</name></name> <operator>&gt;=</operator> <name>SENDHEADERS_VERSION</name></expr>)</condition> <block>{<block_content>
            <comment type="line">// Tell our peer we prefer to receive headers rather than inv's</comment>
            <comment type="line">// We send this to non-NODE NETWORK peers as well, because even</comment>
            <comment type="line">// non-NODE NETWORK peers can announce blocks (such as pruning</comment>
            <comment type="line">// nodes)</comment>
            <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>SENDHEADERS</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>pfrom</name><operator>-&gt;</operator><name>nVersion</name></name> <operator>&gt;=</operator> <name>SHORT_IDS_BLOCKS_VERSION</name></expr>)</condition> <block>{<block_content>
            <comment type="line">// Tell our peer we are willing to provide version 1 or 2 cmpctblocks</comment>
            <comment type="line">// However, we do not request new block announcements using</comment>
            <comment type="line">// cmpctblock messages.</comment>
            <comment type="line">// We send this to non-NODE NETWORK peers as well, because</comment>
            <comment type="line">// they may wish to request compact blocks from us</comment>
            <decl_stmt><decl><type><name>bool</name></type> <name>fAnnounceUsingCMPCTBLOCK</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uint64_t</name></type> <name>nCMPCTBLOCKVersion</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetLocalServices</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>NODE_WITNESS</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>SENDCMPCT</name></name></expr></argument>, <argument><expr><name>fAnnounceUsingCMPCTBLOCK</name></expr></argument>, <argument><expr><name>nCMPCTBLOCKVersion</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>nCMPCTBLOCKVersion</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>SENDCMPCT</name></name></expr></argument>, <argument><expr><name>fAnnounceUsingCMPCTBLOCK</name></expr></argument>, <argument><expr><name>nCMPCTBLOCKVersion</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>fSuccessfullyConnected</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pfrom</name><operator>-&gt;</operator><name>fSuccessfullyConnected</name></name></expr>)</condition> <block>{<block_content>
        <comment type="line">// Must have a verack message before anything else</comment>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Misbehaving</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>strCommand</name> <operator>==</operator> <name><name>NetMsgType</name><operator>::</operator><name>ADDR</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CAddress</name></expr></argument>&gt;</argument_list></name></type> <name>vAddr</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>vRecv</name> <operator>&gt;&gt;</operator> <name>vAddr</name></expr>;</expr_stmt>

        <comment type="line">// Don't want addr from older versions unless seeding</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pfrom</name><operator>-&gt;</operator><name>nVersion</name> <argument_list type="generic">&lt; <argument><expr><name>CADDR_TIME_VERSION</name> <operator>&amp;&amp;</operator> <name><name>connman</name><operator>-&gt;</operator><name>GetAddressCount</name></name><operator>(</operator><operator>)</operator></expr></argument> &gt;</argument_list></name> <literal type="number">1000</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pfrom</name><operator>-&gt;</operator><name>IsAddrRelayPeer</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>vAddr</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1000</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Misbehaving</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>, <argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"message addr size() = %u"</literal></expr></argument>, <argument><expr><call><name><name>vAddr</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Store the new addresses</comment>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CAddress</name></expr></argument>&gt;</argument_list></name></type> <name>vAddrOk</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>nNow</name> <init>= <expr><call><name>GetAdjustedTime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>nSince</name> <init>= <expr><name>nNow</name> <operator>-</operator> <literal type="number">10</literal> <operator>*</operator> <literal type="number">60</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>CAddress</name><modifier>&amp;</modifier></type> <name>addr</name> <range>: <expr><name>vAddr</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>interruptMsgProc</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>

            <comment type="line">// We only bother storing full nodes, though this may include</comment>
            <comment type="line">// things which we would not make an outbound connection to, in</comment>
            <comment type="line">// part because we may make feeler connections to them.</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MayHaveUsefulAddressDB</name><argument_list>(<argument><expr><name><name>addr</name><operator>.</operator><name>nServices</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>HasAllDesirableServiceFlags</name><argument_list>(<argument><expr><name><name>addr</name><operator>.</operator><name>nServices</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>addr</name><operator>.</operator><name>nTime</name></name> <operator>&lt;=</operator> <literal type="number">100000000</literal> <operator>||</operator> <name><name>addr</name><operator>.</operator><name>nTime</name></name> <operator>&gt;</operator> <name>nNow</name> <operator>+</operator> <literal type="number">10</literal> <operator>*</operator> <literal type="number">60</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>addr</name><operator>.</operator><name>nTime</name></name> <operator>=</operator> <name>nNow</name> <operator>-</operator> <literal type="number">5</literal> <operator>*</operator> <literal type="number">24</literal> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">60</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>AddAddressKnown</name></name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>banman</name><operator>-&gt;</operator><name>IsBanned</name></name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt> <comment type="line">// Do not process banned addresses beyond remembering we received them</comment>
            <decl_stmt><decl><type><name>bool</name></type> <name>fReachable</name> <init>= <expr><call><name>IsReachable</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>addr</name><operator>.</operator><name>nTime</name></name> <operator>&gt;</operator> <name>nSince</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pfrom</name><operator>-&gt;</operator><name>fGetAddr</name></name> <operator>&amp;&amp;</operator> <call><name><name>vAddr</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <literal type="number">10</literal> <operator>&amp;&amp;</operator> <call><name><name>addr</name><operator>.</operator><name>IsRoutable</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Relay to a limited number of other nodes</comment>
                <expr_stmt><expr><call><name>RelayAddress</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>fReachable</name></expr></argument>, <argument><expr><name>connman</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="line">// Do not store addresses outside our network</comment>
            <if_stmt><if>if <condition>(<expr><name>fReachable</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>vAddrOk</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>AddNewAddresses</name></name><argument_list>(<argument><expr><name>vAddrOk</name></expr></argument>, <argument><expr><name><name>pfrom</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">60</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>vAddr</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">1000</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>fGetAddr</name></name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>pfrom</name><operator>-&gt;</operator><name>fOneShot</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>strCommand</name> <operator>==</operator> <name><name>NetMsgType</name><operator>::</operator><name>SENDHEADERS</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>State</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fPreferHeaders</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>strCommand</name> <operator>==</operator> <name><name>NetMsgType</name><operator>::</operator><name>SENDCMPCT</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type> <name>fAnnounceUsingCMPCTBLOCK</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>nCMPCTBLOCKVersion</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>vRecv</name> <operator>&gt;&gt;</operator> <name>fAnnounceUsingCMPCTBLOCK</name> <operator>&gt;&gt;</operator> <name>nCMPCTBLOCKVersion</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nCMPCTBLOCKVersion</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <operator>(</operator><operator>(</operator><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetLocalServices</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>NODE_WITNESS</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>nCMPCTBLOCKVersion</name> <operator>==</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// fProvidesHeaderAndIDs is used to "lock in" version of compact blocks we send (fWantsCmpctWitness)</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>State</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fProvidesHeaderAndIDs</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>State</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fProvidesHeaderAndIDs</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>State</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fWantsCmpctWitness</name> <operator>=</operator> <name>nCMPCTBLOCKVersion</name> <operator>==</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>State</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fWantsCmpctWitness</name> <operator>==</operator> <operator>(</operator><name>nCMPCTBLOCKVersion</name> <operator>==</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <comment type="line">// ignore later version announces</comment>
                <expr_stmt><expr><call><name>State</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fPreferHeaderAndIDs</name> <operator>=</operator> <name>fAnnounceUsingCMPCTBLOCK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>State</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fSupportsDesiredCmpctVersion</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetLocalServices</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>NODE_WITNESS</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>State</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fSupportsDesiredCmpctVersion</name> <operator>=</operator> <operator>(</operator><name>nCMPCTBLOCKVersion</name> <operator>==</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>State</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fSupportsDesiredCmpctVersion</name> <operator>=</operator> <operator>(</operator><name>nCMPCTBLOCKVersion</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>strCommand</name> <operator>==</operator> <name><name>NetMsgType</name><operator>::</operator><name>INV</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CInv</name></expr></argument>&gt;</argument_list></name></type> <name>vInv</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>vRecv</name> <operator>&gt;&gt;</operator> <name>vInv</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>vInv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>MAX_INV_SZ</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Misbehaving</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>, <argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"message inv size() = %u"</literal></expr></argument>, <argument><expr><call><name><name>vInv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// We won't accept tx inv's if we're in blocks-only mode, or this is a</comment>
        <comment type="line">// block-relay-only peer</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>fBlocksOnly</name> <init>= <expr><operator>!</operator><name>g_relay_txes</name> <operator>||</operator> <operator>(</operator><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name></name> <operator>==</operator> <literal type="null">nullptr</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

        <comment type="line">// Allow whitelisted peers to send data other than blocks in blocks only mode if whitelistrelay is true</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>HasPermission</name></name><argument_list>(<argument><expr><name>PF_RELAY</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>fBlocksOnly</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>uint32_t</name></type> <name>nFetchFlags</name> <init>= <expr><call><name>GetFetchFlags</name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>current_time</name> <init>= <expr><call><name><name>GetTime</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>microseconds</name></name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>CInv</name> <modifier>&amp;</modifier></type><name>inv</name> <range>: <expr><name>vInv</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>interruptMsgProc</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>

            <decl_stmt><decl><type><name>bool</name></type> <name>fAlreadyHave</name> <init>= <expr><call><name>AlreadyHave</name><argument_list>(<argument><expr><name>inv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"got inv: %s  %s peer=%d\n"</literal></expr></argument>, <argument><expr><call><name><name>inv</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><name>fAlreadyHave</name></expr> ?</condition><then> <expr><literal type="string">"have"</literal></expr> </then><else>: <expr><literal type="string">"new"</literal></expr></else></ternary></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>inv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>MSG_TX</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>inv</name><operator>.</operator><name>type</name></name> <operator>|=</operator> <name>nFetchFlags</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>inv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>MSG_BLOCK</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>UpdateBlockAvailability</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>inv</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fAlreadyHave</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>fImporting</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>fReindex</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>mapBlocksInFlight</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name><name>inv</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <comment type="line">// We used to request the full block here, but since headers-announcements are now the</comment>
                    <comment type="line">// primary method of announcement on the network, and since, in the case that a node</comment>
                    <comment type="line">// fell back to inv we probably have a reorg which we should get the headers for first,</comment>
                    <comment type="line">// we now only provide a getheaders response here. When we receive the headers, we will</comment>
                    <comment type="line">// then ask for the blocks we need.</comment>
                    <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>GETHEADERS</name></name></expr></argument>, <argument><expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetLocator</name><argument_list>(<argument><expr><name>pindexBestHeader</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>inv</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"getheaders (%d) %s to peer=%d\n"</literal></expr></argument>, <argument><expr><name><name>pindexBestHeader</name><operator>-&gt;</operator><name>nHeight</name></name></expr></argument>, <argument><expr><call><name><name>inv</name><operator>.</operator><name>hash</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>AddInventoryKnown</name></name><argument_list>(<argument><expr><name>inv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>fBlocksOnly</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"transaction (%s) inv sent in violation of protocol, disconnecting peer=%d\n"</literal></expr></argument>, <argument><expr><call><name><name>inv</name><operator>.</operator><name>hash</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>fAlreadyHave</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>fImporting</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>fReindex</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><operator>::</operator><name>ChainstateActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>IsInitialBlockDownload</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>RequestTx</name><argument_list>(<argument><expr><call><name>State</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>inv</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><name>current_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>strCommand</name> <operator>==</operator> <name><name>NetMsgType</name><operator>::</operator><name>GETDATA</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CInv</name></expr></argument>&gt;</argument_list></name></type> <name>vInv</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>vRecv</name> <operator>&gt;&gt;</operator> <name>vInv</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>vInv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>MAX_INV_SZ</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Misbehaving</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>, <argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"message getdata size() = %u"</literal></expr></argument>, <argument><expr><call><name><name>vInv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"received getdata (%u invsz) peer=%d\n"</literal></expr></argument>, <argument><expr><call><name><name>vInv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>vInv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"received getdata for: %s peer=%d\n"</literal></expr></argument>, <argument><expr><name><name>vInv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>ToString</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>vRecvGetData</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>vRecvGetData</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>vInv</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>vInv</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ProcessGetData</name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><name>chainparams</name></expr></argument>, <argument><expr><name>connman</name></expr></argument>, <argument><expr><name>interruptMsgProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>strCommand</name> <operator>==</operator> <name><name>NetMsgType</name><operator>::</operator><name>GETBLOCKS</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>CBlockLocator</name></type> <name>locator</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint256</name></type> <name>hashStop</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>vRecv</name> <operator>&gt;&gt;</operator> <name>locator</name> <operator>&gt;&gt;</operator> <name>hashStop</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>locator</name><operator>.</operator><name>vHave</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>MAX_LOCATOR_SZ</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"getblocks locator size %lld &gt; %d, disconnect peer=%d\n"</literal></expr></argument>, <argument><expr><call><name><name>locator</name><operator>.</operator><name>vHave</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>MAX_LOCATOR_SZ</name></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// We might have announced the currently-being-connected tip using a</comment>
        <comment type="line">// compact block, which resulted in the peer sending a getblocks</comment>
        <comment type="line">// request, which we would otherwise respond to without the new block.</comment>
        <comment type="line">// To avoid this situation we simply verify that we are on our best</comment>
        <comment type="line">// known chain now. This is super overkill, but we handle it better</comment>
        <comment type="line">// for getheaders requests, and there are no known nodes which support</comment>
        <comment type="line">// compact blocks but still use getblocks to request blocks.</comment>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CBlock</name></expr></argument>&gt;</argument_list></name></type> <name>a_recent_block</name></decl>;</decl_stmt>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_most_recent_block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>a_recent_block</name> <operator>=</operator> <name>most_recent_block</name></expr>;</expr_stmt>
            </block_content>}</block>
            <decl_stmt><decl><type><name>BlockValidationState</name></type> <name>state</name></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ActivateBestChain</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>Params</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>a_recent_block</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"failed to activate chain (%s)\n"</literal></expr></argument>, <argument><expr><call><name>FormatStateMessage</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>

        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Find the last block the caller has in the main chain</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>CBlockIndex</name><modifier>*</modifier></type> <name>pindex</name> <init>= <expr><call><name>FindForkInGlobalIndex</name><argument_list>(<argument><expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Send the rest of the chain</comment>
        <if_stmt><if>if <condition>(<expr><name>pindex</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>pindex</name> <operator>=</operator> <call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Next</name><argument_list>(<argument><expr><name>pindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nLimit</name> <init>= <expr><literal type="number">500</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"getblocks %d to %s limit %d from peer=%d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>pindex</name></expr> ?</condition><then> <expr><name><name>pindex</name><operator>-&gt;</operator><name>nHeight</name></name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><ternary><condition><expr><call><name><name>hashStop</name><operator>.</operator><name>IsNull</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"end"</literal></expr> </then><else>: <expr><call><name><name>hashStop</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr></argument>, <argument><expr><name>nLimit</name></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init>;</init> <condition><expr><name>pindex</name></expr>;</condition> <incr><expr><name>pindex</name> <operator>=</operator> <call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Next</name><argument_list>(<argument><expr><name>pindex</name></expr></argument>)</argument_list></call></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>pindex</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>hashStop</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"  getblocks stopping at %d %s\n"</literal></expr></argument>, <argument><expr><name><name>pindex</name><operator>-&gt;</operator><name>nHeight</name></name></expr></argument>, <argument><expr><call><name><name>pindex</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ToString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <comment type="line">// If pruning, don't inv blocks unless we have on disk and are likely to still have</comment>
            <comment type="line">// for some reasonable time window (1 hour) that block relay might require.</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nPrunedBlocksLikelyToHave</name> <init>= <expr><name>MIN_BLOCKS_TO_KEEP</name> <operator>-</operator> <literal type="number">3600</literal> <operator>/</operator> <call><name><name>chainparams</name><operator>.</operator><name>GetConsensus</name></name><argument_list>()</argument_list></call><operator>.</operator><name>nPowTargetSpacing</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>fPruneMode</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><operator>(</operator><name><name>pindex</name><operator>-&gt;</operator><name>nStatus</name></name> <operator>&amp;</operator> <name>BLOCK_HAVE_DATA</name><operator>)</operator> <operator>||</operator> <name><name>pindex</name><operator>-&gt;</operator><name>nHeight</name></name> <operator>&lt;=</operator> <call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Tip</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>nHeight</name> <operator>-</operator> <name>nPrunedBlocksLikelyToHave</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">" getblocks stopping, pruned or too old block at %d %s\n"</literal></expr></argument>, <argument><expr><name><name>pindex</name><operator>-&gt;</operator><name>nHeight</name></name></expr></argument>, <argument><expr><call><name><name>pindex</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ToString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>PushInventory</name></name><argument_list>(<argument><expr><call><name>CInv</name><argument_list>(<argument><expr><name>MSG_BLOCK</name></expr></argument>, <argument><expr><call><name><name>pindex</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>--</operator><name>nLimit</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// When this block is requested, we'll send an inv that'll</comment>
                <comment type="line">// trigger the peer to getblocks the next batch of inventory.</comment>
                <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"  getblocks stopping at limit %d %s\n"</literal></expr></argument>, <argument><expr><name><name>pindex</name><operator>-&gt;</operator><name>nHeight</name></name></expr></argument>, <argument><expr><call><name><name>pindex</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ToString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>hashContinue</name></name> <operator>=</operator> <call><name><name>pindex</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>strCommand</name> <operator>==</operator> <name><name>NetMsgType</name><operator>::</operator><name>GETBLOCKTXN</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>BlockTransactionsRequest</name></type> <name>req</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>vRecv</name> <operator>&gt;&gt;</operator> <name>req</name></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CBlock</name></expr></argument>&gt;</argument_list></name></type> <name>recent_block</name></decl>;</decl_stmt>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_most_recent_block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>most_recent_block_hash</name> <operator>==</operator> <name><name>req</name><operator>.</operator><name>blockhash</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>recent_block</name> <operator>=</operator> <name>most_recent_block</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="line">// Unlock cs_most_recent_block to avoid cs_main lock inversion</comment>
        </block_content>}</block>
        <if_stmt><if>if <condition>(<expr><name>recent_block</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>SendBlockTransactions</name><argument_list>(<argument><expr><operator>*</operator><name>recent_block</name></expr></argument>, <argument><expr><name>req</name></expr></argument>, <argument><expr><name>pfrom</name></expr></argument>, <argument><expr><name>connman</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><specifier>const</specifier> <name>CBlockIndex</name><modifier>*</modifier></type> <name>pindex</name> <init>= <expr><call><name>LookupBlockIndex</name><argument_list>(<argument><expr><name><name>req</name><operator>.</operator><name>blockhash</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pindex</name> <operator>||</operator> <operator>!</operator><operator>(</operator><name><name>pindex</name><operator>-&gt;</operator><name>nStatus</name></name> <operator>&amp;</operator> <name>BLOCK_HAVE_DATA</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"Peer %d sent us a getblocktxn for a block we don't have\n"</literal></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pindex</name><operator>-&gt;</operator><name>nHeight</name></name> <operator>&lt;</operator> <call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Height</name><argument_list>()</argument_list></call> <operator>-</operator> <name>MAX_BLOCKTXN_DEPTH</name></expr>)</condition> <block>{<block_content>
            <comment type="line">// If an older block is requested (should never happen in practice,</comment>
            <comment type="line">// but can happen in tests) send a block response instead of a</comment>
            <comment type="line">// blocktxn response. Sending a full block response instead of a</comment>
            <comment type="line">// small blocktxn response is preferable in the case where a peer</comment>
            <comment type="line">// might maliciously send lots of getblocktxn requests to trigger</comment>
            <comment type="line">// expensive disk reads, because it will require the peer to</comment>
            <comment type="line">// actually receive all the data read from disk over the network.</comment>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"Peer %d sent us a getblocktxn for a block &gt; %i deep\n"</literal></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>MAX_BLOCKTXN_DEPTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>CInv</name></type> <name>inv</name></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>inv</name><operator>.</operator><name>type</name></name> <operator>=</operator> <ternary><condition><expr><call><name>State</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fWantsCmpctWitness</name></expr> ?</condition><then> <expr><name>MSG_WITNESS_BLOCK</name></expr> </then><else>: <expr><name>MSG_BLOCK</name></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>inv</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name><name>req</name><operator>.</operator><name>blockhash</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>vRecvGetData</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>inv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// The message processing loop will go around again (without pausing) and we'll respond then (without cs_main)</comment>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>CBlock</name></type> <name>block</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><call><name>ReadBlockFromDisk</name><argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><name>pindex</name></expr></argument>, <argument><expr><call><name><name>chainparams</name><operator>.</operator><name>GetConsensus</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>SendBlockTransactions</name><argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><name>req</name></expr></argument>, <argument><expr><name>pfrom</name></expr></argument>, <argument><expr><name>connman</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>strCommand</name> <operator>==</operator> <name><name>NetMsgType</name><operator>::</operator><name>GETHEADERS</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>CBlockLocator</name></type> <name>locator</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint256</name></type> <name>hashStop</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>vRecv</name> <operator>&gt;&gt;</operator> <name>locator</name> <operator>&gt;&gt;</operator> <name>hashStop</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>locator</name><operator>.</operator><name>vHave</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>MAX_LOCATOR_SZ</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"getheaders locator size %lld &gt; %d, disconnect peer=%d\n"</literal></expr></argument>, <argument><expr><call><name><name>locator</name><operator>.</operator><name>vHave</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>MAX_LOCATOR_SZ</name></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><operator>::</operator><name>ChainstateActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>IsInitialBlockDownload</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>pfrom</name><operator>-&gt;</operator><name>HasPermission</name></name><argument_list>(<argument><expr><name>PF_NOBAN</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"Ignoring getheaders from peer=%d because node is in initial block download\n"</literal></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>CNodeState</name> <modifier>*</modifier></type><name>nodestate</name> <init>= <expr><call><name>State</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>CBlockIndex</name><modifier>*</modifier></type> <name>pindex</name> <init>= <expr><literal type="null">nullptr</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>locator</name><operator>.</operator><name>IsNull</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// If locator is null, return the hashStop block</comment>
            <expr_stmt><expr><name>pindex</name> <operator>=</operator> <call><name>LookupBlockIndex</name><argument_list>(<argument><expr><name>hashStop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pindex</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BlockRequestAllowed</name><argument_list>(<argument><expr><name>pindex</name></expr></argument>, <argument><expr><call><name><name>chainparams</name><operator>.</operator><name>GetConsensus</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"%s: ignoring request from peer=%i for old block header that isn't in the main chain\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// Find the last block the caller has in the main chain</comment>
            <expr_stmt><expr><name>pindex</name> <operator>=</operator> <call><name>FindForkInGlobalIndex</name><argument_list>(<argument><expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>pindex</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>pindex</name> <operator>=</operator> <call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Next</name><argument_list>(<argument><expr><name>pindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="line">// we must use CBlocks, as CBlockHeaders won't include the 0x00 nTx count at the end</comment>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CBlock</name></expr></argument>&gt;</argument_list></name></type> <name>vHeaders</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nLimit</name> <init>= <expr><name>MAX_HEADERS_RESULTS</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"getheaders %d to %s from peer=%d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>pindex</name></expr> ?</condition><then> <expr><name><name>pindex</name><operator>-&gt;</operator><name>nHeight</name></name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><ternary><condition><expr><call><name><name>hashStop</name><operator>.</operator><name>IsNull</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"end"</literal></expr> </then><else>: <expr><call><name><name>hashStop</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init>;</init> <condition><expr><name>pindex</name></expr>;</condition> <incr><expr><name>pindex</name> <operator>=</operator> <call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Next</name><argument_list>(<argument><expr><name>pindex</name></expr></argument>)</argument_list></call></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>vHeaders</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>pindex</name><operator>-&gt;</operator><name>GetBlockHeader</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>--</operator><name>nLimit</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name><name>pindex</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>hashStop</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <comment type="line">// pindex can be nullptr either if we sent ::ChainActive().Tip() OR</comment>
        <comment type="line">// if our peer has ::ChainActive().Tip() (and thus we are sending an empty</comment>
        <comment type="line">// headers message). In both cases it's safe to update</comment>
        <comment type="line">// pindexBestHeaderSent to be our tip.</comment>
        <comment type="line">//</comment>
        <comment type="line">// It is important that we simply reset the BestHeaderSent value here,</comment>
        <comment type="line">// and not max(BestHeaderSent, newHeaderSent). We might have announced</comment>
        <comment type="line">// the currently-being-connected tip using a compact block, which</comment>
        <comment type="line">// resulted in the peer sending a headers request, which we respond to</comment>
        <comment type="line">// without the new block. By resetting the BestHeaderSent, we ensure we</comment>
        <comment type="line">// will re-announce the new block via headers (or compact blocks again)</comment>
        <comment type="line">// in the SendMessages logic.</comment>
        <expr_stmt><expr><name><name>nodestate</name><operator>-&gt;</operator><name>pindexBestHeaderSent</name></name> <operator>=</operator> <ternary><condition><expr><name>pindex</name></expr> ?</condition><then> <expr><name>pindex</name></expr> </then><else>: <expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Tip</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>HEADERS</name></name></expr></argument>, <argument><expr><name>vHeaders</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>strCommand</name> <operator>==</operator> <name><name>NetMsgType</name><operator>::</operator><name>TX</name></name></expr>)</condition> <block>{<block_content>
        <comment type="line">// Stop processing the transaction early if</comment>
        <comment type="line">// We are in blocks only mode and peer is either not whitelisted or whitelistrelay is off</comment>
        <comment type="line">// or if this peer is supposed to be a block-relay-only peer</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>g_relay_txes</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>pfrom</name><operator>-&gt;</operator><name>HasPermission</name></name><argument_list>(<argument><expr><name>PF_RELAY</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name></name> <operator>==</operator> <literal type="null">nullptr</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"transaction sent in violation of protocol peer=%d\n"</literal></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>CTransactionRef</name></type> <name>ptx</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>vRecv</name> <operator>&gt;&gt;</operator> <name>ptx</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>CTransaction</name><modifier>&amp;</modifier></type> <name>tx</name> <init>= <expr><operator>*</operator><name>ptx</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>CInv</name></type> <name>inv</name><argument_list>(<argument><expr><name>MSG_TX</name></expr></argument>, <argument><expr><call><name><name>tx</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>AddInventoryKnown</name></name><argument_list>(<argument><expr><name>inv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>LOCK2</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>, <argument><expr><name>g_cs_orphans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>TxValidationState</name></type> <name>state</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>CNodeState</name><modifier>*</modifier></type> <name>nodestate</name> <init>= <expr><call><name>State</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>nodestate</name><operator>-&gt;</operator><name>m_tx_download</name><operator>.</operator><name>m_tx_announced</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name><name>inv</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>nodestate</name><operator>-&gt;</operator><name>m_tx_download</name><operator>.</operator><name>m_tx_in_flight</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name><name>inv</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>EraseTxRequest</name><argument_list>(<argument><expr><name><name>inv</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>list</name><argument_list type="generic">&lt;<argument><expr><name>CTransactionRef</name></expr></argument>&gt;</argument_list></name></type> <name>lRemovedTxn</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AlreadyHave</name><argument_list>(<argument><expr><name>inv</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>AcceptToMemoryPool</name><argument_list>(<argument><expr><name>mempool</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>ptx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lRemovedTxn</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument> <comment type="block">/* bypass_limits */</comment>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* nAbsurdFee */</comment>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>mempool</name><operator>.</operator><name>check</name></name><argument_list>(<argument><expr><operator>&amp;</operator><call><name><operator>::</operator><name>ChainstateActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>CoinsTip</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RelayTransaction</name><argument_list>(<argument><expr><call><name><name>tx</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>connman</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>tx</name><operator>.</operator><name>vout</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>auto</name></type> <name>it_by_prev</name> <init>= <expr><call><name><name>mapOrphanTransactionsByPrev</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><call><name>COutPoint</name><argument_list>(<argument><expr><name><name>inv</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>it_by_prev</name> <operator>!=</operator> <call><name><name>mapOrphanTransactionsByPrev</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>elem</name> <range>: <expr><name><name>it_by_prev</name><operator>-&gt;</operator><name>second</name></name></expr></range></decl></init>)</control> <block>{<block_content>
                        <expr_stmt><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>orphan_work_set</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>nLastTXTime</name></name> <operator>=</operator> <call><name>GetTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>MEMPOOL</name></name></expr></argument>, <argument><expr><literal type="string">"AcceptToMemoryPool: peer=%d: accepted %s (poolsz %u txn, %u kB)\n"</literal></expr></argument>,
                <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>,
                <argument><expr><call><name><name>tx</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ToString</name><argument_list>()</argument_list></call></expr></argument>,
                <argument><expr><call><name><name>mempool</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>mempool</name><operator>.</operator><name>DynamicMemoryUsage</name></name><argument_list>()</argument_list></call> <operator>/</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Recursively process any orphan transactions that depended on this one</comment>
            <expr_stmt><expr><call><name>ProcessOrphanTx</name><argument_list>(<argument><expr><name>connman</name></expr></argument>, <argument><expr><name><name>pfrom</name><operator>-&gt;</operator><name>orphan_work_set</name></name></expr></argument>, <argument><expr><name>lRemovedTxn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name><name>state</name><operator>.</operator><name>GetResult</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>TxValidationResult</name><operator>::</operator><name>TX_MISSING_INPUTS</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type> <name>fRejectedParents</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt> <comment type="line">// It may be the case that the orphans parents have all been rejected</comment>
            <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CTxIn</name><modifier>&amp;</modifier></type> <name>txin</name> <range>: <expr><name><name>tx</name><operator>.</operator><name>vin</name></name></expr></range></decl></init>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>recentRejects</name><operator>-&gt;</operator><name>contains</name></name><argument_list>(<argument><expr><name><name>txin</name><operator>.</operator><name>prevout</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>fRejectedParents</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fRejectedParents</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>uint32_t</name></type> <name>nFetchFlags</name> <init>= <expr><call><name>GetFetchFlags</name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>current_time</name> <init>= <expr><call><name><name>GetTime</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>microseconds</name></name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CTxIn</name><modifier>&amp;</modifier></type> <name>txin</name> <range>: <expr><name><name>tx</name><operator>.</operator><name>vin</name></name></expr></range></decl></init>)</control> <block>{<block_content>
                    <decl_stmt><decl><type><name>CInv</name></type> <name>_inv</name><argument_list>(<argument><expr><name>MSG_TX</name> <operator>|</operator> <name>nFetchFlags</name></expr></argument>, <argument><expr><name><name>txin</name><operator>.</operator><name>prevout</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>AddInventoryKnown</name></name><argument_list>(<argument><expr><name>_inv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AlreadyHave</name><argument_list>(<argument><expr><name>_inv</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RequestTx</name><argument_list>(<argument><expr><call><name>State</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>_inv</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><name>current_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><call><name>AddOrphanTx</name><argument_list>(<argument><expr><name>ptx</name></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// DoS prevention: do not allow mapOrphanTransactions to grow unbounded (see CVE-2012-3789)</comment>
                <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nMaxOrphanTx</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name><name>std</name><operator>::</operator><name>max</name></name><argument_list>(<argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>gArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-maxorphantx"</literal></expr></argument>, <argument><expr><name>DEFAULT_MAX_ORPHAN_TRANSACTIONS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nEvicted</name> <init>= <expr><call><name>LimitOrphanTxSize</name><argument_list>(<argument><expr><name>nMaxOrphanTx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>nEvicted</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>MEMPOOL</name></name></expr></argument>, <argument><expr><literal type="string">"mapOrphan overflow, removed %u tx\n"</literal></expr></argument>, <argument><expr><name>nEvicted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>MEMPOOL</name></name></expr></argument>, <argument><expr><literal type="string">"not keeping orphan with rejected parents %s\n"</literal></expr></argument>,<argument><expr><call><name><name>tx</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ToString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// We will continue to reject this tx since it has rejected</comment>
                <comment type="line">// parents so avoid re-requesting it from other peers.</comment>
                <expr_stmt><expr><call><name><name>recentRejects</name><operator>-&gt;</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>tx</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>tx</name><operator>.</operator><name>HasWitness</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>state</name><operator>.</operator><name>GetResult</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name><name>TxValidationResult</name><operator>::</operator><name>TX_WITNESS_MUTATED</name></name></expr>)</condition> <block>{<block_content>
                <comment type="line">// Do not use rejection cache for witness transactions or</comment>
                <comment type="line">// witness-stripped transactions, as they can have been malleated.</comment>
                <comment type="line">// See https://github.com/bitcoin/bitcoin/issues/8279 for details.</comment>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>recentRejects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>recentRejects</name><operator>-&gt;</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>tx</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>RecursiveDynamicUsage</name><argument_list>(<argument><expr><operator>*</operator><name>ptx</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">100000</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>AddToCompactExtraTransactions</name><argument_list>(<argument><expr><name>ptx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>tx</name><operator>.</operator><name>HasWitness</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RecursiveDynamicUsage</name><argument_list>(<argument><expr><operator>*</operator><name>ptx</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">100000</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>AddToCompactExtraTransactions</name><argument_list>(<argument><expr><name>ptx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>HasPermission</name></name><argument_list>(<argument><expr><name>PF_FORCERELAY</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <comment type="line">// Always relay transactions received from whitelisted peers, even</comment>
                <comment type="line">// if they were already in the mempool or rejected from it due</comment>
                <comment type="line">// to policy, allowing the node to function as a gateway for</comment>
                <comment type="line">// nodes hidden behind it.</comment>
                <comment type="line">//</comment>
                <comment type="line">// Never relay transactions that might result in being</comment>
                <comment type="line">// disconnected (or banned).</comment>
                <if_stmt><if>if <condition>(<expr><call><name><name>state</name><operator>.</operator><name>IsInvalid</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>TxRelayMayResultInDisconnect</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"Not relaying invalid transaction %s from whitelisted peer=%d (%s)\n"</literal></expr></argument>, <argument><expr><call><name><name>tx</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ToString</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>FormatStateMessage</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"Force relaying tx %s from whitelisted peer=%d\n"</literal></expr></argument>, <argument><expr><call><name><name>tx</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ToString</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>RelayTransaction</name><argument_list>(<argument><expr><call><name><name>tx</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>connman</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CTransactionRef</name><modifier>&amp;</modifier></type> <name>removedTx</name> <range>: <expr><name>lRemovedTxn</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>AddToCompactExtraTransactions</name><argument_list>(<argument><expr><name>removedTx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

        <comment type="line">// If a tx has been detected by recentRejects, we will have reached</comment>
        <comment type="line">// this point and the tx will have been ignored. Because we haven't run</comment>
        <comment type="line">// the tx through AcceptToMemoryPool, we won't have computed a DoS</comment>
        <comment type="line">// score for it or determined exactly why we consider it invalid.</comment>
        <comment type="line">//</comment>
        <comment type="line">// This means we won't penalize any peer subsequently relaying a DoSy</comment>
        <comment type="line">// tx (even if we penalized the first peer who gave it to us) because</comment>
        <comment type="line">// we have to account for recentRejects showing false positives. In</comment>
        <comment type="line">// other words, we shouldn't penalize a peer if we aren't *sure* they</comment>
        <comment type="line">// submitted a DoSy tx.</comment>
        <comment type="line">//</comment>
        <comment type="line">// Note that recentRejects doesn't just record DoSy or invalid</comment>
        <comment type="line">// transactions, but any tx not accepted by the mempool, which may be</comment>
        <comment type="line">// due to node policy (vs. consensus). So we can't blanket penalize a</comment>
        <comment type="line">// peer simply for relaying a tx that our recentRejects has caught,</comment>
        <comment type="line">// regardless of false positives.</comment>

        <if_stmt><if>if <condition>(<expr><call><name><name>state</name><operator>.</operator><name>IsInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>MEMPOOLREJ</name></name></expr></argument>, <argument><expr><literal type="string">"%s from peer=%d was not accepted: %s\n"</literal></expr></argument>, <argument><expr><call><name><name>tx</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ToString</name><argument_list>()</argument_list></call></expr></argument>,
                <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>,
                <argument><expr><call><name>FormatStateMessage</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MaybePunishNodeForTx</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>strCommand</name> <operator>==</operator> <name><name>NetMsgType</name><operator>::</operator><name>CMPCTBLOCK</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// Ignore cmpctblock received while importing</comment>
        <if_stmt><if>if <condition>(<expr><name>fImporting</name> <operator>||</operator> <name>fReindex</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"Unexpected cmpctblock message received from peer %d\n"</literal></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>CBlockHeaderAndShortTxIDs</name></type> <name>cmpctblock</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>vRecv</name> <operator>&gt;&gt;</operator> <name>cmpctblock</name></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>bool</name></type> <name>received_new_header</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>

        <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LookupBlockIndex</name><argument_list>(<argument><expr><name><name>cmpctblock</name><operator>.</operator><name>header</name><operator>.</operator><name>hashPrevBlock</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="line">// Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><operator>::</operator><name>ChainstateActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>IsInitialBlockDownload</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>GETHEADERS</name></name></expr></argument>, <argument><expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetLocator</name><argument_list>(<argument><expr><name>pindexBestHeader</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>uint256</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LookupBlockIndex</name><argument_list>(<argument><expr><call><name><name>cmpctblock</name><operator>.</operator><name>header</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>received_new_header</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        </block_content>}</block>

        <decl_stmt><decl><type><specifier>const</specifier> <name>CBlockIndex</name> <modifier>*</modifier></type><name>pindex</name> <init>= <expr><literal type="null">nullptr</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BlockValidationState</name></type> <name>state</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ProcessNewBlockHeaders</name><argument_list>(<argument><expr><block>{<expr><name><name>cmpctblock</name><operator>.</operator><name>header</name></name></expr>}</block></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>chainparams</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pindex</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>state</name><operator>.</operator><name>IsInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>MaybePunishNodeForBlock</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>state</name></expr></argument>, <comment type="block">/*via_compact_block*/</comment> <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"invalid header via cmpctblock"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// When we succeed in decoding a block's txids from a cmpctblock</comment>
        <comment type="line">// message we typically jump to the BLOCKTXN handling code, with a</comment>
        <comment type="line">// dummy (empty) BLOCKTXN message, to re-use the logic there in</comment>
        <comment type="line">// completing processing of the putative block (without cs_main).</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>fProcessBLOCKTXN</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CDataStream</name></type> <name>blockTxnMsg</name><argument_list>(<argument><expr><name>SER_NETWORK</name></expr></argument>, <argument><expr><name>PROTOCOL_VERSION</name></expr></argument>)</argument_list></decl>;</decl_stmt>

        <comment type="line">// If we end up treating this as a plain headers message, call that as well</comment>
        <comment type="line">// without cs_main.</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>fRevertToHeaderProcessing</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>

        <comment type="line">// Keep a CBlock for "optimistic" compactblock reconstructions (see</comment>
        <comment type="line">// below)</comment>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CBlock</name></expr></argument>&gt;</argument_list></name></type> <name>pblock</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>make_shared</name><argument_list type="generic">&lt;<argument><expr><name>CBlock</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>fBlockReconstructed</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>

        <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK2</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>, <argument><expr><name>g_cs_orphans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// If AcceptBlockHeader returned true, it set pindex</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UpdateBlockAvailability</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pindex</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>CNodeState</name> <modifier>*</modifier></type><name>nodestate</name> <init>= <expr><call><name>State</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// If this was a new header with more work than our tip, update the</comment>
        <comment type="line">// peer's last block announcement time</comment>
        <if_stmt><if>if <condition>(<expr><name>received_new_header</name> <operator>&amp;&amp;</operator> <name><name>pindex</name><operator>-&gt;</operator><name>nChainWork</name></name> <operator>&gt;</operator> <call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Tip</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>nChainWork</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>nodestate</name><operator>-&gt;</operator><name>m_last_block_announcement</name></name> <operator>=</operator> <call><name>GetTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>NodeId</name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>list</name><argument_list type="generic">&lt;<argument><expr><name>QueuedBlock</name></expr></argument>&gt;</argument_list><operator>::</operator><name>iterator</name></name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list><operator>::</operator><name>iterator</name></name></type> <name>blockInFlightIt</name> <init>= <expr><call><name><name>mapBlocksInFlight</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><call><name><name>pindex</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>fAlreadyInFlight</name> <init>= <expr><name>blockInFlightIt</name> <operator>!=</operator> <call><name><name>mapBlocksInFlight</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pindex</name><operator>-&gt;</operator><name>nStatus</name></name> <operator>&amp;</operator> <name>BLOCK_HAVE_DATA</name></expr>)</condition><block type="pseudo"><block_content> <comment type="line">// Nothing to do here</comment>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pindex</name><operator>-&gt;</operator><name>nChainWork</name></name> <operator>&lt;=</operator> <call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Tip</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>nChainWork</name> <operator>||</operator> <comment type="line">// We know something better</comment>
                <name><name>pindex</name><operator>-&gt;</operator><name>nTx</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <comment type="line">// We had this block at some point, but pruned it</comment>
            <if_stmt><if>if <condition>(<expr><name>fAlreadyInFlight</name></expr>)</condition> <block>{<block_content>
                <comment type="line">// We requested this block for some reason, but our mempool will probably be useless</comment>
                <comment type="line">// so we just grab the block via normal getdata</comment>
                <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CInv</name></expr></argument>&gt;</argument_list></name></type> <name>vInv</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>vInv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CInv</name><argument_list>(<argument><expr><name>MSG_BLOCK</name> <operator>|</operator> <call><name>GetFetchFlags</name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>cmpctblock</name><operator>.</operator><name>header</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>GETDATA</name></name></expr></argument>, <argument><expr><name>vInv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// If we're not close to tip yet, give up and let parallel block fetch work its magic</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fAlreadyInFlight</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>CanDirectFetch</name><argument_list>(<argument><expr><call><name><name>chainparams</name><operator>.</operator><name>GetConsensus</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>IsWitnessEnabled</name><argument_list>(<argument><expr><name><name>pindex</name><operator>-&gt;</operator><name>pprev</name></name></expr></argument>, <argument><expr><call><name><name>chainparams</name><operator>.</operator><name>GetConsensus</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>nodestate</name><operator>-&gt;</operator><name>fSupportsDesiredCmpctVersion</name></name></expr>)</condition> <block>{<block_content>
            <comment type="line">// Don't bother trying to process compact blocks from v1 peers</comment>
            <comment type="line">// after segwit activates.</comment>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// We want to be a bit conservative just to be extra careful about DoS</comment>
        <comment type="line">// possibilities in compact block processing...</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pindex</name><operator>-&gt;</operator><name>nHeight</name></name> <operator>&lt;=</operator> <call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Height</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>fAlreadyInFlight</name> <operator>&amp;&amp;</operator> <name><name>nodestate</name><operator>-&gt;</operator><name>nBlocksInFlight</name></name> <operator>&lt;</operator> <name>MAX_BLOCKS_IN_TRANSIT_PER_PEER</name><operator>)</operator> <operator>||</operator>
                 <operator>(</operator><name>fAlreadyInFlight</name> <operator>&amp;&amp;</operator> <name><name>blockInFlightIt</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>first</name></name> <operator>==</operator> <call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>list</name><argument_list type="generic">&lt;<argument><expr><name>QueuedBlock</name></expr></argument>&gt;</argument_list><operator>::</operator><name>iterator</name></name><modifier>*</modifier></type> <name>queuedBlockIt</name> <init>= <expr><literal type="null">nullptr</literal></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MarkBlockAsInFlight</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pindex</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pindex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>queuedBlockIt</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><operator>(</operator><operator>*</operator><name>queuedBlockIt</name><operator>)</operator><operator>-&gt;</operator><name>partialBlock</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name><operator>(</operator><operator>*</operator><name>queuedBlockIt</name><operator>)</operator><operator>-&gt;</operator><name><name>partialBlock</name><operator>.</operator><name>reset</name></name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>PartiallyDownloadedBlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mempool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <else>else <block>{<block_content>
                        <comment type="line">// The block was already in flight using compact blocks from the same peer</comment>
                        <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"Peer sent us compact block we were already syncing!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>

                <decl_stmt><decl><type><name>PartiallyDownloadedBlock</name><modifier>&amp;</modifier></type> <name>partialBlock</name> <init>= <expr><operator>*</operator><name><operator>(</operator><operator>*</operator><name>queuedBlockIt</name><operator>)</operator><operator>-&gt;</operator><name>partialBlock</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ReadStatus</name></type> <name>status</name> <init>= <expr><call><name><name>partialBlock</name><operator>.</operator><name>InitData</name></name><argument_list>(<argument><expr><name>cmpctblock</name></expr></argument>, <argument><expr><name>vExtraTxnForCompact</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>READ_STATUS_INVALID</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>MarkBlockAsReceived</name><argument_list>(<argument><expr><call><name><name>pindex</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Reset in-flight state in case of whitelist</comment>
                    <expr_stmt><expr><call><name>Misbehaving</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"Peer %d sent us invalid compact block\n"</literal></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>status</name> <operator>==</operator> <name>READ_STATUS_FAILED</name></expr>)</condition> <block>{<block_content>
                    <comment type="line">// Duplicate txindexes, the block is now in-flight, so just request it</comment>
                    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CInv</name></expr></argument>&gt;</argument_list></name></type> <name>vInv</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
                    <expr_stmt><expr><name><name>vInv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CInv</name><argument_list>(<argument><expr><name>MSG_BLOCK</name> <operator>|</operator> <call><name>GetFetchFlags</name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>cmpctblock</name><operator>.</operator><name>header</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>GETDATA</name></name></expr></argument>, <argument><expr><name>vInv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>

                <decl_stmt><decl><type><name>BlockTransactionsRequest</name></type> <name>req</name></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>cmpctblock</name><operator>.</operator><name>BlockTxCount</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>partialBlock</name><operator>.</operator><name>IsTxAvailable</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name><name>req</name><operator>.</operator><name>indexes</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></for>
                <if_stmt><if>if <condition>(<expr><call><name><name>req</name><operator>.</operator><name>indexes</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <comment type="line">// Dirty hack to jump to BLOCKTXN code (TODO: move message handling into their own functions)</comment>
                    <decl_stmt><decl><type><name>BlockTransactions</name></type> <name>txn</name></decl>;</decl_stmt>
                    <expr_stmt><expr><name><name>txn</name><operator>.</operator><name>blockhash</name></name> <operator>=</operator> <call><name><name>cmpctblock</name><operator>.</operator><name>header</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>blockTxnMsg</name> <operator>&lt;&lt;</operator> <name>txn</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>fProcessBLOCKTXN</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><name><name>req</name><operator>.</operator><name>blockhash</name></name> <operator>=</operator> <call><name><name>pindex</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>GETBLOCKTXN</name></name></expr></argument>, <argument><expr><name>req</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <comment type="line">// This block is either already in flight from a different</comment>
                <comment type="line">// peer, or this peer has too many blocks outstanding to</comment>
                <comment type="line">// download from.</comment>
                <comment type="line">// Optimistically try to reconstruct anyway since we might be</comment>
                <comment type="line">// able to without any round trips.</comment>
                <decl_stmt><decl><type><name>PartiallyDownloadedBlock</name></type> <name>tempBlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mempool</name></expr></argument>)</argument_list></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ReadStatus</name></type> <name>status</name> <init>= <expr><call><name><name>tempBlock</name><operator>.</operator><name>InitData</name></name><argument_list>(<argument><expr><name>cmpctblock</name></expr></argument>, <argument><expr><name>vExtraTxnForCompact</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>READ_STATUS_OK</name></expr>)</condition> <block>{<block_content>
                    <comment type="line">// TODO: don't ignore failures</comment>
                    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>
                <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CTransactionRef</name></expr></argument>&gt;</argument_list></name></type> <name>dummy</name></decl>;</decl_stmt>
                <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name><name>tempBlock</name><operator>.</operator><name>FillBlock</name></name><argument_list>(<argument><expr><operator>*</operator><name>pblock</name></expr></argument>, <argument><expr><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>READ_STATUS_OK</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>fBlockReconstructed</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>fAlreadyInFlight</name></expr>)</condition> <block>{<block_content>
                <comment type="line">// We requested this block, but its far into the future, so our</comment>
                <comment type="line">// mempool will probably be useless - request the block normally</comment>
                <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CInv</name></expr></argument>&gt;</argument_list></name></type> <name>vInv</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>vInv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CInv</name><argument_list>(<argument><expr><name>MSG_BLOCK</name> <operator>|</operator> <call><name>GetFetchFlags</name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>cmpctblock</name><operator>.</operator><name>header</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>GETDATA</name></name></expr></argument>, <argument><expr><name>vInv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <comment type="line">// If this was an announce-cmpctblock, we want the same treatment as a header message</comment>
                <expr_stmt><expr><name>fRevertToHeaderProcessing</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
        </block_content>}</block> <comment type="line">// cs_main</comment>

        <if_stmt><if>if <condition>(<expr><name>fProcessBLOCKTXN</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>ProcessMessage</name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><name><name>NetMsgType</name><operator>::</operator><name>BLOCKTXN</name></name></expr></argument>, <argument><expr><name>blockTxnMsg</name></expr></argument>, <argument><expr><name>nTimeReceived</name></expr></argument>, <argument><expr><name>chainparams</name></expr></argument>, <argument><expr><name>connman</name></expr></argument>, <argument><expr><name>banman</name></expr></argument>, <argument><expr><name>interruptMsgProc</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>fRevertToHeaderProcessing</name></expr>)</condition> <block>{<block_content>
            <comment type="line">// Headers received from HB compact block peers are permitted to be</comment>
            <comment type="line">// relayed before full validation (see BIP 152), so we don't want to disconnect</comment>
            <comment type="line">// the peer if the header turns out to be for an invalid block.</comment>
            <comment type="line">// Note that if a peer tries to build on an invalid chain, that</comment>
            <comment type="line">// will be detected and the peer will be banned.</comment>
            <return>return <expr><call><name>ProcessHeadersMessage</name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><name>connman</name></expr></argument>, <block>{<block_content><expr><name><name>cmpctblock</name><operator>.</operator><name>header</name></name></expr></block_content>}</block></argument_list></call></expr></return><operator>,</operator> <expr_stmt><expr><name>chainparams</name></expr><operator>,</operator> <comment type="block">/*via_compact_block=*/</comment><expr><literal type="boolean">true</literal></expr></expr_stmt>)</block_content></block><empty_stmt>;</empty_stmt></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>fBlockReconstructed</name></expr>)</condition> <block>{<block_content>
            <comment type="line">// If we got here, we were able to optimistically reconstruct a</comment>
            <comment type="line">// block that is in flight from some other peer.</comment>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>mapBlockSource</name><operator>.</operator><name>emplace</name></name><argument_list>(<argument><expr><call><name><name>pblock</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <decl_stmt><decl><type><name>bool</name></type> <name>fNewBlock</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
            <comment type="line">// Setting fForceProcessing to true means that we bypass some of</comment>
            <comment type="line">// our anti-DoS protections in AcceptBlock, which filters</comment>
            <comment type="line">// unrequested blocks that might be trying to waste our resources</comment>
            <comment type="line">// (eg disk space). Because we only try to reconstruct blocks when</comment>
            <comment type="line">// we're close to caught up (via the CanDirectFetch() requirement</comment>
            <comment type="line">// above, combined with the behavior of not requesting blocks until</comment>
            <comment type="line">// we have a chain with at least nMinimumChainWork), and we ignore</comment>
            <comment type="line">// compact blocks with less work than our tip, it is safe to treat</comment>
            <comment type="line">// reconstructed compact blocks as having been requested.</comment>
            <expr_stmt><expr><call><name>ProcessNewBlock</name><argument_list>(<argument><expr><name>chainparams</name></expr></argument>, <argument><expr><name>pblock</name></expr></argument>, <comment type="block">/*fForceProcessing=*/</comment><argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>fNewBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>fNewBlock</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>nLastBlockTime</name></name> <operator>=</operator> <call><name>GetTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>mapBlockSource</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><call><name><name>pblock</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// hold cs_main for CBlockIndex::IsValid()</comment>
            <if_stmt><if>if <condition>(<expr><call><name><name>pindex</name><operator>-&gt;</operator><name>IsValid</name></name><argument_list>(<argument><expr><name>BLOCK_VALID_TRANSACTIONS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <comment type="line">// Clear download state for this block, which is in</comment>
                <comment type="line">// process from some other peer.  We do this after calling</comment>
                <comment type="line">// ProcessNewBlock so that a malleated cmpctblock announcement</comment>
                <comment type="line">// can't be used to interfere with block relay.</comment>
                <expr_stmt><expr><call><name>MarkBlockAsReceived</name><argument_list>(<argument><expr><call><name><name>pblock</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></function>

    <if_stmt><if>if <condition>(<expr><name>strCommand</name> <operator>==</operator> <name><name>NetMsgType</name><operator>::</operator><name>BLOCKTXN</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// Ignore blocktxn received while importing</comment>
        <if_stmt><if>if <condition>(<expr><name>fImporting</name> <operator>||</operator> <name>fReindex</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"Unexpected blocktxn message received from peer %d\n"</literal></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>BlockTransactions</name></type> <name>resp</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>vRecv</name> <operator>&gt;&gt;</operator> <name>resp</name></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CBlock</name></expr></argument>&gt;</argument_list></name></type> <name>pblock</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>make_shared</name><argument_list type="generic">&lt;<argument><expr><name>CBlock</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>fBlockRead</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>NodeId</name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>list</name><argument_list type="generic">&lt;<argument><expr><name>QueuedBlock</name></expr></argument>&gt;</argument_list><operator>::</operator><name>iterator</name></name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list><operator>::</operator><name>iterator</name></name></type> <name>it</name> <init>= <expr><call><name><name>mapBlocksInFlight</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name><name>resp</name><operator>.</operator><name>blockhash</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>it</name> <operator>==</operator> <call><name><name>mapBlocksInFlight</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><name><name>it</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>second</name><operator>-&gt;</operator><name>partialBlock</name></name> <operator>||</operator>
                    <name><name>it</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>first</name></name> <operator>!=</operator> <call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"Peer %d sent us block transactions for block we weren't expecting\n"</literal></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <decl_stmt><decl><type><name>PartiallyDownloadedBlock</name><modifier>&amp;</modifier></type> <name>partialBlock</name> <init>= <expr><operator>*</operator><name><name>it</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>second</name><operator>-&gt;</operator><name>partialBlock</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ReadStatus</name></type> <name>status</name> <init>= <expr><call><name><name>partialBlock</name><operator>.</operator><name>FillBlock</name></name><argument_list>(<argument><expr><operator>*</operator><name>pblock</name></expr></argument>, <argument><expr><name><name>resp</name><operator>.</operator><name>txn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>READ_STATUS_INVALID</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>MarkBlockAsReceived</name><argument_list>(<argument><expr><name><name>resp</name><operator>.</operator><name>blockhash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Reset in-flight state in case of whitelist</comment>
                <expr_stmt><expr><call><name>Misbehaving</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"Peer %d sent us invalid compact block/non-matching block transactions\n"</literal></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>status</name> <operator>==</operator> <name>READ_STATUS_FAILED</name></expr>)</condition> <block>{<block_content>
                <comment type="line">// Might have collided, fall back to getdata now :(</comment>
                <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CInv</name></expr></argument>&gt;</argument_list></name></type> <name>invs</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>invs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>CInv</name><argument_list>(<argument><expr><name>MSG_BLOCK</name> <operator>|</operator> <call><name>GetFetchFlags</name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>resp</name><operator>.</operator><name>blockhash</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>GETDATA</name></name></expr></argument>, <argument><expr><name>invs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <comment type="line">// Block is either okay, or possibly we received</comment>
                <comment type="line">// READ_STATUS_CHECKBLOCK_FAILED.</comment>
                <comment type="line">// Note that CheckBlock can only fail for one of a few reasons:</comment>
                <comment type="line">// 1. bad-proof-of-work (impossible here, because we've already</comment>
                <comment type="line">//    accepted the header)</comment>
                <comment type="line">// 2. merkleroot doesn't match the transactions given (already</comment>
                <comment type="line">//    caught in FillBlock with READ_STATUS_FAILED, so</comment>
                <comment type="line">//    impossible here)</comment>
                <comment type="line">// 3. the block is otherwise invalid (eg invalid coinbase,</comment>
                <comment type="line">//    block is too big, too many legacy sigops, etc).</comment>
                <comment type="line">// So if CheckBlock failed, #3 is the only possibility.</comment>
                <comment type="line">// Under BIP 152, we don't DoS-ban unless proof of work is</comment>
                <comment type="line">// invalid (we don't require all the stateless checks to have</comment>
                <comment type="line">// been run).  This is handled below, so just treat this as</comment>
                <comment type="line">// though the block was successfully read, and rely on the</comment>
                <comment type="line">// handling in ProcessNewBlock to ensure the block index is</comment>
                <comment type="line">// updated, etc.</comment>
                <expr_stmt><expr><call><name>MarkBlockAsReceived</name><argument_list>(<argument><expr><name><name>resp</name><operator>.</operator><name>blockhash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// it is now an empty pointer</comment>
                <expr_stmt><expr><name>fBlockRead</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <comment type="line">// mapBlockSource is used for potentially punishing peers and</comment>
                <comment type="line">// updating which peers send us compact blocks, so the race</comment>
                <comment type="line">// between here and cs_main in ProcessNewBlock is fine.</comment>
                <comment type="line">// BIP 152 permits peers to relay compact blocks after validating</comment>
                <comment type="line">// the header only; we should not punish peers if the block turns</comment>
                <comment type="line">// out to be invalid.</comment>
                <expr_stmt><expr><call><name><name>mapBlockSource</name><operator>.</operator><name>emplace</name></name><argument_list>(<argument><expr><name><name>resp</name><operator>.</operator><name>blockhash</name></name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block> <comment type="line">// Don't hold cs_main when we call into ProcessNewBlock</comment>
        <if_stmt><if>if <condition>(<expr><name>fBlockRead</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type> <name>fNewBlock</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
            <comment type="line">// Since we requested this block (it was in mapBlocksInFlight), force it to be processed,</comment>
            <comment type="line">// even if it would not be a candidate for new tip (missing previous block, chain not long enough, etc)</comment>
            <comment type="line">// This bypasses some anti-DoS logic in AcceptBlock (eg to prevent</comment>
            <comment type="line">// disk-space attacks), but this should be safe due to the</comment>
            <comment type="line">// protections in the compact block handler -- see related comment</comment>
            <comment type="line">// in compact block optimistic reconstruction handling.</comment>
            <expr_stmt><expr><call><name>ProcessNewBlock</name><argument_list>(<argument><expr><name>chainparams</name></expr></argument>, <argument><expr><name>pblock</name></expr></argument>, <comment type="block">/*fForceProcessing=*/</comment><argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>fNewBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>fNewBlock</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>nLastBlockTime</name></name> <operator>=</operator> <call><name>GetTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>mapBlockSource</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><call><name><name>pblock</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>strCommand</name> <operator>==</operator> <name><name>NetMsgType</name><operator>::</operator><name>HEADERS</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// Ignore headers received while importing</comment>
        <if_stmt><if>if <condition>(<expr><name>fImporting</name> <operator>||</operator> <name>fReindex</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"Unexpected headers message received from peer %d\n"</literal></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CBlockHeader</name></expr></argument>&gt;</argument_list></name></type> <name>headers</name></decl>;</decl_stmt>

        <comment type="line">// Bypass the normal CBlock deserialization, as we don't want to risk deserializing 2000 full blocks.</comment>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nCount</name> <init>= <expr><call><name>ReadCompactSize</name><argument_list>(<argument><expr><name>vRecv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>nCount</name> <operator>&gt;</operator> <name>MAX_HEADERS_RESULTS</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Misbehaving</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>, <argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"headers message size = %u"</literal></expr></argument>, <argument><expr><name>nCount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>headers</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><name>nCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>nCount</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><name>vRecv</name> <operator>&gt;&gt;</operator> <name><name>headers</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ReadCompactSize</name><argument_list>(<argument><expr><name>vRecv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// ignore tx count; assume it is 0.</comment>
        </block_content>}</block></for>

        <return>return <expr><call><name>ProcessHeadersMessage</name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><name>connman</name></expr></argument>, <argument><expr><name>headers</name></expr></argument>, <argument><expr><name>chainparams</name></expr></argument>, <comment type="block">/*via_compact_block=*/</comment><argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>strCommand</name> <operator>==</operator> <name><name>NetMsgType</name><operator>::</operator><name>BLOCK</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// Ignore block received while importing</comment>
        <if_stmt><if>if <condition>(<expr><name>fImporting</name> <operator>||</operator> <name>fReindex</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"Unexpected block message received from peer %d\n"</literal></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CBlock</name></expr></argument>&gt;</argument_list></name></type> <name>pblock</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>make_shared</name><argument_list type="generic">&lt;<argument><expr><name>CBlock</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>vRecv</name> <operator>&gt;&gt;</operator> <operator>*</operator><name>pblock</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"received block %s peer=%d\n"</literal></expr></argument>, <argument><expr><call><name><name>pblock</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ToString</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>bool</name></type> <name>forceProcessing</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint256</name></type> <name>hash</name><argument_list>(<argument><expr><call><name><name>pblock</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// Also always process if we requested the block explicitly, as we may</comment>
            <comment type="line">// need it even though it is not a candidate for a new best tip.</comment>
            <expr_stmt><expr><name>forceProcessing</name> <operator>|=</operator> <call><name>MarkBlockAsReceived</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// mapBlockSource is only used for punishing peers and setting</comment>
            <comment type="line">// which peers send us compact blocks, so the race between here and</comment>
            <comment type="line">// cs_main in ProcessNewBlock is fine.</comment>
            <expr_stmt><expr><call><name><name>mapBlockSource</name><operator>.</operator><name>emplace</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <decl_stmt><decl><type><name>bool</name></type> <name>fNewBlock</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ProcessNewBlock</name><argument_list>(<argument><expr><name>chainparams</name></expr></argument>, <argument><expr><name>pblock</name></expr></argument>, <argument><expr><name>forceProcessing</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fNewBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>fNewBlock</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>nLastBlockTime</name></name> <operator>=</operator> <call><name>GetTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>mapBlockSource</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><call><name><name>pblock</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>strCommand</name> <operator>==</operator> <name><name>NetMsgType</name><operator>::</operator><name>GETADDR</name></name></expr>)</condition> <block>{<block_content>
        <comment type="line">// This asymmetric behavior for inbound and outbound connections was introduced</comment>
        <comment type="line">// to prevent a fingerprinting attack: an attacker can send specific fake addresses</comment>
        <comment type="line">// to users' AddrMan and later request them by sending getaddr messages.</comment>
        <comment type="line">// Making nodes which are behind NAT and can only make outgoing connections ignore</comment>
        <comment type="line">// the getaddr message mitigates the attack.</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pfrom</name><operator>-&gt;</operator><name>fInbound</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"Ignoring \"getaddr\" from outbound connection. peer=%d\n"</literal></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pfrom</name><operator>-&gt;</operator><name>IsAddrRelayPeer</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"Ignoring \"getaddr\" from block-relay-only connection. peer=%d\n"</literal></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Only send one GetAddr response per connection to reduce resource waste</comment>
        <comment type="line">//  and discourage addr stamping of INV announcements.</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pfrom</name><operator>-&gt;</operator><name>fSentAddr</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"Ignoring repeated \"getaddr\". peer=%d\n"</literal></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>fSentAddr</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>vAddrToSend</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CAddress</name></expr></argument>&gt;</argument_list></name></type> <name>vAddr</name> <init>= <expr><call><name><name>connman</name><operator>-&gt;</operator><name>GetAddresses</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>FastRandomContext</name></type> <name>insecure_rand</name></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CAddress</name> <modifier>&amp;</modifier></type><name>addr</name> <range>: <expr><name>vAddr</name></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>banman</name><operator>-&gt;</operator><name>IsBanned</name></name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>PushAddress</name></name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>insecure_rand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>strCommand</name> <operator>==</operator> <name><name>NetMsgType</name><operator>::</operator><name>MEMPOOL</name></name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetLocalServices</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>NODE_BLOOM</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>pfrom</name><operator>-&gt;</operator><name>HasPermission</name></name><argument_list>(<argument><expr><name>PF_MEMPOOL</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pfrom</name><operator>-&gt;</operator><name>HasPermission</name></name><argument_list>(<argument><expr><name>PF_NOBAN</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"mempool request with bloom filters disabled, disconnect peer=%d\n"</literal></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>connman</name><operator>-&gt;</operator><name>OutboundTargetReached</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>pfrom</name><operator>-&gt;</operator><name>HasPermission</name></name><argument_list>(<argument><expr><name>PF_MEMPOOL</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pfrom</name><operator>-&gt;</operator><name>HasPermission</name></name><argument_list>(<argument><expr><name>PF_NOBAN</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"mempool request with bandwidth limit reached, disconnect peer=%d\n"</literal></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name></name> <operator>!=</operator> <literal type="null">nullptr</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>cs_tx_inventory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>fSendMempool</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>strCommand</name> <operator>==</operator> <name><name>NetMsgType</name><operator>::</operator><name>PING</name></name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>pfrom</name><operator>-&gt;</operator><name>nVersion</name></name> <operator>&gt;</operator> <name>BIP0031_VERSION</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>uint64_t</name></type> <name>nonce</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>vRecv</name> <operator>&gt;&gt;</operator> <name>nonce</name></expr>;</expr_stmt>
            <comment type="line">// Echo the message back with the nonce. This allows for two useful features:</comment>
            <comment type="line">//</comment>
            <comment type="line">// 1) A remote node can quickly check if the connection is operational</comment>
            <comment type="line">// 2) Remote nodes can measure the latency of the network thread. If this node</comment>
            <comment type="line">//    is overloaded it won't respond to pings quickly and the remote node can</comment>
            <comment type="line">//    avoid sending us more work, like chain download requests.</comment>
            <comment type="line">//</comment>
            <comment type="line">// The nonce stops the remote getting confused between different pings: without</comment>
            <comment type="line">// it, if the remote node sends a ping once per second and this node takes 5</comment>
            <comment type="line">// seconds to respond to each, the 5th ping the remote sends would appear to</comment>
            <comment type="line">// return very quickly.</comment>
            <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>PONG</name></name></expr></argument>, <argument><expr><name>nonce</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>strCommand</name> <operator>==</operator> <name><name>NetMsgType</name><operator>::</operator><name>PONG</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>pingUsecEnd</name> <init>= <expr><name>nTimeReceived</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>nonce</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>nAvail</name> <init>= <expr><call><name><name>vRecv</name><operator>.</operator><name>in_avail</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>bPingFinished</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>sProblem</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>nAvail</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>nonce</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>vRecv</name> <operator>&gt;&gt;</operator> <name>nonce</name></expr>;</expr_stmt>

            <comment type="line">// Only process pong message if there is an outstanding ping (old ping without nonce should never pong)</comment>
            <if_stmt><if>if <condition>(<expr><name><name>pfrom</name><operator>-&gt;</operator><name>nPingNonceSent</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>nonce</name> <operator>==</operator> <name><name>pfrom</name><operator>-&gt;</operator><name>nPingNonceSent</name></name></expr>)</condition> <block>{<block_content>
                    <comment type="line">// Matching pong received, this ping is no longer outstanding</comment>
                    <expr_stmt><expr><name>bPingFinished</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                    <decl_stmt><decl><type><name>int64_t</name></type> <name>pingUsecTime</name> <init>= <expr><name>pingUsecEnd</name> <operator>-</operator> <name><name>pfrom</name><operator>-&gt;</operator><name>nPingUsecStart</name></name></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>pingUsecTime</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                        <comment type="line">// Successful ping time measurement, replace previous</comment>
                        <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>nPingUsecTime</name></name> <operator>=</operator> <name>pingUsecTime</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>nMinPingUsecTime</name></name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>min</name></name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>nMinPingUsecTime</name><operator>.</operator><name>load</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pingUsecTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <comment type="line">// This should never happen</comment>
                        <expr_stmt><expr><name>sProblem</name> <operator>=</operator> <literal type="string">"Timing mishap"</literal></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <comment type="line">// Nonce mismatches are normal when pings are overlapping</comment>
                    <expr_stmt><expr><name>sProblem</name> <operator>=</operator> <literal type="string">"Nonce mismatch"</literal></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>nonce</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                        <comment type="line">// This is most likely a bug in another implementation somewhere; cancel this ping</comment>
                        <expr_stmt><expr><name>bPingFinished</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>sProblem</name> <operator>=</operator> <literal type="string">"Nonce zero"</literal></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>sProblem</name> <operator>=</operator> <literal type="string">"Unsolicited pong without ping"</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="line">// This is most likely a bug in another implementation somewhere; cancel this ping</comment>
            <expr_stmt><expr><name>bPingFinished</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>sProblem</name> <operator>=</operator> <literal type="string">"Short payload"</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name><name>sProblem</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"pong peer=%d: %s, %x expected, %x received, %u bytes\n"</literal></expr></argument>,
                <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>,
                <argument><expr><name>sProblem</name></expr></argument>,
                <argument><expr><name><name>pfrom</name><operator>-&gt;</operator><name>nPingNonceSent</name></name></expr></argument>,
                <argument><expr><name>nonce</name></expr></argument>,
                <argument><expr><name>nAvail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>bPingFinished</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>nPingNonceSent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>strCommand</name> <operator>==</operator> <name><name>NetMsgType</name><operator>::</operator><name>FILTERLOAD</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>CBloomFilter</name></type> <name>filter</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>vRecv</name> <operator>&gt;&gt;</operator> <name>filter</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>filter</name><operator>.</operator><name>IsWithinSizeConstraints</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// There is no excuse for sending a too-large filter</comment>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Misbehaving</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name></name> <operator>!=</operator> <literal type="null">nullptr</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>cs_filter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>pfilter</name><operator>.</operator><name>reset</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>CBloomFilter</name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>pfilter</name><operator>-&gt;</operator><name>UpdateEmptyFull</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>fRelayTxes</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>strCommand</name> <operator>==</operator> <name><name>NetMsgType</name><operator>::</operator><name>FILTERADD</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>vData</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>vRecv</name> <operator>&gt;&gt;</operator> <name>vData</name></expr>;</expr_stmt>

        <comment type="line">// Nodes must NEVER send a data item &gt; 520 bytes (the max size for a script data object,</comment>
        <comment type="line">// and thus, the maximum size any matched object can have) in a filteradd message</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>bad</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>vData</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>MAX_SCRIPT_ELEMENT_SIZE</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>bad</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name></name> <operator>!=</operator> <literal type="null">nullptr</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>cs_filter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>pfilter</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>pfilter</name><operator>-&gt;</operator><name>insert</name></name><argument_list>(<argument><expr><name>vData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>bad</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>bad</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Misbehaving</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>strCommand</name> <operator>==</operator> <name><name>NetMsgType</name><operator>::</operator><name>FILTERCLEAR</name></name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name></name> <operator>==</operator> <literal type="null">nullptr</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>cs_filter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetLocalServices</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>NODE_BLOOM</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>pfilter</name><operator>.</operator><name>reset</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>CBloomFilter</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>fRelayTxes</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>strCommand</name> <operator>==</operator> <name><name>NetMsgType</name><operator>::</operator><name>FEEFILTER</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>CAmount</name></type> <name>newFeeFilter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>vRecv</name> <operator>&gt;&gt;</operator> <name>newFeeFilter</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>MoneyRange</name><argument_list>(<argument><expr><name>newFeeFilter</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name></name> <operator>!=</operator> <literal type="null">nullptr</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>cs_feeFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>minFeeFilter</name></name> <operator>=</operator> <name>newFeeFilter</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"received: feefilter of %s from peer=%d\n"</literal></expr></argument>, <argument><expr><call><name>CFeeRate</name><argument_list>(<argument><expr><name>newFeeFilter</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>ToString</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>strCommand</name> <operator>==</operator> <name><name>NetMsgType</name><operator>::</operator><name>NOTFOUND</name></name></expr>)</condition> <block>{<block_content>
        <comment type="line">// Remove the NOTFOUND transactions from the peer</comment>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>CNodeState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><call><name>State</name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CInv</name></expr></argument>&gt;</argument_list></name></type> <name>vInv</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>vRecv</name> <operator>&gt;&gt;</operator> <name>vInv</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>vInv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>MAX_PEER_TX_IN_FLIGHT</name> <operator>+</operator> <name>MAX_BLOCKS_IN_TRANSIT_PER_PEER</name></expr>)</condition> <block>{<block_content>
            <for>for <control>(<init><decl><type><name>CInv</name> <modifier>&amp;</modifier></type><name>inv</name> <range>: <expr><name>vInv</name></expr></range></decl></init>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>inv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>MSG_TX</name> <operator>||</operator> <name><name>inv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>MSG_WITNESS_TX</name></expr>)</condition> <block>{<block_content>
                    <comment type="line">// If we receive a NOTFOUND message for a txid we requested, erase</comment>
                    <comment type="line">// it from our data structures for this peer.</comment>
                    <decl_stmt><decl><type><name>auto</name></type> <name>in_flight_it</name> <init>= <expr><call><name><name>state</name><operator>-&gt;</operator><name>m_tx_download</name><operator>.</operator><name>m_tx_in_flight</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name><name>inv</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>in_flight_it</name> <operator>==</operator> <call><name><name>state</name><operator>-&gt;</operator><name>m_tx_download</name><operator>.</operator><name>m_tx_in_flight</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                        <comment type="line">// Skip any further work if this is a spurious NOTFOUND</comment>
                        <comment type="line">// message.</comment>
                        <continue>continue;</continue>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name><name>state</name><operator>-&gt;</operator><name>m_tx_download</name><operator>.</operator><name>m_tx_in_flight</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>in_flight_it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>state</name><operator>-&gt;</operator><name>m_tx_download</name><operator>.</operator><name>m_tx_announced</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name><name>inv</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Ignore unknown commands for extensibility</comment>
    <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"Unknown command \"%s\" from peer=%d\n"</literal></expr></argument>, <argument><expr><call><name>SanitizeString</name><argument_list>(<argument><expr><name>strCommand</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
}

bool <macro><name>PeerLogicValidation</name></macro><expr_stmt><expr><name><operator>::</operator><name>CheckIfBanned</name></name><operator>(</operator><name>CNode</name><operator>*</operator> <name>pnode</name><operator>)</operator>
<block>{
    <expr><call><name>AssertLockHeld</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>CNodeState</name> <operator>&amp;</operator><name>state</name> <operator>=</operator> <operator>*</operator><call><name>State</name><argument_list>(<argument><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;

    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>fShouldBan</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>fShouldBan</name></name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>pnode</name><operator>-&gt;</operator><name>HasPermission</name></name><argument_list>(<argument><expr><name>PF_NOBAN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"Warning: not punishing whitelisted peer %s!\n"</literal></expr></argument>, <argument><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>pnode</name><operator>-&gt;</operator><name>m_manual_connection</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"Warning: not punishing manually-connected peer %s!\n"</literal></expr></argument>, <argument><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name><name>pnode</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>IsLocal</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="line">// Disconnect but don't ban _this_ local node</comment>
            <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"Warning: disconnecting but not banning local peer %s!\n"</literal></expr></argument>, <argument><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pnode</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        <expr_stmt/></block_content></block></if></if_stmt></block_content></block></if></if_stmt>}</block></expr></expr_stmt> <if_stmt><else>else <block>{<block_content>
            <comment type="line">// Disconnect and ban all nodes sharing the address</comment>
            <if_stmt><if>if <condition>(<expr><name>m_banman</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>m_banman</name><operator>-&gt;</operator><name>Ban</name></name><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>BanReasonNodeMisbehaving</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>DisconnectNode</name></name><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }
    return <expr_stmt><expr><literal type="boolean">false</literal></expr>;</expr_stmt>
}

bool <macro><name>PeerLogicValidation</name></macro><expr_stmt><expr><name><operator>::</operator><name>ProcessMessages</name></name><operator>(</operator><name>CNode</name><operator>*</operator> <name>pfrom</name><operator>,</operator> <name><name>std</name><operator>::</operator><name>atomic</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>interruptMsgProc</name><operator>)</operator>
<block>{
    <expr><specifier>const</specifier> <name>CChainParams</name><operator>&amp;</operator> <name>chainparams</name> <operator>=</operator> <call><name>Params</name><argument_list>()</argument_list></call></expr>;
    <comment type="line">//</comment>
    <comment type="line">// Message format</comment>
    <comment type="line">//  (4) message start</comment>
    <comment type="line">//  (12) command</comment>
    <comment type="line">//  (4) size</comment>
    <comment type="line">//  (4) checksum</comment>
    <comment type="line">//  (x) data</comment>
    <comment type="line">//</comment>
    <expr><name>bool</name> <name>fMoreWork</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pfrom</name><operator>-&gt;</operator><name>vRecvGetData</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ProcessGetData</name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><name>chainparams</name></expr></argument>, <argument><expr><name>connman</name></expr></argument>, <argument><expr><name>interruptMsgProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr></expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pfrom</name><operator>-&gt;</operator><name>orphan_work_set</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>list</name><argument_list type="generic">&lt;<argument><expr><name>CTransactionRef</name></expr></argument>&gt;</argument_list></name></type> <name>removed_txn</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>LOCK2</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>, <argument><expr><name>g_cs_orphans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ProcessOrphanTx</name><argument_list>(<argument><expr><name>connman</name></expr></argument>, <argument><expr><name><name>pfrom</name><operator>-&gt;</operator><name>orphan_work_set</name></name></expr></argument>, <argument><expr><name>removed_txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CTransactionRef</name><modifier>&amp;</modifier></type> <name>removedTx</name> <range>: <expr><name>removed_txn</name></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>AddToCompactExtraTransactions</name><argument_list>(<argument><expr><name>removedTx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pfrom</name><operator>-&gt;</operator><name>fDisconnect</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// this maintains the order of responses</comment>
    <comment type="line">// and prevents vRecvGetData to grow unbounded</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pfrom</name><operator>-&gt;</operator><name>vRecvGetData</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pfrom</name><operator>-&gt;</operator><name>orphan_work_set</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// Don't bother if send buffer is too full to respond anyway</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pfrom</name><operator>-&gt;</operator><name>fPauseSend</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>list</name><argument_list type="generic">&lt;<argument><expr><name>CNetMessage</name></expr></argument>&gt;</argument_list></name></type> <name>msgs</name></decl>;</decl_stmt>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pfrom</name><operator>-&gt;</operator><name>cs_vProcessMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>vProcessMsg</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
        <comment type="line">// Just take one message</comment>
        <expr_stmt><expr><call><name><name>msgs</name><operator>.</operator><name>splice</name></name><argument_list>(<argument><expr><call><name><name>msgs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>pfrom</name><operator>-&gt;</operator><name>vProcessMsg</name></name></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>vProcessMsg</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>nProcessQueueSize</name></name> <operator>-=</operator> <call><name><name>msgs</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call><operator>.</operator><name>m_raw_message_size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>fPauseRecv</name></name> <operator>=</operator> <name><name>pfrom</name><operator>-&gt;</operator><name>nProcessQueueSize</name></name> <operator>&gt;</operator> <call><name><name>connman</name><operator>-&gt;</operator><name>GetReceiveFloodSize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>fMoreWork</name> <operator>=</operator> <operator>!</operator><call><name><name>pfrom</name><operator>-&gt;</operator><name>vProcessMsg</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <decl_stmt><decl><type><name>CNetMessage</name><modifier>&amp;</modifier></type> <name>msg</name><argument_list>(<argument><expr><call><name><name>msgs</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

    <expr_stmt><expr><call><name><name>msg</name><operator>.</operator><name>SetVersion</name></name><argument_list>(<argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetRecvVersion</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Check network magic</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>msg</name><operator>.</operator><name>m_valid_netmagic</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"PROCESSMESSAGE: INVALID MESSAGESTART %s peer=%d\n"</literal></expr></argument>, <argument><expr><call><name>SanitizeString</name><argument_list>(<argument><expr><name><name>msg</name><operator>.</operator><name>m_command</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pfrom</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Check header</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>msg</name><operator>.</operator><name>m_valid_header</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"PROCESSMESSAGE: ERRORS IN HEADER %s peer=%d\n"</literal></expr></argument>, <argument><expr><call><name>SanitizeString</name><argument_list>(<argument><expr><name><name>msg</name><operator>.</operator><name>m_command</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>fMoreWork</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>strCommand</name> <init>= <expr><name><name>msg</name><operator>.</operator><name>m_command</name></name></expr></init></decl>;</decl_stmt>

    <comment type="line">// Message size</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nMessageSize</name> <init>= <expr><name><name>msg</name><operator>.</operator><name>m_message_size</name></name></expr></init></decl>;</decl_stmt>

    <comment type="line">// Checksum</comment>
    <decl_stmt><decl><type><name>CDataStream</name><modifier>&amp;</modifier></type> <name>vRecv</name> <init>= <expr><name><name>msg</name><operator>.</operator><name>m_recv</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>msg</name><operator>.</operator><name>m_valid_checksum</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"%s(%s, %u bytes): CHECKSUM ERROR peer=%d\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>,
           <argument><expr><call><name>SanitizeString</name><argument_list>(<argument><expr><name>strCommand</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nMessageSize</name></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>fMoreWork</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Process message</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>fRet</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
    <try>try
    <block>{<block_content>
        <expr_stmt><expr><name>fRet</name> <operator>=</operator> <call><name>ProcessMessage</name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>, <argument><expr><name>strCommand</name></expr></argument>, <argument><expr><name>vRecv</name></expr></argument>, <argument><expr><name><name>msg</name><operator>.</operator><name>m_time</name></name></expr></argument>, <argument><expr><name>chainparams</name></expr></argument>, <argument><expr><name>connman</name></expr></argument>, <argument><expr><name>m_banman</name></expr></argument>, <argument><expr><name>interruptMsgProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>interruptMsgProc</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pfrom</name><operator>-&gt;</operator><name>vRecvGetData</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>fMoreWork</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>
    <catch>catch <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>ios_base</name><operator>::</operator><name>failure</name></name><modifier>&amp;</modifier></type> <name>e</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><call><name><name>e</name><operator>.</operator><name>what</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"end of data"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="line">// Allow exceptions from under-length message on vRecv</comment>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"%s(%s, %u bytes): Exception '%s' caught, normally caused by a message being shorter than its stated length\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><call><name>SanitizeString</name><argument_list>(<argument><expr><name>strCommand</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nMessageSize</name></expr></argument>, <argument><expr><call><name><name>e</name><operator>.</operator><name>what</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><call><name><name>e</name><operator>.</operator><name>what</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"size too large"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="line">// Allow exceptions from over-long size</comment>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"%s(%s, %u bytes): Exception '%s' caught\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><call><name>SanitizeString</name><argument_list>(<argument><expr><name>strCommand</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nMessageSize</name></expr></argument>, <argument><expr><call><name><name>e</name><operator>.</operator><name>what</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><call><name><name>e</name><operator>.</operator><name>what</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"non-canonical ReadCompactSize()"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="line">// Allow exceptions from non-canonical encoding</comment>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"%s(%s, %u bytes): Exception '%s' caught\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><call><name>SanitizeString</name><argument_list>(<argument><expr><name>strCommand</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nMessageSize</name></expr></argument>, <argument><expr><call><name><name>e</name><operator>.</operator><name>what</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><call><name><name>e</name><operator>.</operator><name>what</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Superfluous witness record"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="line">// Allow exceptions from illegal witness encoding</comment>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"%s(%s, %u bytes): Exception '%s' caught\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><call><name>SanitizeString</name><argument_list>(<argument><expr><name>strCommand</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nMessageSize</name></expr></argument>, <argument><expr><call><name><name>e</name><operator>.</operator><name>what</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><call><name><name>e</name><operator>.</operator><name>what</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Unknown transaction optional data"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="line">// Allow exceptions from unknown witness encoding</comment>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"%s(%s, %u bytes): Exception '%s' caught\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><call><name>SanitizeString</name><argument_list>(<argument><expr><name>strCommand</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nMessageSize</name></expr></argument>, <argument><expr><call><name><name>e</name><operator>.</operator><name>what</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>PrintExceptionContinue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><literal type="string">"ProcessMessages()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></catch>
    <catch>catch <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>exception</name></name><modifier>&amp;</modifier></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>PrintExceptionContinue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><literal type="string">"ProcessMessages()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></catch> <catch>catch <parameter_list>(<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>PrintExceptionContinue</name><argument_list>(<argument><expr><literal type="null">nullptr</literal></expr></argument>, <argument><expr><literal type="string">"ProcessMessages()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></catch></try>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fRet</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"%s(%s, %u bytes) FAILED peer=%d\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><call><name>SanitizeString</name><argument_list>(<argument><expr><name>strCommand</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nMessageSize</name></expr></argument>, <argument><expr><call><name><name>pfrom</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CheckIfBanned</name><argument_list>(<argument><expr><name>pfrom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>fMoreWork</name></expr>;</return>
}

void <macro><name>PeerLogicValidation</name></macro><expr_stmt><expr><name><operator>::</operator><name>ConsiderEviction</name></name><operator>(</operator><name>CNode</name> <operator>*</operator><name>pto</name><operator>,</operator> <name>int64_t</name> <name>time_in_seconds</name><operator>)</operator>
<block>{
    <expr><call><name>AssertLockHeld</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;

    <expr><name>CNodeState</name> <operator>&amp;</operator><name>state</name> <operator>=</operator> <operator>*</operator><call><name>State</name><argument_list>(<argument><expr><call><name><name>pto</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><specifier>const</specifier> <name>CNetMsgMaker</name> <call><name>msgMaker</name><argument_list>(<argument><expr><call><name><name>pto</name><operator>-&gt;</operator><name>GetSendVersion</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>.</operator><name>m_chain_sync</name><operator>.</operator><name>m_protect</name></name> <operator>&amp;&amp;</operator> <call><name>IsOutboundDisconnectionCandidate</name><argument_list>(<argument><expr><name>pto</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>fSyncStarted</name></name></expr>)</condition> <block>{<block_content>
        <comment type="line">// This is an outbound peer subject to disconnection if they don't</comment>
        <comment type="line">// announce a block with as much work as the current tip within</comment>
        <comment type="line">// CHAIN_SYNC_TIMEOUT + HEADERS_RESPONSE_TIME seconds (note: if</comment>
        <comment type="line">// their chain has more work than ours, we should sync to it,</comment>
        <comment type="line">// unless it's invalid, in which case we should find that out and</comment>
        <comment type="line">// disconnect from them elsewhere).</comment>
        <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>pindexBestKnownBlock</name></name> <operator>!=</operator> <literal type="null">nullptr</literal> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>pindexBestKnownBlock</name><operator>-&gt;</operator><name>nChainWork</name></name> <operator>&gt;=</operator> <call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Tip</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>nChainWork</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>m_chain_sync</name><operator>.</operator><name>m_timeout</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>state</name><operator>.</operator><name>m_chain_sync</name><operator>.</operator><name>m_timeout</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>.</operator><name>m_chain_sync</name><operator>.</operator><name>m_work_header</name></name> <operator>=</operator> <literal type="null">nullptr</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>.</operator><name>m_chain_sync</name><operator>.</operator><name>m_sent_getheaders</name></name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
            <expr_stmt/></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>}</block></expr></expr_stmt>
        } else <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>m_chain_sync</name><operator>.</operator><name>m_timeout</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>state</name><operator>.</operator><name>m_chain_sync</name><operator>.</operator><name>m_work_header</name></name> <operator>!=</operator> <literal type="null">nullptr</literal> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>pindexBestKnownBlock</name></name> <operator>!=</operator> <literal type="null">nullptr</literal> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>pindexBestKnownBlock</name><operator>-&gt;</operator><name>nChainWork</name></name> <operator>&gt;=</operator> <name><name>state</name><operator>.</operator><name>m_chain_sync</name><operator>.</operator><name>m_work_header</name><operator>-&gt;</operator><name>nChainWork</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <comment type="line">// Our best block known by this peer is behind our tip, and we're either noticing</comment>
            <comment type="line">// that for the first time, OR this peer was able to catch up to some earlier point</comment>
            <comment type="line">// where we checked against our tip.</comment>
            <comment type="line">// Either way, set a new timeout based on current tip.</comment>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>m_chain_sync</name><operator>.</operator><name>m_timeout</name></name> <operator>=</operator> <name>time_in_seconds</name> <operator>+</operator> <name>CHAIN_SYNC_TIMEOUT</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>m_chain_sync</name><operator>.</operator><name>m_work_header</name></name> <operator>=</operator> <call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Tip</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>m_chain_sync</name><operator>.</operator><name>m_sent_getheaders</name></name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>state</name><operator>.</operator><name>m_chain_sync</name><operator>.</operator><name>m_timeout</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>time_in_seconds</name> <operator>&gt;</operator> <name><name>state</name><operator>.</operator><name>m_chain_sync</name><operator>.</operator><name>m_timeout</name></name></expr>)</condition> <block>{<block_content>
            <comment type="line">// No evidence yet that our peer has synced to a chain with work equal to that</comment>
            <comment type="line">// of our tip, when we first detected it was behind. Send a single getheaders</comment>
            <comment type="line">// message to give the peer a chance to update us.</comment>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>m_chain_sync</name><operator>.</operator><name>m_sent_getheaders</name></name></expr>)</condition> <block>{<block_content>
                <comment type="line">// They've run out of time to catch up!</comment>
                <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"Disconnecting outbound peer %d for old chain, best known block = %s\n"</literal></expr></argument>, <argument><expr><call><name><name>pto</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><name><name>state</name><operator>.</operator><name>pindexBestKnownBlock</name></name> <operator>!=</operator> <literal type="null">nullptr</literal></expr> ?</condition><then> <expr><call><name><name>state</name><operator>.</operator><name>pindexBestKnownBlock</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ToString</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="string">"&lt;none&gt;"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pto</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>m_chain_sync</name><operator>.</operator><name>m_work_header</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"sending getheaders to outbound peer=%d to verify chain work (current best known block:%s, benchmark blockhash: %s)\n"</literal></expr></argument>, <argument><expr><call><name><name>pto</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><name><name>state</name><operator>.</operator><name>pindexBestKnownBlock</name></name> <operator>!=</operator> <literal type="null">nullptr</literal></expr> ?</condition><then> <expr><call><name><name>state</name><operator>.</operator><name>pindexBestKnownBlock</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ToString</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="string">"&lt;none&gt;"</literal></expr></else></ternary></expr></argument>, <argument><expr><call><name><name>state</name><operator>.</operator><name>m_chain_sync</name><operator>.</operator><name>m_work_header</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ToString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pto</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>GETHEADERS</name></name></expr></argument>, <argument><expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetLocator</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>m_chain_sync</name><operator>.</operator><name>m_work_header</name><operator>-&gt;</operator><name>pprev</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>uint256</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>.</operator><name>m_chain_sync</name><operator>.</operator><name>m_sent_getheaders</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <decl_stmt><decl><type><specifier>constexpr</specifier> <name>int64_t</name></type> <name>HEADERS_RESPONSE_TIME</name> <init>= <expr><literal type="number">120</literal></expr></init></decl>;</decl_stmt> <comment type="line">// 2 minutes</comment>
                <comment type="line">// Bump the timeout to allow a response, which could clear the timeout</comment>
                <comment type="line">// (if the response shows the peer has synced), reset the timeout (if</comment>
                <comment type="line">// the peer syncs to the required work but not to our tip), or result</comment>
                <comment type="line">// in disconnect (if we advance to the timeout and pindexBestKnownBlock</comment>
                <comment type="line">// has not sufficiently progressed)</comment>
                <expr_stmt><expr><name><name>state</name><operator>.</operator><name>m_chain_sync</name><operator>.</operator><name>m_timeout</name></name> <operator>=</operator> <name>time_in_seconds</name> <operator>+</operator> <name>HEADERS_RESPONSE_TIME</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    }
}

<function><type><name>void</name></type> <name><name>PeerLogicValidation</name><operator>::</operator><name>EvictExtraOutboundPeers</name></name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>time_in_seconds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">// Check whether we have too many outbound peers</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>extra_peers</name> <init>= <expr><call><name><name>connman</name><operator>-&gt;</operator><name>GetExtraOutboundCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>extra_peers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// If we have more outbound peers than we target, disconnect one.</comment>
        <comment type="line">// Pick the outbound peer that least recently announced</comment>
        <comment type="line">// us a new block, with ties broken by choosing the more recent</comment>
        <comment type="line">// connection (higher node id)</comment>
        <decl_stmt><decl><type><name>NodeId</name></type> <name>worst_peer</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>oldest_block_announcement</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>numeric_limits</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list><operator>::</operator><name>max</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>ForEachNode</name></name><argument_list>(<argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <expr_stmt><expr><call><name>AssertLockHeld</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Ignore non-outbound peers, or nodes marked for disconnect already</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsOutboundDisconnectionCandidate</name><argument_list>(<argument><expr><name>pnode</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>pnode</name><operator>-&gt;</operator><name>fDisconnect</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
            <decl_stmt><decl><type><name>CNodeState</name> <modifier>*</modifier><name>state</name> = <name>State</name>(<name><name>pnode</name><operator>-&gt;</operator><name>GetId</name></name>(</type></decl>)</decl_stmt>)</block_content></block></lambda></expr></argument>;</argument_list></call></expr></expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <literal type="null">nullptr</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt> <comment type="line">// shouldn't be possible, but just in case</comment>
            <comment type="line">// Don't evict our protected peers</comment>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>m_chain_sync</name><operator>.</operator><name>m_protect</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
            <comment type="line">// Don't evict our block-relay-only peers.</comment>
            <if_stmt><if>if <condition>(<expr><name><name>pnode</name><operator>-&gt;</operator><name>m_tx_relay</name></name> <operator>==</operator> <literal type="null">nullptr</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>m_last_block_announcement</name></name> <operator>&lt;</operator> <name>oldest_block_announcement</name> <operator>||</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>m_last_block_announcement</name></name> <operator>==</operator> <name>oldest_block_announcement</name> <operator>&amp;&amp;</operator> <call><name><name>pnode</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>worst_peer</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>worst_peer</name> <operator>=</operator> <call><name><name>pnode</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>oldest_block_announcement</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>m_last_block_announcement</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>)</block_content></block>;</function>
        <if_stmt><if>if <condition>(<expr><name>worst_peer</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type> <name>disconnected</name> <init>= <expr><call><name><name>connman</name><operator>-&gt;</operator><name>ForNode</name></name><argument_list>(<argument><expr><name>worst_peer</name></expr></argument>, <argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name>CNode</name> <modifier>*</modifier></type><name>pnode</name></decl></parameter>)</parameter_list> <block>{<block_content>
                <expr_stmt><expr><call><name>AssertLockHeld</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Only disconnect a peer that has been connected to us for</comment>
                <comment type="line">// some reasonable fraction of our check-frequency, to give</comment>
                <comment type="line">// it time for new information to have arrived.</comment>
                <comment type="line">// Also don't disconnect any peer we're trying to download a</comment>
                <comment type="line">// block from.</comment>
                <decl_stmt><decl><type><name>CNodeState</name> <modifier>&amp;</modifier><name>state</name> = <modifier>*</modifier><name>State</name>(<name><name>pnode</name><operator>-&gt;</operator><name>GetId</name></name>(</type></decl>)</decl_stmt>)</block_content></block></lambda></expr></argument>;</argument_list></call></expr></init></decl></decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>time_in_seconds</name> <operator>-</operator> <name><name>pnode</name><operator>-&gt;</operator><name>nTimeConnected</name></name> <operator>&gt;</operator> <name>MINIMUM_CONNECT_TIME</name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>nBlocksInFlight</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"disconnecting extra outbound peer=%d (last block announcement received at time %d)\n"</literal></expr></argument>, <argument><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>oldest_block_announcement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>pnode</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"keeping outbound peer=%d chosen for eviction (connect time: %d, blocks_in_flight: %d)\n"</literal></expr></argument>, <argument><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>nTimeConnected</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>.</operator><name>nBlocksInFlight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>)<empty_stmt>;</empty_stmt>
            <if_stmt><if>if <condition>(<expr><name>disconnected</name></expr>)</condition> <block>{<block_content>
                <comment type="line">// If we disconnected an extra peer, that means we successfully</comment>
                <comment type="line">// connected to at least one peer after the last time we</comment>
                <comment type="line">// detected a stale tip. Don't try any more extra peers until</comment>
                <comment type="line">// we next detect a stale tip, to limit the load we put on the</comment>
                <comment type="line">// network from these extra connections.</comment>
                <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>SetTryNewOutboundPeer</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        }
    }
}

void <macro><name>PeerLogicValidation</name></macro><expr_stmt><expr><name><operator>::</operator><name>CheckForStaleTipAndEvictPeers</name></name><operator>(</operator><specifier>const</specifier> <name><name>Consensus</name><operator>::</operator><name>Params</name></name> <operator>&amp;</operator><name>consensusParams</name><operator>)</operator>
<block>{
    <expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;

    <if_stmt><if>if <condition>(<expr><name>connman</name> <operator>==</operator> <literal type="null">nullptr</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <name>int64_t</name> <name>time_in_seconds</name> <operator>=</operator> <call><name>GetTime</name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>EvictExtraOutboundPeers</name><argument_list>(<argument><expr><name>time_in_seconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>time_in_seconds</name> <operator>&gt;</operator> <name>m_stale_tip_check_time</name></expr>)</condition> <block>{<block_content>
        <comment type="line">// Check whether our tip is stale, and if so, allow using an extra</comment>
        <comment type="line">// outbound peer</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fImporting</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>fReindex</name> <operator>&amp;&amp;</operator> <call><name><name>connman</name><operator>-&gt;</operator><name>GetNetworkActive</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>connman</name><operator>-&gt;</operator><name>GetUseAddrmanOutgoing</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>TipMayBeStale</name><argument_list>(<argument><expr><name>consensusParams</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"Potential stale tip detected, will try using extra outbound peer (last tip update: %d seconds ago)\n"</literal></expr></argument>, <argument><expr><name>time_in_seconds</name> <operator>-</operator> <name>g_last_tip_update</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>SetTryNewOutboundPeer</name></name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>connman</name><operator>-&gt;</operator><name>GetTryNewOutboundPeer</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>SetTryNewOutboundPeer</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>m_stale_tip_check_time</name> <operator>=</operator> <name>time_in_seconds</name> <operator>+</operator> <name>STALE_CHECK_INTERVAL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
}

namespace <block>{<block_content>
<class>class <name>CompareInvMempoolOrder</name>
<block>{<private type="default">
    <decl_stmt><decl><type><name>CTxMemPool</name> <modifier>*</modifier></type><name>mp</name></decl>;</decl_stmt>
</private><public>public:
    <constructor><specifier>explicit</specifier> <name>CompareInvMempoolOrder</name><parameter_list>(<parameter><decl><type><name>CTxMemPool</name> <modifier>*</modifier></type><name>_mempool</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name>mp</name> <operator>=</operator> <name>_mempool</name></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <function type="operator"><type><name>bool</name></type> <name>operator<name>()</name></name><parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>&gt;</argument_list><operator>::</operator><name>iterator</name></name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>&gt;</argument_list><operator>::</operator><name>iterator</name></name></type> <name>b</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="block">/* As std::make_heap produces a max-heap, we want the entries with the
         * fewest ancestors/highest fee to sort later. */</comment>
        <return>return <expr><call><name><name>mp</name><operator>-&gt;</operator><name>CompareDepthAndScore</name></name><argument_list>(<argument><expr><operator>*</operator><name>b</name></expr></argument>, <argument><expr><operator>*</operator><name>a</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>
</public>}</block>;</class>
</block_content>}</block>

<function><type><name>bool</name></type> <name><name>PeerLogicValidation</name><operator>::</operator><name>SendMessages</name></name><parameter_list>(<parameter><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pto</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>Consensus</name><operator>::</operator><name>Params</name></name><modifier>&amp;</modifier></type> <name>consensusParams</name> <init>= <expr><call><name>Params</name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetConsensus</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <block>{<block_content>
        <comment type="line">// Don't send anything until the version handshake is complete</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pto</name><operator>-&gt;</operator><name>fSuccessfullyConnected</name></name> <operator>||</operator> <name><name>pto</name><operator>-&gt;</operator><name>fDisconnect</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>

        <comment type="line">// If we get here, the outgoing message serialization version is set and can't change.</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>CNetMsgMaker</name></type> <name>msgMaker</name><argument_list>(<argument><expr><call><name><name>pto</name><operator>-&gt;</operator><name>GetSendVersion</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

        <comment type="line">//</comment>
        <comment type="line">// Message: ping</comment>
        <comment type="line">//</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>pingSend</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>pto</name><operator>-&gt;</operator><name>fPingQueued</name></name></expr>)</condition> <block>{<block_content>
            <comment type="line">// RPC ping request by user</comment>
            <expr_stmt><expr><name>pingSend</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>pto</name><operator>-&gt;</operator><name>nPingNonceSent</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pto</name><operator>-&gt;</operator><name>nPingUsecStart</name></name> <operator>+</operator> <name>PING_INTERVAL</name> <operator>*</operator> <literal type="number">1000000</literal> <operator>&lt;</operator> <call><name>GetTimeMicros</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="line">// Ping automatically sent as a latency probe &amp; keepalive.</comment>
            <expr_stmt><expr><name>pingSend</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>pingSend</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>uint64_t</name></type> <name>nonce</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><name>nonce</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>GetRandBytes</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>nonce</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nonce</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><name><name>pto</name><operator>-&gt;</operator><name>fPingQueued</name></name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pto</name><operator>-&gt;</operator><name>nPingUsecStart</name></name> <operator>=</operator> <call><name>GetTimeMicros</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>pto</name><operator>-&gt;</operator><name>nVersion</name></name> <operator>&gt;</operator> <name>BIP0031_VERSION</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>pto</name><operator>-&gt;</operator><name>nPingNonceSent</name></name> <operator>=</operator> <name>nonce</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pto</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>PING</name></name></expr></argument>, <argument><expr><name>nonce</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <comment type="line">// Peer is too old to support ping command with nonce, pong will never arrive.</comment>
                <expr_stmt><expr><name><name>pto</name><operator>-&gt;</operator><name>nPingNonceSent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pto</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>PING</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>TRY_LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>, <argument><expr><name>lockMain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>lockMain</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>CheckIfBanned</name><argument_list>(<argument><expr><name>pto</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>CNodeState</name> <modifier>&amp;</modifier></type><name>state</name> <init>= <expr><operator>*</operator><call><name>State</name><argument_list>(<argument><expr><call><name><name>pto</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Address refresh broadcast</comment>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>nNow</name> <init>= <expr><call><name>GetTimeMicros</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>current_time</name> <init>= <expr><call><name><name>GetTime</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>microseconds</name></name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>pto</name><operator>-&gt;</operator><name>IsAddrRelayPeer</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><operator>::</operator><name>ChainstateActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>IsInitialBlockDownload</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pto</name><operator>-&gt;</operator><name>nNextLocalAddrSend</name></name> <operator>&lt;</operator> <name>nNow</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>AdvertiseLocal</name><argument_list>(<argument><expr><name>pto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pto</name><operator>-&gt;</operator><name>nNextLocalAddrSend</name></name> <operator>=</operator> <call><name>PoissonNextSend</name><argument_list>(<argument><expr><name>nNow</name></expr></argument>, <argument><expr><name>AVG_LOCAL_ADDRESS_BROADCAST_INTERVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">//</comment>
        <comment type="line">// Message: addr</comment>
        <comment type="line">//</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>pto</name><operator>-&gt;</operator><name>IsAddrRelayPeer</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pto</name><operator>-&gt;</operator><name>nNextAddrSend</name></name> <operator>&lt;</operator> <name>nNow</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>pto</name><operator>-&gt;</operator><name>nNextAddrSend</name></name> <operator>=</operator> <call><name>PoissonNextSend</name><argument_list>(<argument><expr><name>nNow</name></expr></argument>, <argument><expr><name>AVG_ADDRESS_BROADCAST_INTERVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CAddress</name></expr></argument>&gt;</argument_list></name></type> <name>vAddr</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>vAddr</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>pto</name><operator>-&gt;</operator><name>vAddrToSend</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pto</name><operator>-&gt;</operator><name>m_addr_known</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CAddress</name><modifier>&amp;</modifier></type> <name>addr</name> <range>: <expr><name><name>pto</name><operator>-&gt;</operator><name>vAddrToSend</name></name></expr></range></decl></init>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pto</name><operator>-&gt;</operator><name>m_addr_known</name><operator>-&gt;</operator><name>contains</name></name><argument_list>(<argument><expr><call><name><name>addr</name><operator>.</operator><name>GetKey</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name><name>pto</name><operator>-&gt;</operator><name>m_addr_known</name><operator>-&gt;</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>addr</name><operator>.</operator><name>GetKey</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>vAddr</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="line">// receiver rejects addr messages larger than 1000</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>vAddr</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <literal type="number">1000</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pto</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>ADDR</name></name></expr></argument>, <argument><expr><name>vAddr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>vAddr</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name><name>pto</name><operator>-&gt;</operator><name>vAddrToSend</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>vAddr</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pto</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>ADDR</name></name></expr></argument>, <argument><expr><name>vAddr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="line">// we only send the big addr message once</comment>
            <if_stmt><if>if <condition>(<expr><call><name><name>pto</name><operator>-&gt;</operator><name>vAddrToSend</name><operator>.</operator><name>capacity</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">40</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>pto</name><operator>-&gt;</operator><name>vAddrToSend</name><operator>.</operator><name>shrink_to_fit</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Start block sync</comment>
        <if_stmt><if>if <condition>(<expr><name>pindexBestHeader</name> <operator>==</operator> <literal type="null">nullptr</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>pindexBestHeader</name> <operator>=</operator> <call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Tip</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>fFetch</name> <init>= <expr><name><name>state</name><operator>.</operator><name>fPreferredDownload</name></name> <operator>||</operator> <operator>(</operator><name>nPreferredDownload</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pto</name><operator>-&gt;</operator><name>fClient</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pto</name><operator>-&gt;</operator><name>fOneShot</name></name><operator>)</operator></expr></init></decl>;</decl_stmt> <comment type="line">// Download if this is a nice peer, or we have no nice peers and this one might do.</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>.</operator><name>fSyncStarted</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pto</name><operator>-&gt;</operator><name>fClient</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>fImporting</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>fReindex</name></expr>)</condition> <block>{<block_content>
            <comment type="line">// Only actively request headers from a single peer, unless we're close to today.</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>nSyncStarted</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>fFetch</name><operator>)</operator> <operator>||</operator> <call><name><name>pindexBestHeader</name><operator>-&gt;</operator><name>GetBlockTime</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <call><name>GetAdjustedTime</name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">24</literal> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">60</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>state</name><operator>.</operator><name>fSyncStarted</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>.</operator><name>nHeadersSyncTimeout</name></name> <operator>=</operator> <call><name>GetTimeMicros</name><argument_list>()</argument_list></call> <operator>+</operator> <name>HEADERS_DOWNLOAD_TIMEOUT_BASE</name> <operator>+</operator> <name>HEADERS_DOWNLOAD_TIMEOUT_PER_HEADER</name> <operator>*</operator> <operator>(</operator><call><name>GetAdjustedTime</name><argument_list>()</argument_list></call> <operator>-</operator> <call><name><name>pindexBestHeader</name><operator>-&gt;</operator><name>GetBlockTime</name></name><argument_list>()</argument_list></call><operator>)</operator><operator>/</operator><operator>(</operator><name><name>consensusParams</name><operator>.</operator><name>nPowTargetSpacing</name></name><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>nSyncStarted</name><operator>++</operator></expr>;</expr_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>CBlockIndex</name> <modifier>*</modifier></type><name>pindexStart</name> <init>= <expr><name>pindexBestHeader</name></expr></init></decl>;</decl_stmt>
                <comment type="block">/* If possible, start at the block preceding the currently
                   best known header.  This ensures that we always get a
                   non-empty list of headers back as long as the peer
                   is up-to-date.  With a non-empty response, we can initialise
                   the peer's known best block.  This wouldn't be possible
                   if we requested starting at pindexBestHeader and
                   got back an empty response.  */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>pindexStart</name><operator>-&gt;</operator><name>pprev</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>pindexStart</name> <operator>=</operator> <name><name>pindexStart</name><operator>-&gt;</operator><name>pprev</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"initial getheaders (%d) to peer=%d (startheight:%d)\n"</literal></expr></argument>, <argument><expr><name><name>pindexStart</name><operator>-&gt;</operator><name>nHeight</name></name></expr></argument>, <argument><expr><call><name><name>pto</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>pto</name><operator>-&gt;</operator><name>nStartingHeight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pto</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>GETHEADERS</name></name></expr></argument>, <argument><expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetLocator</name><argument_list>(<argument><expr><name>pindexStart</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>uint256</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">//</comment>
        <comment type="line">// Try sending block announcements via headers</comment>
        <comment type="line">//</comment>
        <block>{<block_content>
            <comment type="line">// If we have less than MAX_BLOCKS_TO_ANNOUNCE in our</comment>
            <comment type="line">// list of block hashes we're relaying, and our peer wants</comment>
            <comment type="line">// headers announcements, then find the first header</comment>
            <comment type="line">// not yet known to our peer but would connect, and send.</comment>
            <comment type="line">// If no header would connect, or if we have too many</comment>
            <comment type="line">// blocks, or if the peer doesn't want headers, just</comment>
            <comment type="line">// add all to the inv queue.</comment>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pto</name><operator>-&gt;</operator><name>cs_inventory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CBlock</name></expr></argument>&gt;</argument_list></name></type> <name>vHeaders</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>fRevertToInv</name> <init>= <expr><operator>(</operator><operator>(</operator><operator>!</operator><name><name>state</name><operator>.</operator><name>fPreferHeaders</name></name> <operator>&amp;&amp;</operator>
                                 <operator>(</operator><operator>!</operator><name><name>state</name><operator>.</operator><name>fPreferHeaderAndIDs</name></name> <operator>||</operator> <call><name><name>pto</name><operator>-&gt;</operator><name>vBlockHashesToAnnounce</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>||</operator>
                                <call><name><name>pto</name><operator>-&gt;</operator><name>vBlockHashesToAnnounce</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>MAX_BLOCKS_TO_ANNOUNCE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>CBlockIndex</name> <modifier>*</modifier></type><name>pBestIndex</name> <init>= <expr><literal type="null">nullptr</literal></expr></init></decl>;</decl_stmt> <comment type="line">// last header queued for delivery</comment>
            <expr_stmt><expr><call><name>ProcessBlockAvailability</name><argument_list>(<argument><expr><call><name><name>pto</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// ensure pindexBestKnownBlock is up-to-date</comment>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fRevertToInv</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>bool</name></type> <name>fFoundStartingHeader</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
                <comment type="line">// Try to find first header that our peer doesn't have, and</comment>
                <comment type="line">// then send all headers past that one.  If we come across any</comment>
                <comment type="line">// headers that aren't on ::ChainActive(), give up.</comment>
                <for>for <control>(<init><decl><type><specifier>const</specifier> <name>uint256</name> <modifier>&amp;</modifier></type><name>hash</name> <range>: <expr><name><name>pto</name><operator>-&gt;</operator><name>vBlockHashesToAnnounce</name></name></expr></range></decl></init>)</control> <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>CBlockIndex</name><modifier>*</modifier></type> <name>pindex</name> <init>= <expr><call><name>LookupBlockIndex</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><index>[<expr><name><name>pindex</name><operator>-&gt;</operator><name>nHeight</name></name></expr>]</index> <operator>!=</operator> <name>pindex</name></expr>)</condition> <block>{<block_content>
                        <comment type="line">// Bail out if we reorged away from this block</comment>
                        <expr_stmt><expr><name>fRevertToInv</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><name>pBestIndex</name> <operator>!=</operator> <literal type="null">nullptr</literal> <operator>&amp;&amp;</operator> <name><name>pindex</name><operator>-&gt;</operator><name>pprev</name></name> <operator>!=</operator> <name>pBestIndex</name></expr>)</condition> <block>{<block_content>
                        <comment type="line">// This means that the list of blocks to announce don't</comment>
                        <comment type="line">// connect to each other.</comment>
                        <comment type="line">// This shouldn't really be possible to hit during</comment>
                        <comment type="line">// regular operation (because reorgs should take us to</comment>
                        <comment type="line">// a chain that has some block not on the prior chain,</comment>
                        <comment type="line">// which should be caught by the prior check), but one</comment>
                        <comment type="line">// way this could happen is by using invalidateblock /</comment>
                        <comment type="line">// reconsiderblock repeatedly on the tip, causing it to</comment>
                        <comment type="line">// be added multiple times to vBlockHashesToAnnounce.</comment>
                        <comment type="line">// Robustly deal with this rare situation by reverting</comment>
                        <comment type="line">// to an inv.</comment>
                        <expr_stmt><expr><name>fRevertToInv</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>pBestIndex</name> <operator>=</operator> <name>pindex</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>fFoundStartingHeader</name></expr>)</condition> <block>{<block_content>
                        <comment type="line">// add this to the headers message</comment>
                        <expr_stmt><expr><call><name><name>vHeaders</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>pindex</name><operator>-&gt;</operator><name>GetBlockHeader</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>PeerHasHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>pindex</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <continue>continue;</continue> <comment type="line">// keep looking for the first new block</comment>
                    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pindex</name><operator>-&gt;</operator><name>pprev</name></name> <operator>==</operator> <literal type="null">nullptr</literal> <operator>||</operator> <call><name>PeerHasHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name><name>pindex</name><operator>-&gt;</operator><name>pprev</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <comment type="line">// Peer doesn't have this header but they do have the prior one.</comment>
                        <comment type="line">// Start sending headers.</comment>
                        <expr_stmt><expr><name>fFoundStartingHeader</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>vHeaders</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>pindex</name><operator>-&gt;</operator><name>GetBlockHeader</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <comment type="line">// Peer doesn't have this header or the prior one -- nothing will</comment>
                        <comment type="line">// connect, so bail out.</comment>
                        <expr_stmt><expr><name>fRevertToInv</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fRevertToInv</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>vHeaders</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>vHeaders</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>fPreferHeaderAndIDs</name></name></expr>)</condition> <block>{<block_content>
                    <comment type="line">// We only send up to 1 block as header-and-ids, as otherwise</comment>
                    <comment type="line">// probably means we're doing an initial-ish-sync or they're slow</comment>
                    <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"%s sending header-and-ids %s to peer=%d\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>,
                            <argument><expr><call><name><name>vHeaders</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetHash</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ToString</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pto</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <decl_stmt><decl><type><name>int</name></type> <name>nSendFlags</name> <init>= <expr><ternary><condition><expr><name><name>state</name><operator>.</operator><name>fWantsCmpctWitness</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>SERIALIZE_TRANSACTION_NO_WITNESS</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

                    <decl_stmt><decl><type><name>bool</name></type> <name>fGotBlockFromCache</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_most_recent_block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>most_recent_block_hash</name> <operator>==</operator> <call><name><name>pBestIndex</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>fWantsCmpctWitness</name></name> <operator>||</operator> <operator>!</operator><name>fWitnessesPresentInMostRecentCompactBlock</name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pto</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name>nSendFlags</name></expr></argument>, <argument><expr><name><name>NetMsgType</name><operator>::</operator><name>CMPCTBLOCK</name></name></expr></argument>, <argument><expr><operator>*</operator><name>most_recent_compact_block</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                            <else>else <block>{<block_content>
                                <decl_stmt><decl><type><name>CBlockHeaderAndShortTxIDs</name></type> <name>cmpctblock</name><argument_list>(<argument><expr><operator>*</operator><name>most_recent_block</name></expr></argument>, <argument><expr><name><name>state</name><operator>.</operator><name>fWantsCmpctWitness</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
                                <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pto</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name>nSendFlags</name></expr></argument>, <argument><expr><name><name>NetMsgType</name><operator>::</operator><name>CMPCTBLOCK</name></name></expr></argument>, <argument><expr><name>cmpctblock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></else></if_stmt>
                            <expr_stmt><expr><name>fGotBlockFromCache</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fGotBlockFromCache</name></expr>)</condition> <block>{<block_content>
                        <decl_stmt><decl><type><name>CBlock</name></type> <name>block</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><call><name>ReadBlockFromDisk</name><argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><name>pBestIndex</name></expr></argument>, <argument><expr><name>consensusParams</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <decl_stmt><decl><type><name>CBlockHeaderAndShortTxIDs</name></type> <name>cmpctblock</name><argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><name><name>state</name><operator>.</operator><name>fWantsCmpctWitness</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pto</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name>nSendFlags</name></expr></argument>, <argument><expr><name><name>NetMsgType</name><operator>::</operator><name>CMPCTBLOCK</name></name></expr></argument>, <argument><expr><name>cmpctblock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>pindexBestHeaderSent</name></name> <operator>=</operator> <name>pBestIndex</name></expr>;</expr_stmt>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>state</name><operator>.</operator><name>fPreferHeaders</name></name></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name><name>vHeaders</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"%s: %u headers, range (%s, %s), to peer=%d\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>,
                                <argument><expr><call><name><name>vHeaders</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>vHeaders</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetHash</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ToString</name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>vHeaders</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetHash</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ToString</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pto</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"%s: sending header %s to peer=%d\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>,
                                <argument><expr><call><name><name>vHeaders</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetHash</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ToString</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pto</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                    <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pto</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>HEADERS</name></name></expr></argument>, <argument><expr><name>vHeaders</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>pindexBestHeaderSent</name></name> <operator>=</operator> <name>pBestIndex</name></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>fRevertToInv</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>fRevertToInv</name></expr>)</condition> <block>{<block_content>
                <comment type="line">// If falling back to using an inv, just try to inv the tip.</comment>
                <comment type="line">// The last entry in vBlockHashesToAnnounce was our tip at some point</comment>
                <comment type="line">// in the past.</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pto</name><operator>-&gt;</operator><name>vBlockHashesToAnnounce</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>uint256</name> <modifier>&amp;</modifier></type><name>hashToAnnounce</name> <init>= <expr><call><name><name>pto</name><operator>-&gt;</operator><name>vBlockHashesToAnnounce</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>CBlockIndex</name><modifier>*</modifier></type> <name>pindex</name> <init>= <expr><call><name>LookupBlockIndex</name><argument_list>(<argument><expr><name>hashToAnnounce</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Warn if we're announcing a block that is not on the main chain.</comment>
                    <comment type="line">// This should be very rare and could be optimized out.</comment>
                    <comment type="line">// Just log for now.</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><index>[<expr><name><name>pindex</name><operator>-&gt;</operator><name>nHeight</name></name></expr>]</index> <operator>!=</operator> <name>pindex</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"Announcing block %s not on main chain (tip=%s)\n"</literal></expr></argument>,
                            <argument><expr><call><name><name>hashToAnnounce</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Tip</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>GetBlockHash</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ToString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="line">// If the peer's chain has this block, don't inv it back.</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PeerHasHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>pindex</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name><name>pto</name><operator>-&gt;</operator><name>PushInventory</name></name><argument_list>(<argument><expr><call><name>CInv</name><argument_list>(<argument><expr><name>MSG_BLOCK</name></expr></argument>, <argument><expr><name>hashToAnnounce</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"%s: sending inv peer=%d hash=%s\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>,
                            <argument><expr><call><name><name>pto</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>hashToAnnounce</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name><name>pto</name><operator>-&gt;</operator><name>vBlockHashesToAnnounce</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <comment type="line">//</comment>
        <comment type="line">// Message: inventory</comment>
        <comment type="line">//</comment>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CInv</name></expr></argument>&gt;</argument_list></name></type> <name>vInv</name></decl>;</decl_stmt>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pto</name><operator>-&gt;</operator><name>cs_inventory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>vInv</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>max</name><argument_list type="generic">&lt;<argument><expr><name>size_t</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>pto</name><operator>-&gt;</operator><name>vInventoryBlockToSend</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>INVENTORY_BROADCAST_MAX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Add blocks</comment>
            <for>for <control>(<init><decl><type><specifier>const</specifier> <name>uint256</name><modifier>&amp;</modifier></type> <name>hash</name> <range>: <expr><name><name>pto</name><operator>-&gt;</operator><name>vInventoryBlockToSend</name></name></expr></range></decl></init>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name><name>vInv</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>CInv</name><argument_list>(<argument><expr><name>MSG_BLOCK</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>vInv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>MAX_INV_SZ</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pto</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>INV</name></name></expr></argument>, <argument><expr><name>vInv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>vInv</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name><name>pto</name><operator>-&gt;</operator><name>vInventoryBlockToSend</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name></name> <operator>!=</operator> <literal type="null">nullptr</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>cs_tx_inventory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// Check whether periodic sends should happen</comment>
                <decl_stmt><decl><type><name>bool</name></type> <name>fSendTrickle</name> <init>= <expr><call><name><name>pto</name><operator>-&gt;</operator><name>HasPermission</name></name><argument_list>(<argument><expr><name>PF_NOBAN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>nNextInvSend</name></name> <operator>&lt;</operator> <name>current_time</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>fSendTrickle</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>pto</name><operator>-&gt;</operator><name>fInbound</name></name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>nNextInvSend</name></name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>microseconds</name></name><argument_list>{<argument><expr><macro><name>connman</name></macro><operator>-&gt;</operator><macro><name>PoissonNextSendInbound</name><argument_list>(<argument>nNow</argument>, <argument>INVENTORY_BROADCAST_INTERVAL</argument>)</argument_list></macro></expr></argument>}</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <comment type="line">// Use half the delay for outbound peers, as there is less privacy concern for them.</comment>
                        <expr_stmt><expr><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>nNextInvSend</name></name> <operator>=</operator> <call><name>PoissonNextSend</name><argument_list>(<argument><expr><name>current_time</name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>seconds</name></name><argument_list>{<argument><expr><name>INVENTORY_BROADCAST_INTERVAL</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr></argument>}</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// Time to send but the peer has requested we not relay transactions.</comment>
                <if_stmt><if>if <condition>(<expr><name>fSendTrickle</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>cs_filter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>fRelayTxes</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>setInventoryTxToSend</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// Respond to BIP35 mempool requests</comment>
                <if_stmt><if>if <condition>(<expr><name>fSendTrickle</name> <operator>&amp;&amp;</operator> <name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>fSendMempool</name></name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>auto</name></type> <name>vtxinfo</name> <init>= <expr><call><name><name>mempool</name><operator>.</operator><name>infoAll</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>fSendMempool</name></name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                    <decl_stmt><decl><type><name>CFeeRate</name></type> <name>filterrate</name></decl>;</decl_stmt>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>cs_feeFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>filterrate</name> <operator>=</operator> <call><name>CFeeRate</name><argument_list>(<argument><expr><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>minFeeFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block>

                    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>cs_filter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>txinfo</name> <range>: <expr><name>vtxinfo</name></expr></range></decl></init>)</control> <block>{<block_content>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>uint256</name><modifier>&amp;</modifier></type> <name>hash</name> <init>= <expr><call><name><name>txinfo</name><operator>.</operator><name>tx</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>CInv</name></type> <name>inv</name><argument_list>(<argument><expr><name>MSG_TX</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>setInventoryTxToSend</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="line">// Don't send transactions that peers will not put into their mempool</comment>
                        <if_stmt><if>if <condition>(<expr><name><name>txinfo</name><operator>.</operator><name>fee</name></name> <operator>&lt;</operator> <call><name><name>filterrate</name><operator>.</operator><name>GetFee</name></name><argument_list>(<argument><expr><name><name>txinfo</name><operator>.</operator><name>vsize</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                            <continue>continue;</continue>
                        </block_content>}</block></if></if_stmt>
                        <if_stmt><if>if <condition>(<expr><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>pfilter</name></name></expr>)</condition> <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>pfilter</name><operator>-&gt;</operator><name>IsRelevantAndUpdate</name></name><argument_list>(<argument><expr><operator>*</operator><name><name>txinfo</name><operator>.</operator><name>tx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><call><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>filterInventoryKnown</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>vInv</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>inv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><call><name><name>vInv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>MAX_INV_SZ</name></expr>)</condition> <block>{<block_content>
                            <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pto</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>INV</name></name></expr></argument>, <argument><expr><name>vInv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>vInv</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>
                    <expr_stmt><expr><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>m_last_mempool_req</name></name> <operator>=</operator> <call><name><name>GetTime</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>seconds</name></name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// Determine transactions to relay</comment>
                <if_stmt><if>if <condition>(<expr><name>fSendTrickle</name></expr>)</condition> <block>{<block_content>
                    <comment type="line">// Produce a vector with all candidates for sending</comment>
                    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>&gt;</argument_list><operator>::</operator><name>iterator</name></name></expr></argument>&gt;</argument_list></name></type> <name>vInvTx</name></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>vInvTx</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>setInventoryTxToSend</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <for>for <control>(<init><decl><type><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>&gt;</argument_list><operator>::</operator><name>iterator</name></name></type> <name>it</name> <init>= <expr><call><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>setInventoryTxToSend</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>it</name> <operator>!=</operator> <call><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>setInventoryTxToSend</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>it</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                        <expr_stmt><expr><call><name><name>vInvTx</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></for>
                    <decl_stmt><decl><type><name>CFeeRate</name></type> <name>filterrate</name></decl>;</decl_stmt>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>cs_feeFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>filterrate</name> <operator>=</operator> <call><name>CFeeRate</name><argument_list>(<argument><expr><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>minFeeFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block>
                    <comment type="line">// Topologically and fee-rate sort the inventory we send for privacy and priority reasons.</comment>
                    <comment type="line">// A heap is used so that not all items need sorting if only a few are being sent.</comment>
                    <decl_stmt><decl><type><name>CompareInvMempoolOrder</name></type> <name>compareInvMempoolOrder</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mempool</name></expr></argument>)</argument_list></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>std</name><operator>::</operator><name>make_heap</name></name><argument_list>(<argument><expr><call><name><name>vInvTx</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>vInvTx</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>compareInvMempoolOrder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="line">// No reason to drain out at many times the network's capacity,</comment>
                    <comment type="line">// especially since we have many peers and some will draw much shorter delays.</comment>
                    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nRelayedTransactions</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>cs_filter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <while>while <condition>(<expr><operator>!</operator><call><name><name>vInvTx</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>nRelayedTransactions</name> <operator>&lt;</operator> <name>INVENTORY_BROADCAST_MAX</name></expr>)</condition> <block>{<block_content>
                        <comment type="line">// Fetch the top element from the heap</comment>
                        <expr_stmt><expr><call><name><name>std</name><operator>::</operator><name>pop_heap</name></name><argument_list>(<argument><expr><call><name><name>vInvTx</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>vInvTx</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>compareInvMempoolOrder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>&gt;</argument_list><operator>::</operator><name>iterator</name></name></type> <name>it</name> <init>= <expr><call><name><name>vInvTx</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name><name>vInvTx</name><operator>.</operator><name>pop_back</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <decl_stmt><decl><type><name>uint256</name></type> <name>hash</name> <init>= <expr><operator>*</operator><name>it</name></expr></init></decl>;</decl_stmt>
                        <comment type="line">// Remove it from the to-be-sent set</comment>
                        <expr_stmt><expr><call><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>setInventoryTxToSend</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="line">// Check if not in the filter already</comment>
                        <if_stmt><if>if <condition>(<expr><call><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>filterInventoryKnown</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                            <continue>continue;</continue>
                        </block_content>}</block></if></if_stmt>
                        <comment type="line">// Not in the mempool anymore? don't bother sending it.</comment>
                        <decl_stmt><decl><type><name>auto</name></type> <name>txinfo</name> <init>= <expr><call><name><name>mempool</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>txinfo</name><operator>.</operator><name>tx</name></name></expr>)</condition> <block>{<block_content>
                            <continue>continue;</continue>
                        </block_content>}</block></if></if_stmt>
                        <comment type="line">// Peer told you to not send transactions at that feerate? Don't bother sending it.</comment>
                        <if_stmt><if>if <condition>(<expr><name><name>txinfo</name><operator>.</operator><name>fee</name></name> <operator>&lt;</operator> <call><name><name>filterrate</name><operator>.</operator><name>GetFee</name></name><argument_list>(<argument><expr><name><name>txinfo</name><operator>.</operator><name>vsize</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                            <continue>continue;</continue>
                        </block_content>}</block></if></if_stmt>
                        <if_stmt><if>if <condition>(<expr><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>pfilter</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>pfilter</name><operator>-&gt;</operator><name>IsRelevantAndUpdate</name></name><argument_list>(<argument><expr><operator>*</operator><name><name>txinfo</name><operator>.</operator><name>tx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
                        <comment type="line">// Send</comment>
                        <expr_stmt><expr><call><name><name>vInv</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>CInv</name><argument_list>(<argument><expr><name>MSG_TX</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>nRelayedTransactions</name><operator>++</operator></expr>;</expr_stmt>
                        <block>{<block_content>
                            <comment type="line">// Expire old relay messages</comment>
                            <while>while <condition>(<expr><operator>!</operator><call><name><name>vRelayExpiration</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>vRelayExpiration</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call><operator>.</operator><name>first</name> <operator>&lt;</operator> <name>nNow</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name><name>mapRelay</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><call><name><name>vRelayExpiration</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call><operator>.</operator><name>second</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name><name>vRelayExpiration</name><operator>.</operator><name>pop_front</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></while>

                            <decl_stmt><decl><type><name>auto</name></type> <name>ret</name> <init>= <expr><call><name><name>mapRelay</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name><name>txinfo</name><operator>.</operator><name>tx</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <if_stmt><if>if <condition>(<expr><name><name>ret</name><operator>.</operator><name>second</name></name></expr>)</condition> <block>{<block_content>
                                <expr_stmt><expr><call><name><name>vRelayExpiration</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><name>nNow</name> <operator>+</operator> <call><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>microseconds</name></name><argument_list>{<argument><expr><name>RELAY_TX_CACHE_TIME</name></expr></argument>}</argument_list></call><operator>.</operator><call><name>count</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>ret</name><operator>.</operator><name>first</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block>
                        <if_stmt><if>if <condition>(<expr><call><name><name>vInv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>MAX_INV_SZ</name></expr>)</condition> <block>{<block_content>
                            <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pto</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>INV</name></name></expr></argument>, <argument><expr><name>vInv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>vInv</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><call><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>filterInventoryKnown</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></while>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>vInv</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pto</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>INV</name></name></expr></argument>, <argument><expr><name>vInv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Detect whether we're stalling</comment>
        <expr_stmt><expr><name>current_time</name> <operator>=</operator> <call><name><name>GetTime</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>microseconds</name></name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// nNow is the current system time (GetTimeMicros is not mockable) and</comment>
        <comment type="line">// should be replaced by the mockable current_time eventually</comment>
        <expr_stmt><expr><name>nNow</name> <operator>=</operator> <call><name>GetTimeMicros</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>nStallingSince</name></name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>nStallingSince</name></name> <operator>&lt;</operator> <name>nNow</name> <operator>-</operator> <literal type="number">1000000</literal> <operator>*</operator> <name>BLOCK_STALLING_TIMEOUT</name></expr>)</condition> <block>{<block_content>
            <comment type="line">// Stalling only triggers when the block download window cannot move. During normal steady state,</comment>
            <comment type="line">// the download window should be much larger than the to-be-downloaded set of blocks, so disconnection</comment>
            <comment type="line">// should only happen during initial block download.</comment>
            <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"Peer=%d is stalling block download, disconnecting\n"</literal></expr></argument>, <argument><expr><call><name><name>pto</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pto</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <comment type="line">// In case there is a block that has been in flight from this peer for 2 + 0.5 * N times the block interval</comment>
        <comment type="line">// (with N the number of peers from which we're downloading validated blocks), disconnect due to timeout.</comment>
        <comment type="line">// We compensate for other peers to prevent killing off peers due to our own downstream link</comment>
        <comment type="line">// being saturated. We only count validated in-flight blocks so peers can't advertise non-existing block hashes</comment>
        <comment type="line">// to unreasonably increase our timeout.</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>state</name><operator>.</operator><name>vBlocksInFlight</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>QueuedBlock</name> <modifier>&amp;</modifier></type><name>queuedBlock</name> <init>= <expr><call><name><name>state</name><operator>.</operator><name>vBlocksInFlight</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>nOtherPeersWithValidatedDownloads</name> <init>= <expr><name>nPeersWithValidatedDownloads</name> <operator>-</operator> <operator>(</operator><name><name>state</name><operator>.</operator><name>nBlocksInFlightValidHeaders</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>nNow</name> <operator>&gt;</operator> <name><name>state</name><operator>.</operator><name>nDownloadingSince</name></name> <operator>+</operator> <name><name>consensusParams</name><operator>.</operator><name>nPowTargetSpacing</name></name> <operator>*</operator> <operator>(</operator><name>BLOCK_DOWNLOAD_TIMEOUT_BASE</name> <operator>+</operator> <name>BLOCK_DOWNLOAD_TIMEOUT_PER_PEER</name> <operator>*</operator> <name>nOtherPeersWithValidatedDownloads</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"Timeout downloading block %s from peer=%d, disconnecting\n"</literal></expr></argument>, <argument><expr><call><name><name>queuedBlock</name><operator>.</operator><name>hash</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pto</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pto</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="line">// Check for headers sync timeouts</comment>
        <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>fSyncStarted</name></name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>nHeadersSyncTimeout</name></name> <operator>&lt;</operator> <call><name><name>std</name><operator>::</operator><name>numeric_limits</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list><operator>::</operator><name>max</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="line">// Detect whether this is a stalling initial-headers-sync peer</comment>
            <if_stmt><if>if <condition>(<expr><call><name><name>pindexBestHeader</name><operator>-&gt;</operator><name>GetBlockTime</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <call><name>GetAdjustedTime</name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">24</literal><operator>*</operator><literal type="number">60</literal><operator>*</operator><literal type="number">60</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>nNow</name> <operator>&gt;</operator> <name><name>state</name><operator>.</operator><name>nHeadersSyncTimeout</name></name> <operator>&amp;&amp;</operator> <name>nSyncStarted</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>nPreferredDownload</name> <operator>-</operator> <name><name>state</name><operator>.</operator><name>fPreferredDownload</name></name> <operator>&gt;=</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
                    <comment type="line">// Disconnect a (non-whitelisted) peer if it is our only sync peer,</comment>
                    <comment type="line">// and we have others we could be using instead.</comment>
                    <comment type="line">// Note: If all our peers are inbound, then we won't</comment>
                    <comment type="line">// disconnect our sync peer for stalling; we have bigger</comment>
                    <comment type="line">// problems if we can't get any outbound peers.</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pto</name><operator>-&gt;</operator><name>HasPermission</name></name><argument_list>(<argument><expr><name>PF_NOBAN</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"Timeout downloading headers from peer=%d, disconnecting\n"</literal></expr></argument>, <argument><expr><call><name><name>pto</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>pto</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"Timeout downloading headers from whitelisted peer=%d, not disconnecting\n"</literal></expr></argument>, <argument><expr><call><name><name>pto</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="line">// Reset the headers sync state so that we have a</comment>
                        <comment type="line">// chance to try downloading from a different peer.</comment>
                        <comment type="line">// Note: this will also result in at least one more</comment>
                        <comment type="line">// getheaders message to be sent to</comment>
                        <comment type="line">// this peer (eventually).</comment>
                        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>fSyncStarted</name></name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>nSyncStarted</name><operator>--</operator></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>nHeadersSyncTimeout</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <comment type="line">// After we've caught up once, reset the timeout so we can't trigger</comment>
                <comment type="line">// disconnect later.</comment>
                <expr_stmt><expr><name><name>state</name><operator>.</operator><name>nHeadersSyncTimeout</name></name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>numeric_limits</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list><operator>::</operator><name>max</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Check that outbound peers have reasonable chains</comment>
        <comment type="line">// GetTime() is used by this anti-DoS logic so we can test this using mocktime</comment>
        <expr_stmt><expr><call><name>ConsiderEviction</name><argument_list>(<argument><expr><name>pto</name></expr></argument>, <argument><expr><call><name>GetTime</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">//</comment>
        <comment type="line">// Message: getdata (blocks)</comment>
        <comment type="line">//</comment>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CInv</name></expr></argument>&gt;</argument_list></name></type> <name>vGetData</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pto</name><operator>-&gt;</operator><name>fClient</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>fFetch</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pto</name><operator>-&gt;</operator><name>m_limited_node</name></name><operator>)</operator> <operator>||</operator> <operator>!</operator><call><name><operator>::</operator><name>ChainstateActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>IsInitialBlockDownload</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>nBlocksInFlight</name></name> <operator>&lt;</operator> <name>MAX_BLOCKS_IN_TRANSIT_PER_PEER</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CBlockIndex</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>vToDownload</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>NodeId</name></type> <name>staller</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>FindNextBlocksToDownload</name><argument_list>(<argument><expr><call><name><name>pto</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>MAX_BLOCKS_IN_TRANSIT_PER_PEER</name> <operator>-</operator> <name><name>state</name><operator>.</operator><name>nBlocksInFlight</name></name></expr></argument>, <argument><expr><name>vToDownload</name></expr></argument>, <argument><expr><name>staller</name></expr></argument>, <argument><expr><name>consensusParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CBlockIndex</name> <modifier>*</modifier></type><name>pindex</name> <range>: <expr><name>vToDownload</name></expr></range></decl></init>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>uint32_t</name></type> <name>nFetchFlags</name> <init>= <expr><call><name>GetFetchFlags</name><argument_list>(<argument><expr><name>pto</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>vGetData</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>CInv</name><argument_list>(<argument><expr><name>MSG_BLOCK</name> <operator>|</operator> <name>nFetchFlags</name></expr></argument>, <argument><expr><call><name><name>pindex</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>MarkBlockAsInFlight</name><argument_list>(<argument><expr><call><name><name>pto</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pindex</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"Requesting block %s (%d) peer=%d\n"</literal></expr></argument>, <argument><expr><call><name><name>pindex</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ToString</name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><name><name>pindex</name><operator>-&gt;</operator><name>nHeight</name></name></expr></argument>, <argument><expr><call><name><name>pto</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>nBlocksInFlight</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>staller</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>State</name><argument_list>(<argument><expr><name>staller</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>nStallingSince</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>State</name><argument_list>(<argument><expr><name>staller</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>nStallingSince</name> <operator>=</operator> <name>nNow</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"Stall started peer=%d\n"</literal></expr></argument>, <argument><expr><name>staller</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">//</comment>
        <comment type="line">// Message: getdata (non-blocks)</comment>
        <comment type="line">//</comment>

        <comment type="line">// For robustness, expire old requests after a long timeout, so that</comment>
        <comment type="line">// we can resume downloading transactions from a peer even if they</comment>
        <comment type="line">// were unresponsive in the past.</comment>
        <comment type="line">// Eventually we should consider disconnecting peers, but this is</comment>
        <comment type="line">// conservative.</comment>
        <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>m_tx_download</name><operator>.</operator><name>m_check_expiry_timer</name></name> <operator>&lt;=</operator> <name>current_time</name></expr>)</condition> <block>{<block_content>
            <for>for <control>(<init><decl><type><name>auto</name></type> <name>it</name><init>=<expr><call><name><name>state</name><operator>.</operator><name>m_tx_download</name><operator>.</operator><name>m_tx_in_flight</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>it</name> <operator>!=</operator> <call><name><name>state</name><operator>.</operator><name>m_tx_download</name><operator>.</operator><name>m_tx_in_flight</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition><incr/>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>second</name></name> <operator>&lt;=</operator> <name>current_time</name> <operator>-</operator> <name>TX_EXPIRY_INTERVAL</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"timeout of inflight tx %s from peer=%d\n"</literal></expr></argument>, <argument><expr><call><name><name>it</name><operator>-&gt;</operator><name>first</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pto</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>state</name><operator>.</operator><name>m_tx_download</name><operator>.</operator><name>m_tx_announced</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>state</name><operator>.</operator><name>m_tx_download</name><operator>.</operator><name>m_tx_in_flight</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>it</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><operator>++</operator><name>it</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></for>
            <comment type="line">// On average, we do this check every TX_EXPIRY_INTERVAL. Randomize</comment>
            <comment type="line">// so that we're not doing this for all peers at the same time.</comment>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>m_tx_download</name><operator>.</operator><name>m_check_expiry_timer</name></name> <operator>=</operator> <name>current_time</name> <operator>+</operator> <name>TX_EXPIRY_INTERVAL</name> <operator>/</operator> <literal type="number">2</literal> <operator>+</operator> <call><name>GetRandMicros</name><argument_list>(<argument><expr><name>TX_EXPIRY_INTERVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>auto</name><operator>&amp;</operator> <name>tx_process_time</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>m_tx_download</name><operator>.</operator><name>m_tx_process_time</name></name></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>!</operator><call><name><name>tx_process_time</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>tx_process_time</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>first</name> <operator>&lt;=</operator> <name>current_time</name> <operator>&amp;&amp;</operator> <call><name><name>state</name><operator>.</operator><name>m_tx_download</name><operator>.</operator><name>m_tx_in_flight</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>MAX_PEER_TX_IN_FLIGHT</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>uint256</name></type> <name>txid</name> <init>= <expr><call><name><name>tx_process_time</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>second</name></expr></init></decl>;</decl_stmt>
            <comment type="line">// Erase this entry from tx_process_time (it may be added back for</comment>
            <comment type="line">// processing at a later time, see below)</comment>
            <expr_stmt><expr><call><name><name>tx_process_time</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><call><name><name>tx_process_time</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>CInv</name></type> <name>inv</name><argument_list>(<argument><expr><name>MSG_TX</name> <operator>|</operator> <call><name>GetFetchFlags</name><argument_list>(<argument><expr><name>pto</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>txid</name></expr></argument>)</argument_list></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AlreadyHave</name><argument_list>(<argument><expr><name>inv</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <comment type="line">// If this transaction was last requested more than 1 minute ago,</comment>
                <comment type="line">// then request.</comment>
                <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>last_request_time</name> <init>= <expr><call><name>GetTxRequestTime</name><argument_list>(<argument><expr><name><name>inv</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>last_request_time</name> <operator>&lt;=</operator> <name>current_time</name> <operator>-</operator> <name>GETDATA_TX_INTERVAL</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"Requesting %s peer=%d\n"</literal></expr></argument>, <argument><expr><call><name><name>inv</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pto</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>vGetData</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>inv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name><name>vGetData</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>MAX_GETDATA_SZ</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pto</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>GETDATA</name></name></expr></argument>, <argument><expr><name>vGetData</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>vGetData</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name>UpdateTxRequestTime</name><argument_list>(<argument><expr><name><name>inv</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><name>current_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>state</name><operator>.</operator><name>m_tx_download</name><operator>.</operator><name>m_tx_in_flight</name><operator>.</operator><name>emplace</name></name><argument_list>(<argument><expr><name><name>inv</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><name>current_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <comment type="line">// This transaction is in flight from someone else; queue</comment>
                    <comment type="line">// up processing to happen after the download times out</comment>
                    <comment type="line">// (with a slight delay for inbound peers, to prefer</comment>
                    <comment type="line">// requests to outbound peers).</comment>
                    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>next_process_time</name> <init>= <expr><call><name>CalculateTxGetDataTime</name><argument_list>(<argument><expr><name>txid</name></expr></argument>, <argument><expr><name>current_time</name></expr></argument>, <argument><expr><operator>!</operator><name><name>state</name><operator>.</operator><name>fPreferredDownload</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>tx_process_time</name><operator>.</operator><name>emplace</name></name><argument_list>(<argument><expr><name>next_process_time</name></expr></argument>, <argument><expr><name>txid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <comment type="line">// We have already seen this transaction, no need to download.</comment>
                <expr_stmt><expr><call><name><name>state</name><operator>.</operator><name>m_tx_download</name><operator>.</operator><name>m_tx_announced</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name><name>inv</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>state</name><operator>.</operator><name>m_tx_download</name><operator>.</operator><name>m_tx_in_flight</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name><name>inv</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>


        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>vGetData</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pto</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>GETDATA</name></name></expr></argument>, <argument><expr><name>vGetData</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">//</comment>
        <comment type="line">// Message: feefilter</comment>
        <comment type="line">//</comment>
        <comment type="line">// We don't want white listed peers to filter txs to us if we have -whitelistforcerelay</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name></name> <operator>!=</operator> <literal type="null">nullptr</literal> <operator>&amp;&amp;</operator> <name><name>pto</name><operator>-&gt;</operator><name>nVersion</name></name> <operator>&gt;=</operator> <name>FEEFILTER_VERSION</name> <operator>&amp;&amp;</operator> <call><name><name>gArgs</name><operator>.</operator><name>GetBoolArg</name></name><argument_list>(<argument><expr><literal type="string">"-feefilter"</literal></expr></argument>, <argument><expr><name>DEFAULT_FEEFILTER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <operator>!</operator><call><name><name>pto</name><operator>-&gt;</operator><name>HasPermission</name></name><argument_list>(<argument><expr><name>PF_FORCERELAY</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>CAmount</name></type> <name>currentFilter</name> <init>= <expr><call><name><name>mempool</name><operator>.</operator><name>GetMinFee</name></name><argument_list>(<argument><expr><call><name><name>gArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-maxmempool"</literal></expr></argument>, <argument><expr><name>DEFAULT_MAX_MEMPOOL_SIZE</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">1000000</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>GetFeePerK</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>timeNow</name> <init>= <expr><call><name>GetTimeMicros</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>timeNow</name> <operator>&gt;</operator> <name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>nextSendTimeFeeFilter</name></name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><specifier>static</specifier> <name>CFeeRate</name></type> <name>default_feerate</name><argument_list>(<argument><expr><name>DEFAULT_MIN_RELAY_TX_FEE</name></expr></argument>)</argument_list></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>static</specifier> <name>FeeFilterRounder</name></type> <name>filterRounder</name><argument_list>(<argument><expr><name>default_feerate</name></expr></argument>)</argument_list></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>CAmount</name></type> <name>filterToSend</name> <init>= <expr><call><name><name>filterRounder</name><operator>.</operator><name>round</name></name><argument_list>(<argument><expr><name>currentFilter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <comment type="line">// We always have a fee filter of at least minRelayTxFee</comment>
                <expr_stmt><expr><name>filterToSend</name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>max</name></name><argument_list>(<argument><expr><name>filterToSend</name></expr></argument>, <argument><expr><call><name><operator>::</operator><name>minRelayTxFee</name><operator>.</operator><name>GetFeePerK</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>filterToSend</name> <operator>!=</operator> <name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>lastSentFeeFilter</name></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>connman</name><operator>-&gt;</operator><name>PushMessage</name></name><argument_list>(<argument><expr><name>pto</name></expr></argument>, <argument><expr><call><name><name>msgMaker</name><operator>.</operator><name>Make</name></name><argument_list>(<argument><expr><name><name>NetMsgType</name><operator>::</operator><name>FEEFILTER</name></name></expr></argument>, <argument><expr><name>filterToSend</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>lastSentFeeFilter</name></name> <operator>=</operator> <name>filterToSend</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>nextSendTimeFeeFilter</name></name> <operator>=</operator> <call><name>PoissonNextSend</name><argument_list>(<argument><expr><name>timeNow</name></expr></argument>, <argument><expr><name>AVG_FEEFILTER_BROADCAST_INTERVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <comment type="line">// If the fee filter has changed substantially and it's still more than MAX_FEEFILTER_CHANGE_DELAY</comment>
            <comment type="line">// until scheduled broadcast, then move the broadcast to within MAX_FEEFILTER_CHANGE_DELAY.</comment>
            <if type="elseif">else if <condition>(<expr><name>timeNow</name> <operator>+</operator> <name>MAX_FEEFILTER_CHANGE_DELAY</name> <operator>*</operator> <literal type="number">1000000</literal> <operator>&lt;</operator> <name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>nextSendTimeFeeFilter</name></name> <operator>&amp;&amp;</operator>
                     <operator>(</operator><name><name>currentFilter</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">3</literal> <operator>*</operator> <name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>lastSentFeeFilter</name></name> <operator>/</operator> <literal type="number">4</literal> <operator>||</operator> <name>currentFilter</name></expr></argument> &gt;</argument_list></name> <literal type="number">4</literal> <operator>*</operator> <name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>lastSentFeeFilter</name></name> <operator>/</operator> <literal type="number">3</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>pto</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>nextSendTimeFeeFilter</name></name> <operator>=</operator> <name>timeNow</name> <operator>+</operator> <call><name>GetRandInt</name><argument_list>(<argument><expr><name>MAX_FEEFILTER_CHANGE_DELAY</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<class>class <name>CNetProcessingCleanup</name>
<block>{<private type="default">
</private><public>public:
    <constructor><name>CNetProcessingCleanup</name><parameter_list>()</parameter_list> <block>{<block_content/>}</block></constructor>
    <destructor><name>~CNetProcessingCleanup</name><parameter_list>()</parameter_list> <block>{<block_content>
        <comment type="line">// orphan transactions</comment>
        <expr_stmt><expr><call><name><name>mapOrphanTransactions</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mapOrphanTransactionsByPrev</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></destructor>
</public>}</block>;</class>
<decl_stmt><decl><type><specifier>static</specifier> <name>CNetProcessingCleanup</name></type> <name>instance_of_cnetprocessingcleanup</name></decl>;</decl_stmt>
</unit>
