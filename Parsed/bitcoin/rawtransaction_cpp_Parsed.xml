<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C++" filename="/home/mmm/Projects/bitcoin/src/rpc/rawtransaction.cpp"><comment type="line">// Copyright (c) 2010 Satoshi Nakamoto</comment>
<comment type="line">// Copyright (c) 2009-2019 The Bitcoin Core developers</comment>
<comment type="line">// Distributed under the MIT software license, see the accompanying</comment>
<comment type="line">// file COPYING or http://www.opensource.org/licenses/mit-license.php.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;chain.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;coins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;consensus/validation.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;core_io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;index/txindex.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;key_io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;merkleblock.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;node/coin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;node/context.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;node/psbt.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;node/transaction.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;policy/policy.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;policy/rbf.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;primitives/transaction.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;psbt.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;random.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;rpc/blockchain.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;rpc/rawtransaction_util.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;rpc/server.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;rpc/util.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;script/script.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;script/sign.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;script/signingprovider.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;script/standard.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;uint256.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/moneystr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/strencodings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;validation.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;validationinterface.h&gt;</cpp:file></cpp:include>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;numeric&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;univalue.h&gt;</cpp:file></cpp:include>

<comment type="block" format="doxygen">/** Maximum fee rate for sendrawtransaction and testmempoolaccept.
 * By default, a transaction with a fee rate higher than this will be rejected
 * by the RPCs. This can be overridden with the maxfeerate argument.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>CFeeRate</name></type> <name>DEFAULT_MAX_RAW_TX_FEE_RATE</name><argument_list>{<argument><expr><name>COIN</name> <operator>/</operator> <literal type="number">10</literal></expr></argument>}</argument_list></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>TxToJSON</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CTransaction</name><modifier>&amp;</modifier></type> <name>tx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint256</name></type> <name>hashBlock</name></decl></parameter>, <parameter><decl><type><name>UniValue</name><modifier>&amp;</modifier></type> <name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">// Call into TxToUniv() in bitcoin-common to decode the transaction hex.</comment>
    <comment type="line">//</comment>
    <comment type="line">// Blockchain contextual information (confirmations and blocktime) is not</comment>
    <comment type="line">// available to code in bitcoin-common, so we query them here and push the</comment>
    <comment type="line">// data into the returned UniValue.</comment>
    <expr_stmt><expr><call><name>TxToUniv</name><argument_list>(<argument><expr><name>tx</name></expr></argument>, <argument><expr><call><name>uint256</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><call><name>RPCSerializationFlags</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>hashBlock</name><operator>.</operator><name>IsNull</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>entry</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"blockhash"</literal></expr></argument>, <argument><expr><call><name><name>hashBlock</name><operator>.</operator><name>GetHex</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>CBlockIndex</name><modifier>*</modifier></type> <name>pindex</name> <init>= <expr><call><name>LookupBlockIndex</name><argument_list>(<argument><expr><name>hashBlock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>pindex</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Contains</name><argument_list>(<argument><expr><name>pindex</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>entry</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"confirmations"</literal></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Height</name><argument_list>()</argument_list></call> <operator>-</operator> <name><name>pindex</name><operator>-&gt;</operator><name>nHeight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>entry</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"time"</literal></expr></argument>, <argument><expr><call><name><name>pindex</name><operator>-&gt;</operator><name>GetBlockTime</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>entry</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"blocktime"</literal></expr></argument>, <argument><expr><call><name><name>pindex</name><operator>-&gt;</operator><name>GetBlockTime</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>entry</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"confirmations"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>UniValue</name></type> <name>getrawtransaction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>JSONRPCRequest</name><modifier>&amp;</modifier></type> <name>request</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>RPCHelpMan</name><argument_list>{
                <argument><expr><literal type="string">"getrawtransaction"</literal></expr></argument>,
                <argument><expr><literal type="string">"\nReturn the raw transaction data.\n"</literal>

                <literal type="string">"\nBy default this function only works for mempool transactions. When called with a blockhash\n"</literal>
                <literal type="string">"argument, getrawtransaction will return the transaction if the specified block is available and\n"</literal>
                <literal type="string">"the transaction is found in that block. When called without a blockhash argument, getrawtransaction\n"</literal>
                <literal type="string">"will return the transaction if it is in the mempool, or if -txindex is enabled and the transaction\n"</literal>
                <literal type="string">"is in a block in the blockchain.\n"</literal>

                <literal type="string">"\nHint: Use gettransaction for wallet transactions.\n"</literal>

                <literal type="string">"\nIf verbose is 'true', returns an Object with information about 'txid'.\n"</literal>
                <literal type="string">"If verbose is 'false' or omitted, returns a string that is serialized, hex-encoded data for 'txid'.\n"</literal></expr></argument>,
                <block>{<block_content>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"txid"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR_HEX</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"The transaction id"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"verbose"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>BOOL</name></name></expr><operator>,</operator> <comment type="block">/* default */</comment> <expr><literal type="string">"false"</literal></expr><operator>,</operator> <expr><literal type="string">"If false, return a string, otherwise return a json object"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"blockhash"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR_HEX</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>OMITTED_NAMED_ARG</name></name></expr><operator>,</operator> <expr><literal type="string">"The block in which to look for the transaction"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                <expr_stmt/>}</block_content></block>,
                <block>{<block_content>
                    <expr_stmt><expr><call><name>RPCResult</name><argument_list>{<argument><expr><literal type="string">"if verbose is not set or set to false"</literal></expr></argument>,
            <argument><expr><literal type="string">"\"data\"      (string) The serialized, hex-encoded data for 'txid'\n"</literal></expr></argument>
                     }</argument_list></call></expr><operator>,</operator>
                     <expr><call><name>RPCResult</name><argument_list>{<argument><expr><literal type="string">"if verbose is set to true"</literal></expr></argument>,
            <argument><expr><literal type="string">"{\n"</literal>
            <literal type="string">"  \"in_active_chain\": b, (bool) Whether specified block is in the active chain or not (only present with explicit \"blockhash\" argument)\n"</literal>
            <literal type="string">"  \"hex\" : \"data\",       (string) The serialized, hex-encoded data for 'txid'\n"</literal>
            <literal type="string">"  \"txid\" : \"id\",        (string) The transaction id (same as provided)\n"</literal>
            <literal type="string">"  \"hash\" : \"id\",        (string) The transaction hash (differs from txid for witness transactions)\n"</literal>
            <literal type="string">"  \"size\" : n,             (numeric) The serialized transaction size\n"</literal>
            <literal type="string">"  \"vsize\" : n,            (numeric) The virtual transaction size (differs from size for witness transactions)\n"</literal>
            <literal type="string">"  \"weight\" : n,           (numeric) The transaction's weight (between vsize*4-3 and vsize*4)\n"</literal>
            <literal type="string">"  \"version\" : n,          (numeric) The version\n"</literal>
            <literal type="string">"  \"locktime\" : ttt,       (numeric) The lock time\n"</literal>
            <literal type="string">"  \"vin\" : [               (array of json objects)\n"</literal>
            <literal type="string">"     {\n"</literal>
            <literal type="string">"       \"txid\": \"id\",    (string) The transaction id\n"</literal>
            <literal type="string">"       \"vout\": n,         (numeric) \n"</literal>
            <literal type="string">"       \"scriptSig\": {     (json object) The script\n"</literal>
            <literal type="string">"         \"asm\": \"asm\",  (string) asm\n"</literal>
            <literal type="string">"         \"hex\": \"hex\"   (string) hex\n"</literal>
            <literal type="string">"       },\n"</literal>
            <literal type="string">"       \"sequence\": n      (numeric) The script sequence number\n"</literal>
            <literal type="string">"       \"txinwitness\": [\"hex\", ...] (array of string) hex-encoded witness data (if any)\n"</literal>
            <literal type="string">"     }\n"</literal>
            <literal type="string">"     ,...\n"</literal>
            <literal type="string">"  ],\n"</literal>
            <literal type="string">"  \"vout\" : [              (array of json objects)\n"</literal>
            <literal type="string">"     {\n"</literal>
            <literal type="string">"       \"value\" : x.xxx,            (numeric) The value in "</literal> <operator>+</operator> <name>CURRENCY_UNIT</name> <operator>+</operator> <literal type="string">"\n"</literal>
            <literal type="string">"       \"n\" : n,                    (numeric) index\n"</literal>
            <literal type="string">"       \"scriptPubKey\" : {          (json object)\n"</literal>
            <literal type="string">"         \"asm\" : \"asm\",          (string) the asm\n"</literal>
            <literal type="string">"         \"hex\" : \"hex\",          (string) the hex\n"</literal>
            <literal type="string">"         \"reqSigs\" : n,            (numeric) The required sigs\n"</literal>
            <literal type="string">"         \"type\" : \"pubkeyhash\",  (string) The type, eg 'pubkeyhash'\n"</literal>
            <literal type="string">"         \"addresses\" : [           (json array of string)\n"</literal>
            <literal type="string">"           \"address\"        (string) bitcoin address\n"</literal>
            <literal type="string">"           ,...\n"</literal>
            <literal type="string">"         ]\n"</literal>
            <literal type="string">"       }\n"</literal>
            <literal type="string">"     }\n"</literal>
            <literal type="string">"     ,...\n"</literal>
            <literal type="string">"  ],\n"</literal>
            <literal type="string">"  \"blockhash\" : \"hash\",   (string) the block hash\n"</literal>
            <literal type="string">"  \"confirmations\" : n,      (numeric) The confirmations\n"</literal>
            <literal type="string">"  \"blocktime\" : ttt         (numeric) The block time in seconds since epoch (Jan 1 1970 GMT)\n"</literal>
            <literal type="string">"  \"time\" : ttt,             (numeric) Same as \"blocktime\"\n"</literal>
            <literal type="string">"}\n"</literal></expr></argument>
                    }</argument_list></call></expr><operator>,</operator></expr_stmt>
                }</block_content></block>,
                <argument><expr><call><name>RPCExamples</name><argument_list>{
                    <argument><expr><call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"getrawtransaction"</literal></expr></argument>, <argument><expr><literal type="string">"\"mytxid\""</literal></expr></argument>)</argument_list></call>
            <operator>+</operator> <call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"getrawtransaction"</literal></expr></argument>, <argument><expr><literal type="string">"\"mytxid\" true"</literal></expr></argument>)</argument_list></call>
            <operator>+</operator> <call><name>HelpExampleRpc</name><argument_list>(<argument><expr><literal type="string">"getrawtransaction"</literal></expr></argument>, <argument><expr><literal type="string">"\"mytxid\", true"</literal></expr></argument>)</argument_list></call>
            <operator>+</operator> <call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"getrawtransaction"</literal></expr></argument>, <argument><expr><literal type="string">"\"mytxid\" false \"myblockhash\""</literal></expr></argument>)</argument_list></call>
            <operator>+</operator> <macro><name>HelpExampleCli</name><argument_list>(<argument><literal type="string">"getrawtransaction"</literal></argument>, <argument><literal type="string">"\"mytxid\" true \"myblockhash\""</literal></argument>)</argument_list></macro></expr></argument>
                }</argument_list></call></expr></argument>,
    }</argument_list></call><operator>.</operator><call><name>Check</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>in_active_chain</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint256</name></type> <name>hash</name> <init>= <expr><call><name>ParseHashV</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"parameter 1"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CBlockIndex</name><modifier>*</modifier></type> <name>blockindex</name> <init>= <expr><literal type="null">nullptr</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>hash</name> <operator>==</operator> <call><name>Params</name><argument_list>()</argument_list></call><operator>.</operator><call><name>GenesisBlock</name><argument_list>()</argument_list></call><operator>.</operator><name>hashMerkleRoot</name></expr>)</condition> <block>{<block_content>
        <comment type="line">// Special exception for the genesis block coinbase transaction</comment>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><literal type="string">"The genesis block coinbase is not considered an ordinary transaction and cannot be retrieved"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Accept either a bool (true) or a num (&gt;=1) to indicate verbose output.</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>fVerbose</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>fVerbose</name> <operator>=</operator> <ternary><condition><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>isNum</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><operator>(</operator><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>get_int</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> </then><else>: <expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>get_bool</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>uint256</name></type> <name>blockhash</name> <init>= <expr><call><name>ParseHashV</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"parameter 3"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>blockindex</name> <operator>=</operator> <call><name>LookupBlockIndex</name><argument_list>(<argument><expr><name>blockhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>blockindex</name></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><literal type="string">"Block hash not found"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>in_active_chain</name> <operator>=</operator> <call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Contains</name><argument_list>(<argument><expr><name>blockindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>f_txindex_ready</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>g_txindex</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>blockindex</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>f_txindex_ready</name> <operator>=</operator> <call><name><name>g_txindex</name><operator>-&gt;</operator><name>BlockUntilSyncedToCurrentChain</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>CTransactionRef</name></type> <name>tx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint256</name></type> <name>hash_block</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetTransaction</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>tx</name></expr></argument>, <argument><expr><call><name>Params</name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetConsensus</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>hash_block</name></expr></argument>, <argument><expr><name>blockindex</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>errmsg</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>blockindex</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>blockindex</name><operator>-&gt;</operator><name>nStatus</name></name> <operator>&amp;</operator> <name>BLOCK_HAVE_DATA</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_MISC_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Block not available"</literal></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>errmsg</name> <operator>=</operator> <literal type="string">"No such transaction found in the provided block"</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>g_txindex</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>errmsg</name> <operator>=</operator> <literal type="string">"No such mempool transaction. Use -txindex or provide a block hash to enable blockchain transaction queries"</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>f_txindex_ready</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>errmsg</name> <operator>=</operator> <literal type="string">"No such mempool transaction. Blockchain transactions are still in the process of being indexed"</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>errmsg</name> <operator>=</operator> <literal type="string">"No such mempool or blockchain transaction"</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><name>errmsg</name> <operator>+</operator> <literal type="string">". Use gettransaction for wallet transactions."</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fVerbose</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>EncodeHexTx</name><argument_list>(<argument><expr><operator>*</operator><name>tx</name></expr></argument>, <argument><expr><call><name>RPCSerializationFlags</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>UniValue</name></type> <name>result</name><argument_list>(<argument><expr><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>blockindex</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"in_active_chain"</literal></expr></argument>, <argument><expr><name>in_active_chain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>TxToJSON</name><argument_list>(<argument><expr><operator>*</operator><name>tx</name></expr></argument>, <argument><expr><name>hash_block</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>UniValue</name></type> <name>gettxoutproof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>JSONRPCRequest</name><modifier>&amp;</modifier></type> <name>request</name></decl></parameter>)</parameter_list>
<block>{<block_content>
            <expr_stmt><expr><call><name>RPCHelpMan</name><argument_list>{<argument><expr><literal type="string">"gettxoutproof"</literal></expr></argument>,
                <argument><expr><literal type="string">"\nReturns a hex-encoded proof that \"txid\" was included in a block.\n"</literal>
                <literal type="string">"\nNOTE: By default this function only works sometimes. This is when there is an\n"</literal>
                <literal type="string">"unspent output in the utxo for this transaction. To make it always work,\n"</literal>
                <literal type="string">"you need to maintain a transaction index, using the -txindex command line option or\n"</literal>
                <literal type="string">"specify the block in which the transaction is included manually (by blockhash).\n"</literal></expr></argument>,
                <block>{<block_content>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"txids"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>ARR</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"A json array of txids to filter"</literal></expr><operator>,</operator>
                        <expr><block>{
                            <expr><block>{<expr><literal type="string">"txid"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR_HEX</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>OMITTED</name></name></expr>, <expr><literal type="string">"A transaction hash"</literal></expr>}</block></expr>,
                        }</block></expr><operator>,</operator></expr_stmt>
                        }</block_content></block><operator>,</operator>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"blockhash"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR_HEX</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>OMITTED_NAMED_ARG</name></name></expr><operator>,</operator> <expr><literal type="string">"If specified, looks for txid in the block with this hash"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                <expr_stmt/>}</block_content></block>,
                <argument><expr><call><name>RPCResult</name><argument_list>{
            <argument><expr><literal type="string">"\"data\"           (string) A string that is a serialized, hex-encoded data for the proof.\n"</literal></expr></argument>
                }</argument_list></call></expr></argument>,
                <argument><expr><call><name>RPCExamples</name><argument_list>{<argument><expr><literal type="string">""</literal></expr></argument>}</argument_list></call></expr></argument>,
            }</argument_list></call><operator>.</operator><call><name>Check</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>&gt;</argument_list></name></type> <name>setTxids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint256</name></type> <name>oneTxid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>UniValue</name></type> <name>txids</name> <init>= <expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>get_array</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <call><name><name>txids</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>UniValue</name><modifier>&amp;</modifier></type> <name>txid</name> <init>= <expr><name><name>txids</name><index>[<expr><name>idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint256</name></type> <name>hash</name><argument_list>(<argument><expr><call><name>ParseHashV</name><argument_list>(<argument><expr><name>txid</name></expr></argument>, <argument><expr><literal type="string">"txid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>setTxids</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_PARAMETER</name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">"Invalid parameter, duplicated txid: "</literal></expr></argument>)</argument_list></call><operator>+</operator><call><name><name>txid</name><operator>.</operator><name>get_str</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
       <expr_stmt><expr><call><name><name>setTxids</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><name>oneTxid</name> <operator>=</operator> <name>hash</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <decl_stmt><decl><type><name>CBlockIndex</name><modifier>*</modifier></type> <name>pblockindex</name> <init>= <expr><literal type="null">nullptr</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint256</name></type> <name>hashBlock</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>hashBlock</name> <operator>=</operator> <call><name>ParseHashV</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"blockhash"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pblockindex</name> <operator>=</operator> <call><name>LookupBlockIndex</name><argument_list>(<argument><expr><name>hashBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pblockindex</name></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><literal type="string">"Block not found"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Loop through txids and try to find which block they're in. Exit loop once a block is found.</comment>
        <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>tx</name> <range>: <expr><name>setTxids</name></expr></range></decl></init>)</control> <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>Coin</name><modifier>&amp;</modifier></type> <name>coin</name> <init>= <expr><call><name>AccessByTxid</name><argument_list>(<argument><expr><call><name><operator>::</operator><name>ChainstateActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>CoinsTip</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>coin</name><operator>.</operator><name>IsSpent</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>pblockindex</name> <operator>=</operator> <call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><index>[<expr><name><name>coin</name><operator>.</operator><name>nHeight</name></name></expr>]</index></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>


    <comment type="line">// Allow txindex to catch up if we need to query it and before we acquire cs_main.</comment>
    <if_stmt><if>if <condition>(<expr><name>g_txindex</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pblockindex</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>g_txindex</name><operator>-&gt;</operator><name>BlockUntilSyncedToCurrentChain</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>pblockindex</name> <operator>==</operator> <literal type="null">nullptr</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CTransactionRef</name></type> <name>tx</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetTransaction</name><argument_list>(<argument><expr><name>oneTxid</name></expr></argument>, <argument><expr><name>tx</name></expr></argument>, <argument><expr><call><name>Params</name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetConsensus</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>hashBlock</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>hashBlock</name><operator>.</operator><name>IsNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><literal type="string">"Transaction not yet in block"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>pblockindex</name> <operator>=</operator> <call><name>LookupBlockIndex</name><argument_list>(<argument><expr><name>hashBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pblockindex</name></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INTERNAL_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Transaction index corrupt"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>CBlock</name></type> <name>block</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ReadBlockFromDisk</name><argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><name>pblockindex</name></expr></argument>, <argument><expr><call><name>Params</name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetConsensus</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INTERNAL_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Can't read block from disk"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>ntxFound</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>tx</name> <range>: <expr><name><name>block</name><operator>.</operator><name>vtx</name></name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>setTxids</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><call><name><name>tx</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>ntxFound</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
    <if_stmt><if>if <condition>(<expr><name>ntxFound</name> <operator>!=</operator> <call><name><name>setTxids</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><literal type="string">"Not all transactions found in specified or retrieved block"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>CDataStream</name></type> <name>ssMB</name><argument_list>(<argument><expr><name>SER_NETWORK</name></expr></argument>, <argument><expr><name>PROTOCOL_VERSION</name> <operator>|</operator> <name>SERIALIZE_TRANSACTION_NO_WITNESS</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CMerkleBlock</name></type> <name>mb</name><argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><name>setTxids</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><name>ssMB</name> <operator>&lt;&lt;</operator> <name>mb</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>strHex</name> <init>= <expr><call><name>HexStr</name><argument_list>(<argument><expr><call><name><name>ssMB</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>ssMB</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>strHex</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>UniValue</name></type> <name>verifytxoutproof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>JSONRPCRequest</name><modifier>&amp;</modifier></type> <name>request</name></decl></parameter>)</parameter_list>
<block>{<block_content>
            <expr_stmt><expr><call><name>RPCHelpMan</name><argument_list>{<argument><expr><literal type="string">"verifytxoutproof"</literal></expr></argument>,
                <argument><expr><literal type="string">"\nVerifies that a proof points to a transaction in a block, returning the transaction it commits to\n"</literal>
                <literal type="string">"and throwing an RPC error if the block is not in our best chain\n"</literal></expr></argument>,
                <block>{<block_content>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"proof"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR_HEX</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"The hex-encoded proof generated by gettxoutproof"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                <expr_stmt/>}</block_content></block>,
                <argument><expr><call><name>RPCResult</name><argument_list>{
            <argument><expr><literal type="string">"[\"txid\"]      (array, strings) The txid(s) which the proof commits to, or empty array if the proof can not be validated.\n"</literal></expr></argument>
                }</argument_list></call></expr></argument>,
                <argument><expr><call><name>RPCExamples</name><argument_list>{<argument><expr><literal type="string">""</literal></expr></argument>}</argument_list></call></expr></argument>,
            }</argument_list></call><operator>.</operator><call><name>Check</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>CDataStream</name></type> <name>ssMB</name><argument_list>(<argument><expr><call><name>ParseHexV</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"proof"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SER_NETWORK</name></expr></argument>, <argument><expr><name>PROTOCOL_VERSION</name> <operator>|</operator> <name>SERIALIZE_TRANSACTION_NO_WITNESS</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CMerkleBlock</name></type> <name>merkleBlock</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>ssMB</name> <operator>&gt;&gt;</operator> <name>merkleBlock</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>UniValue</name></type> <name>res</name><argument_list>(<argument><expr><name><name>UniValue</name><operator>::</operator><name>VARR</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>&gt;</argument_list></name></type> <name>vMatch</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>int</name></expr></argument>&gt;</argument_list></name></type> <name>vIndex</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>merkleBlock</name><operator>.</operator><name>txn</name><operator>.</operator><name>ExtractMatches</name></name><argument_list>(<argument><expr><name>vMatch</name></expr></argument>, <argument><expr><name>vIndex</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>merkleBlock</name><operator>.</operator><name>header</name><operator>.</operator><name>hashMerkleRoot</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>CBlockIndex</name><modifier>*</modifier></type> <name>pindex</name> <init>= <expr><call><name>LookupBlockIndex</name><argument_list>(<argument><expr><call><name><name>merkleBlock</name><operator>.</operator><name>header</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pindex</name> <operator>||</operator> <operator>!</operator><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Contains</name><argument_list>(<argument><expr><name>pindex</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>pindex</name><operator>-&gt;</operator><name>nTx</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><literal type="string">"Block not found in chain"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Check if proof is valid, only add results if so</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pindex</name><operator>-&gt;</operator><name>nTx</name></name> <operator>==</operator> <call><name><name>merkleBlock</name><operator>.</operator><name>txn</name><operator>.</operator><name>GetNumTransactions</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><decl><type><specifier>const</specifier> <name>uint256</name><modifier>&amp;</modifier></type> <name>hash</name> <range>: <expr><name>vMatch</name></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>res</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>hash</name><operator>.</operator><name>GetHex</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>UniValue</name></type> <name>createrawtransaction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>JSONRPCRequest</name><modifier>&amp;</modifier></type> <name>request</name></decl></parameter>)</parameter_list>
<block>{<block_content>
            <expr_stmt><expr><call><name>RPCHelpMan</name><argument_list>{<argument><expr><literal type="string">"createrawtransaction"</literal></expr></argument>,
                <argument><expr><literal type="string">"\nCreate a transaction spending the given inputs and creating new outputs.\n"</literal>
                <literal type="string">"Outputs can be addresses or data.\n"</literal>
                <literal type="string">"Returns hex-encoded raw transaction.\n"</literal>
                <literal type="string">"Note that the transaction's inputs are not signed, and\n"</literal>
                <literal type="string">"it is not stored in the wallet or transmitted to the network.\n"</literal></expr></argument>,
                <block>{<block_content>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"inputs"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>ARR</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"A json array of json objects"</literal></expr><operator>,</operator>
                        <expr><block>{
                            <expr><block>{<expr><literal type="string">""</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>OBJ</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>OMITTED</name></name></expr>, <expr><literal type="string">""</literal></expr>,
                                <expr><block>{
                                    <expr><block>{<expr><literal type="string">"txid"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR_HEX</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr>, <expr><literal type="string">"The transaction id"</literal></expr>}</block></expr>,
                                    <expr><block>{<expr><literal type="string">"vout"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>NUM</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr>, <expr><literal type="string">"The output number"</literal></expr>}</block></expr>,
                                    <expr><block>{<expr><literal type="string">"sequence"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>NUM</name></name></expr>, <comment type="block">/* default */</comment> <expr><literal type="string">"depends on the value of the 'replaceable' and 'locktime' arguments"</literal></expr>, <expr><literal type="string">"The sequence number"</literal></expr>}</block></expr>,
                                }</block></expr>,
                                }</block></expr>,
                        }</block></expr><operator>,</operator></expr_stmt>
                        }</block_content></block><operator>,</operator>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"outputs"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>ARR</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"a json array with outputs (key-value pairs), where none of the keys are duplicated.\n"</literal>
                            <literal type="string">"That is, each address can only appear once and there can only be one 'data' object.\n"</literal>
                            <literal type="string">"For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\n"</literal>
                            <literal type="string">"                             accepted as second parameter."</literal></expr><operator>,</operator>
                        <expr><block>{
                            <expr><block>{<expr><literal type="string">""</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>OBJ</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>OMITTED</name></name></expr>, <expr><literal type="string">""</literal></expr>,
                                <expr><block>{
                                    <expr><block>{<expr><literal type="string">"address"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>AMOUNT</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr>, <expr><literal type="string">"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in "</literal> <operator>+</operator> <name>CURRENCY_UNIT</name></expr>}</block></expr>,
                                }</block></expr>,
                                }</block></expr>,
                            <expr><block>{<expr><literal type="string">""</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>OBJ</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>OMITTED</name></name></expr>, <expr><literal type="string">""</literal></expr>,
                                <expr><block>{
                                    <expr><block>{<expr><literal type="string">"data"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR_HEX</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr>, <expr><literal type="string">"A key-value pair. The key must be \"data\", the value is hex-encoded data"</literal></expr>}</block></expr>,
                                }</block></expr>,
                                }</block></expr>,
                        }</block></expr><operator>,</operator></expr_stmt>
                        }</block_content></block><operator>,</operator>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"locktime"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>NUM</name></name></expr><operator>,</operator> <comment type="block">/* default */</comment> <expr><literal type="string">"0"</literal></expr><operator>,</operator> <expr><literal type="string">"Raw locktime. Non-0 value also locktime-activates inputs"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"replaceable"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>BOOL</name></name></expr><operator>,</operator> <comment type="block">/* default */</comment> <expr><literal type="string">"false"</literal></expr><operator>,</operator> <expr><literal type="string">"Marks this transaction as BIP125-replaceable.\n"</literal>
            <literal type="string">"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible."</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                <expr_stmt/>}</block_content></block>,
                <argument><expr><call><name>RPCResult</name><argument_list>{
            <argument><expr><literal type="string">"\"transaction\"              (string) hex string of the transaction\n"</literal></expr></argument>
                }</argument_list></call></expr></argument>,
                <argument><expr><call><name>RPCExamples</name><argument_list>{
                    <argument><expr><call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"createrawtransaction"</literal></expr></argument>, <argument><expr><literal type="string">"\"[{\\\"txid\\\":\\\"myid\\\",\\\"vout\\\":0}]\" \"[{\\\"address\\\":0.01}]\""</literal></expr></argument>)</argument_list></call>
            <operator>+</operator> <call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"createrawtransaction"</literal></expr></argument>, <argument><expr><literal type="string">"\"[{\\\"txid\\\":\\\"myid\\\",\\\"vout\\\":0}]\" \"[{\\\"data\\\":\\\"00010203\\\"}]\""</literal></expr></argument>)</argument_list></call>
            <operator>+</operator> <call><name>HelpExampleRpc</name><argument_list>(<argument><expr><literal type="string">"createrawtransaction"</literal></expr></argument>, <argument><expr><literal type="string">"\"[{\\\"txid\\\":\\\"myid\\\",\\\"vout\\\":0}]\", \"[{\\\"address\\\":0.01}]\""</literal></expr></argument>)</argument_list></call>
            <operator>+</operator> <macro><name>HelpExampleRpc</name><argument_list>(<argument><literal type="string">"createrawtransaction"</literal></argument>, <argument><literal type="string">"\"[{\\\"txid\\\":\\\"myid\\\",\\\"vout\\\":0}]\", \"[{\\\"data\\\":\\\"00010203\\\"}]\""</literal></argument>)</argument_list></macro></expr></argument>
                }</argument_list></call></expr></argument>,
            }</argument_list></call><operator>.</operator><call><name>Check</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>RPCTypeCheck</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name></name></expr></argument>, <block>{<block_content>
        <expr_stmt><expr><name><name>UniValue</name><operator>::</operator><name>VARR</name></name></expr><operator>,</operator>
        <expr><call><name>UniValueType</name><argument_list>()</argument_list></call></expr><operator>,</operator> <comment type="line">// ARR or OBJ, checked later</comment>
        <expr><name><name>UniValue</name><operator>::</operator><name>VNUM</name></name></expr><operator>,</operator>
        <expr><name><name>UniValue</name><operator>::</operator><name>VBOOL</name></name></expr></expr_stmt>
        </block_content>}</block></argument_list></call></expr></expr_stmt><operator>,</operator> <expr_stmt><expr><literal type="boolean">true</literal></expr></expr_stmt>
    )</block_content></block>;</function>

    <decl_stmt><decl><type><name>bool</name></type> <name>rbf</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>rbf</name> <operator>=</operator> <name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><call><name>isTrue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>CMutableTransaction</name></type> <name>rawTx</name> <init>= <expr><call><name>ConstructTransaction</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>rbf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>EncodeHexTx</name><argument_list>(<argument><expr><call><name>CTransaction</name><argument_list>(<argument><expr><name>rawTx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

static <function><type><name>UniValue</name></type> <name>decoderawtransaction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>JSONRPCRequest</name><modifier>&amp;</modifier></type> <name>request</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>RPCHelpMan</name><argument_list>{<argument><expr><literal type="string">"decoderawtransaction"</literal></expr></argument>,
                <argument><expr><literal type="string">"\nReturn a JSON object representing the serialized, hex-encoded transaction.\n"</literal></expr></argument>,
                <block>{<block_content>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"hexstring"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR_HEX</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"The transaction hex string"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"iswitness"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>BOOL</name></name></expr><operator>,</operator> <comment type="block">/* default */</comment> <expr><literal type="string">"depends on heuristic tests"</literal></expr><operator>,</operator> <expr><literal type="string">"Whether the transaction hex is a serialized witness transaction.\n"</literal>
                        <literal type="string">"If iswitness is not present, heuristic tests will be used in decoding.\n"</literal>
                        <literal type="string">"If true, only witness deserialization will be tried.\n"</literal>
                        <literal type="string">"If false, only non-witness deserialization will be tried.\n"</literal>
                        <literal type="string">"This boolean should reflect whether the transaction has inputs\n"</literal>
                        <literal type="string">"(e.g. fully valid, or on-chain transactions), if known by the caller."</literal></expr></expr_stmt>
                    }</block_content></block><operator>,</operator>
                <expr_stmt/>}</block_content></block>,
                <argument><expr><call><name>RPCResult</name><argument_list>{
            <argument><expr><literal type="string">"{\n"</literal>
            <literal type="string">"  \"txid\" : \"id\",        (string) The transaction id\n"</literal>
            <literal type="string">"  \"hash\" : \"id\",        (string) The transaction hash (differs from txid for witness transactions)\n"</literal>
            <literal type="string">"  \"size\" : n,             (numeric) The transaction size\n"</literal>
            <literal type="string">"  \"vsize\" : n,            (numeric) The virtual transaction size (differs from size for witness transactions)\n"</literal>
            <literal type="string">"  \"weight\" : n,           (numeric) The transaction's weight (between vsize*4 - 3 and vsize*4)\n"</literal>
            <literal type="string">"  \"version\" : n,          (numeric) The version\n"</literal>
            <literal type="string">"  \"locktime\" : ttt,       (numeric) The lock time\n"</literal>
            <literal type="string">"  \"vin\" : [               (array of json objects)\n"</literal>
            <literal type="string">"     {\n"</literal>
            <literal type="string">"       \"txid\": \"id\",    (string) The transaction id\n"</literal>
            <literal type="string">"       \"vout\": n,         (numeric) The output number\n"</literal>
            <literal type="string">"       \"scriptSig\": {     (json object) The script\n"</literal>
            <literal type="string">"         \"asm\": \"asm\",  (string) asm\n"</literal>
            <literal type="string">"         \"hex\": \"hex\"   (string) hex\n"</literal>
            <literal type="string">"       },\n"</literal>
            <literal type="string">"       \"txinwitness\": [\"hex\", ...] (array of string) hex-encoded witness data (if any)\n"</literal>
            <literal type="string">"       \"sequence\": n     (numeric) The script sequence number\n"</literal>
            <literal type="string">"     }\n"</literal>
            <literal type="string">"     ,...\n"</literal>
            <literal type="string">"  ],\n"</literal>
            <literal type="string">"  \"vout\" : [             (array of json objects)\n"</literal>
            <literal type="string">"     {\n"</literal>
            <literal type="string">"       \"value\" : x.xxx,            (numeric) The value in "</literal> <operator>+</operator> <name>CURRENCY_UNIT</name> <operator>+</operator> <literal type="string">"\n"</literal>
            <literal type="string">"       \"n\" : n,                    (numeric) index\n"</literal>
            <literal type="string">"       \"scriptPubKey\" : {          (json object)\n"</literal>
            <literal type="string">"         \"asm\" : \"asm\",          (string) the asm\n"</literal>
            <literal type="string">"         \"hex\" : \"hex\",          (string) the hex\n"</literal>
            <literal type="string">"         \"reqSigs\" : n,            (numeric) The required sigs\n"</literal>
            <literal type="string">"         \"type\" : \"pubkeyhash\",  (string) The type, eg 'pubkeyhash'\n"</literal>
            <literal type="string">"         \"addresses\" : [           (json array of string)\n"</literal>
            <literal type="string">"           \"12tvKAXCxZjSmdNbao16dKXC8tRWfcF5oc\"   (string) bitcoin address\n"</literal>
            <literal type="string">"           ,...\n"</literal>
            <literal type="string">"         ]\n"</literal>
            <literal type="string">"       }\n"</literal>
            <literal type="string">"     }\n"</literal>
            <literal type="string">"     ,...\n"</literal>
            <literal type="string">"  ],\n"</literal>
            <literal type="string">"}\n"</literal></expr></argument>
                }</argument_list></call></expr></argument>,
                <argument><expr><call><name>RPCExamples</name><argument_list>{
                    <argument><expr><call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"decoderawtransaction"</literal></expr></argument>, <argument><expr><literal type="string">"\"hexstring\""</literal></expr></argument>)</argument_list></call>
            <operator>+</operator> <macro><name>HelpExampleRpc</name><argument_list>(<argument><literal type="string">"decoderawtransaction"</literal></argument>, <argument><literal type="string">"\"hexstring\""</literal></argument>)</argument_list></macro></expr></argument>
                }</argument_list></call></expr></argument>,
    }</argument_list></call><operator>.</operator><call><name>Check</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>RPCTypeCheck</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name></name></expr></argument>, <block>{<block_content><expr><name><name>UniValue</name><operator>::</operator><name>VSTR</name></name></expr><operator>,</operator> <expr><name><name>UniValue</name><operator>::</operator><name>VBOOL</name></name></expr></block_content>}</block></argument_list></call></expr></expr_stmt>)</block_content></block>;</function>

    <decl_stmt><decl><type><name>CMutableTransaction</name></type> <name>mtx</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>try_witness</name> <init>= <expr><ternary><condition><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="boolean">true</literal></expr> </then><else>: <expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>get_bool</name><argument_list>()</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>try_no_witness</name> <init>= <expr><ternary><condition><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="boolean">true</literal></expr> </then><else>: <expr><operator>!</operator><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>get_bool</name><argument_list>()</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DecodeHexTx</name><argument_list>(<argument><expr><name>mtx</name></expr></argument>, <argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>try_no_witness</name></expr></argument>, <argument><expr><name>try_witness</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_DESERIALIZATION_ERROR</name></expr></argument>, <argument><expr><literal type="string">"TX decode failed"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <function_decl><type><name>UniValue</name></type> <name>result</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name>TxToUniv</name><argument_list>(<argument><expr><call><name>CTransaction</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>mtx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>uint256</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
}

static <function><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>GetAllOutputTypes</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>ret</name></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>TX_NONSTANDARD</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>TX_WITNESS_UNKNOWN</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>TX_NONSTANDARD</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ret</name> <operator>+=</operator> <literal type="string">", "</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>ret</name> <operator>+=</operator> <call><name>GetTxnOutputType</name><argument_list>(<argument><expr><cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>txnouttype</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></cast></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>UniValue</name></type> <name>decodescript</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>JSONRPCRequest</name><modifier>&amp;</modifier></type> <name>request</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>RPCHelpMan</name><argument_list>{<argument><expr><literal type="string">"decodescript"</literal></expr></argument>,
                <argument><expr><literal type="string">"\nDecode a hex-encoded script.\n"</literal></expr></argument>,
                <block>{<block_content>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"hexstring"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR_HEX</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"the hex-encoded script"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                <expr_stmt/>}</block_content></block>,
                <argument><expr><call><name>RPCResult</name><argument_list>{
            <argument><expr><literal type="string">"{\n"</literal>
            <literal type="string">"  \"asm\":\"asm\",          (string) Script public key\n"</literal>
            <literal type="string">"  \"type\":\"type\",        (string) The output type (e.g. "</literal><operator>+</operator><call><name>GetAllOutputTypes</name><argument_list>()</argument_list></call><operator>+</operator><literal type="string">")\n"</literal>
            <literal type="string">"  \"reqSigs\": n,         (numeric) The required signatures\n"</literal>
            <literal type="string">"  \"addresses\": [        (json array of string)\n"</literal>
            <literal type="string">"     \"address\"          (string) bitcoin address\n"</literal>
            <literal type="string">"     ,...\n"</literal>
            <literal type="string">"  ],\n"</literal>
            <literal type="string">"  \"p2sh\":\"str\"          (string) address of P2SH script wrapping this redeem script (not returned if the script is already a P2SH).\n"</literal>
            <literal type="string">"  \"segwit\": {           (json object) Result of a witness script public key wrapping this redeem script (not returned if the script is a P2SH or witness).\n"</literal>
            <literal type="string">"    \"asm\":\"str\",        (string) String representation of the script public key\n"</literal>
            <literal type="string">"    \"hex\":\"hexstr\",     (string) Hex string of the script public key\n"</literal>
            <literal type="string">"    \"type\":\"str\",       (string) The type of the script public key (e.g. witness_v0_keyhash or witness_v0_scripthash)\n"</literal>
            <literal type="string">"    \"reqSigs\": n,       (numeric) The required signatures (always 1)\n"</literal>
            <literal type="string">"    \"addresses\": [      (json array of string) (always length 1)\n"</literal>
            <literal type="string">"      \"address\"         (string) segwit address\n"</literal>
            <literal type="string">"       ,...\n"</literal>
            <literal type="string">"    ],\n"</literal>
            <literal type="string">"    \"p2sh-segwit\":\"str\" (string) address of the P2SH script wrapping this witness redeem script.\n"</literal>
            <literal type="string">"}\n"</literal></expr></argument>
                }</argument_list></call></expr></argument>,
                <argument><expr><call><name>RPCExamples</name><argument_list>{
                    <argument><expr><call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"decodescript"</literal></expr></argument>, <argument><expr><literal type="string">"\"hexstring\""</literal></expr></argument>)</argument_list></call>
            <operator>+</operator> <macro><name>HelpExampleRpc</name><argument_list>(<argument><literal type="string">"decodescript"</literal></argument>, <argument><literal type="string">"\"hexstring\""</literal></argument>)</argument_list></macro></expr></argument>
                }</argument_list></call></expr></argument>,
    }</argument_list></call><operator>.</operator><call><name>Check</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>RPCTypeCheck</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name></name></expr></argument>, <block>{<block_content><expr><name><name>UniValue</name><operator>::</operator><name>VSTR</name></name></expr></block_content>}</block></argument_list></call></expr></expr_stmt>)</block_content></block>;</function>

    <function_decl><type><name>UniValue</name></type> <name>r</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>CScript</name></type> <name>script</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>scriptData</name><argument_list>(<argument><expr><call><name>ParseHexV</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"argument"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <expr_stmt><expr><name>script</name> <operator>=</operator> <call><name>CScript</name><argument_list>(<argument><expr><call><name><name>scriptData</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>scriptData</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="line">// Empty scripts are valid</comment>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>ScriptPubKeyToUniv</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <comment type="block">/* fIncludeHex */</comment> <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>UniValue</name></type> <name>type</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>find_value</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name><name>type</name><operator>.</operator><name>isStr</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>type</name><operator>.</operator><name>get_str</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="string">"scripthash"</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// P2SH cannot be wrapped in a P2SH. If this script is already a P2SH,</comment>
        <comment type="line">// don't return the address for a P2SH of the P2SH.</comment>
        <expr_stmt><expr><call><name><name>r</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"p2sh"</literal></expr></argument>, <argument><expr><call><name>EncodeDestination</name><argument_list>(<argument><expr><call><name>ScriptHash</name><argument_list>(<argument><expr><name>script</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// P2SH and witness programs cannot be wrapped in P2WSH, if this script</comment>
        <comment type="line">// is a witness program, don't return addresses for a segwit programs.</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>type</name><operator>.</operator><name>get_str</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="string">"pubkey"</literal> <operator>||</operator> <call><name><name>type</name><operator>.</operator><name>get_str</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="string">"pubkeyhash"</literal> <operator>||</operator> <call><name><name>type</name><operator>.</operator><name>get_str</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="string">"multisig"</literal> <operator>||</operator> <call><name><name>type</name><operator>.</operator><name>get_str</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="string">"nonstandard"</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>solutions_data</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>txnouttype</name></type> <name>which_type</name> <init>= <expr><call><name>Solver</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><name>solutions_data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="line">// Uncompressed pubkeys cannot be used with segwit checksigs.</comment>
            <comment type="line">// If the script contains an uncompressed pubkey, skip encoding of a segwit program.</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>which_type</name> <operator>==</operator> <name>TX_PUBKEY</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>which_type</name> <operator>==</operator> <name>TX_MULTISIG</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>solution</name> <range>: <expr><name>solutions_data</name></expr></range></decl></init>)</control> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name><name>solution</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>CPubKey</name><argument_list>(<argument><expr><name>solution</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>IsCompressed</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                        <return>return <expr><name>r</name></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
            <function_decl><type><name>UniValue</name></type> <name>sr</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
            <decl_stmt><decl><type><name>CScript</name></type> <name>segwitScr</name></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>which_type</name> <operator>==</operator> <name>TX_PUBKEY</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>segwitScr</name> <operator>=</operator> <call><name>GetScriptForDestination</name><argument_list>(<argument><expr><call><name>WitnessV0KeyHash</name><argument_list>(<argument><expr><call><name>Hash160</name><argument_list>(<argument><expr><name><name>solutions_data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>solutions_data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>which_type</name> <operator>==</operator> <name>TX_PUBKEYHASH</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>segwitScr</name> <operator>=</operator> <call><name>GetScriptForDestination</name><argument_list>(<argument><expr><call><name>WitnessV0KeyHash</name><argument_list>(<argument><expr><name><name>solutions_data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <comment type="line">// Scripts that are not fit for P2WPKH are encoded as P2WSH.</comment>
                <comment type="line">// Newer segwit program versions should be considered when then become available.</comment>
                <expr_stmt><expr><name>segwitScr</name> <operator>=</operator> <call><name>GetScriptForDestination</name><argument_list>(<argument><expr><call><name>WitnessV0ScriptHash</name><argument_list>(<argument><expr><name>script</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><call><name>ScriptPubKeyToUniv</name><argument_list>(<argument><expr><name>segwitScr</name></expr></argument>, <argument><expr><name>sr</name></expr></argument>, <comment type="block">/* fIncludeHex */</comment> <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>sr</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"p2sh-segwit"</literal></expr></argument>, <argument><expr><call><name>EncodeDestination</name><argument_list>(<argument><expr><call><name>ScriptHash</name><argument_list>(<argument><expr><name>segwitScr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>r</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"segwit"</literal></expr></argument>, <argument><expr><name>sr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>r</name></expr>;</return>
}

static <function><type><name>UniValue</name></type> <name>combinerawtransaction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>JSONRPCRequest</name><modifier>&amp;</modifier></type> <name>request</name></decl></parameter>)</parameter_list>
<block>{<block_content>
            <expr_stmt><expr><call><name>RPCHelpMan</name><argument_list>{<argument><expr><literal type="string">"combinerawtransaction"</literal></expr></argument>,
                <argument><expr><literal type="string">"\nCombine multiple partially signed transactions into one transaction.\n"</literal>
                <literal type="string">"The combined transaction may be another partially signed transaction or a \n"</literal>
                <literal type="string">"fully signed transaction."</literal></expr></argument>,
                <block>{<block_content>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"txs"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>ARR</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"A json array of hex strings of partially signed transactions"</literal></expr><operator>,</operator>
                        <expr><block>{
                            <expr><block>{<expr><literal type="string">"hexstring"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR_HEX</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>OMITTED</name></name></expr>, <expr><literal type="string">"A transaction hash"</literal></expr>}</block></expr>,
                        }</block></expr><operator>,</operator></expr_stmt>
                        }</block_content></block><operator>,</operator>
                <expr_stmt/>}</block_content></block>,
                <argument><expr><call><name>RPCResult</name><argument_list>{
            <argument><expr><literal type="string">"\"hex\"            (string) The hex-encoded raw transaction with signature(s)\n"</literal></expr></argument>
                }</argument_list></call></expr></argument>,
                <argument><expr><call><name>RPCExamples</name><argument_list>{
                    <argument><expr><macro><name>HelpExampleCli</name><argument_list>(<argument><literal type="string">"combinerawtransaction"</literal></argument>, <argument><literal type="string">R"('["myhex1", "myhex2", "myhex3"]')"</literal></argument>)</argument_list></macro></expr></argument>
                }</argument_list></call></expr></argument>,
            }</argument_list></call><operator>.</operator><call><name>Check</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <decl_stmt><decl><type><name>UniValue</name></type> <name>txs</name> <init>= <expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>get_array</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CMutableTransaction</name></expr></argument>&gt;</argument_list></name></type> <name>txVariants</name><argument_list>(<argument><expr><call><name><name>txs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <call><name><name>txs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DecodeHexTx</name><argument_list>(<argument><expr><name><name>txVariants</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>txs</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_DESERIALIZATION_ERROR</name></expr></argument>, <argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"TX decode failed for tx %d"</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><call><name><name>txVariants</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_DESERIALIZATION_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Missing transactions"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// mergedTx will end up with all the signatures; it</comment>
    <comment type="line">// starts as a clone of the rawtx:</comment>
    <decl_stmt><decl><type><name>CMutableTransaction</name></type> <name>mergedTx</name><argument_list>(<argument><expr><name><name>txVariants</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></decl>;</decl_stmt>

    <comment type="line">// Fetch previous transactions (inputs):</comment>
    <decl_stmt><decl><type><name>CCoinsView</name></type> <name>viewDummy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CCoinsViewCache</name></type> <name>view</name><argument_list>(<argument><expr><operator>&amp;</operator><name>viewDummy</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>mempool</name><operator>.</operator><name>cs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>CCoinsViewCache</name> <modifier>&amp;</modifier></type><name>viewChain</name> <init>= <expr><call><name><operator>::</operator><name>ChainstateActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>CoinsTip</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CCoinsViewMemPool</name></type> <name>viewMempool</name><argument_list>(<argument><expr><operator>&amp;</operator><name>viewChain</name></expr></argument>, <argument><expr><name>mempool</name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>view</name><operator>.</operator><name>SetBackend</name></name><argument_list>(<argument><expr><name>viewMempool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// temporarily switch cache backend to db+mempool view</comment>

        <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CTxIn</name><modifier>&amp;</modifier></type> <name>txin</name> <range>: <expr><name><name>mergedTx</name><operator>.</operator><name>vin</name></name></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>view</name><operator>.</operator><name>AccessCoin</name></name><argument_list>(<argument><expr><name><name>txin</name><operator>.</operator><name>prevout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Load entries from viewChain into view; can fail.</comment>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name><name>view</name><operator>.</operator><name>SetBackend</name></name><argument_list>(<argument><expr><name>viewDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// switch back to avoid locking mempool for too long</comment>
    </block_content>}</block>

    <comment type="line">// Use CTransaction for the constant parts of the</comment>
    <comment type="line">// transaction to avoid rehashing.</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CTransaction</name></type> <name>txConst</name><argument_list>(<argument><expr><name>mergedTx</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <comment type="line">// Sign what we can:</comment>
    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>mergedTx</name><operator>.</operator><name>vin</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>CTxIn</name><modifier>&amp;</modifier></type> <name>txin</name> <init>= <expr><name><name>mergedTx</name><operator>.</operator><name>vin</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>Coin</name><modifier>&amp;</modifier></type> <name>coin</name> <init>= <expr><call><name><name>view</name><operator>.</operator><name>AccessCoin</name></name><argument_list>(<argument><expr><name><name>txin</name><operator>.</operator><name>prevout</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>coin</name><operator>.</operator><name>IsSpent</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_VERIFY_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Input not found or already spent"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>SignatureData</name></type> <name>sigdata</name></decl>;</decl_stmt>

        <comment type="line">// ... and merge in other signatures:</comment>
        <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CMutableTransaction</name><modifier>&amp;</modifier></type> <name>txv</name> <range>: <expr><name>txVariants</name></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>txv</name><operator>.</operator><name>vin</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>i</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>sigdata</name><operator>.</operator><name>MergeSignatureData</name></name><argument_list>(<argument><expr><call><name>DataFromTransaction</name><argument_list>(<argument><expr><name>txv</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>coin</name><operator>.</operator><name>out</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>ProduceSignature</name><argument_list>(<argument><expr><name>DUMMY_SIGNING_PROVIDER</name></expr></argument>, <argument><expr><call><name>MutableTransactionSignatureCreator</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mergedTx</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>coin</name><operator>.</operator><name>out</name><operator>.</operator><name>nValue</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>coin</name><operator>.</operator><name>out</name><operator>.</operator><name>scriptPubKey</name></name></expr></argument>, <argument><expr><name>sigdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>UpdateInput</name><argument_list>(<argument><expr><name>txin</name></expr></argument>, <argument><expr><name>sigdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><call><name>EncodeHexTx</name><argument_list>(<argument><expr><call><name>CTransaction</name><argument_list>(<argument><expr><name>mergedTx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>UniValue</name></type> <name>signrawtransactionwithkey</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>JSONRPCRequest</name><modifier>&amp;</modifier></type> <name>request</name></decl></parameter>)</parameter_list>
<block>{<block_content>
            <expr_stmt><expr><call><name>RPCHelpMan</name><argument_list>{<argument><expr><literal type="string">"signrawtransactionwithkey"</literal></expr></argument>,
                <argument><expr><literal type="string">"\nSign inputs for raw transaction (serialized, hex-encoded).\n"</literal>
                <literal type="string">"The second argument is an array of base58-encoded private\n"</literal>
                <literal type="string">"keys that will be the only keys used to sign the transaction.\n"</literal>
                <literal type="string">"The third optional argument (may be null) is an array of previous transaction outputs that\n"</literal>
                <literal type="string">"this transaction depends on but may not yet be in the block chain.\n"</literal></expr></argument>,
                <block>{<block_content>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"hexstring"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"The transaction hex string"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"privkeys"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>ARR</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"A json array of base58-encoded private keys for signing"</literal></expr><operator>,</operator>
                        <expr><block>{
                            <expr><block>{<expr><literal type="string">"privatekey"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR_HEX</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>OMITTED</name></name></expr>, <expr><literal type="string">"private key in base58-encoding"</literal></expr>}</block></expr>,
                        }</block></expr><operator>,</operator></expr_stmt>
                        }</block_content></block><operator>,</operator>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"prevtxs"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>ARR</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>OMITTED_NAMED_ARG</name></name></expr><operator>,</operator> <expr><literal type="string">"A json array of previous dependent transaction outputs"</literal></expr><operator>,</operator>
                        <expr><block>{
                            <expr><block>{<expr><literal type="string">""</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>OBJ</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>OMITTED</name></name></expr>, <expr><literal type="string">""</literal></expr>,
                                <expr><block>{
                                    <expr><block>{<expr><literal type="string">"txid"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR_HEX</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr>, <expr><literal type="string">"The transaction id"</literal></expr>}</block></expr>,
                                    <expr><block>{<expr><literal type="string">"vout"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>NUM</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr>, <expr><literal type="string">"The output number"</literal></expr>}</block></expr>,
                                    <expr><block>{<expr><literal type="string">"scriptPubKey"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR_HEX</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr>, <expr><literal type="string">"script key"</literal></expr>}</block></expr>,
                                    <expr><block>{<expr><literal type="string">"redeemScript"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR_HEX</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>OMITTED</name></name></expr>, <expr><literal type="string">"(required for P2SH) redeem script"</literal></expr>}</block></expr>,
                                    <expr><block>{<expr><literal type="string">"witnessScript"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR_HEX</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>OMITTED</name></name></expr>, <expr><literal type="string">"(required for P2WSH or P2SH-P2WSH) witness script"</literal></expr>}</block></expr>,
                                    <expr><block>{<expr><literal type="string">"amount"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>AMOUNT</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>OMITTED</name></name></expr>, <expr><literal type="string">"(required for Segwit inputs) the amount spent"</literal></expr>}</block></expr>,
                                }</block></expr>,
                                }</block></expr>,
                        }</block></expr><operator>,</operator></expr_stmt>
                        }</block_content></block><operator>,</operator>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"sighashtype"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR</name></name></expr><operator>,</operator> <comment type="block">/* default */</comment> <expr><literal type="string">"ALL"</literal></expr><operator>,</operator> <expr><literal type="string">"The signature hash type. Must be one of:\n"</literal>
            <literal type="string">"       \"ALL\"\n"</literal>
            <literal type="string">"       \"NONE\"\n"</literal>
            <literal type="string">"       \"SINGLE\"\n"</literal>
            <literal type="string">"       \"ALL|ANYONECANPAY\"\n"</literal>
            <literal type="string">"       \"NONE|ANYONECANPAY\"\n"</literal>
            <literal type="string">"       \"SINGLE|ANYONECANPAY\"\n"</literal></expr></expr_stmt>
                    }</block_content></block><operator>,</operator>
                <expr_stmt/>}</block_content></block>,
                <argument><expr><call><name>RPCResult</name><argument_list>{
            <argument><expr><literal type="string">"{\n"</literal>
            <literal type="string">"  \"hex\" : \"value\",                  (string) The hex-encoded raw transaction with signature(s)\n"</literal>
            <literal type="string">"  \"complete\" : true|false,          (boolean) If the transaction has a complete set of signatures\n"</literal>
            <literal type="string">"  \"errors\" : [                      (json array of objects) Script verification errors (if there are any)\n"</literal>
            <literal type="string">"    {\n"</literal>
            <literal type="string">"      \"txid\" : \"hash\",              (string) The hash of the referenced, previous transaction\n"</literal>
            <literal type="string">"      \"vout\" : n,                   (numeric) The index of the output to spent and used as input\n"</literal>
            <literal type="string">"      \"scriptSig\" : \"hex\",          (string) The hex-encoded signature script\n"</literal>
            <literal type="string">"      \"sequence\" : n,               (numeric) Script sequence number\n"</literal>
            <literal type="string">"      \"error\" : \"text\"              (string) Verification or signing error related to the input\n"</literal>
            <literal type="string">"    }\n"</literal>
            <literal type="string">"    ,...\n"</literal>
            <literal type="string">"  ]\n"</literal>
            <literal type="string">"}\n"</literal></expr></argument>
                }</argument_list></call></expr></argument>,
                <argument><expr><call><name>RPCExamples</name><argument_list>{
                    <argument><expr><call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"signrawtransactionwithkey"</literal></expr></argument>, <argument><expr><literal type="string">"\"myhex\" \"[\\\"key1\\\",\\\"key2\\\"]\""</literal></expr></argument>)</argument_list></call>
            <operator>+</operator> <macro><name>HelpExampleRpc</name><argument_list>(<argument><literal type="string">"signrawtransactionwithkey"</literal></argument>, <argument><literal type="string">"\"myhex\", \"[\\\"key1\\\",\\\"key2\\\"]\""</literal></argument>)</argument_list></macro></expr></argument>
                }</argument_list></call></expr></argument>,
            }</argument_list></call><operator>.</operator><call><name>Check</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>RPCTypeCheck</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name></name></expr></argument>, <block>{<block_content><expr><name><name>UniValue</name><operator>::</operator><name>VSTR</name></name></expr><operator>,</operator> <expr><name><name>UniValue</name><operator>::</operator><name>VARR</name></name></expr><operator>,</operator> <expr><name><name>UniValue</name><operator>::</operator><name>VARR</name></name></expr><operator>,</operator> <expr><name><name>UniValue</name><operator>::</operator><name>VSTR</name></name></expr></block_content>}</block></argument_list></call></expr></expr_stmt><operator>,</operator> <expr_stmt><expr><literal type="boolean">true</literal></expr></expr_stmt>)</block_content></block>;</function>

    <decl_stmt><decl><type><name>CMutableTransaction</name></type> <name>mtx</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DecodeHexTx</name><argument_list>(<argument><expr><name>mtx</name></expr></argument>, <argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_DESERIALIZATION_ERROR</name></expr></argument>, <argument><expr><literal type="string">"TX decode failed"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>FillableSigningProvider</name></type> <name>keystore</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>UniValue</name><modifier>&amp;</modifier></type> <name>keys</name> <init>= <expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>get_array</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <call><name><name>keys</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>idx</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>UniValue</name></type> <name>k</name> <init>= <expr><name><name>keys</name><index>[<expr><name>idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CKey</name></type> <name>key</name> <init>= <expr><call><name>DecodeSecret</name><argument_list>(<argument><expr><call><name><name>k</name><operator>.</operator><name>get_str</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>key</name><operator>.</operator><name>IsValid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><literal type="string">"Invalid private key"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>keystore</name><operator>.</operator><name>AddKey</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="line">// Fetch previous transactions (inputs):</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>COutPoint</name></expr></argument>, <argument><expr><name>Coin</name></expr></argument>&gt;</argument_list></name></type> <name>coins</name></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CTxIn</name><modifier>&amp;</modifier></type> <name>txin</name> <range>: <expr><name><name>mtx</name><operator>.</operator><name>vin</name></name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>coins</name><index>[<expr><name><name>txin</name><operator>.</operator><name>prevout</name></name></expr>]</index></name></expr>;</expr_stmt> <comment type="line">// Create empty map entry keyed by prevout.</comment>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>FindCoins</name><argument_list>(<argument><expr><name>coins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Parse the prevtxs array</comment>
    <expr_stmt><expr><call><name>ParsePrevouts</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>keystore</name></expr></argument>, <argument><expr><name>coins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <function_decl><type><name>UniValue</name></type> <name>result</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name>SignTransaction</name><argument_list>(<argument><expr><name>mtx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>keystore</name></expr></argument>, <argument><expr><name>coins</name></expr></argument>, <argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
}

static <function><type><name>UniValue</name></type> <name>sendrawtransaction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>JSONRPCRequest</name><modifier>&amp;</modifier></type> <name>request</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>RPCHelpMan</name><argument_list>{<argument><expr><literal type="string">"sendrawtransaction"</literal></expr></argument>,
                <argument><expr><literal type="string">"\nSubmit a raw transaction (serialized, hex-encoded) to local node and network.\n"</literal>
                <literal type="string">"\nNote that the transaction will be sent unconditionally to all peers, so using this\n"</literal>
                <literal type="string">"for manual rebroadcast may degrade privacy by leaking the transaction's origin, as\n"</literal>
                <literal type="string">"nodes will normally not rebroadcast non-wallet transactions already in their mempool.\n"</literal>
                <literal type="string">"\nAlso see createrawtransaction and signrawtransactionwithkey calls.\n"</literal></expr></argument>,
                <block>{<block_content>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"hexstring"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR_HEX</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"The hex string of the raw transaction"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"maxfeerate"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>AMOUNT</name></name></expr><operator>,</operator> <comment type="block">/* default */</comment> <expr><call><name>FormatMoney</name><argument_list>(<argument><expr><call><name><name>DEFAULT_MAX_RAW_TX_FEE_RATE</name><operator>.</operator><name>GetFeePerK</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
                        <expr><literal type="string">"Reject transactions whose fee rate is higher than the specified value, expressed in "</literal> <operator>+</operator> <name>CURRENCY_UNIT</name> <operator>+</operator>
                            <literal type="string">"/kB.\nSet to 0 to accept any fee rate.\n"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                <expr_stmt/>}</block_content></block>,
                <argument><expr><call><name>RPCResult</name><argument_list>{
            <argument><expr><literal type="string">"\"hex\"             (string) The transaction hash in hex\n"</literal></expr></argument>
                }</argument_list></call></expr></argument>,
                <argument><expr><call><name>RPCExamples</name><argument_list>{
            <argument><expr><literal type="string">"\nCreate a transaction\n"</literal>
            <operator>+</operator> <call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"createrawtransaction"</literal></expr></argument>, <argument><expr><literal type="string">"\"[{\\\"txid\\\" : \\\"mytxid\\\",\\\"vout\\\":0}]\" \"{\\\"myaddress\\\":0.01}\""</literal></expr></argument>)</argument_list></call> <operator>+</operator>
            <literal type="string">"Sign the transaction, and get back the hex\n"</literal>
            <operator>+</operator> <call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"signrawtransactionwithwallet"</literal></expr></argument>, <argument><expr><literal type="string">"\"myhex\""</literal></expr></argument>)</argument_list></call> <operator>+</operator>
            <literal type="string">"\nSend the transaction (signed hex)\n"</literal>
            <operator>+</operator> <call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"sendrawtransaction"</literal></expr></argument>, <argument><expr><literal type="string">"\"signedhex\""</literal></expr></argument>)</argument_list></call> <operator>+</operator>
            <literal type="string">"\nAs a JSON-RPC call\n"</literal>
            <operator>+</operator> <macro><name>HelpExampleRpc</name><argument_list>(<argument><literal type="string">"sendrawtransaction"</literal></argument>, <argument><literal type="string">"\"signedhex\""</literal></argument>)</argument_list></macro></expr></argument>
                }</argument_list></call></expr></argument>,
    }</argument_list></call><operator>.</operator><call><name>Check</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>RPCTypeCheck</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name></name></expr></argument>, <block>{<block_content>
        <expr_stmt><expr><name><name>UniValue</name><operator>::</operator><name>VSTR</name></name></expr><operator>,</operator>
        <expr><call><name>UniValueType</name><argument_list>()</argument_list></call></expr><operator>,</operator></expr_stmt> <comment type="line">// NUM or BOOL, checked later</comment>
    </block_content>}</block></argument_list></call></expr></expr_stmt>)</block_content></block>;</function>

    <comment type="line">// parse hex string from parameter</comment>
    <decl_stmt><decl><type><name>CMutableTransaction</name></type> <name>mtx</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DecodeHexTx</name><argument_list>(<argument><expr><name>mtx</name></expr></argument>, <argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_DESERIALIZATION_ERROR</name></expr></argument>, <argument><expr><literal type="string">"TX decode failed"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>CTransactionRef</name></type> <name>tx</name><argument_list>(<argument><expr><call><name>MakeTransactionRef</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>mtx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>CFeeRate</name></type> <name>max_raw_tx_fee_rate</name> <init>= <expr><name>DEFAULT_MAX_RAW_TX_FEE_RATE</name></expr></init></decl>;</decl_stmt>
    <comment type="line">// TODO: temporary migration code for old clients. Remove in v0.20</comment>
    <if_stmt><if>if <condition>(<expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>isBool</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_PARAMETER</name></expr></argument>, <argument><expr><literal type="string">"Second argument must be numeric (maxfeerate) and no longer supports a boolean. To allow a transaction with high fees, set maxfeerate to 0."</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>max_raw_tx_fee_rate</name> <operator>=</operator> <call><name>CFeeRate</name><argument_list>(<argument><expr><call><name>AmountFromValue</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>virtual_size</name> <init>= <expr><call><name>GetVirtualTransactionSize</name><argument_list>(<argument><expr><operator>*</operator><name>tx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CAmount</name></type> <name>max_raw_tx_fee</name> <init>= <expr><call><name><name>max_raw_tx_fee_rate</name><operator>.</operator><name>GetFee</name></name><argument_list>(<argument><expr><name>virtual_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>err_string</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>AssertLockNotHeld</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>TransactionError</name></type> <name>err</name> <init>= <expr><call><name>BroadcastTransaction</name><argument_list>(<argument><expr><operator>*</operator><name>g_rpc_node</name></expr></argument>, <argument><expr><name>tx</name></expr></argument>, <argument><expr><name>err_string</name></expr></argument>, <argument><expr><name>max_raw_tx_fee</name></expr></argument>, <comment type="block">/*relay*/</comment> <argument><expr><literal type="boolean">true</literal></expr></argument>, <comment type="block">/*wait_callback*/</comment> <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>TransactionError</name><operator>::</operator><name>OK</name></name> <operator>!=</operator> <name>err</name></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCTransactionError</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>err_string</name></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><call><name><name>tx</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetHex</name><argument_list>()</argument_list></call></expr>;</return>
}

static <function><type><name>UniValue</name></type> <name>testmempoolaccept</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>JSONRPCRequest</name><modifier>&amp;</modifier></type> <name>request</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>RPCHelpMan</name><argument_list>{<argument><expr><literal type="string">"testmempoolaccept"</literal></expr></argument>,
                <argument><expr><literal type="string">"\nReturns result of mempool acceptance tests indicating if raw transaction (serialized, hex-encoded) would be accepted by mempool.\n"</literal>
                <literal type="string">"\nThis checks if the transaction violates the consensus or policy rules.\n"</literal>
                <literal type="string">"\nSee sendrawtransaction call.\n"</literal></expr></argument>,
                <block>{<block_content>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"rawtxs"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>ARR</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"An array of hex strings of raw transactions.\n"</literal>
            <literal type="string">"                                        Length must be one for now."</literal></expr><operator>,</operator>
                        <expr><block>{
                            <expr><block>{<expr><literal type="string">"rawtx"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR_HEX</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>OMITTED</name></name></expr>, <expr><literal type="string">""</literal></expr>}</block></expr>,
                        }</block></expr><operator>,</operator></expr_stmt>
                        }</block_content></block><operator>,</operator>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"maxfeerate"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>AMOUNT</name></name></expr><operator>,</operator> <comment type="block">/* default */</comment> <expr><call><name>FormatMoney</name><argument_list>(<argument><expr><call><name><name>DEFAULT_MAX_RAW_TX_FEE_RATE</name><operator>.</operator><name>GetFeePerK</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><literal type="string">"Reject transactions whose fee rate is higher than the specified value, expressed in "</literal> <operator>+</operator> <name>CURRENCY_UNIT</name> <operator>+</operator> <literal type="string">"/kB\n"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                <expr_stmt/>}</block_content></block>,
                <argument><expr><call><name>RPCResult</name><argument_list>{
            <argument><expr><literal type="string">"[                   (array) The result of the mempool acceptance test for each raw transaction in the input array.\n"</literal>
            <literal type="string">"                            Length is exactly one for now.\n"</literal>
            <literal type="string">" {\n"</literal>
            <literal type="string">"  \"txid\"           (string) The transaction hash in hex\n"</literal>
            <literal type="string">"  \"allowed\"        (boolean) If the mempool allows this tx to be inserted\n"</literal>
            <literal type="string">"  \"reject-reason\"  (string) Rejection string (only present when 'allowed' is false)\n"</literal>
            <literal type="string">" }\n"</literal>
            <literal type="string">"]\n"</literal></expr></argument>
                }</argument_list></call></expr></argument>,
                <argument><expr><call><name>RPCExamples</name><argument_list>{
            <argument><expr><literal type="string">"\nCreate a transaction\n"</literal>
            <operator>+</operator> <call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"createrawtransaction"</literal></expr></argument>, <argument><expr><literal type="string">"\"[{\\\"txid\\\" : \\\"mytxid\\\",\\\"vout\\\":0}]\" \"{\\\"myaddress\\\":0.01}\""</literal></expr></argument>)</argument_list></call> <operator>+</operator>
            <literal type="string">"Sign the transaction, and get back the hex\n"</literal>
            <operator>+</operator> <call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"signrawtransactionwithwallet"</literal></expr></argument>, <argument><expr><literal type="string">"\"myhex\""</literal></expr></argument>)</argument_list></call> <operator>+</operator>
            <literal type="string">"\nTest acceptance of the transaction (signed hex)\n"</literal>
            <operator>+</operator> <call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"testmempoolaccept"</literal></expr></argument>, <argument><expr><literal type="string">R"('["signedhex"]')"</literal></expr></argument>)</argument_list></call> <operator>+</operator>
            <literal type="string">"\nAs a JSON-RPC call\n"</literal>
            <operator>+</operator> <macro><name>HelpExampleRpc</name><argument_list>(<argument><literal type="string">"testmempoolaccept"</literal></argument>, <argument><literal type="string">"[\"signedhex\"]"</literal></argument>)</argument_list></macro></expr></argument>
                }</argument_list></call></expr></argument>,
    }</argument_list></call><operator>.</operator><call><name>Check</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>RPCTypeCheck</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name></name></expr></argument>, <block>{<block_content>
        <expr_stmt><expr><name><name>UniValue</name><operator>::</operator><name>VARR</name></name></expr><operator>,</operator>
        <expr><call><name>UniValueType</name><argument_list>()</argument_list></call></expr><operator>,</operator></expr_stmt> <comment type="line">// NUM or BOOL, checked later</comment>
    </block_content>}</block></argument_list></call></expr></expr_stmt>)</block_content></block>;</function>

    <if_stmt><if>if <condition>(<expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>get_array</name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_PARAMETER</name></expr></argument>, <argument><expr><literal type="string">"Array must contain exactly one raw transaction for now"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>CMutableTransaction</name></type> <name>mtx</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DecodeHexTx</name><argument_list>(<argument><expr><name>mtx</name></expr></argument>, <argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>get_array</name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_DESERIALIZATION_ERROR</name></expr></argument>, <argument><expr><literal type="string">"TX decode failed"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>CTransactionRef</name></type> <name>tx</name><argument_list>(<argument><expr><call><name>MakeTransactionRef</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>mtx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint256</name><modifier>&amp;</modifier></type> <name>tx_hash</name> <init>= <expr><call><name><name>tx</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>CFeeRate</name></type> <name>max_raw_tx_fee_rate</name> <init>= <expr><name>DEFAULT_MAX_RAW_TX_FEE_RATE</name></expr></init></decl>;</decl_stmt>
    <comment type="line">// TODO: temporary migration code for old clients. Remove in v0.20</comment>
    <if_stmt><if>if <condition>(<expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>isBool</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_PARAMETER</name></expr></argument>, <argument><expr><literal type="string">"Second argument must be numeric (maxfeerate) and no longer supports a boolean. To allow a transaction with high fees, set maxfeerate to 0."</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>max_raw_tx_fee_rate</name> <operator>=</operator> <call><name>CFeeRate</name><argument_list>(<argument><expr><call><name>AmountFromValue</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>virtual_size</name> <init>= <expr><call><name>GetVirtualTransactionSize</name><argument_list>(<argument><expr><operator>*</operator><name>tx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CAmount</name></type> <name>max_raw_tx_fee</name> <init>= <expr><call><name><name>max_raw_tx_fee_rate</name><operator>.</operator><name>GetFee</name></name><argument_list>(<argument><expr><name>virtual_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <function_decl><type><name>UniValue</name></type> <name>result</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VARR</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
    <function_decl><type><name>UniValue</name></type> <name>result_0</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name><name>result_0</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"txid"</literal></expr></argument>, <argument><expr><call><name><name>tx_hash</name><operator>.</operator><name>GetHex</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>TxValidationState</name></type> <name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>test_accept_res</name></decl>;</decl_stmt>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>test_accept_res</name> <operator>=</operator> <call><name>AcceptToMemoryPool</name><argument_list>(<argument><expr><name>mempool</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><literal type="null">nullptr</literal></expr></argument> <comment type="block">/* plTxnReplaced */</comment>, <argument><expr><literal type="boolean">false</literal></expr></argument> <comment type="block">/* bypass_limits */</comment>, <argument><expr><name>max_raw_tx_fee</name></expr></argument>, <comment type="block">/* test_accept */</comment> <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name><name>result_0</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"allowed"</literal></expr></argument>, <argument><expr><name>test_accept_res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>test_accept_res</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>state</name><operator>.</operator><name>IsInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>state</name><operator>.</operator><name>GetResult</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>TxValidationResult</name><operator>::</operator><name>TX_MISSING_INPUTS</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>result_0</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"reject-reason"</literal></expr></argument>, <argument><expr><literal type="string">"missing-inputs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name><name>result_0</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"reject-reason"</literal></expr></argument>, <argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name><name>state</name><operator>.</operator><name>GetRejectReason</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name><name>result_0</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"reject-reason"</literal></expr></argument>, <argument><expr><call><name><name>state</name><operator>.</operator><name>GetRejectReason</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>result_0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
}

static <function><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>WriteHDKeypath</name><parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>uint32_t</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>keypath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>keypath_str</name> <init>= <expr><literal type="string">"m"</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>uint32_t</name></type> <name>num</name> <range>: <expr><name>keypath</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><name>keypath_str</name> <operator>+=</operator> <literal type="string">"/"</literal></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>hardened</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>num</name> <operator>&amp;</operator> <literal type="number">0x80000000</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>hardened</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>num</name> <operator>&amp;=</operator> <operator>~</operator><literal type="number">0x80000000</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>keypath_str</name> <operator>+=</operator> <call><name><name>std</name><operator>::</operator><name>to_string</name></name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>hardened</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>keypath_str</name> <operator>+=</operator> <literal type="string">"'"</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>keypath_str</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>UniValue</name></type> <name>decodepsbt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>JSONRPCRequest</name><modifier>&amp;</modifier></type> <name>request</name></decl></parameter>)</parameter_list>
<block>{<block_content>
            <expr_stmt><expr><call><name>RPCHelpMan</name><argument_list>{<argument><expr><literal type="string">"decodepsbt"</literal></expr></argument>,
                <argument><expr><literal type="string">"\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\n"</literal></expr></argument>,
                <block>{<block_content>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"psbt"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"The PSBT base64 string"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                <expr_stmt/>}</block_content></block>,
                <argument><expr><call><name>RPCResult</name><argument_list>{
            <argument><expr><literal type="string">"{\n"</literal>
            <literal type="string">"  \"tx\" : {                   (json object) The decoded network-serialized unsigned transaction.\n"</literal>
            <literal type="string">"    ...                                      The layout is the same as the output of decoderawtransaction.\n"</literal>
            <literal type="string">"  },\n"</literal>
            <literal type="string">"  \"unknown\" : {                (json object) The unknown global fields\n"</literal>
            <literal type="string">"    \"key\" : \"value\"            (key-value pair) An unknown key-value pair\n"</literal>
            <literal type="string">"     ...\n"</literal>
            <literal type="string">"  },\n"</literal>
            <literal type="string">"  \"inputs\" : [                 (array of json objects)\n"</literal>
            <literal type="string">"    {\n"</literal>
            <literal type="string">"      \"non_witness_utxo\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\n"</literal>
            <literal type="string">"        ...\n"</literal>
            <literal type="string">"      },\n"</literal>
            <literal type="string">"      \"witness_utxo\" : {            (json object, optional) Transaction output for witness UTXOs\n"</literal>
            <literal type="string">"        \"amount\" : x.xxx,           (numeric) The value in "</literal> <operator>+</operator> <name>CURRENCY_UNIT</name> <operator>+</operator> <literal type="string">"\n"</literal>
            <literal type="string">"        \"scriptPubKey\" : {          (json object)\n"</literal>
            <literal type="string">"          \"asm\" : \"asm\",            (string) The asm\n"</literal>
            <literal type="string">"          \"hex\" : \"hex\",            (string) The hex\n"</literal>
            <literal type="string">"          \"type\" : \"pubkeyhash\",    (string) The type, eg 'pubkeyhash'\n"</literal>
            <literal type="string">"          \"address\" : \"address\"     (string) Bitcoin address if there is one\n"</literal>
            <literal type="string">"        }\n"</literal>
            <literal type="string">"      },\n"</literal>
            <literal type="string">"      \"partial_signatures\" : {             (json object, optional)\n"</literal>
            <literal type="string">"        \"pubkey\" : \"signature\",           (string) The public key and signature that corresponds to it.\n"</literal>
            <literal type="string">"        ,...\n"</literal>
            <literal type="string">"      }\n"</literal>
            <literal type="string">"      \"sighash\" : \"type\",                  (string, optional) The sighash type to be used\n"</literal>
            <literal type="string">"      \"redeem_script\" : {       (json object, optional)\n"</literal>
            <literal type="string">"          \"asm\" : \"asm\",            (string) The asm\n"</literal>
            <literal type="string">"          \"hex\" : \"hex\",            (string) The hex\n"</literal>
            <literal type="string">"          \"type\" : \"pubkeyhash\",    (string) The type, eg 'pubkeyhash'\n"</literal>
            <literal type="string">"        }\n"</literal>
            <literal type="string">"      \"witness_script\" : {       (json object, optional)\n"</literal>
            <literal type="string">"          \"asm\" : \"asm\",            (string) The asm\n"</literal>
            <literal type="string">"          \"hex\" : \"hex\",            (string) The hex\n"</literal>
            <literal type="string">"          \"type\" : \"pubkeyhash\",    (string) The type, eg 'pubkeyhash'\n"</literal>
            <literal type="string">"        }\n"</literal>
            <literal type="string">"      \"bip32_derivs\" : {          (json object, optional)\n"</literal>
            <literal type="string">"        \"pubkey\" : {                     (json object, optional) The public key with the derivation path as the value.\n"</literal>
            <literal type="string">"          \"master_fingerprint\" : \"fingerprint\"     (string) The fingerprint of the master key\n"</literal>
            <literal type="string">"          \"path\" : \"path\",                         (string) The path\n"</literal>
            <literal type="string">"        }\n"</literal>
            <literal type="string">"        ,...\n"</literal>
            <literal type="string">"      }\n"</literal>
            <literal type="string">"      \"final_scriptsig\" : {       (json object, optional)\n"</literal>
            <literal type="string">"          \"asm\" : \"asm\",            (string) The asm\n"</literal>
            <literal type="string">"          \"hex\" : \"hex\",            (string) The hex\n"</literal>
            <literal type="string">"        }\n"</literal>
            <literal type="string">"       \"final_scriptwitness\": [\"hex\", ...] (array of string) hex-encoded witness data (if any)\n"</literal>
            <literal type="string">"      \"unknown\" : {                (json object) The unknown global fields\n"</literal>
            <literal type="string">"        \"key\" : \"value\"            (key-value pair) An unknown key-value pair\n"</literal>
            <literal type="string">"         ...\n"</literal>
            <literal type="string">"      },\n"</literal>
            <literal type="string">"    }\n"</literal>
            <literal type="string">"    ,...\n"</literal>
            <literal type="string">"  ]\n"</literal>
            <literal type="string">"  \"outputs\" : [                 (array of json objects)\n"</literal>
            <literal type="string">"    {\n"</literal>
            <literal type="string">"      \"redeem_script\" : {       (json object, optional)\n"</literal>
            <literal type="string">"          \"asm\" : \"asm\",            (string) The asm\n"</literal>
            <literal type="string">"          \"hex\" : \"hex\",            (string) The hex\n"</literal>
            <literal type="string">"          \"type\" : \"pubkeyhash\",    (string) The type, eg 'pubkeyhash'\n"</literal>
            <literal type="string">"        }\n"</literal>
            <literal type="string">"      \"witness_script\" : {       (json object, optional)\n"</literal>
            <literal type="string">"          \"asm\" : \"asm\",            (string) The asm\n"</literal>
            <literal type="string">"          \"hex\" : \"hex\",            (string) The hex\n"</literal>
            <literal type="string">"          \"type\" : \"pubkeyhash\",    (string) The type, eg 'pubkeyhash'\n"</literal>
            <literal type="string">"      }\n"</literal>
            <literal type="string">"      \"bip32_derivs\" : [          (array of json objects, optional)\n"</literal>
            <literal type="string">"        {\n"</literal>
            <literal type="string">"          \"pubkey\" : \"pubkey\",                     (string) The public key this path corresponds to\n"</literal>
            <literal type="string">"          \"master_fingerprint\" : \"fingerprint\"     (string) The fingerprint of the master key\n"</literal>
            <literal type="string">"          \"path\" : \"path\",                         (string) The path\n"</literal>
            <literal type="string">"          }\n"</literal>
            <literal type="string">"        }\n"</literal>
            <literal type="string">"        ,...\n"</literal>
            <literal type="string">"      ],\n"</literal>
            <literal type="string">"      \"unknown\" : {                (json object) The unknown global fields\n"</literal>
            <literal type="string">"        \"key\" : \"value\"            (key-value pair) An unknown key-value pair\n"</literal>
            <literal type="string">"         ...\n"</literal>
            <literal type="string">"      },\n"</literal>
            <literal type="string">"    }\n"</literal>
            <literal type="string">"    ,...\n"</literal>
            <literal type="string">"  ]\n"</literal>
            <literal type="string">"  \"fee\" : fee                      (numeric, optional) The transaction fee paid if all UTXOs slots in the PSBT have been filled.\n"</literal>
            <literal type="string">"}\n"</literal></expr></argument>
                }</argument_list></call></expr></argument>,
                <argument><expr><call><name>RPCExamples</name><argument_list>{
                    <argument><expr><macro><name>HelpExampleCli</name><argument_list>(<argument><literal type="string">"decodepsbt"</literal></argument>, <argument><literal type="string">"\"psbt\""</literal></argument>)</argument_list></macro></expr></argument>
                }</argument_list></call></expr></argument>,
            }</argument_list></call><operator>.</operator><call><name>Check</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>RPCTypeCheck</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name></name></expr></argument>, <block>{<block_content><expr><name><name>UniValue</name><operator>::</operator><name>VSTR</name></name></expr></block_content>}</block></argument_list></call></expr></expr_stmt>)</block_content></block>;</function>

    <comment type="line">// Unserialize the transactions</comment>
    <decl_stmt><decl><type><name>PartiallySignedTransaction</name></type> <name>psbtx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>error</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DecodeBase64PSBT</name><argument_list>(<argument><expr><name>psbtx</name></expr></argument>, <argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_DESERIALIZATION_ERROR</name></expr></argument>, <argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"TX decode failed %s"</literal></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <function_decl><type><name>UniValue</name></type> <name>result</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></type></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="line">// Add the decoded tx</comment>
    <function_decl><type><name>UniValue</name></type> <name>tx_univ</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name>TxToUniv</name><argument_list>(<argument><expr><call><name>CTransaction</name><argument_list>(<argument><expr><operator>*</operator><name><name>psbtx</name><operator>.</operator><name>tx</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>uint256</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>tx_univ</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"tx"</literal></expr></argument>, <argument><expr><name>tx_univ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Unknown data</comment>
    <function_decl><type><name>UniValue</name></type> <name>unknowns</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>entry</name> <range>: <expr><name><name>psbtx</name><operator>.</operator><name>unknown</name></name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>unknowns</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>first</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>second</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"unknown"</literal></expr></argument>, <argument><expr><name>unknowns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// inputs</comment>
    <decl_stmt><decl><type><name>CAmount</name></type> <name>total_in</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>have_all_utxos</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>
    <function_decl><type><name>UniValue</name></type> <name>inputs</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VARR</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>psbtx</name><operator>.</operator><name>inputs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>PSBTInput</name><modifier>&amp;</modifier></type> <name>input</name> <init>= <expr><name><name>psbtx</name><operator>.</operator><name>inputs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <function_decl><type><name>UniValue</name></type> <name>in</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
        <comment type="line">// UTXOs</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>input</name><operator>.</operator><name>witness_utxo</name><operator>.</operator><name>IsNull</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>CTxOut</name><modifier>&amp;</modifier></type> <name>txout</name> <init>= <expr><name><name>input</name><operator>.</operator><name>witness_utxo</name></name></expr></init></decl>;</decl_stmt>

            <function_decl><type><name>UniValue</name></type> <name>out</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></type></decl></parameter>)</parameter_list>;</function_decl>

            <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"amount"</literal></expr></argument>, <argument><expr><call><name>ValueFromAmount</name><argument_list>(<argument><expr><name><name>txout</name><operator>.</operator><name>nValue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>total_in</name> <operator>+=</operator> <name><name>txout</name><operator>.</operator><name>nValue</name></name></expr>;</expr_stmt>

            <function_decl><type><name>UniValue</name></type> <name>o</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
            <expr_stmt><expr><call><name>ScriptToUniv</name><argument_list>(<argument><expr><name><name>txout</name><operator>.</operator><name>scriptPubKey</name></name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"scriptPubKey"</literal></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>in</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"witness_utxo"</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><operator>.</operator><name>non_witness_utxo</name></name></expr>)</condition> <block>{<block_content>
            <function_decl><type><name>UniValue</name></type> <name>non_wit</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
            <expr_stmt><expr><call><name>TxToUniv</name><argument_list>(<argument><expr><operator>*</operator><name><name>input</name><operator>.</operator><name>non_witness_utxo</name></name></expr></argument>, <argument><expr><call><name>uint256</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>non_wit</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>in</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"non_witness_utxo"</literal></expr></argument>, <argument><expr><name>non_wit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>total_in</name> <operator>+=</operator> <name><name>input</name><operator>.</operator><name>non_witness_utxo</name><operator>-&gt;</operator><name>vout</name><index>[<expr><name><name>psbtx</name><operator>.</operator><name>tx</name><operator>-&gt;</operator><name>vin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>prevout</name><operator>.</operator><name>n</name></name></expr>]</index></name><operator>.</operator><name>nValue</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>have_all_utxos</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="line">// Partial sigs</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>input</name><operator>.</operator><name>partial_sigs</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <function_decl><type><name>UniValue</name></type> <name>partial_sigs</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
            <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>sig</name> <range>: <expr><name><name>input</name><operator>.</operator><name>partial_sigs</name></name></expr></range></decl></init>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name><name>partial_sigs</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><name><name>sig</name><operator>.</operator><name>second</name><operator>.</operator><name>first</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><name><name>sig</name><operator>.</operator><name>second</name><operator>.</operator><name>second</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name><name>in</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"partial_signatures"</literal></expr></argument>, <argument><expr><name>partial_sigs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Sighash</comment>
        <if_stmt><if>if <condition>(<expr><name><name>input</name><operator>.</operator><name>sighash_type</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>in</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"sighash"</literal></expr></argument>, <argument><expr><call><name>SighashToStr</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>input</name><operator>.</operator><name>sighash_type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Redeem script and witness script</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>input</name><operator>.</operator><name>redeem_script</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <function_decl><type><name>UniValue</name></type> <name>r</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
            <expr_stmt><expr><call><name>ScriptToUniv</name><argument_list>(<argument><expr><name><name>input</name><operator>.</operator><name>redeem_script</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>in</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"redeem_script"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>input</name><operator>.</operator><name>witness_script</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <function_decl><type><name>UniValue</name></type> <name>r</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
            <expr_stmt><expr><call><name>ScriptToUniv</name><argument_list>(<argument><expr><name><name>input</name><operator>.</operator><name>witness_script</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>in</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"witness_script"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// keypaths</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>input</name><operator>.</operator><name>hd_keypaths</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <function_decl><type><name>UniValue</name></type> <name>keypaths</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VARR</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
            <for>for <control>(<init><decl><type><name>auto</name></type> <name>entry</name> <range>: <expr><name><name>input</name><operator>.</operator><name>hd_keypaths</name></name></expr></range></decl></init>)</control> <block>{<block_content>
                <function_decl><type><name>UniValue</name></type> <name>keypath</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
                <expr_stmt><expr><call><name><name>keypath</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"pubkey"</literal></expr></argument>, <argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>first</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name><name>keypath</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"master_fingerprint"</literal></expr></argument>, <argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"%08x"</literal></expr></argument>, <argument><expr><call><name>ReadBE32</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>second</name><operator>.</operator><name>fingerprint</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>keypath</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"path"</literal></expr></argument>, <argument><expr><call><name>WriteHDKeypath</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>second</name><operator>.</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>keypaths</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>keypath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name><name>in</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"bip32_derivs"</literal></expr></argument>, <argument><expr><name>keypaths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Final scriptSig and scriptwitness</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>input</name><operator>.</operator><name>final_script_sig</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <function_decl><type><name>UniValue</name></type> <name>scriptsig</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
            <expr_stmt><expr><call><name><name>scriptsig</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"asm"</literal></expr></argument>, <argument><expr><call><name>ScriptToAsmStr</name><argument_list>(<argument><expr><name><name>input</name><operator>.</operator><name>final_script_sig</name></name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>scriptsig</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"hex"</literal></expr></argument>, <argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><name><name>input</name><operator>.</operator><name>final_script_sig</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>in</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"final_scriptSig"</literal></expr></argument>, <argument><expr><name>scriptsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>input</name><operator>.</operator><name>final_script_witness</name><operator>.</operator><name>IsNull</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <function_decl><type><name>UniValue</name></type> <name>txinwitness</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VARR</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
            <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>item</name> <range>: <expr><name><name>input</name><operator>.</operator><name>final_script_witness</name><operator>.</operator><name>stack</name></name></expr></range></decl></init>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name><name>txinwitness</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><call><name><name>item</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>item</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name><name>in</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"final_scriptwitness"</literal></expr></argument>, <argument><expr><name>txinwitness</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Unknown data</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>input</name><operator>.</operator><name>unknown</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <function_decl><type><name>UniValue</name></type> <name>unknowns</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
            <for>for <control>(<init><decl><type><name>auto</name></type> <name>entry</name> <range>: <expr><name><name>input</name><operator>.</operator><name>unknown</name></name></expr></range></decl></init>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name><name>unknowns</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>first</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>second</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name><name>in</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"unknown"</literal></expr></argument>, <argument><expr><name>unknowns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name><name>inputs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"inputs"</literal></expr></argument>, <argument><expr><name>inputs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// outputs</comment>
    <decl_stmt><decl><type><name>CAmount</name></type> <name>output_value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <function_decl><type><name>UniValue</name></type> <name>outputs</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VARR</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>psbtx</name><operator>.</operator><name>outputs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>PSBTOutput</name><modifier>&amp;</modifier></type> <name>output</name> <init>= <expr><name><name>psbtx</name><operator>.</operator><name>outputs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <function_decl><type><name>UniValue</name></type> <name>out</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
        <comment type="line">// Redeem script and witness script</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>output</name><operator>.</operator><name>redeem_script</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <function_decl><type><name>UniValue</name></type> <name>r</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
            <expr_stmt><expr><call><name>ScriptToUniv</name><argument_list>(<argument><expr><name><name>output</name><operator>.</operator><name>redeem_script</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"redeem_script"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>output</name><operator>.</operator><name>witness_script</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <function_decl><type><name>UniValue</name></type> <name>r</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
            <expr_stmt><expr><call><name>ScriptToUniv</name><argument_list>(<argument><expr><name><name>output</name><operator>.</operator><name>witness_script</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"witness_script"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// keypaths</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>output</name><operator>.</operator><name>hd_keypaths</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <function_decl><type><name>UniValue</name></type> <name>keypaths</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VARR</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
            <for>for <control>(<init><decl><type><name>auto</name></type> <name>entry</name> <range>: <expr><name><name>output</name><operator>.</operator><name>hd_keypaths</name></name></expr></range></decl></init>)</control> <block>{<block_content>
                <function_decl><type><name>UniValue</name></type> <name>keypath</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
                <expr_stmt><expr><call><name><name>keypath</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"pubkey"</literal></expr></argument>, <argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>first</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>keypath</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"master_fingerprint"</literal></expr></argument>, <argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"%08x"</literal></expr></argument>, <argument><expr><call><name>ReadBE32</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>second</name><operator>.</operator><name>fingerprint</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>keypath</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"path"</literal></expr></argument>, <argument><expr><call><name>WriteHDKeypath</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>second</name><operator>.</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>keypaths</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>keypath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"bip32_derivs"</literal></expr></argument>, <argument><expr><name>keypaths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Unknown data</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>output</name><operator>.</operator><name>unknown</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <function_decl><type><name>UniValue</name></type> <name>unknowns</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
            <for>for <control>(<init><decl><type><name>auto</name></type> <name>entry</name> <range>: <expr><name><name>output</name><operator>.</operator><name>unknown</name></name></expr></range></decl></init>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name><name>unknowns</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>first</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>second</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name><name>out</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"unknown"</literal></expr></argument>, <argument><expr><name>unknowns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name><name>outputs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Fee calculation</comment>
        <expr_stmt><expr><name>output_value</name> <operator>+=</operator> <name><name>psbtx</name><operator>.</operator><name>tx</name><operator>-&gt;</operator><name>vout</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nValue</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"outputs"</literal></expr></argument>, <argument><expr><name>outputs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>have_all_utxos</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"fee"</literal></expr></argument>, <argument><expr><call><name>ValueFromAmount</name><argument_list>(<argument><expr><name>total_in</name> <operator>-</operator> <name>output_value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
}

UniValue <macro><name>combinepsbt</name><argument_list>(<argument>const JSONRPCRequest&amp; request</argument>)</argument_list></macro>
<block>{<block_content>
            <expr_stmt><expr><call><name>RPCHelpMan</name><argument_list>{<argument><expr><literal type="string">"combinepsbt"</literal></expr></argument>,
                <argument><expr><literal type="string">"\nCombine multiple partially signed Bitcoin transactions into one transaction.\n"</literal>
                <literal type="string">"Implements the Combiner role.\n"</literal></expr></argument>,
                <block>{<block_content>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"txs"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>ARR</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"A json array of base64 strings of partially signed transactions"</literal></expr><operator>,</operator>
                        <expr><block>{
                            <expr><block>{<expr><literal type="string">"psbt"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>OMITTED</name></name></expr>, <expr><literal type="string">"A base64 string of a PSBT"</literal></expr>}</block></expr>,
                        }</block></expr><operator>,</operator></expr_stmt>
                        }</block_content></block><operator>,</operator>
                <expr_stmt/>}</block_content></block>,
                <argument><expr><call><name>RPCResult</name><argument_list>{
            <argument><expr><literal type="string">"  \"psbt\"          (string) The base64-encoded partially signed transaction\n"</literal></expr></argument>
                }</argument_list></call></expr></argument>,
                <argument><expr><call><name>RPCExamples</name><argument_list>{
                    <argument><expr><macro><name>HelpExampleCli</name><argument_list>(<argument><literal type="string">"combinepsbt"</literal></argument>, <argument><literal type="string">R"('["mybase64_1", "mybase64_2", "mybase64_3"]')"</literal></argument>)</argument_list></macro></expr></argument>
                }</argument_list></call></expr></argument>,
            }</argument_list></call><operator>.</operator><call><name>Check</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>RPCTypeCheck</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name></name></expr></argument>, <block>{<block_content><expr><name><name>UniValue</name><operator>::</operator><name>VARR</name></name></expr></block_content>}</block></argument_list></call></expr></expr_stmt><operator>,</operator> <expr_stmt><expr><literal type="boolean">true</literal></expr></expr_stmt>)</block_content></block><empty_stmt>;</empty_stmt>

    <comment type="line">// Unserialize the transactions</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>PartiallySignedTransaction</name></expr></argument>&gt;</argument_list></name></type> <name>psbtxs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>UniValue</name></type> <name>txs</name> <init>= <expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>get_array</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>txs</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_PARAMETER</name></expr></argument>, <argument><expr><literal type="string">"Parameter 'txs' cannot be empty"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>txs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>PartiallySignedTransaction</name></type> <name>psbtx</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>error</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DecodeBase64PSBT</name><argument_list>(<argument><expr><name>psbtx</name></expr></argument>, <argument><expr><name><name>txs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_DESERIALIZATION_ERROR</name></expr></argument>, <argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"TX decode failed %s"</literal></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>psbtxs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>psbtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <decl_stmt><decl><type><name>PartiallySignedTransaction</name></type> <name>merged_psbt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>TransactionError</name></type> <name>error</name> <init>= <expr><call><name>CombinePSBTs</name><argument_list>(<argument><expr><name>merged_psbt</name></expr></argument>, <argument><expr><name>psbtxs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>error</name> <operator>!=</operator> <name><name>TransactionError</name><operator>::</operator><name>OK</name></name></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCTransactionError</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <function_decl><type><name>CDataStream</name></type> <name>ssTx</name><parameter_list>(<parameter><decl><type><name>SER_NETWORK</name></type></decl></parameter>, <parameter><decl><type><name>PROTOCOL_VERSION</name></type></decl></parameter>)</parameter_list>;</function_decl>
    <expr_stmt><expr><name>ssTx</name> <operator>&lt;&lt;</operator> <name>merged_psbt</name></expr>;</expr_stmt>
    <return>return <expr><call><name>EncodeBase64</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><call><name><name>ssTx</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>ssTx</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

UniValue <macro><name>finalizepsbt</name><argument_list>(<argument>const JSONRPCRequest&amp; request</argument>)</argument_list></macro>
<block>{<block_content>
            <expr_stmt><expr><call><name>RPCHelpMan</name><argument_list>{<argument><expr><literal type="string">"finalizepsbt"</literal></expr></argument>,
                <argument><expr><literal type="string">"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\n"</literal>
                <literal type="string">"network serialized transaction which can be broadcast with sendrawtransaction. Otherwise a PSBT will be\n"</literal>
                <literal type="string">"created which has the final_scriptSig and final_scriptWitness fields filled for inputs that are complete.\n"</literal>
                <literal type="string">"Implements the Finalizer and Extractor roles.\n"</literal></expr></argument>,
                <block>{<block_content>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"psbt"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"A base64 string of a PSBT"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"extract"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>BOOL</name></name></expr><operator>,</operator> <comment type="block">/* default */</comment> <expr><literal type="string">"true"</literal></expr><operator>,</operator> <expr><literal type="string">"If true and the transaction is complete,\n"</literal>
            <literal type="string">"                             extract and return the complete transaction in normal network serialization instead of the PSBT."</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                <expr_stmt/>}</block_content></block>,
                <argument><expr><call><name>RPCResult</name><argument_list>{
            <argument><expr><literal type="string">"{\n"</literal>
            <literal type="string">"  \"psbt\" : \"value\",          (string) The base64-encoded partially signed transaction if not extracted\n"</literal>
            <literal type="string">"  \"hex\" : \"value\",           (string) The hex-encoded network transaction if extracted\n"</literal>
            <literal type="string">"  \"complete\" : true|false,   (boolean) If the transaction has a complete set of signatures\n"</literal>
            <literal type="string">"  ]\n"</literal>
            <literal type="string">"}\n"</literal></expr></argument>
                }</argument_list></call></expr></argument>,
                <argument><expr><call><name>RPCExamples</name><argument_list>{
                    <argument><expr><macro><name>HelpExampleCli</name><argument_list>(<argument><literal type="string">"finalizepsbt"</literal></argument>, <argument><literal type="string">"\"psbt\""</literal></argument>)</argument_list></macro></expr></argument>
                }</argument_list></call></expr></argument>,
            }</argument_list></call><operator>.</operator><call><name>Check</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>RPCTypeCheck</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name></name></expr></argument>, <block>{<block_content><expr><name><name>UniValue</name><operator>::</operator><name>VSTR</name></name></expr><operator>,</operator> <expr><name><name>UniValue</name><operator>::</operator><name>VBOOL</name></name></expr></block_content>}</block></argument_list></call></expr></expr_stmt><operator>,</operator> <expr_stmt><expr><literal type="boolean">true</literal></expr></expr_stmt>)</block_content></block><empty_stmt>;</empty_stmt>

    <comment type="line">// Unserialize the transactions</comment>
    <decl_stmt><decl><type><name>PartiallySignedTransaction</name></type> <name>psbtx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>error</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DecodeBase64PSBT</name><argument_list>(<argument><expr><name>psbtx</name></expr></argument>, <argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_DESERIALIZATION_ERROR</name></expr></argument>, <argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"TX decode failed %s"</literal></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>extract</name> <init>= <expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>(</operator><operator>!</operator><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>get_bool</name><argument_list>()</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>CMutableTransaction</name></type> <name>mtx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>complete</name> <init>= <expr><call><name>FinalizeAndExtractPSBT</name><argument_list>(<argument><expr><name>psbtx</name></expr></argument>, <argument><expr><name>mtx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <function_decl><type><name>UniValue</name></type> <name>result</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
    <function_decl><type><name>CDataStream</name></type> <name>ssTx</name><parameter_list>(<parameter><decl><type><name>SER_NETWORK</name></type></decl></parameter>, <parameter><decl><type><name>PROTOCOL_VERSION</name></type></decl></parameter>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>result_str</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>complete</name> <operator>&amp;&amp;</operator> <name>extract</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>ssTx</name> <operator>&lt;&lt;</operator> <name>mtx</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>result_str</name> <operator>=</operator> <call><name>HexStr</name><argument_list>(<argument><expr><call><name><name>ssTx</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"hex"</literal></expr></argument>, <argument><expr><name>result_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>ssTx</name> <operator>&lt;&lt;</operator> <name>psbtx</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>result_str</name> <operator>=</operator> <call><name>EncodeBase64</name><argument_list>(<argument><expr><call><name><name>ssTx</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"psbt"</literal></expr></argument>, <argument><expr><name>result_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"complete"</literal></expr></argument>, <argument><expr><name>complete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
}

UniValue <macro><name>createpsbt</name><argument_list>(<argument>const JSONRPCRequest&amp; request</argument>)</argument_list></macro>
<block>{<block_content>
            <expr_stmt><expr><call><name>RPCHelpMan</name><argument_list>{<argument><expr><literal type="string">"createpsbt"</literal></expr></argument>,
                <argument><expr><literal type="string">"\nCreates a transaction in the Partially Signed Transaction format.\n"</literal>
                <literal type="string">"Implements the Creator role.\n"</literal></expr></argument>,
                <block>{<block_content>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"inputs"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>ARR</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"A json array of json objects"</literal></expr><operator>,</operator>
                        <expr><block>{
                            <expr><block>{<expr><literal type="string">""</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>OBJ</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>OMITTED</name></name></expr>, <expr><literal type="string">""</literal></expr>,
                                <expr><block>{
                                    <expr><block>{<expr><literal type="string">"txid"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR_HEX</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr>, <expr><literal type="string">"The transaction id"</literal></expr>}</block></expr>,
                                    <expr><block>{<expr><literal type="string">"vout"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>NUM</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr>, <expr><literal type="string">"The output number"</literal></expr>}</block></expr>,
                                    <expr><block>{<expr><literal type="string">"sequence"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>NUM</name></name></expr>, <comment type="block">/* default */</comment> <expr><literal type="string">"depends on the value of the 'replaceable' and 'locktime' arguments"</literal></expr>, <expr><literal type="string">"The sequence number"</literal></expr>}</block></expr>,
                                }</block></expr>,
                                }</block></expr>,
                        }</block></expr><operator>,</operator></expr_stmt>
                        }</block_content></block><operator>,</operator>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"outputs"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>ARR</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"a json array with outputs (key-value pairs), where none of the keys are duplicated.\n"</literal>
                            <literal type="string">"That is, each address can only appear once and there can only be one 'data' object.\n"</literal>
                            <literal type="string">"For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\n"</literal>
                            <literal type="string">"                             accepted as second parameter."</literal></expr><operator>,</operator>
                        <expr><block>{
                            <expr><block>{<expr><literal type="string">""</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>OBJ</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>OMITTED</name></name></expr>, <expr><literal type="string">""</literal></expr>,
                                <expr><block>{
                                    <expr><block>{<expr><literal type="string">"address"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>AMOUNT</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr>, <expr><literal type="string">"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in "</literal> <operator>+</operator> <name>CURRENCY_UNIT</name></expr>}</block></expr>,
                                }</block></expr>,
                                }</block></expr>,
                            <expr><block>{<expr><literal type="string">""</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>OBJ</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>OMITTED</name></name></expr>, <expr><literal type="string">""</literal></expr>,
                                <expr><block>{
                                    <expr><block>{<expr><literal type="string">"data"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR_HEX</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr>, <expr><literal type="string">"A key-value pair. The key must be \"data\", the value is hex-encoded data"</literal></expr>}</block></expr>,
                                }</block></expr>,
                                }</block></expr>,
                        }</block></expr><operator>,</operator></expr_stmt>
                        }</block_content></block><operator>,</operator>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"locktime"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>NUM</name></name></expr><operator>,</operator> <comment type="block">/* default */</comment> <expr><literal type="string">"0"</literal></expr><operator>,</operator> <expr><literal type="string">"Raw locktime. Non-0 value also locktime-activates inputs"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"replaceable"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>BOOL</name></name></expr><operator>,</operator> <comment type="block">/* default */</comment> <expr><literal type="string">"false"</literal></expr><operator>,</operator> <expr><literal type="string">"Marks this transaction as BIP125 replaceable.\n"</literal>
                            <literal type="string">"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible."</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                <expr_stmt/>}</block_content></block>,
                <argument><expr><call><name>RPCResult</name><argument_list>{
                            <argument><expr><literal type="string">"  \"psbt\"        (string)  The resulting raw transaction (base64-encoded string)\n"</literal></expr></argument>
                }</argument_list></call></expr></argument>,
                <argument><expr><call><name>RPCExamples</name><argument_list>{
                    <argument><expr><macro><name>HelpExampleCli</name><argument_list>(<argument><literal type="string">"createpsbt"</literal></argument>, <argument><literal type="string">"\"[{\\\"txid\\\":\\\"myid\\\",\\\"vout\\\":0}]\" \"[{\\\"data\\\":\\\"00010203\\\"}]\""</literal></argument>)</argument_list></macro></expr></argument>
                }</argument_list></call></expr></argument>,
            }</argument_list></call><operator>.</operator><call><name>Check</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <expr_stmt><expr><call><name>RPCTypeCheck</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name></name></expr></argument>, <block>{<block_content>
        <expr_stmt><expr><name><name>UniValue</name><operator>::</operator><name>VARR</name></name></expr><operator>,</operator>
        <expr><call><name>UniValueType</name><argument_list>()</argument_list></call></expr><operator>,</operator> <comment type="line">// ARR or OBJ, checked later</comment>
        <expr><name><name>UniValue</name><operator>::</operator><name>VNUM</name></name></expr><operator>,</operator>
        <expr><name><name>UniValue</name><operator>::</operator><name>VBOOL</name></name></expr><operator>,</operator></expr_stmt>
        </block_content>}</block></argument_list></call></expr></expr_stmt><operator>,</operator> <expr_stmt><expr><literal type="boolean">true</literal></expr></expr_stmt>
    )</block_content></block><empty_stmt>;</empty_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>rbf</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>rbf</name> <operator>=</operator> <name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><call><name>isTrue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>CMutableTransaction</name></type> <name>rawTx</name> <init>= <expr><call><name>ConstructTransaction</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>rbf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Make a blank psbt</comment>
    <decl_stmt><decl><type><name>PartiallySignedTransaction</name></type> <name>psbtx</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>psbtx</name><operator>.</operator><name>tx</name></name> <operator>=</operator> <name>rawTx</name></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>rawTx</name><operator>.</operator><name>vin</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>psbtx</name><operator>.</operator><name>inputs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>PSBTInput</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>rawTx</name><operator>.</operator><name>vout</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>psbtx</name><operator>.</operator><name>outputs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>PSBTOutput</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="line">// Serialize the PSBT</comment>
    <function_decl><type><name>CDataStream</name></type> <name>ssTx</name><parameter_list>(<parameter><decl><type><name>SER_NETWORK</name></type></decl></parameter>, <parameter><decl><type><name>PROTOCOL_VERSION</name></type></decl></parameter>)</parameter_list>;</function_decl>
    <expr_stmt><expr><name>ssTx</name> <operator>&lt;&lt;</operator> <name>psbtx</name></expr>;</expr_stmt>

    <return>return <expr><call><name>EncodeBase64</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><call><name><name>ssTx</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>ssTx</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

UniValue <macro><name>converttopsbt</name><argument_list>(<argument>const JSONRPCRequest&amp; request</argument>)</argument_list></macro>
<block>{<block_content>
    <expr_stmt><expr><call><name>RPCHelpMan</name><argument_list>{<argument><expr><literal type="string">"converttopsbt"</literal></expr></argument>,
                <argument><expr><literal type="string">"\nConverts a network serialized transaction to a PSBT. This should be used only with createrawtransaction and fundrawtransaction\n"</literal>
                <literal type="string">"createpsbt and walletcreatefundedpsbt should be used for new applications.\n"</literal></expr></argument>,
                <block>{<block_content>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"hexstring"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR_HEX</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"The hex string of a raw transaction"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"permitsigdata"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>BOOL</name></name></expr><operator>,</operator> <comment type="block">/* default */</comment> <expr><literal type="string">"false"</literal></expr><operator>,</operator> <expr><literal type="string">"If true, any signatures in the input will be discarded and conversion\n"</literal>
                            <literal type="string">"                              will continue. If false, RPC will fail if any signatures are present."</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"iswitness"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>BOOL</name></name></expr><operator>,</operator> <comment type="block">/* default */</comment> <expr><literal type="string">"depends on heuristic tests"</literal></expr><operator>,</operator> <expr><literal type="string">"Whether the transaction hex is a serialized witness transaction.\n"</literal>
                        <literal type="string">"If iswitness is not present, heuristic tests will be used in decoding.\n"</literal>
                        <literal type="string">"If true, only witness deserialization will be tried.\n"</literal>
                        <literal type="string">"If false, only non-witness deserialization will be tried.\n"</literal>
                        <literal type="string">"This boolean should reflect whether the transaction has inputs\n"</literal>
                        <literal type="string">"(e.g. fully valid, or on-chain transactions), if known by the caller."</literal></expr></expr_stmt>
                    }</block_content></block><operator>,</operator>
                <expr_stmt/>}</block_content></block>,
                <argument><expr><call><name>RPCResult</name><argument_list>{
                            <argument><expr><literal type="string">"  \"psbt\"        (string)  The resulting raw transaction (base64-encoded string)\n"</literal></expr></argument>
                }</argument_list></call></expr></argument>,
                <argument><expr><call><name>RPCExamples</name><argument_list>{
                            <argument><expr><literal type="string">"\nCreate a transaction\n"</literal>
                            <operator>+</operator> <call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"createrawtransaction"</literal></expr></argument>, <argument><expr><literal type="string">"\"[{\\\"txid\\\":\\\"myid\\\",\\\"vout\\\":0}]\" \"[{\\\"data\\\":\\\"00010203\\\"}]\""</literal></expr></argument>)</argument_list></call> <operator>+</operator>
                            <literal type="string">"\nConvert the transaction to a PSBT\n"</literal>
                            <operator>+</operator> <macro><name>HelpExampleCli</name><argument_list>(<argument><literal type="string">"converttopsbt"</literal></argument>, <argument><literal type="string">"\"rawtransaction\""</literal></argument>)</argument_list></macro></expr></argument>
                }</argument_list></call></expr></argument>,
    }</argument_list></call><operator>.</operator><call><name>Check</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>RPCTypeCheck</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name></name></expr></argument>, <block>{<block_content><expr><name><name>UniValue</name><operator>::</operator><name>VSTR</name></name></expr><operator>,</operator> <expr><name><name>UniValue</name><operator>::</operator><name>VBOOL</name></name></expr><operator>,</operator> <expr><name><name>UniValue</name><operator>::</operator><name>VBOOL</name></name></expr></block_content>}</block></argument_list></call></expr></expr_stmt><operator>,</operator> <expr_stmt><expr><literal type="boolean">true</literal></expr></expr_stmt>)</block_content></block><empty_stmt>;</empty_stmt>

    <comment type="line">// parse hex string from parameter</comment>
    <decl_stmt><decl><type><name>CMutableTransaction</name></type> <name>tx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>permitsigdata</name> <init>= <expr><ternary><condition><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="boolean">false</literal></expr> </then><else>: <expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>get_bool</name><argument_list>()</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>witness_specified</name> <init>= <expr><operator>!</operator><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>iswitness</name> <init>= <expr><ternary><condition><expr><name>witness_specified</name></expr> ?</condition><then> <expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><call><name>get_bool</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="boolean">false</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>try_witness</name> <init>= <expr><ternary><condition><expr><name>witness_specified</name></expr> ?</condition><then> <expr><name>iswitness</name></expr> </then><else>: <expr><literal type="boolean">true</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>try_no_witness</name> <init>= <expr><ternary><condition><expr><name>witness_specified</name></expr> ?</condition><then> <expr><operator>!</operator><name>iswitness</name></expr> </then><else>: <expr><literal type="boolean">true</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DecodeHexTx</name><argument_list>(<argument><expr><name>tx</name></expr></argument>, <argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>try_no_witness</name></expr></argument>, <argument><expr><name>try_witness</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_DESERIALIZATION_ERROR</name></expr></argument>, <argument><expr><literal type="string">"TX decode failed"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Remove all scriptSigs and scriptWitnesses from inputs</comment>
    <for>for <control>(<init><decl><type><name>CTxIn</name><modifier>&amp;</modifier></type> <name>input</name> <range>: <expr><name><name>tx</name><operator>.</operator><name>vin</name></name></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><call><name><name>input</name><operator>.</operator><name>scriptSig</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name><name>input</name><operator>.</operator><name>scriptWitness</name><operator>.</operator><name>IsNull</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>permitsigdata</name></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_DESERIALIZATION_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Inputs must not have scriptSigs and scriptWitnesses"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>input</name><operator>.</operator><name>scriptSig</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>input</name><operator>.</operator><name>scriptWitness</name><operator>.</operator><name>SetNull</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="line">// Make a blank psbt</comment>
    <decl_stmt><decl><type><name>PartiallySignedTransaction</name></type> <name>psbtx</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>psbtx</name><operator>.</operator><name>tx</name></name> <operator>=</operator> <name>tx</name></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>tx</name><operator>.</operator><name>vin</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>psbtx</name><operator>.</operator><name>inputs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>PSBTInput</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>tx</name><operator>.</operator><name>vout</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>psbtx</name><operator>.</operator><name>outputs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>PSBTOutput</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="line">// Serialize the PSBT</comment>
    <function_decl><type><name>CDataStream</name></type> <name>ssTx</name><parameter_list>(<parameter><decl><type><name>SER_NETWORK</name></type></decl></parameter>, <parameter><decl><type><name>PROTOCOL_VERSION</name></type></decl></parameter>)</parameter_list>;</function_decl>
    <expr_stmt><expr><name>ssTx</name> <operator>&lt;&lt;</operator> <name>psbtx</name></expr>;</expr_stmt>

    <return>return <expr><call><name>EncodeBase64</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><call><name><name>ssTx</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>ssTx</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

UniValue <macro><name>utxoupdatepsbt</name><argument_list>(<argument>const JSONRPCRequest&amp; request</argument>)</argument_list></macro>
<block>{<block_content>
            <expr_stmt><expr><call><name>RPCHelpMan</name><argument_list>{<argument><expr><literal type="string">"utxoupdatepsbt"</literal></expr></argument>,
            <argument><expr><literal type="string">"\nUpdates all segwit inputs and outputs in a PSBT with data from output descriptors, the UTXO set or the mempool.\n"</literal></expr></argument>,
            <block>{<block_content>
                <block>{<block_content><expr_stmt><expr><literal type="string">"psbt"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"A base64 string of a PSBT"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                <block>{<block_content><expr_stmt><expr><literal type="string">"descriptors"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>ARR</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>OMITTED_NAMED_ARG</name></name></expr><operator>,</operator> <expr><literal type="string">"An array of either strings or objects"</literal></expr><operator>,</operator> <expr><block>{
                    <expr><block>{<expr><literal type="string">""</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>OMITTED</name></name></expr>, <expr><literal type="string">"An output descriptor"</literal></expr>}</block></expr>,
                    <expr><block>{<expr><literal type="string">""</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>OBJ</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>OMITTED</name></name></expr>, <expr><literal type="string">"An object with an output descriptor and extra information"</literal></expr>, <expr><block>{
                         <expr><block>{<expr><literal type="string">"desc"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr>, <expr><literal type="string">"An output descriptor"</literal></expr>}</block></expr>,
                         <expr><block>{<expr><literal type="string">"range"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>RANGE</name></name></expr>, <expr><literal type="string">"1000"</literal></expr>, <expr><literal type="string">"Up to what index HD chains should be explored (either end or [begin,end])"</literal></expr>}</block></expr>,
                    }</block></expr>}</block></expr>,
                }</block></expr></expr_stmt>}</block_content></block><operator>,</operator>
            <expr_stmt/>}</block_content></block>,
            <argument><expr><call><name>RPCResult</name> <argument_list>{
                <argument><expr><literal type="string">"  \"psbt\"          (string) The base64-encoded partially signed transaction with inputs updated\n"</literal></expr></argument>
            }</argument_list></call></expr></argument>,
            <argument><expr><macro><name>RPCExamples</name></macro> <block>{
                <macro><name>HelpExampleCli</name><argument_list>(<argument><literal type="string">"utxoupdatepsbt"</literal></argument>, <argument><literal type="string">"\"psbt\""</literal></argument>)</argument_list></macro>
            }</block></expr></argument>}</argument_list></call><operator>.</operator><call><name>Check</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>RPCTypeCheck</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name></name></expr></argument>, <block>{<block_content><expr><name><name>UniValue</name><operator>::</operator><name>VSTR</name></name></expr><operator>,</operator> <expr><name><name>UniValue</name><operator>::</operator><name>VARR</name></name></expr></block_content>}</block></argument_list></call></expr></expr_stmt><operator>,</operator> <expr_stmt><expr><literal type="boolean">true</literal></expr></expr_stmt>)</block_content></block><empty_stmt>;</empty_stmt>

    <comment type="line">// Unserialize the transactions</comment>
    <decl_stmt><decl><type><name>PartiallySignedTransaction</name></type> <name>psbtx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>error</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DecodeBase64PSBT</name><argument_list>(<argument><expr><name>psbtx</name></expr></argument>, <argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_DESERIALIZATION_ERROR</name></expr></argument>, <argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"TX decode failed %s"</literal></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Parse descriptors, if any.</comment>
    <decl_stmt><decl><type><name>FlatSigningProvider</name></type> <name>provider</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>descs</name> <init>= <expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>get_array</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>descs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>EvalDescriptorStringOrObject</name><argument_list>(<argument><expr><name><name>descs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>provider</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <comment type="line">// We don't actually need private keys further on; hide them as a precaution.</comment>
    <decl_stmt><decl><type><name>HidingSigningProvider</name></type> <name>public_provider</name><argument_list>(<argument><expr><operator>&amp;</operator><name>provider</name></expr></argument>, <comment type="block">/* nosign */</comment> <argument><expr><literal type="boolean">true</literal></expr></argument>, <comment type="block">/* nobip32derivs */</comment> <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></decl>;</decl_stmt>

    <comment type="line">// Fetch previous transactions (inputs):</comment>
    <decl_stmt><decl><type><name>CCoinsView</name></type> <name>viewDummy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CCoinsViewCache</name></type> <name>view</name><argument_list>(<argument><expr><operator>&amp;</operator><name>viewDummy</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK2</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>, <argument><expr><name><name>mempool</name><operator>.</operator><name>cs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>CCoinsViewCache</name> <modifier>&amp;</modifier></type><name>viewChain</name> <init>= <expr><call><name><operator>::</operator><name>ChainstateActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>CoinsTip</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CCoinsViewMemPool</name></type> <name>viewMempool</name><argument_list>(<argument><expr><operator>&amp;</operator><name>viewChain</name></expr></argument>, <argument><expr><name>mempool</name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>view</name><operator>.</operator><name>SetBackend</name></name><argument_list>(<argument><expr><name>viewMempool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// temporarily switch cache backend to db+mempool view</comment>

        <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CTxIn</name><modifier>&amp;</modifier></type> <name>txin</name> <range>: <expr><name><name>psbtx</name><operator>.</operator><name>tx</name><operator>-&gt;</operator><name>vin</name></name></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>view</name><operator>.</operator><name>AccessCoin</name></name><argument_list>(<argument><expr><name><name>txin</name><operator>.</operator><name>prevout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Load entries from viewChain into view; can fail.</comment>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name><name>view</name><operator>.</operator><name>SetBackend</name></name><argument_list>(<argument><expr><name>viewDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// switch back to avoid locking mempool for too long</comment>
    </block_content>}</block>

    <comment type="line">// Fill the inputs</comment>
    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>psbtx</name><operator>.</operator><name>tx</name><operator>-&gt;</operator><name>vin</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>PSBTInput</name><modifier>&amp;</modifier></type> <name>input</name> <init>= <expr><call><name><name>psbtx</name><operator>.</operator><name>inputs</name><operator>.</operator><name>at</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>input</name><operator>.</operator><name>non_witness_utxo</name></name> <operator>||</operator> <operator>!</operator><call><name><name>input</name><operator>.</operator><name>witness_utxo</name><operator>.</operator><name>IsNull</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><specifier>const</specifier> <name>Coin</name><modifier>&amp;</modifier></type> <name>coin</name> <init>= <expr><call><name><name>view</name><operator>.</operator><name>AccessCoin</name></name><argument_list>(<argument><expr><name><name>psbtx</name><operator>.</operator><name>tx</name><operator>-&gt;</operator><name>vin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>prevout</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>IsSegWitOutput</name><argument_list>(<argument><expr><name>provider</name></expr></argument>, <argument><expr><name><name>coin</name><operator>.</operator><name>out</name><operator>.</operator><name>scriptPubKey</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>input</name><operator>.</operator><name>witness_utxo</name></name> <operator>=</operator> <name><name>coin</name><operator>.</operator><name>out</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Update script/keypath information using descriptor data.</comment>
        <comment type="line">// Note that SignPSBTInput does a lot more than just constructing ECDSA signatures</comment>
        <comment type="line">// we don't actually care about those here, in fact.</comment>
        <expr_stmt><expr><call><name>SignPSBTInput</name><argument_list>(<argument><expr><name>public_provider</name></expr></argument>, <argument><expr><name>psbtx</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <comment type="block">/* sighash_type */</comment> <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="line">// Update script/keypath information using descriptor data.</comment>
    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>psbtx</name><operator>.</operator><name>tx</name><operator>-&gt;</operator><name>vout</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>UpdatePSBTOutput</name><argument_list>(<argument><expr><name>public_provider</name></expr></argument>, <argument><expr><name>psbtx</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <function_decl><type><name>CDataStream</name></type> <name>ssTx</name><parameter_list>(<parameter><decl><type><name>SER_NETWORK</name></type></decl></parameter>, <parameter><decl><type><name>PROTOCOL_VERSION</name></type></decl></parameter>)</parameter_list>;</function_decl>
    <expr_stmt><expr><name>ssTx</name> <operator>&lt;&lt;</operator> <name>psbtx</name></expr>;</expr_stmt>
    <return>return <expr><call><name>EncodeBase64</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><call><name><name>ssTx</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>ssTx</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

UniValue <macro><name>joinpsbts</name><argument_list>(<argument>const JSONRPCRequest&amp; request</argument>)</argument_list></macro>
<block>{<block_content>
            <expr_stmt><expr><call><name>RPCHelpMan</name><argument_list>{<argument><expr><literal type="string">"joinpsbts"</literal></expr></argument>,
            <argument><expr><literal type="string">"\nJoins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs\n"</literal>
            <literal type="string">"No input in any of the PSBTs can be in more than one of the PSBTs.\n"</literal></expr></argument>,
            <block>{<block_content>
                <block>{<block_content><expr_stmt><expr><literal type="string">"txs"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>ARR</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"A json array of base64 strings of partially signed transactions"</literal></expr><operator>,</operator>
                    <expr><block>{
                        <expr><block>{<expr><literal type="string">"psbt"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr>, <expr><literal type="string">"A base64 string of a PSBT"</literal></expr>}</block></expr>
                    }</block></expr></expr_stmt>}</block_content>
            }</block><operator>,</operator>
            <expr_stmt><expr><call><name>RPCResult</name> <argument_list>{
                <argument><expr><literal type="string">"  \"psbt\"          (string) The base64-encoded partially signed transaction\n"</literal></expr></argument>
            }</argument_list></call></expr><operator>,</operator>
            <macro><name>RPCExamples</name></macro> <expr><block>{
                <macro><name>HelpExampleCli</name><argument_list>(<argument><literal type="string">"joinpsbts"</literal></argument>, <argument><literal type="string">"\"psbt\""</literal></argument>)</argument_list></macro>
            }</block></expr></expr_stmt>}</block_content>.Check(request</block>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>RPCTypeCheck</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name></name></expr></argument>, <block>{<block_content><expr><name><name>UniValue</name><operator>::</operator><name>VARR</name></name></expr></block_content>}</block></argument_list></call></expr></expr_stmt><operator>,</operator> <expr_stmt><expr><literal type="boolean">true</literal></expr></expr_stmt>)</block_content></block><empty_stmt>;</empty_stmt>

    <comment type="line">// Unserialize the transactions</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>PartiallySignedTransaction</name></expr></argument>&gt;</argument_list></name></type> <name>psbtxs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>UniValue</name></type> <name>txs</name> <init>= <expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>get_array</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name><name>txs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_PARAMETER</name></expr></argument>, <argument><expr><literal type="string">"At least two PSBTs are required to join PSBTs."</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>int32_t</name></type> <name>best_version</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>best_locktime</name> <init>= <expr><literal type="number">0xffffffff</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>txs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>PartiallySignedTransaction</name></type> <name>psbtx</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>error</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DecodeBase64PSBT</name><argument_list>(<argument><expr><name>psbtx</name></expr></argument>, <argument><expr><name><name>txs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_DESERIALIZATION_ERROR</name></expr></argument>, <argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"TX decode failed %s"</literal></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>psbtxs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>psbtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// Choose the highest version number</comment>
        <if_stmt><if>if <condition>(<expr><name><name>psbtx</name><operator>.</operator><name>tx</name><operator>-&gt;</operator><name>nVersion</name></name> <operator>&gt;</operator> <name>best_version</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>best_version</name> <operator>=</operator> <name><name>psbtx</name><operator>.</operator><name>tx</name><operator>-&gt;</operator><name>nVersion</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="line">// Choose the lowest lock time</comment>
        <if_stmt><if>if <condition>(<expr><name><name>psbtx</name><operator>.</operator><name>tx</name><operator>-&gt;</operator><name>nLockTime</name></name> <operator>&lt;</operator> <name>best_locktime</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>best_locktime</name> <operator>=</operator> <name><name>psbtx</name><operator>.</operator><name>tx</name><operator>-&gt;</operator><name>nLockTime</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="line">// Create a blank psbt where everything will be added</comment>
    <decl_stmt><decl><type><name>PartiallySignedTransaction</name></type> <name>merged_psbt</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>merged_psbt</name><operator>.</operator><name>tx</name></name> <operator>=</operator> <call><name>CMutableTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>merged_psbt</name><operator>.</operator><name>tx</name><operator>-&gt;</operator><name>nVersion</name></name> <operator>=</operator> <name>best_version</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>merged_psbt</name><operator>.</operator><name>tx</name><operator>-&gt;</operator><name>nLockTime</name></name> <operator>=</operator> <name>best_locktime</name></expr>;</expr_stmt>

    <comment type="line">// Merge</comment>
    <for>for <control>(<init><expr><name>auto</name><operator>&amp;</operator> <name>psbt</name> <operator>:</operator> <name>psbtxs</name></expr></init>)</control> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>psbt</name><operator>.</operator><name>tx</name><operator>-&gt;</operator><name>vin</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>merged_psbt</name><operator>.</operator><name>AddInput</name></name><argument_list>(<argument><expr><name><name>psbt</name><operator>.</operator><name>tx</name><operator>-&gt;</operator><name>vin</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>psbt</name><operator>.</operator><name>inputs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_PARAMETER</name></expr></argument>, <argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"Input %s:%d exists in multiple PSBTs"</literal></expr></argument>, <argument><expr><name><name>psbt</name><operator>.</operator><name>tx</name><operator>-&gt;</operator><name>vin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name><name>prevout</name><operator>.</operator><name>hash</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>psbt</name><operator>.</operator><name>tx</name><operator>-&gt;</operator><name>vin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>prevout</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>psbt</name><operator>.</operator><name>tx</name><operator>-&gt;</operator><name>vout</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>merged_psbt</name><operator>.</operator><name>AddOutput</name></name><argument_list>(<argument><expr><name><name>psbt</name><operator>.</operator><name>tx</name><operator>-&gt;</operator><name>vout</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>psbt</name><operator>.</operator><name>outputs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name><name>merged_psbt</name><operator>.</operator><name>unknown</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>psbt</name><operator>.</operator><name>unknown</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>psbt</name><operator>.</operator><name>unknown</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="line">// Generate list of shuffled indices for shuffling inputs and outputs of the merged PSBT</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type> <name>input_indices</name><argument_list>(<argument><expr><call><name><name>merged_psbt</name><operator>.</operator><name>inputs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>std</name><operator>::</operator><name>iota</name></name><argument_list>(<argument><expr><call><name><name>input_indices</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>input_indices</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type> <name>output_indices</name><argument_list>(<argument><expr><call><name><name>merged_psbt</name><operator>.</operator><name>outputs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>std</name><operator>::</operator><name>iota</name></name><argument_list>(<argument><expr><call><name><name>output_indices</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>output_indices</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Shuffle input and output indices lists</comment>
    <expr_stmt><expr><call><name>Shuffle</name><argument_list>(<argument><expr><call><name><name>input_indices</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>input_indices</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>FastRandomContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Shuffle</name><argument_list>(<argument><expr><call><name><name>output_indices</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>output_indices</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>FastRandomContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>PartiallySignedTransaction</name></type> <name>shuffled_psbt</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>shuffled_psbt</name><operator>.</operator><name>tx</name></name> <operator>=</operator> <call><name>CMutableTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>shuffled_psbt</name><operator>.</operator><name>tx</name><operator>-&gt;</operator><name>nVersion</name></name> <operator>=</operator> <name><name>merged_psbt</name><operator>.</operator><name>tx</name><operator>-&gt;</operator><name>nVersion</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>shuffled_psbt</name><operator>.</operator><name>tx</name><operator>-&gt;</operator><name>nLockTime</name></name> <operator>=</operator> <name><name>merged_psbt</name><operator>.</operator><name>tx</name><operator>-&gt;</operator><name>nLockTime</name></name></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <range>: <expr><name>input_indices</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>shuffled_psbt</name><operator>.</operator><name>AddInput</name></name><argument_list>(<argument><expr><name><name>merged_psbt</name><operator>.</operator><name>tx</name><operator>-&gt;</operator><name>vin</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>merged_psbt</name><operator>.</operator><name>inputs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <range>: <expr><name>output_indices</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>shuffled_psbt</name><operator>.</operator><name>AddOutput</name></name><argument_list>(<argument><expr><name><name>merged_psbt</name><operator>.</operator><name>tx</name><operator>-&gt;</operator><name>vout</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>merged_psbt</name><operator>.</operator><name>outputs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name><name>shuffled_psbt</name><operator>.</operator><name>unknown</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>merged_psbt</name><operator>.</operator><name>unknown</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>merged_psbt</name><operator>.</operator><name>unknown</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <function_decl><type><name>CDataStream</name></type> <name>ssTx</name><parameter_list>(<parameter><decl><type><name>SER_NETWORK</name></type></decl></parameter>, <parameter><decl><type><name>PROTOCOL_VERSION</name></type></decl></parameter>)</parameter_list>;</function_decl>
    <expr_stmt><expr><name>ssTx</name> <operator>&lt;&lt;</operator> <name>shuffled_psbt</name></expr>;</expr_stmt>
    <return>return <expr><call><name>EncodeBase64</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><call><name><name>ssTx</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>ssTx</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

UniValue <macro><name>analyzepsbt</name><argument_list>(<argument>const JSONRPCRequest&amp; request</argument>)</argument_list></macro>
<block>{<block_content>
            <expr_stmt><expr><call><name>RPCHelpMan</name><argument_list>{<argument><expr><literal type="string">"analyzepsbt"</literal></expr></argument>,
            <argument><expr><literal type="string">"\nAnalyzes and provides information about the current status of a PSBT and its inputs\n"</literal></expr></argument>,
            <block>{<block_content>
                <block>{<block_content><expr_stmt><expr><literal type="string">"psbt"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"A base64 string of a PSBT"</literal></expr></expr_stmt>}</block_content>
            }</block><operator>,</operator>
            <expr_stmt><expr><call><name>RPCResult</name> <argument_list>{
                <argument><expr><literal type="string">"{\n"</literal>
                <literal type="string">"  \"inputs\" : [                      (array of json objects)\n"</literal>
                <literal type="string">"    {\n"</literal>
                <literal type="string">"      \"has_utxo\" : true|false     (boolean) Whether a UTXO is provided\n"</literal>
                <literal type="string">"      \"is_final\" : true|false     (boolean) Whether the input is finalized\n"</literal>
                <literal type="string">"      \"missing\" : {               (json object, optional) Things that are missing that are required to complete this input\n"</literal>
                <literal type="string">"        \"pubkeys\" : [             (array, optional)\n"</literal>
                <literal type="string">"          \"keyid\"                 (string) Public key ID, hash160 of the public key, of a public key whose BIP 32 derivation path is missing\n"</literal>
                <literal type="string">"        ]\n"</literal>
                <literal type="string">"        \"signatures\" : [          (array, optional)\n"</literal>
                <literal type="string">"          \"keyid\"                 (string) Public key ID, hash160 of the public key, of a public key whose signature is missing\n"</literal>
                <literal type="string">"        ]\n"</literal>
                <literal type="string">"        \"redeemscript\" : \"hash\"   (string, optional) Hash160 of the redeemScript that is missing\n"</literal>
                <literal type="string">"        \"witnessscript\" : \"hash\"  (string, optional) SHA256 of the witnessScript that is missing\n"</literal>
                <literal type="string">"      }\n"</literal>
                <literal type="string">"      \"next\" : \"role\"             (string, optional) Role of the next person that this input needs to go to\n"</literal>
                <literal type="string">"    }\n"</literal>
                <literal type="string">"    ,...\n"</literal>
                <literal type="string">"  ]\n"</literal>
                <literal type="string">"  \"estimated_vsize\" : vsize       (numeric, optional) Estimated vsize of the final signed transaction\n"</literal>
                <literal type="string">"  \"estimated_feerate\" : feerate   (numeric, optional) Estimated feerate of the final signed transaction in "</literal> <operator>+</operator> <name>CURRENCY_UNIT</name> <operator>+</operator> <literal type="string">"/kB. Shown only if all UTXO slots in the PSBT have been filled.\n"</literal>
                <literal type="string">"  \"fee\" : fee                     (numeric, optional) The transaction fee paid. Shown only if all UTXO slots in the PSBT have been filled.\n"</literal>
                <literal type="string">"  \"next\" : \"role\"                 (string) Role of the next person that this psbt needs to go to\n"</literal>
                <literal type="string">"}\n"</literal></expr></argument>
            }</argument_list></call></expr><operator>,</operator>
            <macro><name>RPCExamples</name></macro> <expr><block>{
                <macro><name>HelpExampleCli</name><argument_list>(<argument><literal type="string">"analyzepsbt"</literal></argument>, <argument><literal type="string">"\"psbt\""</literal></argument>)</argument_list></macro>
            }</block></expr></expr_stmt>}</block_content>.Check(request</block>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>RPCTypeCheck</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name></name></expr></argument>, <block>{<block_content><expr><name><name>UniValue</name><operator>::</operator><name>VSTR</name></name></expr></block_content>}</block></argument_list></call></expr></expr_stmt>)</block_content></block><empty_stmt>;</empty_stmt>

    <comment type="line">// Unserialize the transaction</comment>
    <decl_stmt><decl><type><name>PartiallySignedTransaction</name></type> <name>psbtx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>error</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DecodeBase64PSBT</name><argument_list>(<argument><expr><name>psbtx</name></expr></argument>, <argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_DESERIALIZATION_ERROR</name></expr></argument>, <argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"TX decode failed %s"</literal></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>PSBTAnalysis</name></type> <name>psbta</name> <init>= <expr><call><name>AnalyzePSBT</name><argument_list>(<argument><expr><name>psbtx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <function_decl><type><name>UniValue</name></type> <name>result</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
    <function_decl><type><name>UniValue</name></type> <name>inputs_result</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VARR</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>input</name> <range>: <expr><name><name>psbta</name><operator>.</operator><name>inputs</name></name></expr></range></decl></init>)</control> <block>{<block_content>
        <function_decl><type><name>UniValue</name></type> <name>input_univ</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
        <function_decl><type><name>UniValue</name></type> <name>missing</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></type></decl></parameter>)</parameter_list>;</function_decl>

        <expr_stmt><expr><call><name><name>input_univ</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"has_utxo"</literal></expr></argument>, <argument><expr><name><name>input</name><operator>.</operator><name>has_utxo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>input_univ</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"is_final"</literal></expr></argument>, <argument><expr><name><name>input</name><operator>.</operator><name>is_final</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>input_univ</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"next"</literal></expr></argument>, <argument><expr><call><name>PSBTRoleName</name><argument_list>(<argument><expr><name><name>input</name><operator>.</operator><name>next</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>input</name><operator>.</operator><name>missing_pubkeys</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <function_decl><type><name>UniValue</name></type> <name>missing_pubkeys_univ</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VARR</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
            <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CKeyID</name><modifier>&amp;</modifier></type> <name>pubkey</name> <range>: <expr><name><name>input</name><operator>.</operator><name>missing_pubkeys</name></name></expr></range></decl></init>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name><name>missing_pubkeys_univ</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><name>pubkey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name><name>missing</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"pubkeys"</literal></expr></argument>, <argument><expr><name>missing_pubkeys_univ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>input</name><operator>.</operator><name>missing_redeem_script</name><operator>.</operator><name>IsNull</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>missing</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"redeemscript"</literal></expr></argument>, <argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><name><name>input</name><operator>.</operator><name>missing_redeem_script</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>input</name><operator>.</operator><name>missing_witness_script</name><operator>.</operator><name>IsNull</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>missing</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"witnessscript"</literal></expr></argument>, <argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><name><name>input</name><operator>.</operator><name>missing_witness_script</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>input</name><operator>.</operator><name>missing_sigs</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <function_decl><type><name>UniValue</name></type> <name>missing_sigs_univ</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VARR</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
            <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CKeyID</name><modifier>&amp;</modifier></type> <name>pubkey</name> <range>: <expr><name><name>input</name><operator>.</operator><name>missing_sigs</name></name></expr></range></decl></init>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name><name>missing_sigs_univ</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><name>pubkey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name><name>missing</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"signatures"</literal></expr></argument>, <argument><expr><name>missing_sigs_univ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>missing</name><operator>.</operator><name>getKeys</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>empty</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>input_univ</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"missing"</literal></expr></argument>, <argument><expr><name>missing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>inputs_result</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>input_univ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"inputs"</literal></expr></argument>, <argument><expr><name>inputs_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>psbta</name><operator>.</operator><name>estimated_vsize</name></name> <operator>!=</operator> <name>nullopt</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"estimated_vsize"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>*</operator><name><name>psbta</name><operator>.</operator><name>estimated_vsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>psbta</name><operator>.</operator><name>estimated_feerate</name></name> <operator>!=</operator> <name>nullopt</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"estimated_feerate"</literal></expr></argument>, <argument><expr><call><name>ValueFromAmount</name><argument_list>(<argument><expr><call><name><name>psbta</name><operator>.</operator><name>estimated_feerate</name><operator>-&gt;</operator><name>GetFeePerK</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>psbta</name><operator>.</operator><name>fee</name></name> <operator>!=</operator> <name>nullopt</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"fee"</literal></expr></argument>, <argument><expr><call><name>ValueFromAmount</name><argument_list>(<argument><expr><operator>*</operator><name><name>psbta</name><operator>.</operator><name>fee</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"next"</literal></expr></argument>, <argument><expr><call><name>PSBTRoleName</name><argument_list>(<argument><expr><name><name>psbta</name><operator>.</operator><name>next</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
}

<comment type="line">// clang-format off</comment>
static <decl_stmt><decl><type><specifier>const</specifier> <name>CRPCCommand</name></type> <name><name>commands</name><index>[]</index></name> <init>=
<expr><block>{ <comment type="line">//  category              name                            actor (function)            argNames</comment>
  <comment type="line">//  --------------------- ------------------------        -----------------------     ----------</comment>
    <expr><block>{ <expr><literal type="string">"rawtransactions"</literal></expr>,    <expr><literal type="string">"getrawtransaction"</literal></expr>,            <expr><operator>&amp;</operator><name>getrawtransaction</name></expr>,         <expr><block>{<expr><literal type="string">"txid"</literal></expr>,<expr><literal type="string">"verbose"</literal></expr>,<expr><literal type="string">"blockhash"</literal></expr>}</block></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"rawtransactions"</literal></expr>,    <expr><literal type="string">"createrawtransaction"</literal></expr>,         <expr><operator>&amp;</operator><name>createrawtransaction</name></expr>,      <expr><block>{<expr><literal type="string">"inputs"</literal></expr>,<expr><literal type="string">"outputs"</literal></expr>,<expr><literal type="string">"locktime"</literal></expr>,<expr><literal type="string">"replaceable"</literal></expr>}</block></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"rawtransactions"</literal></expr>,    <expr><literal type="string">"decoderawtransaction"</literal></expr>,         <expr><operator>&amp;</operator><name>decoderawtransaction</name></expr>,      <expr><block>{<expr><literal type="string">"hexstring"</literal></expr>,<expr><literal type="string">"iswitness"</literal></expr>}</block></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"rawtransactions"</literal></expr>,    <expr><literal type="string">"decodescript"</literal></expr>,                 <expr><operator>&amp;</operator><name>decodescript</name></expr>,              <expr><block>{<expr><literal type="string">"hexstring"</literal></expr>}</block></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"rawtransactions"</literal></expr>,    <expr><literal type="string">"sendrawtransaction"</literal></expr>,           <expr><operator>&amp;</operator><name>sendrawtransaction</name></expr>,        <expr><block>{<expr><literal type="string">"hexstring"</literal></expr>,<expr><literal type="string">"allowhighfees|maxfeerate"</literal></expr>}</block></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"rawtransactions"</literal></expr>,    <expr><literal type="string">"combinerawtransaction"</literal></expr>,        <expr><operator>&amp;</operator><name>combinerawtransaction</name></expr>,     <expr><block>{<expr><literal type="string">"txs"</literal></expr>}</block></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"rawtransactions"</literal></expr>,    <expr><literal type="string">"signrawtransactionwithkey"</literal></expr>,    <expr><operator>&amp;</operator><name>signrawtransactionwithkey</name></expr>, <expr><block>{<expr><literal type="string">"hexstring"</literal></expr>,<expr><literal type="string">"privkeys"</literal></expr>,<expr><literal type="string">"prevtxs"</literal></expr>,<expr><literal type="string">"sighashtype"</literal></expr>}</block></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"rawtransactions"</literal></expr>,    <expr><literal type="string">"testmempoolaccept"</literal></expr>,            <expr><operator>&amp;</operator><name>testmempoolaccept</name></expr>,         <expr><block>{<expr><literal type="string">"rawtxs"</literal></expr>,<expr><literal type="string">"allowhighfees|maxfeerate"</literal></expr>}</block></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"rawtransactions"</literal></expr>,    <expr><literal type="string">"decodepsbt"</literal></expr>,                   <expr><operator>&amp;</operator><name>decodepsbt</name></expr>,                <expr><block>{<expr><literal type="string">"psbt"</literal></expr>}</block></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"rawtransactions"</literal></expr>,    <expr><literal type="string">"combinepsbt"</literal></expr>,                  <expr><operator>&amp;</operator><name>combinepsbt</name></expr>,               <expr><block>{<expr><literal type="string">"txs"</literal></expr>}</block></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"rawtransactions"</literal></expr>,    <expr><literal type="string">"finalizepsbt"</literal></expr>,                 <expr><operator>&amp;</operator><name>finalizepsbt</name></expr>,              <expr><block>{<expr><literal type="string">"psbt"</literal></expr>, <expr><literal type="string">"extract"</literal></expr>}</block></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"rawtransactions"</literal></expr>,    <expr><literal type="string">"createpsbt"</literal></expr>,                   <expr><operator>&amp;</operator><name>createpsbt</name></expr>,                <expr><block>{<expr><literal type="string">"inputs"</literal></expr>,<expr><literal type="string">"outputs"</literal></expr>,<expr><literal type="string">"locktime"</literal></expr>,<expr><literal type="string">"replaceable"</literal></expr>}</block></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"rawtransactions"</literal></expr>,    <expr><literal type="string">"converttopsbt"</literal></expr>,                <expr><operator>&amp;</operator><name>converttopsbt</name></expr>,             <expr><block>{<expr><literal type="string">"hexstring"</literal></expr>,<expr><literal type="string">"permitsigdata"</literal></expr>,<expr><literal type="string">"iswitness"</literal></expr>}</block></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"rawtransactions"</literal></expr>,    <expr><literal type="string">"utxoupdatepsbt"</literal></expr>,               <expr><operator>&amp;</operator><name>utxoupdatepsbt</name></expr>,            <expr><block>{<expr><literal type="string">"psbt"</literal></expr>, <expr><literal type="string">"descriptors"</literal></expr>}</block></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"rawtransactions"</literal></expr>,    <expr><literal type="string">"joinpsbts"</literal></expr>,                    <expr><operator>&amp;</operator><name>joinpsbts</name></expr>,                 <expr><block>{<expr><literal type="string">"txs"</literal></expr>}</block></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"rawtransactions"</literal></expr>,    <expr><literal type="string">"analyzepsbt"</literal></expr>,                  <expr><operator>&amp;</operator><name>analyzepsbt</name></expr>,               <expr><block>{<expr><literal type="string">"psbt"</literal></expr>}</block></expr> }</block></expr>,

    <expr><block>{ <expr><literal type="string">"blockchain"</literal></expr>,         <expr><literal type="string">"gettxoutproof"</literal></expr>,                <expr><operator>&amp;</operator><name>gettxoutproof</name></expr>,             <expr><block>{<expr><literal type="string">"txids"</literal></expr>, <expr><literal type="string">"blockhash"</literal></expr>}</block></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"blockchain"</literal></expr>,         <expr><literal type="string">"verifytxoutproof"</literal></expr>,             <expr><operator>&amp;</operator><name>verifytxoutproof</name></expr>,          <expr><block>{<expr><literal type="string">"proof"</literal></expr>}</block></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
<comment type="line">// clang-format on</comment>

<function><type><name>void</name></type> <name>RegisterRawTransactionRPCCommands</name><parameter_list>(<parameter><decl><type><name>CRPCTable</name> <modifier>&amp;</modifier></type><name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>vcidx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>vcidx</name> <operator>&lt;</operator> <call><name>ARRAYLEN</name><argument_list>(<argument><expr><name>commands</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>vcidx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name><name>t</name><operator>.</operator><name>appendCommand</name></name><argument_list>(<argument><expr><name><name>commands</name><index>[<expr><name>vcidx</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>commands</name><index>[<expr><name>vcidx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>
</unit>
