<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C++" filename="/home/mmm/Projects/bitcoin/src/test/crypto_tests.cpp"><comment type="line">// Copyright (c) 2014-2019 The Bitcoin Core developers</comment>
<comment type="line">// Distributed under the MIT software license, see the accompanying</comment>
<comment type="line">// file COPYING or http://www.opensource.org/licenses/mit-license.php.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;crypto/aes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;crypto/chacha20.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;crypto/chacha_poly_aead.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;crypto/poly1305.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;crypto/hkdf_sha256_32.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;crypto/hmac_sha256.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;crypto/hmac_sha512.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;crypto/ripemd160.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;crypto/sha1.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;crypto/sha256.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;crypto/sha512.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;random.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/strencodings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;test/util/setup_common.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;boost/test/unit_test.hpp&gt;</cpp:file></cpp:include>

<macro><name>BOOST_FIXTURE_TEST_SUITE</name><argument_list>(<argument>crypto_tests</argument>, <argument>BasicTestingSetup</argument>)</argument_list></macro>

<function><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>Hasher</name></parameter>, <parameter><type><name>typename</name></type> <name>In</name></parameter>, <parameter><type><name>typename</name></type> <name>Out</name></parameter>&gt;</parameter_list></template>
<type><specifier>static</specifier> <name>void</name></type> <name>TestVector</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hasher</name> <modifier>&amp;</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>In</name> <modifier>&amp;</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Out</name> <modifier>&amp;</modifier></type><name>out</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>Out</name></type> <name>hash</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>out</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>h</name><operator>.</operator><name>OUTPUT_SIZE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>hash</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><call><name><name>out</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <comment type="line">// Test that writing the whole input string at once works.</comment>
        <expr_stmt><expr><call><name>Hasher</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>Write</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>in</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name><name>in</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>Finalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hash</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name>hash</name> <operator>==</operator> <name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">32</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <comment type="line">// Test that writing the string broken up in random pieces works.</comment>
        <decl_stmt><decl><type><name>Hasher</name></type> <name>hasher</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>pos</name> <operator>&lt;</operator> <call><name><name>in</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>InsecureRandRange</name><argument_list>(<argument><expr><operator>(</operator><call><name><name>in</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>pos</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>hasher</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>in</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pos</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <call><name><name>out</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <call><name><name>in</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>pos</name> <operator>&lt;</operator> <call><name><name>in</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <comment type="line">// Test that writing the rest at once to a copy of a hasher works.</comment>
                <expr_stmt><expr><call><name>Hasher</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>Write</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>in</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>, <argument><expr><call><name><name>in</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>pos</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>Finalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hash</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name>hash</name> <operator>==</operator> <name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name><name>hasher</name><operator>.</operator><name>Finalize</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hash</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name>hash</name> <operator>==</operator> <name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>TestSHA1</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>hexout</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>TestVector</name><argument_list>(<argument><expr><call><name>CSHA1</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>hexout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>TestSHA256</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>hexout</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>TestVector</name><argument_list>(<argument><expr><call><name>CSHA256</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>hexout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>TestSHA512</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>hexout</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>TestVector</name><argument_list>(<argument><expr><call><name>CSHA512</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>hexout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>TestRIPEMD160</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>hexout</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>TestVector</name><argument_list>(<argument><expr><call><name>CRIPEMD160</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>hexout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>TestHMACSHA256</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>hexkey</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>hexin</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>hexout</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>key</name> <init>= <expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>hexkey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>TestVector</name><argument_list>(<argument><expr><call><name>CHMAC_SHA256</name><argument_list>(<argument><expr><call><name><name>key</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>key</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>hexin</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>hexout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>TestHMACSHA512</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>hexkey</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>hexin</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>hexout</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>key</name> <init>= <expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>hexkey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>TestVector</name><argument_list>(<argument><expr><call><name>CHMAC_SHA512</name><argument_list>(<argument><expr><call><name><name>key</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>key</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>hexin</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>hexout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>TestAES256</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>hexkey</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>hexin</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>hexout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>key</name> <init>= <expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>hexkey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>in</name> <init>= <expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>hexin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>correctout</name> <init>= <expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>hexout</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>buf</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>key</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>in</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>correctout</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>AES256Encrypt</name></type> <name>enc</name><argument_list>(<argument><expr><call><name><name>key</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><call><name><name>correctout</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>enc</name><operator>.</operator><name>Encrypt</name></name><argument_list>(<argument><expr><call><name><name>buf</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>in</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name>buf</name> <operator>==</operator> <name>correctout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>AES256Decrypt</name></type> <name>dec</name><argument_list>(<argument><expr><call><name><name>key</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>dec</name><operator>.</operator><name>Decrypt</name></name><argument_list>(<argument><expr><call><name><name>buf</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>buf</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name>buf</name> <operator>==</operator> <name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>TestAES256CBC</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>hexkey</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>hexiv</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>pad</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>hexin</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>hexout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>key</name> <init>= <expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>hexkey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>iv</name> <init>= <expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>hexiv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>in</name> <init>= <expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>hexin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>correctout</name> <init>= <expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>hexout</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>realout</name><argument_list>(<argument><expr><call><name><name>in</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>AES_BLOCKSIZE</name></expr></argument>)</argument_list></decl>;</decl_stmt>

    <comment type="line">// Encrypt the plaintext and verify that it equals the cipher</comment>
    <decl_stmt><decl><type><name>AES256CBCEncrypt</name></type> <name>enc</name><argument_list>(<argument><expr><call><name><name>key</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>iv</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pad</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><call><name><name>enc</name><operator>.</operator><name>Encrypt</name></name><argument_list>(<argument><expr><call><name><name>in</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>in</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>realout</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>realout</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>realout</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>correctout</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_MESSAGE</name><argument_list>(<argument><expr><name>realout</name> <operator>==</operator> <name>correctout</name></expr></argument>, <argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><name>realout</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">" != "</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>hexout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Decrypt the cipher and verify that it equals the plaintext</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>decrypted</name><argument_list>(<argument><expr><call><name><name>correctout</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AES256CBCDecrypt</name></type> <name>dec</name><argument_list>(<argument><expr><call><name><name>key</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>iv</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pad</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name><name>dec</name><operator>.</operator><name>Decrypt</name></name><argument_list>(<argument><expr><call><name><name>correctout</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>correctout</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>decrypted</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>decrypted</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>decrypted</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>in</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_MESSAGE</name><argument_list>(<argument><expr><name>decrypted</name> <operator>==</operator> <name>in</name></expr></argument>, <argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><name>decrypted</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">" != "</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>hexin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Encrypt and re-decrypt substrings of the plaintext and verify that they equal each-other</comment>
    <for>for<control>(<init><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list><operator>::</operator><name>iterator</name></name></type> <name>i</name><argument_list>(<argument><expr><call><name><name>in</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</init> <condition><expr><name>i</name> <operator>!=</operator> <call><name><name>in</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>sub</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><call><name><name>in</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>subout</name><argument_list>(<argument><expr><call><name><name>sub</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>AES_BLOCKSIZE</name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>_size</name> <init>= <expr><call><name><name>enc</name><operator>.</operator><name>Encrypt</name></name><argument_list>(<argument><expr><call><name><name>sub</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>sub</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>subout</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>_size</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>subout</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><name>_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>subdecrypted</name><argument_list>(<argument><expr><call><name><name>subout</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
            <expr_stmt><expr><name>_size</name> <operator>=</operator> <call><name><name>dec</name><operator>.</operator><name>Decrypt</name></name><argument_list>(<argument><expr><call><name><name>subout</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>subout</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>subdecrypted</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>subdecrypted</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><name>_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>decrypted</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>in</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>BOOST_CHECK_MESSAGE</name><argument_list>(<argument><expr><name>subdecrypted</name> <operator>==</operator> <name>sub</name></expr></argument>, <argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><name>subdecrypted</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">" != "</literal></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>HexStr</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>TestChaCha20</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>hex_message</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>hexkey</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>nonce</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>seek</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>hexout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>key</name> <init>= <expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>hexkey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>m</name> <init>= <expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>hex_message</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ChaCha20</name></type> <name>rng</name><argument_list>(<argument><expr><call><name><name>key</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>key</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>rng</name><operator>.</operator><name>SetIV</name></name><argument_list>(<argument><expr><name>nonce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>rng</name><operator>.</operator><name>Seek</name></name><argument_list>(<argument><expr><name>seek</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>out</name> <init>= <expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>hexout</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>outres</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>outres</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><call><name><name>out</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>hex_message</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>m</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>out</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// perform the ChaCha20 round(s), if message is provided it will output the encrypted ciphertext otherwise the keystream</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>hex_message</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>rng</name><operator>.</operator><name>Crypt</name></name><argument_list>(<argument><expr><call><name><name>m</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>outres</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>outres</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name><name>rng</name><operator>.</operator><name>Keystream</name></name><argument_list>(<argument><expr><call><name><name>outres</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>outres</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name>out</name> <operator>==</operator> <name>outres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>hex_message</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="line">// Manually XOR with the keystream and compare the output</comment>
        <expr_stmt><expr><call><name><name>rng</name><operator>.</operator><name>SetIV</name></name><argument_list>(<argument><expr><name>nonce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>rng</name><operator>.</operator><name>Seek</name></name><argument_list>(<argument><expr><name>seek</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>only_keystream</name><argument_list>(<argument><expr><call><name><name>outres</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>rng</name><operator>.</operator><name>Keystream</name></name><argument_list>(<argument><expr><call><name><name>only_keystream</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>only_keystream</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>!=</operator> <call><name><name>m</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><name><name>outres</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>m</name><index>[<expr><name>i</name></expr>]</index></name> <operator>^</operator> <name><name>only_keystream</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name>out</name> <operator>==</operator> <name>outres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>TestPoly1305</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>hexmessage</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>hexkey</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>hextag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>key</name> <init>= <expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>hexkey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>m</name> <init>= <expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>hexmessage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>tag</name> <init>= <expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>hextag</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>tagres</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>tagres</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><name>POLY1305_TAGLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>poly1305_auth</name><argument_list>(<argument><expr><call><name><name>tagres</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>m</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>m</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>key</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name>tag</name> <operator>==</operator> <name>tagres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>TestHKDF_SHA256_32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>ikm_hex</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>salt_hex</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>info_hex</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>okm_check_hex</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>initial_key_material</name> <init>= <expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>ikm_hex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>salt</name> <init>= <expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>salt_hex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>info</name> <init>= <expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>info_hex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


    <comment type="line">// our implementation only supports strings for the "info" and "salt", stringify them</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>salt_stringified</name><argument_list>(<argument><expr><cast type="reinterpret">reinterpret_cast<argument_list type="generic">&lt;<argument><expr><name>char</name><operator>*</operator></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><call><name><name>salt</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></cast></expr></argument>, <argument><expr><call><name><name>salt</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>info_stringified</name><argument_list>(<argument><expr><cast type="reinterpret">reinterpret_cast<argument_list type="generic">&lt;<argument><expr><name>char</name><operator>*</operator></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><call><name><name>info</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></cast></expr></argument>, <argument><expr><call><name><name>info</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>CHKDF_HMAC_SHA256_L32</name></type> <name>hkdf32</name><argument_list>(<argument><expr><call><name><name>initial_key_material</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>initial_key_material</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>salt_stringified</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>out</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>hkdf32</name><operator>.</operator><name>Expand32</name></name><argument_list>(<argument><expr><name>info_stringified</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>out</name> <operator>+</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>okm_check_hex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>std</name><operator>::</operator><name>string</name></name></type> <name>LongTestString</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>ret</name></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">200000</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name>ret</name> <operator>+=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><name>i</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>ret</name> <operator>+=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><name>i</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>ret</name> <operator>+=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><name>i</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>ret</name> <operator>+=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><name>i</name> <operator>&gt;&gt;</operator> <literal type="number">12</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>ret</name> <operator>+=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><name>i</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name></type> <name>test1</name> <init>= <expr><call><name>LongTestString</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>ripemd160_testvectors</argument>)</argument_list></macro> <block>{<block_content>
    <expr_stmt><expr><call><name>TestRIPEMD160</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">"9c1185a5c5e9fc54612808977ee8f548b2258d31"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestRIPEMD160</name><argument_list>(<argument><expr><literal type="string">"abc"</literal></expr></argument>, <argument><expr><literal type="string">"8eb208f7e05d987a9b044a8e98c6b087f15a0bfc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestRIPEMD160</name><argument_list>(<argument><expr><literal type="string">"message digest"</literal></expr></argument>, <argument><expr><literal type="string">"5d0689ef49d2fae572b881b123a85ffa21595f36"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestRIPEMD160</name><argument_list>(<argument><expr><literal type="string">"secure hash algorithm"</literal></expr></argument>, <argument><expr><literal type="string">"20397528223b6a5f4cbc2808aba0464e645544f9"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestRIPEMD160</name><argument_list>(<argument><expr><literal type="string">"RIPEMD160 is considered to be safe"</literal></expr></argument>, <argument><expr><literal type="string">"a7d78608c7af8a8e728778e81576870734122b66"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestRIPEMD160</name><argument_list>(<argument><expr><literal type="string">"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"</literal></expr></argument>,
                  <argument><expr><literal type="string">"12a053384a9c0c88e405a06c27dcf49ada62eb2b"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestRIPEMD160</name><argument_list>(<argument><expr><literal type="string">"For this sample, this 63-byte string will be used as input data"</literal></expr></argument>,
                  <argument><expr><literal type="string">"de90dbfee14b63fb5abf27c2ad4a82aaa5f27a11"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestRIPEMD160</name><argument_list>(<argument><expr><literal type="string">"This is exactly 64 bytes long, not counting the terminating byte"</literal></expr></argument>,
                  <argument><expr><literal type="string">"eda31d51d3a623b81e19eb02e24ff65d27d67b37"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestRIPEMD160</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="number">1000000</literal></expr></argument>, <argument><expr><literal type="char">'a'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"52783243c1697bdbe16d37f97f68f08325dc1528"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestRIPEMD160</name><argument_list>(<argument><expr><name>test1</name></expr></argument>, <argument><expr><literal type="string">"464243587bd146ea835cdf57bdae582f25ec45f1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>sha1_testvectors</argument>)</argument_list></macro> <block>{<block_content>
    <expr_stmt><expr><call><name>TestSHA1</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">"da39a3ee5e6b4b0d3255bfef95601890afd80709"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestSHA1</name><argument_list>(<argument><expr><literal type="string">"abc"</literal></expr></argument>, <argument><expr><literal type="string">"a9993e364706816aba3e25717850c26c9cd0d89d"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestSHA1</name><argument_list>(<argument><expr><literal type="string">"message digest"</literal></expr></argument>, <argument><expr><literal type="string">"c12252ceda8be8994d5fa0290a47231c1d16aae3"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestSHA1</name><argument_list>(<argument><expr><literal type="string">"secure hash algorithm"</literal></expr></argument>, <argument><expr><literal type="string">"d4d6d2f0ebe317513bbd8d967d89bac5819c2f60"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestSHA1</name><argument_list>(<argument><expr><literal type="string">"SHA1 is considered to be safe"</literal></expr></argument>, <argument><expr><literal type="string">"f2b6650569ad3a8720348dd6ea6c497dee3a842a"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestSHA1</name><argument_list>(<argument><expr><literal type="string">"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"</literal></expr></argument>,
             <argument><expr><literal type="string">"84983e441c3bd26ebaae4aa1f95129e5e54670f1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestSHA1</name><argument_list>(<argument><expr><literal type="string">"For this sample, this 63-byte string will be used as input data"</literal></expr></argument>,
             <argument><expr><literal type="string">"4f0ea5cd0585a23d028abdc1a6684e5a8094dc49"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestSHA1</name><argument_list>(<argument><expr><literal type="string">"This is exactly 64 bytes long, not counting the terminating byte"</literal></expr></argument>,
             <argument><expr><literal type="string">"fb679f23e7d1ce053313e66e127ab1b444397057"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestSHA1</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="number">1000000</literal></expr></argument>, <argument><expr><literal type="char">'a'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"34aa973cd4c4daa4f61eeb2bdbad27316534016f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestSHA1</name><argument_list>(<argument><expr><name>test1</name></expr></argument>, <argument><expr><literal type="string">"b7755760681cbfd971451668f32af5774f4656b5"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>sha256_testvectors</argument>)</argument_list></macro> <block>{<block_content>
    <expr_stmt><expr><call><name>TestSHA256</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestSHA256</name><argument_list>(<argument><expr><literal type="string">"abc"</literal></expr></argument>, <argument><expr><literal type="string">"ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestSHA256</name><argument_list>(<argument><expr><literal type="string">"message digest"</literal></expr></argument>,
               <argument><expr><literal type="string">"f7846f55cf23e14eebeab5b4e1550cad5b509e3348fbc4efa3a1413d393cb650"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestSHA256</name><argument_list>(<argument><expr><literal type="string">"secure hash algorithm"</literal></expr></argument>,
               <argument><expr><literal type="string">"f30ceb2bb2829e79e4ca9753d35a8ecc00262d164cc077080295381cbd643f0d"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestSHA256</name><argument_list>(<argument><expr><literal type="string">"SHA256 is considered to be safe"</literal></expr></argument>,
               <argument><expr><literal type="string">"6819d915c73f4d1e77e4e1b52d1fa0f9cf9beaead3939f15874bd988e2a23630"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestSHA256</name><argument_list>(<argument><expr><literal type="string">"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"</literal></expr></argument>,
               <argument><expr><literal type="string">"248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestSHA256</name><argument_list>(<argument><expr><literal type="string">"For this sample, this 63-byte string will be used as input data"</literal></expr></argument>,
               <argument><expr><literal type="string">"f08a78cbbaee082b052ae0708f32fa1e50c5c421aa772ba5dbb406a2ea6be342"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestSHA256</name><argument_list>(<argument><expr><literal type="string">"This is exactly 64 bytes long, not counting the terminating byte"</literal></expr></argument>,
               <argument><expr><literal type="string">"ab64eff7e88e2e46165e29f2bce41826bd4c7b3552f6b382a9e7d3af47c245f8"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestSHA256</name><argument_list>(<argument><expr><literal type="string">"As Bitcoin relies on 80 byte header hashes, we want to have an example for that."</literal></expr></argument>,
               <argument><expr><literal type="string">"7406e8de7d6e4fffc573daef05aefb8806e7790f55eab5576f31349743cca743"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestSHA256</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="number">1000000</literal></expr></argument>, <argument><expr><literal type="char">'a'</literal></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><literal type="string">"cdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestSHA256</name><argument_list>(<argument><expr><name>test1</name></expr></argument>, <argument><expr><literal type="string">"a316d55510b49662420f49d145d42fb83f31ef8dc016aa4e32df049991a91e26"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>sha512_testvectors</argument>)</argument_list></macro> <block>{<block_content>
    <expr_stmt><expr><call><name>TestSHA512</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>,
               <argument><expr><literal type="string">"cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce"</literal>
               <literal type="string">"47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestSHA512</name><argument_list>(<argument><expr><literal type="string">"abc"</literal></expr></argument>,
               <argument><expr><literal type="string">"ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a"</literal>
               <literal type="string">"2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestSHA512</name><argument_list>(<argument><expr><literal type="string">"message digest"</literal></expr></argument>,
               <argument><expr><literal type="string">"107dbf389d9e9f71a3a95f6c055b9251bc5268c2be16d6c13492ea45b0199f33"</literal>
               <literal type="string">"09e16455ab1e96118e8a905d5597b72038ddb372a89826046de66687bb420e7c"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestSHA512</name><argument_list>(<argument><expr><literal type="string">"secure hash algorithm"</literal></expr></argument>,
               <argument><expr><literal type="string">"7746d91f3de30c68cec0dd693120a7e8b04d8073cb699bdce1a3f64127bca7a3"</literal>
               <literal type="string">"d5db502e814bb63c063a7a5043b2df87c61133395f4ad1edca7fcf4b30c3236e"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestSHA512</name><argument_list>(<argument><expr><literal type="string">"SHA512 is considered to be safe"</literal></expr></argument>,
               <argument><expr><literal type="string">"099e6468d889e1c79092a89ae925a9499b5408e01b66cb5b0a3bd0dfa51a9964"</literal>
               <literal type="string">"6b4a3901caab1318189f74cd8cf2e941829012f2449df52067d3dd5b978456c2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestSHA512</name><argument_list>(<argument><expr><literal type="string">"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"</literal></expr></argument>,
               <argument><expr><literal type="string">"204a8fc6dda82f0a0ced7beb8e08a41657c16ef468b228a8279be331a703c335"</literal>
               <literal type="string">"96fd15c13b1b07f9aa1d3bea57789ca031ad85c7a71dd70354ec631238ca3445"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestSHA512</name><argument_list>(<argument><expr><literal type="string">"For this sample, this 63-byte string will be used as input data"</literal></expr></argument>,
               <argument><expr><literal type="string">"b3de4afbc516d2478fe9b518d063bda6c8dd65fc38402dd81d1eb7364e72fb6e"</literal>
               <literal type="string">"6663cf6d2771c8f5a6da09601712fb3d2a36c6ffea3e28b0818b05b0a8660766"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestSHA512</name><argument_list>(<argument><expr><literal type="string">"This is exactly 64 bytes long, not counting the terminating byte"</literal></expr></argument>,
               <argument><expr><literal type="string">"70aefeaa0e7ac4f8fe17532d7185a289bee3b428d950c14fa8b713ca09814a38"</literal>
               <literal type="string">"7d245870e007a80ad97c369d193e41701aa07f3221d15f0e65a1ff970cedf030"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestSHA512</name><argument_list>(<argument><expr><literal type="string">"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmno"</literal>
               <literal type="string">"ijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu"</literal></expr></argument>,
               <argument><expr><literal type="string">"8e959b75dae313da8cf4f72814fc143f8f7779c6eb9f7fa17299aeadb6889018"</literal>
               <literal type="string">"501d289e4900f7e4331b99dec4b5433ac7d329eeb6dd26545e96e55b874be909"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestSHA512</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="number">1000000</literal></expr></argument>, <argument><expr><literal type="char">'a'</literal></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><literal type="string">"e718483d0ce769644e2e42c7bc15b4638e1f98b13b2044285632a803afa973eb"</literal>
               <literal type="string">"de0ff244877ea60a4cb0432ce577c31beb009c5c2c49aa2e4eadb217ad8cc09b"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestSHA512</name><argument_list>(<argument><expr><name>test1</name></expr></argument>,
               <argument><expr><literal type="string">"40cac46c147e6131c5193dd5f34e9d8bb4951395f27b08c558c65ff4ba2de594"</literal>
               <literal type="string">"37de8c3ef5459d76a52cedc02dc499a3c9ed9dedbfb3281afd9653b8a112fafc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>hmac_sha256_testvectors</argument>)</argument_list></macro> <block>{<block_content>
    <comment type="line">// test cases 1, 2, 3, 4, 6 and 7 of RFC 4231</comment>
    <expr_stmt><expr><call><name>TestHMACSHA256</name><argument_list>(<argument><expr><literal type="string">"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"</literal></expr></argument>,
                   <argument><expr><literal type="string">"4869205468657265"</literal></expr></argument>,
                   <argument><expr><literal type="string">"b0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestHMACSHA256</name><argument_list>(<argument><expr><literal type="string">"4a656665"</literal></expr></argument>,
                   <argument><expr><literal type="string">"7768617420646f2079612077616e7420666f72206e6f7468696e673f"</literal></expr></argument>,
                   <argument><expr><literal type="string">"5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestHMACSHA256</name><argument_list>(<argument><expr><literal type="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</literal></expr></argument>,
                   <argument><expr><literal type="string">"dddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd"</literal>
                   <literal type="string">"dddddddddddddddddddddddddddddddddddd"</literal></expr></argument>,
                   <argument><expr><literal type="string">"773ea91e36800e46854db8ebd09181a72959098b3ef8c122d9635514ced565fe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestHMACSHA256</name><argument_list>(<argument><expr><literal type="string">"0102030405060708090a0b0c0d0e0f10111213141516171819"</literal></expr></argument>,
                   <argument><expr><literal type="string">"cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd"</literal>
                   <literal type="string">"cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd"</literal></expr></argument>,
                   <argument><expr><literal type="string">"82558a389a443c0ea4cc819899f2083a85f0faa3e578f8077a2e3ff46729665b"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestHMACSHA256</name><argument_list>(<argument><expr><literal type="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</literal>
                   <literal type="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</literal>
                   <literal type="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</literal>
                   <literal type="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</literal>
                   <literal type="string">"aaaaaa"</literal></expr></argument>,
                   <argument><expr><literal type="string">"54657374205573696e67204c6172676572205468616e20426c6f636b2d53697a"</literal>
                   <literal type="string">"65204b6579202d2048617368204b6579204669727374"</literal></expr></argument>,
                   <argument><expr><literal type="string">"60e431591ee0b67f0d8a26aacbf5b77f8e0bc6213728c5140546040f0ee37f54"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestHMACSHA256</name><argument_list>(<argument><expr><literal type="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</literal>
                   <literal type="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</literal>
                   <literal type="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</literal>
                   <literal type="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</literal>
                   <literal type="string">"aaaaaa"</literal></expr></argument>,
                   <argument><expr><literal type="string">"5468697320697320612074657374207573696e672061206c6172676572207468"</literal>
                   <literal type="string">"616e20626c6f636b2d73697a65206b657920616e642061206c61726765722074"</literal>
                   <literal type="string">"68616e20626c6f636b2d73697a6520646174612e20546865206b6579206e6565"</literal>
                   <literal type="string">"647320746f20626520686173686564206265666f7265206265696e6720757365"</literal>
                   <literal type="string">"642062792074686520484d414320616c676f726974686d2e"</literal></expr></argument>,
                   <argument><expr><literal type="string">"9b09ffa71b942fcb27635fbcd5b0e944bfdc63644f0713938a7f51535c3a35e2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Test case with key length 63 bytes.</comment>
    <expr_stmt><expr><call><name>TestHMACSHA256</name><argument_list>(<argument><expr><literal type="string">"4a6566654a6566654a6566654a6566654a6566654a6566654a6566654a656665"</literal>
                   <literal type="string">"4a6566654a6566654a6566654a6566654a6566654a6566654a6566654a6566"</literal></expr></argument>,
                   <argument><expr><literal type="string">"7768617420646f2079612077616e7420666f72206e6f7468696e673f"</literal></expr></argument>,
                   <argument><expr><literal type="string">"9de4b546756c83516720a4ad7fe7bdbeac4298c6fdd82b15f895a6d10b0769a6"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Test case with key length 64 bytes.</comment>
    <expr_stmt><expr><call><name>TestHMACSHA256</name><argument_list>(<argument><expr><literal type="string">"4a6566654a6566654a6566654a6566654a6566654a6566654a6566654a656665"</literal>
                   <literal type="string">"4a6566654a6566654a6566654a6566654a6566654a6566654a6566654a656665"</literal></expr></argument>,
                   <argument><expr><literal type="string">"7768617420646f2079612077616e7420666f72206e6f7468696e673f"</literal></expr></argument>,
                   <argument><expr><literal type="string">"528c609a4c9254c274585334946b7c2661bad8f1fc406b20f6892478d19163dd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Test case with key length 65 bytes.</comment>
    <expr_stmt><expr><call><name>TestHMACSHA256</name><argument_list>(<argument><expr><literal type="string">"4a6566654a6566654a6566654a6566654a6566654a6566654a6566654a656665"</literal>
                   <literal type="string">"4a6566654a6566654a6566654a6566654a6566654a6566654a6566654a656665"</literal>
                   <literal type="string">"4a"</literal></expr></argument>,
                   <argument><expr><literal type="string">"7768617420646f2079612077616e7420666f72206e6f7468696e673f"</literal></expr></argument>,
                   <argument><expr><literal type="string">"d06af337f359a2330deffb8e3cbe4b5b7aa8ca1f208528cdbd245d5dc63c4483"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>hmac_sha512_testvectors</argument>)</argument_list></macro> <block>{<block_content>
    <comment type="line">// test cases 1, 2, 3, 4, 6 and 7 of RFC 4231</comment>
    <expr_stmt><expr><call><name>TestHMACSHA512</name><argument_list>(<argument><expr><literal type="string">"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"</literal></expr></argument>,
                   <argument><expr><literal type="string">"4869205468657265"</literal></expr></argument>,
                   <argument><expr><literal type="string">"87aa7cdea5ef619d4ff0b4241a1d6cb02379f4e2ce4ec2787ad0b30545e17cde"</literal>
                   <literal type="string">"daa833b7d6b8a702038b274eaea3f4e4be9d914eeb61f1702e696c203a126854"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestHMACSHA512</name><argument_list>(<argument><expr><literal type="string">"4a656665"</literal></expr></argument>,
                   <argument><expr><literal type="string">"7768617420646f2079612077616e7420666f72206e6f7468696e673f"</literal></expr></argument>,
                   <argument><expr><literal type="string">"164b7a7bfcf819e2e395fbe73b56e0a387bd64222e831fd610270cd7ea250554"</literal>
                   <literal type="string">"9758bf75c05a994a6d034f65f8f0e6fdcaeab1a34d4a6b4b636e070a38bce737"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestHMACSHA512</name><argument_list>(<argument><expr><literal type="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</literal></expr></argument>,
                   <argument><expr><literal type="string">"dddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd"</literal>
                   <literal type="string">"dddddddddddddddddddddddddddddddddddd"</literal></expr></argument>,
                   <argument><expr><literal type="string">"fa73b0089d56a284efb0f0756c890be9b1b5dbdd8ee81a3655f83e33b2279d39"</literal>
                   <literal type="string">"bf3e848279a722c806b485a47e67c807b946a337bee8942674278859e13292fb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestHMACSHA512</name><argument_list>(<argument><expr><literal type="string">"0102030405060708090a0b0c0d0e0f10111213141516171819"</literal></expr></argument>,
                   <argument><expr><literal type="string">"cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd"</literal>
                   <literal type="string">"cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd"</literal></expr></argument>,
                   <argument><expr><literal type="string">"b0ba465637458c6990e5a8c5f61d4af7e576d97ff94b872de76f8050361ee3db"</literal>
                   <literal type="string">"a91ca5c11aa25eb4d679275cc5788063a5f19741120c4f2de2adebeb10a298dd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestHMACSHA512</name><argument_list>(<argument><expr><literal type="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</literal>
                   <literal type="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</literal>
                   <literal type="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</literal>
                   <literal type="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</literal>
                   <literal type="string">"aaaaaa"</literal></expr></argument>,
                   <argument><expr><literal type="string">"54657374205573696e67204c6172676572205468616e20426c6f636b2d53697a"</literal>
                   <literal type="string">"65204b6579202d2048617368204b6579204669727374"</literal></expr></argument>,
                   <argument><expr><literal type="string">"80b24263c7c1a3ebb71493c1dd7be8b49b46d1f41b4aeec1121b013783f8f352"</literal>
                   <literal type="string">"6b56d037e05f2598bd0fd2215d6a1e5295e64f73f63f0aec8b915a985d786598"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestHMACSHA512</name><argument_list>(<argument><expr><literal type="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</literal>
                   <literal type="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</literal>
                   <literal type="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</literal>
                   <literal type="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</literal>
                   <literal type="string">"aaaaaa"</literal></expr></argument>,
                   <argument><expr><literal type="string">"5468697320697320612074657374207573696e672061206c6172676572207468"</literal>
                   <literal type="string">"616e20626c6f636b2d73697a65206b657920616e642061206c61726765722074"</literal>
                   <literal type="string">"68616e20626c6f636b2d73697a6520646174612e20546865206b6579206e6565"</literal>
                   <literal type="string">"647320746f20626520686173686564206265666f7265206265696e6720757365"</literal>
                   <literal type="string">"642062792074686520484d414320616c676f726974686d2e"</literal></expr></argument>,
                   <argument><expr><literal type="string">"e37b6a775dc87dbaa4dfa9f96e5e3ffddebd71f8867289865df5a32d20cdc944"</literal>
                   <literal type="string">"b6022cac3c4982b10d5eeb55c3e4de15134676fb6de0446065c97440fa8c6a58"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Test case with key length 127 bytes.</comment>
    <expr_stmt><expr><call><name>TestHMACSHA512</name><argument_list>(<argument><expr><literal type="string">"4a6566654a6566654a6566654a6566654a6566654a6566654a6566654a656665"</literal>
                   <literal type="string">"4a6566654a6566654a6566654a6566654a6566654a6566654a6566654a656665"</literal>
                   <literal type="string">"4a6566654a6566654a6566654a6566654a6566654a6566654a6566654a656665"</literal>
                   <literal type="string">"4a6566654a6566654a6566654a6566654a6566654a6566654a6566654a6566"</literal></expr></argument>,
                   <argument><expr><literal type="string">"7768617420646f2079612077616e7420666f72206e6f7468696e673f"</literal></expr></argument>,
                   <argument><expr><literal type="string">"267424dfb8eeb999f3e5ec39a4fe9fd14c923e6187e0897063e5c9e02b2e624a"</literal>
                   <literal type="string">"c04413e762977df71a9fb5d562b37f89dfdfb930fce2ed1fa783bbc2a203d80e"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Test case with key length 128 bytes.</comment>
    <expr_stmt><expr><call><name>TestHMACSHA512</name><argument_list>(<argument><expr><literal type="string">"4a6566654a6566654a6566654a6566654a6566654a6566654a6566654a656665"</literal>
                   <literal type="string">"4a6566654a6566654a6566654a6566654a6566654a6566654a6566654a656665"</literal>
                   <literal type="string">"4a6566654a6566654a6566654a6566654a6566654a6566654a6566654a656665"</literal>
                   <literal type="string">"4a6566654a6566654a6566654a6566654a6566654a6566654a6566654a656665"</literal></expr></argument>,
                   <argument><expr><literal type="string">"7768617420646f2079612077616e7420666f72206e6f7468696e673f"</literal></expr></argument>,
                   <argument><expr><literal type="string">"43aaac07bb1dd97c82c04df921f83b16a68d76815cd1a30d3455ad43a3d80484"</literal>
                   <literal type="string">"2bb35462be42cc2e4b5902de4d204c1c66d93b47d1383e3e13a3788687d61258"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Test case with key length 129 bytes.</comment>
    <expr_stmt><expr><call><name>TestHMACSHA512</name><argument_list>(<argument><expr><literal type="string">"4a6566654a6566654a6566654a6566654a6566654a6566654a6566654a656665"</literal>
                   <literal type="string">"4a6566654a6566654a6566654a6566654a6566654a6566654a6566654a656665"</literal>
                   <literal type="string">"4a6566654a6566654a6566654a6566654a6566654a6566654a6566654a656665"</literal>
                   <literal type="string">"4a6566654a6566654a6566654a6566654a6566654a6566654a6566654a656665"</literal>
                   <literal type="string">"4a"</literal></expr></argument>,
                   <argument><expr><literal type="string">"7768617420646f2079612077616e7420666f72206e6f7468696e673f"</literal></expr></argument>,
                   <argument><expr><literal type="string">"0b273325191cfc1b4b71d5075c8fcad67696309d292b1dad2cd23983a35feb8e"</literal>
                   <literal type="string">"fb29795e79f2ef27f68cb1e16d76178c307a67beaad9456fac5fdffeadb16e2c"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>aes_testvectors</argument>)</argument_list></macro> <block>{<block_content>
    <comment type="line">// AES test vectors from FIPS 197.</comment>
    <expr_stmt><expr><call><name>TestAES256</name><argument_list>(<argument><expr><literal type="string">"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f"</literal></expr></argument>, <argument><expr><literal type="string">"00112233445566778899aabbccddeeff"</literal></expr></argument>, <argument><expr><literal type="string">"8ea2b7ca516745bfeafc49904b496089"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// AES-ECB test vectors from NIST sp800-38a.</comment>
    <expr_stmt><expr><call><name>TestAES256</name><argument_list>(<argument><expr><literal type="string">"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"</literal></expr></argument>, <argument><expr><literal type="string">"6bc1bee22e409f96e93d7e117393172a"</literal></expr></argument>, <argument><expr><literal type="string">"f3eed1bdb5d2a03c064b5a7e3db181f8"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestAES256</name><argument_list>(<argument><expr><literal type="string">"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"</literal></expr></argument>, <argument><expr><literal type="string">"ae2d8a571e03ac9c9eb76fac45af8e51"</literal></expr></argument>, <argument><expr><literal type="string">"591ccb10d410ed26dc5ba74a31362870"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestAES256</name><argument_list>(<argument><expr><literal type="string">"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"</literal></expr></argument>, <argument><expr><literal type="string">"30c81c46a35ce411e5fbc1191a0a52ef"</literal></expr></argument>, <argument><expr><literal type="string">"b6ed21b99ca6f4f9f153e7b1beafed1d"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestAES256</name><argument_list>(<argument><expr><literal type="string">"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"</literal></expr></argument>, <argument><expr><literal type="string">"f69f2445df4f9b17ad2b417be66c3710"</literal></expr></argument>, <argument><expr><literal type="string">"23304b7a39f9f3ff067d8d8f9e24ecc7"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>aes_cbc_testvectors</argument>)</argument_list></macro> <block>{<block_content>
    <comment type="line">// NIST AES CBC 256-bit encryption test-vectors</comment>
    <expr_stmt><expr><call><name>TestAES256CBC</name><argument_list>(<argument><expr><literal type="string">"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"</literal></expr></argument>, \
                  <argument><expr><literal type="string">"000102030405060708090A0B0C0D0E0F"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"6bc1bee22e409f96e93d7e117393172a"</literal></expr></argument>, \
                  <argument><expr><literal type="string">"f58c4c04d6e5f1ba779eabfb5f7bfbd6"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestAES256CBC</name><argument_list>(<argument><expr><literal type="string">"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"</literal></expr></argument>, \
                  <argument><expr><literal type="string">"F58C4C04D6E5F1BA779EABFB5F7BFBD6"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"ae2d8a571e03ac9c9eb76fac45af8e51"</literal></expr></argument>, \
                  <argument><expr><literal type="string">"9cfc4e967edb808d679f777bc6702c7d"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestAES256CBC</name><argument_list>(<argument><expr><literal type="string">"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"</literal></expr></argument>, \
                  <argument><expr><literal type="string">"9CFC4E967EDB808D679F777BC6702C7D"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"30c81c46a35ce411e5fbc1191a0a52ef"</literal></expr></argument>,
                  <argument><expr><literal type="string">"39f23369a9d9bacfa530e26304231461"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestAES256CBC</name><argument_list>(<argument><expr><literal type="string">"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"</literal></expr></argument>, \
                  <argument><expr><literal type="string">"39F23369A9D9BACFA530E26304231461"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"f69f2445df4f9b17ad2b417be66c3710"</literal></expr></argument>, \
                  <argument><expr><literal type="string">"b2eb05e2c39be9fcda6c19078c6a9d1b"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// The same vectors with padding enabled</comment>
    <expr_stmt><expr><call><name>TestAES256CBC</name><argument_list>(<argument><expr><literal type="string">"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"</literal></expr></argument>, \
                  <argument><expr><literal type="string">"000102030405060708090A0B0C0D0E0F"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"6bc1bee22e409f96e93d7e117393172a"</literal></expr></argument>, \
                  <argument><expr><literal type="string">"f58c4c04d6e5f1ba779eabfb5f7bfbd6485a5c81519cf378fa36d42b8547edc0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestAES256CBC</name><argument_list>(<argument><expr><literal type="string">"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"</literal></expr></argument>, \
                  <argument><expr><literal type="string">"F58C4C04D6E5F1BA779EABFB5F7BFBD6"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"ae2d8a571e03ac9c9eb76fac45af8e51"</literal></expr></argument>, \
                  <argument><expr><literal type="string">"9cfc4e967edb808d679f777bc6702c7d3a3aa5e0213db1a9901f9036cf5102d2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestAES256CBC</name><argument_list>(<argument><expr><literal type="string">"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"</literal></expr></argument>, \
                  <argument><expr><literal type="string">"9CFC4E967EDB808D679F777BC6702C7D"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"30c81c46a35ce411e5fbc1191a0a52ef"</literal></expr></argument>,
                  <argument><expr><literal type="string">"39f23369a9d9bacfa530e263042314612f8da707643c90a6f732b3de1d3f5cee"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestAES256CBC</name><argument_list>(<argument><expr><literal type="string">"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"</literal></expr></argument>, \
                  <argument><expr><literal type="string">"39F23369A9D9BACFA530E26304231461"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"f69f2445df4f9b17ad2b417be66c3710"</literal></expr></argument>, \
                  <argument><expr><literal type="string">"b2eb05e2c39be9fcda6c19078c6a9d1b3f461796d6b0d6b2e0c2a72b4d80e644"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>


<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>chacha20_testvector</argument>)</argument_list></macro>
<block>{<block_content>
    <comment type="line">// Test vector from RFC 7539</comment>

    <comment type="line">// test encryption</comment>
    <expr_stmt><expr><call><name>TestChaCha20</name><argument_list>(<argument><expr><literal type="string">"4c616469657320616e642047656e746c656d656e206f662074686520636c617373206f66202739393a204966204920636f756"</literal>
                 <literal type="string">"c64206f6666657220796f75206f6e6c79206f6e652074697020666f7220746865206675747572652c2073756e73637265656e"</literal>
                 <literal type="string">"20776f756c642062652069742e"</literal></expr></argument>,
                 <argument><expr><literal type="string">"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f"</literal></expr></argument>, <argument><expr><literal type="number">0x4a000000UL</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
                 <argument><expr><literal type="string">"6e2e359a2568f98041ba0728dd0d6981e97e7aec1d4360c20a27afccfd9fae0bf91b65c5524733ab8f593dabcd62b3571639d"</literal>
                 <literal type="string">"624e65152ab8f530c359f0861d807ca0dbf500d6a6156a38e088a22b65e52bc514d16ccf806818ce91ab77937365af90bbf74"</literal>
                 <literal type="string">"a35be6b40b8eedf2785e42874d"</literal></expr></argument>
                 )</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// test keystream output</comment>
    <expr_stmt><expr><call><name>TestChaCha20</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f"</literal></expr></argument>, <argument><expr><literal type="number">0x4a000000UL</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
                 <argument><expr><literal type="string">"224f51f3401bd9e12fde276fb8631ded8c131f823d2c06e27e4fcaec9ef3cf788a3b0aa372600a92b57974cded2b9334794cb"</literal>
                 <literal type="string">"a40c63e34cdea212c4cf07d41b769a6749f3f630f4122cafe28ec4dc47e26d4346d70b98c73f3e9c53ac40c5945398b6eda1a"</literal>
                 <literal type="string">"832c89c167eacd901d7e2bf363"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Test vectors from https://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-04#section-7</comment>
    <expr_stmt><expr><call><name>TestChaCha20</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">"0000000000000000000000000000000000000000000000000000000000000000"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                 <argument><expr><literal type="string">"76b8e0ada0f13d90405d6ae55386bd28bdd219b8a08ded1aa836efcc8b770dc7da41597c5157488d7724e03fb8d84a376a43b"</literal>
                 <literal type="string">"8f41518a11cc387b669b2ee6586"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestChaCha20</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">"0000000000000000000000000000000000000000000000000000000000000001"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                 <argument><expr><literal type="string">"4540f05a9f1fb296d7736e7b208e3c96eb4fe1834688d2604f450952ed432d41bbe2a0b6ea7566d2a5d1e7e20d42af2c53d79"</literal>
                 <literal type="string">"2b1c43fea817e9ad275ae546963"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestChaCha20</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">"0000000000000000000000000000000000000000000000000000000000000000"</literal></expr></argument>, <argument><expr><literal type="number">0x0100000000000000ULL</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                 <argument><expr><literal type="string">"de9cba7bf3d69ef5e786dc63973f653a0b49e015adbff7134fcb7df137821031e85a050278a7084527214f73efc7fa5b52770"</literal>
                 <literal type="string">"62eb7a0433e445f41e3"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestChaCha20</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">"0000000000000000000000000000000000000000000000000000000000000000"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                 <argument><expr><literal type="string">"ef3fdfd6c61578fbf5cf35bd3dd33b8009631634d21e42ac33960bd138e50d32111e4caf237ee53ca8ad6426194a88545ddc4"</literal>
                 <literal type="string">"97a0b466e7d6bbdb0041b2f586b"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestChaCha20</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f"</literal></expr></argument>, <argument><expr><literal type="number">0x0706050403020100ULL</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                 <argument><expr><literal type="string">"f798a189f195e66982105ffb640bb7757f579da31602fc93ec01ac56f85ac3c134a4547b733b46413042c9440049176905d3b"</literal>
                 <literal type="string">"e59ea1c53f15916155c2be8241a38008b9a26bc35941e2444177c8ade6689de95264986d95889fb60e84629c9bd9a5acb1cc1"</literal>
                 <literal type="string">"18be563eb9b3a4a472f82e09a7e778492b562ef7130e88dfe031c79db9d4f7c7a899151b9a475032b63fc385245fe054e3dd5"</literal>
                 <literal type="string">"a97a5f576fe064025d3ce042c566ab2c507b138db853e3d6959660996546cc9c4a6eafdc777c040d70eaf46f76dad3979e5c5"</literal>
                 <literal type="string">"360c3317166a1c894c94a371876a94df7628fe4eaaf2ccb27d5aaae0ad7ad0f9d4b6ad3b54098746d4524d38407a6deb3ab78"</literal>
                 <literal type="string">"fab78c9"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>poly1305_testvector</argument>)</argument_list></macro>
<block>{<block_content>
    <comment type="line">// RFC 7539, section 2.5.2.</comment>
    <expr_stmt><expr><call><name>TestPoly1305</name><argument_list>(<argument><expr><literal type="string">"43727970746f6772617068696320466f72756d2052657365617263682047726f7570"</literal></expr></argument>,
                 <argument><expr><literal type="string">"85d6be7857556d337f4452fe42d506a80103808afb0db2fd4abff6af4149f51b"</literal></expr></argument>,
                 <argument><expr><literal type="string">"a8061dc1305136c6c22b8baf0c0127a9"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// RFC 7539, section A.3.</comment>
    <expr_stmt><expr><call><name>TestPoly1305</name><argument_list>(<argument><expr><literal type="string">"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"</literal>
                 <literal type="string">"000000000000000000000000000"</literal></expr></argument>,
                 <argument><expr><literal type="string">"0000000000000000000000000000000000000000000000000000000000000000"</literal></expr></argument>,
                 <argument><expr><literal type="string">"00000000000000000000000000000000"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TestPoly1305</name><argument_list>(<argument><expr><literal type="string">"416e79207375626d697373696f6e20746f20746865204945544620696e74656e6465642062792074686520436f6e747269627"</literal>
                 <literal type="string">"5746f7220666f72207075626c69636174696f6e20617320616c6c206f722070617274206f6620616e204945544620496e7465"</literal>
                 <literal type="string">"726e65742d4472616674206f722052464320616e6420616e792073746174656d656e74206d6164652077697468696e2074686"</literal>
                 <literal type="string">"520636f6e74657874206f6620616e204945544620616374697669747920697320636f6e7369646572656420616e2022494554"</literal>
                 <literal type="string">"4620436f6e747269627574696f6e222e20537563682073746174656d656e747320696e636c756465206f72616c20737461746"</literal>
                 <literal type="string">"56d656e747320696e20494554462073657373696f6e732c2061732077656c6c206173207772697474656e20616e6420656c65"</literal>
                 <literal type="string">"6374726f6e696320636f6d6d756e69636174696f6e73206d61646520617420616e792074696d65206f7220706c6163652c207"</literal>
                 <literal type="string">"768696368206172652061646472657373656420746f"</literal></expr></argument>,
                 <argument><expr><literal type="string">"0000000000000000000000000000000036e5f6b5c5e06070f0efca96227a863e"</literal></expr></argument>,
                 <argument><expr><literal type="string">"36e5f6b5c5e06070f0efca96227a863e"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TestPoly1305</name><argument_list>(<argument><expr><literal type="string">"416e79207375626d697373696f6e20746f20746865204945544620696e74656e6465642062792074686520436f6e747269627"</literal>
                 <literal type="string">"5746f7220666f72207075626c69636174696f6e20617320616c6c206f722070617274206f6620616e204945544620496e7465"</literal>
                 <literal type="string">"726e65742d4472616674206f722052464320616e6420616e792073746174656d656e74206d6164652077697468696e2074686"</literal>
                 <literal type="string">"520636f6e74657874206f6620616e204945544620616374697669747920697320636f6e7369646572656420616e2022494554"</literal>
                 <literal type="string">"4620436f6e747269627574696f6e222e20537563682073746174656d656e747320696e636c756465206f72616c20737461746"</literal>
                 <literal type="string">"56d656e747320696e20494554462073657373696f6e732c2061732077656c6c206173207772697474656e20616e6420656c65"</literal>
                 <literal type="string">"6374726f6e696320636f6d6d756e69636174696f6e73206d61646520617420616e792074696d65206f7220706c6163652c207"</literal>
                 <literal type="string">"768696368206172652061646472657373656420746f"</literal></expr></argument>,
                 <argument><expr><literal type="string">"36e5f6b5c5e06070f0efca96227a863e00000000000000000000000000000000"</literal></expr></argument>,
                 <argument><expr><literal type="string">"f3477e7cd95417af89a6b8794c310cf0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TestPoly1305</name><argument_list>(<argument><expr><literal type="string">"2754776173206272696c6c69672c20616e642074686520736c6974687920746f7665730a446964206779726520616e6420676"</literal>
                 <literal type="string">"96d626c6520696e2074686520776162653a0a416c6c206d696d737920776572652074686520626f726f676f7665732c0a416e"</literal>
                 <literal type="string">"6420746865206d6f6d65207261746873206f757467726162652e"</literal></expr></argument>,
                 <argument><expr><literal type="string">"1c9240a5eb55d38af333888604f6b5f0473917c1402b80099dca5cbc207075c0"</literal></expr></argument>,
                 <argument><expr><literal type="string">"4541669a7eaaee61e708dc7cbcc5eb62"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TestPoly1305</name><argument_list>(<argument><expr><literal type="string">"ffffffffffffffffffffffffffffffff"</literal></expr></argument>,
                 <argument><expr><literal type="string">"0200000000000000000000000000000000000000000000000000000000000000"</literal></expr></argument>,
                 <argument><expr><literal type="string">"03000000000000000000000000000000"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TestPoly1305</name><argument_list>(<argument><expr><literal type="string">"02000000000000000000000000000000"</literal></expr></argument>,
                 <argument><expr><literal type="string">"02000000000000000000000000000000ffffffffffffffffffffffffffffffff"</literal></expr></argument>,
                 <argument><expr><literal type="string">"03000000000000000000000000000000"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TestPoly1305</name><argument_list>(<argument><expr><literal type="string">"fffffffffffffffffffffffffffffffff0ffffffffffffffffffffffffffffff11000000000000000000000000000000"</literal></expr></argument>,
                 <argument><expr><literal type="string">"0100000000000000000000000000000000000000000000000000000000000000"</literal></expr></argument>,
                 <argument><expr><literal type="string">"05000000000000000000000000000000"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TestPoly1305</name><argument_list>(<argument><expr><literal type="string">"fffffffffffffffffffffffffffffffffbfefefefefefefefefefefefefefefe01010101010101010101010101010101"</literal></expr></argument>,
                 <argument><expr><literal type="string">"0100000000000000000000000000000000000000000000000000000000000000"</literal></expr></argument>,
                 <argument><expr><literal type="string">"00000000000000000000000000000000"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TestPoly1305</name><argument_list>(<argument><expr><literal type="string">"fdffffffffffffffffffffffffffffff"</literal></expr></argument>,
                 <argument><expr><literal type="string">"0200000000000000000000000000000000000000000000000000000000000000"</literal></expr></argument>,
                 <argument><expr><literal type="string">"faffffffffffffffffffffffffffffff"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TestPoly1305</name><argument_list>(<argument><expr><literal type="string">"e33594d7505e43b900000000000000003394d7505e4379cd01000000000000000000000000000000000000000000000001000000000000000000000000000000"</literal></expr></argument>,
                 <argument><expr><literal type="string">"0100000000000000040000000000000000000000000000000000000000000000"</literal></expr></argument>,
                 <argument><expr><literal type="string">"14000000000000005500000000000000"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TestPoly1305</name><argument_list>(<argument><expr><literal type="string">"e33594d7505e43b900000000000000003394d7505e4379cd010000000000000000000000000000000000000000000000"</literal></expr></argument>,
                 <argument><expr><literal type="string">"0100000000000000040000000000000000000000000000000000000000000000"</literal></expr></argument>,
                 <argument><expr><literal type="string">"13000000000000000000000000000000"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>hkdf_hmac_sha256_l32_tests</argument>)</argument_list></macro>
<block>{<block_content>
    <comment type="line">// Use rfc5869 test vectors but truncated to 32 bytes (our implementation only support length 32)</comment>
    <expr_stmt><expr><call><name>TestHKDF_SHA256_32</name><argument_list>(
                <comment type="block">/* IKM */</comment> <argument><expr><literal type="string">"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"</literal></expr></argument>,
                <comment type="block">/* salt */</comment> <argument><expr><literal type="string">"000102030405060708090a0b0c"</literal></expr></argument>,
                <comment type="block">/* info */</comment> <argument><expr><literal type="string">"f0f1f2f3f4f5f6f7f8f9"</literal></expr></argument>,
                <comment type="block">/* expected OKM */</comment> <argument><expr><literal type="string">"3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c5bf"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestHKDF_SHA256_32</name><argument_list>(
                <argument><expr><literal type="string">"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f"</literal></expr></argument>,
                <argument><expr><literal type="string">"606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeaf"</literal></expr></argument>,
                <argument><expr><literal type="string">"b0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff"</literal></expr></argument>,
                <argument><expr><literal type="string">"b11e398dc80327a1c8e7f78c596a49344f012eda2d4efad8a050cc4c19afa97c"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestHKDF_SHA256_32</name><argument_list>(
                <argument><expr><literal type="string">"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"</literal></expr></argument>,
                <argument><expr><literal type="string">""</literal></expr></argument>,
                <argument><expr><literal type="string">""</literal></expr></argument>,
                <argument><expr><literal type="string">"8da4e775a563c18f715f802a063c5a31b8a11f5c5ee1879ec3454e5f3c738d2d"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<function><type><specifier>static</specifier> <name>void</name></type> <name>TestChaCha20Poly1305AEAD</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>must_succeed</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>expected_aad_length</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>hex_m</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>hex_k1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>hex_k2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>hex_aad_keystream</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>hex_encrypted_message</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>hex_encrypted_message_seq_999</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">// we need two sequence numbers, one for the payload cipher instance...</comment>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>seqnr_payload</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <comment type="line">// ... and one for the AAD (length) cipher instance</comment>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>seqnr_aad</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <comment type="line">// we need to keep track of the position in the AAD cipher instance</comment>
    <comment type="line">// keystream since we use the same 64byte output 21 times</comment>
    <comment type="line">// (21 times 3 bytes length &lt; 64)</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>aad_pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>aead_K_1</name> <init>= <expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>hex_k1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>aead_K_2</name> <init>= <expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>hex_k2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>plaintext_buf</name> <init>= <expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>hex_m</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>expected_aad_keystream</name> <init>= <expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>hex_aad_keystream</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>expected_ciphertext_and_mac</name> <init>= <expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>hex_encrypted_message</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>expected_ciphertext_and_mac_sequence999</name> <init>= <expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>hex_encrypted_message_seq_999</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>ciphertext_buf</name><argument_list>(<argument><expr><call><name><name>plaintext_buf</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>POLY1305_TAGLEN</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>plaintext_buf_new</name><argument_list>(<argument><expr><call><name><name>plaintext_buf</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>cmp_ctx_buffer</name><argument_list>(<argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>out_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="line">// create the AEAD instance</comment>
    <decl_stmt><decl><type><name>ChaCha20Poly1305AEAD</name></type> <name>aead</name><argument_list>(<argument><expr><call><name><name>aead_K_1</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>aead_K_1</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>aead_K_2</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>aead_K_2</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

    <comment type="line">// create a chacha20 instance to compare against</comment>
    <decl_stmt><decl><type><name>ChaCha20</name></type> <name>cmp_ctx</name><argument_list>(<argument><expr><call><name><name>aead_K_2</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></decl>;</decl_stmt>

    <comment type="line">// encipher</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><call><name><name>aead</name><operator>.</operator><name>Crypt</name></name><argument_list>(<argument><expr><name>seqnr_payload</name></expr></argument>, <argument><expr><name>seqnr_aad</name></expr></argument>, <argument><expr><name>aad_pos</name></expr></argument>, <argument><expr><call><name><name>ciphertext_buf</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>ciphertext_buf</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>plaintext_buf</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>plaintext_buf</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// make sure the operation succeeded if expected to succeed</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>must_succeed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="line">// verify ciphertext &amp; mac against the test vector</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>expected_ciphertext_and_mac</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>ciphertext_buf</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><call><name><name>ciphertext_buf</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>expected_ciphertext_and_mac</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>ciphertext_buf</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// manually construct the AAD keystream</comment>
    <expr_stmt><expr><call><name><name>cmp_ctx</name><operator>.</operator><name>SetIV</name></name><argument_list>(<argument><expr><name>seqnr_aad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>cmp_ctx</name><operator>.</operator><name>Seek</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>cmp_ctx</name><operator>.</operator><name>Keystream</name></name><argument_list>(<argument><expr><call><name><name>cmp_ctx_buffer</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><call><name><name>expected_aad_keystream</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>cmp_ctx_buffer</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>expected_aad_keystream</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// crypt the 3 length bytes and compare the length</comment>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>len_cmp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>len_cmp</name> <operator>=</operator> <operator>(</operator><name><name>ciphertext_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>^</operator> <name><name>cmp_ctx_buffer</name><index>[<expr><name>aad_pos</name> <operator>+</operator> <literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>|</operator>
              <operator>(</operator><name><name>ciphertext_buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>^</operator> <name><name>cmp_ctx_buffer</name><index>[<expr><name>aad_pos</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal> <operator>|</operator>
              <operator>(</operator><name><name>ciphertext_buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>^</operator> <name><name>cmp_ctx_buffer</name><index>[<expr><name>aad_pos</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>len_cmp</name></expr></argument>, <argument><expr><name>expected_aad_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// encrypt / decrypt 1000 packets</comment>
    <for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">1000</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name><name>aead</name><operator>.</operator><name>Crypt</name></name><argument_list>(<argument><expr><name>seqnr_payload</name></expr></argument>, <argument><expr><name>seqnr_aad</name></expr></argument>, <argument><expr><name>aad_pos</name></expr></argument>, <argument><expr><call><name><name>ciphertext_buf</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>ciphertext_buf</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>plaintext_buf</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>plaintext_buf</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>aead</name><operator>.</operator><name>GetLength</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>out_len</name></expr></argument>, <argument><expr><name>seqnr_aad</name></expr></argument>, <argument><expr><name>aad_pos</name></expr></argument>, <argument><expr><call><name><name>ciphertext_buf</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>out_len</name></expr></argument>, <argument><expr><name>expected_aad_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name><name>aead</name><operator>.</operator><name>Crypt</name></name><argument_list>(<argument><expr><name>seqnr_payload</name></expr></argument>, <argument><expr><name>seqnr_aad</name></expr></argument>, <argument><expr><name>aad_pos</name></expr></argument>, <argument><expr><call><name><name>plaintext_buf_new</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>plaintext_buf_new</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>ciphertext_buf</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>ciphertext_buf</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// make sure we repetitive get the same plaintext</comment>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><call><name><name>plaintext_buf</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>plaintext_buf_new</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>plaintext_buf</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// compare sequence number 999 against the test vector</comment>
        <if_stmt><if>if <condition>(<expr><name>seqnr_payload</name> <operator>==</operator> <literal type="number">999</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><call><name><name>ciphertext_buf</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>expected_ciphertext_and_mac_sequence999</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>expected_ciphertext_and_mac_sequence999</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="line">// set nonce and block counter, output the keystream</comment>
        <expr_stmt><expr><call><name><name>cmp_ctx</name><operator>.</operator><name>SetIV</name></name><argument_list>(<argument><expr><name>seqnr_aad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>cmp_ctx</name><operator>.</operator><name>Seek</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>cmp_ctx</name><operator>.</operator><name>Keystream</name></name><argument_list>(<argument><expr><call><name><name>cmp_ctx_buffer</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// crypt the 3 length bytes and compare the length</comment>
        <expr_stmt><expr><name>len_cmp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>len_cmp</name> <operator>=</operator> <operator>(</operator><name><name>ciphertext_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>^</operator> <name><name>cmp_ctx_buffer</name><index>[<expr><name>aad_pos</name> <operator>+</operator> <literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>|</operator>
                  <operator>(</operator><name><name>ciphertext_buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>^</operator> <name><name>cmp_ctx_buffer</name><index>[<expr><name>aad_pos</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal> <operator>|</operator>
                  <operator>(</operator><name><name>ciphertext_buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>^</operator> <name><name>cmp_ctx_buffer</name><index>[<expr><name>aad_pos</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>len_cmp</name></expr></argument>, <argument><expr><name>expected_aad_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// increment the sequence number(s)</comment>
        <comment type="line">// always increment the payload sequence number</comment>
        <comment type="line">// increment the AAD keystream position by its size (3)</comment>
        <comment type="line">// increment the AAD sequence number if we would hit the 64 byte limit</comment>
        <expr_stmt><expr><name>seqnr_payload</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>aad_pos</name> <operator>+=</operator> <name>CHACHA20_POLY1305_AEAD_AAD_LEN</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>aad_pos</name> <operator>+</operator> <name>CHACHA20_POLY1305_AEAD_AAD_LEN</name> <operator>&gt;</operator> <name>CHACHA20_ROUND_OUTPUT</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>aad_pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>seqnr_aad</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>chacha20_poly1305_aead_testvector</argument>)</argument_list></macro>
<block>{<block_content>
    <comment type="block">/* test chacha20poly1305@bitcoin AEAD */</comment>

    <comment type="line">// must fail with no message</comment>
    <expr_stmt><expr><call><name>TestChaCha20Poly1305AEAD</name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
        <argument><expr><literal type="string">""</literal></expr></argument>,
        <argument><expr><literal type="string">"0000000000000000000000000000000000000000000000000000000000000000"</literal></expr></argument>,
        <argument><expr><literal type="string">"0000000000000000000000000000000000000000000000000000000000000000"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TestChaCha20Poly1305AEAD</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
        <comment type="block">/* m  */</comment> <argument><expr><literal type="string">"0000000000000000000000000000000000000000000000000000000000000000"</literal></expr></argument>,
        <comment type="block">/* k1 (payload) */</comment> <argument><expr><literal type="string">"0000000000000000000000000000000000000000000000000000000000000000"</literal></expr></argument>,
        <comment type="block">/* k2 (AAD) */</comment> <argument><expr><literal type="string">"0000000000000000000000000000000000000000000000000000000000000000"</literal></expr></argument>,
        <comment type="block">/* AAD keystream */</comment> <argument><expr><literal type="string">"76b8e0ada0f13d90405d6ae55386bd28bdd219b8a08ded1aa836efcc8b770dc7da41597c5157488d7724e03fb8d84a376a43b8f41518a11cc387b669b2ee6586"</literal></expr></argument>,
        <comment type="block">/* encrypted message &amp; MAC */</comment> <argument><expr><literal type="string">"76b8e09f07e7be5551387a98ba977c732d080dcb0f29a048e3656912c6533e32d2fc11829c1b6c1df1f551cd6131ff08"</literal></expr></argument>,
        <comment type="block">/* encrypted message &amp; MAC at sequence 999 */</comment> <argument><expr><literal type="string">"b0a03d5bd2855d60699e7d3a3133fa47be740fe4e4c1f967555e2d9271f31c3aaa7aa16ec62c5e24f040c08bb20c3598"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestChaCha20Poly1305AEAD</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
        <argument><expr><literal type="string">"0100000000000000000000000000000000000000000000000000000000000000"</literal></expr></argument>,
        <argument><expr><literal type="string">"0000000000000000000000000000000000000000000000000000000000000000"</literal></expr></argument>,
        <argument><expr><literal type="string">"0000000000000000000000000000000000000000000000000000000000000000"</literal></expr></argument>,
        <argument><expr><literal type="string">"76b8e0ada0f13d90405d6ae55386bd28bdd219b8a08ded1aa836efcc8b770dc7da41597c5157488d7724e03fb8d84a376a43b8f41518a11cc387b669b2ee6586"</literal></expr></argument>,
        <argument><expr><literal type="string">"77b8e09f07e7be5551387a98ba977c732d080dcb0f29a048e3656912c6533e32baf0c85b6dff8602b06cf52a6aefc62e"</literal></expr></argument>,
        <argument><expr><literal type="string">"b1a03d5bd2855d60699e7d3a3133fa47be740fe4e4c1f967555e2d9271f31c3a8bd94d54b5ecabbc41ffbb0c90924080"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestChaCha20Poly1305AEAD</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>,
        <argument><expr><literal type="string">"ff0000f195e66982105ffb640bb7757f579da31602fc93ec01ac56f85ac3c134a4547b733b46413042c9440049176905d3be59ea1c53f15916155c2be8241a38008b9a26bc35941e2444177c8ade6689de95264986d95889fb60e84629c9bd9a5acb1cc118be563eb9b3a4a472f82e09a7e778492b562ef7130e88dfe031c79db9d4f7c7a899151b9a475032b63fc385245fe054e3dd5a97a5f576fe064025d3ce042c566ab2c507b138db853e3d6959660996546cc9c4a6eafdc777c040d70eaf46f76dad3979e5c5360c3317166a1c894c94a371876a94df7628fe4eaaf2ccb27d5aaae0ad7ad0f9d4b6ad3b54098746d4524d38407a6deb3ab78fab78c9"</literal></expr></argument>,
        <argument><expr><literal type="string">"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f"</literal></expr></argument>,
        <argument><expr><literal type="string">"ff0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f"</literal></expr></argument>,
        <argument><expr><literal type="string">"c640c1711e3ee904ac35c57ab9791c8a1c408603a90b77a83b54f6c844cb4b06d94e7fc6c800e165acd66147e80ec45a567f6ce66d05ec0cae679dceeb890017"</literal></expr></argument>,
        <argument><expr><literal type="string">"3940c1e92da4582ff6f92a776aeb14d014d384eeb30f660dacf70a14a23fd31e91212701334e2ce1acf5199dc84f4d61ddbe6571bca5af874b4c9226c26e650995d157644e1848b96ed6c2102d5489a050e71d29a5a66ece11de5fb5c9558d54da28fe45b0bc4db4e5b88030bfc4a352b4b7068eccf656bae7ad6a35615315fc7c49d4200388d5eca67c2e822e069336c69b40db67e0f3c81209c50f3216a4b89fb3ae1b984b7851a2ec6f68ab12b101ab120e1ea7313bb93b5a0f71185c7fea017ddb92769861c29dba4fbc432280d5dff21b36d1c4c790128b22699950bb18bf74c448cdfe547d8ed4f657d8005fdc0cd7a050c2d46050a44c4376355858981fbe8b184288276e7a93eabc899c4a"</literal></expr></argument>,
        <argument><expr><literal type="string">"f039c6689eaeef0456685200feaab9d54bbd9acde4410a3b6f4321296f4a8ca2604b49727d8892c57e005d799b2a38e85e809f20146e08eec75169691c8d4f54a0d51a1e1c7b381e0474eb02f994be9415ef3ffcbd2343f0601e1f3b172a1d494f838824e4df570f8e3b0c04e27966e36c82abd352d07054ef7bd36b84c63f9369afe7ed79b94f953873006b920c3fa251a771de1b63da927058ade119aa898b8c97e42a606b2f6df1e2d957c22f7593c1e2002f4252f4c9ae4bf773499e5cfcfe14dfc1ede26508953f88553bf4a76a802f6a0068d59295b01503fd9a600067624203e880fdf53933b96e1f4d9eb3f4e363dd8165a278ff667a41ee42b9892b077cefff92b93441f7be74cf10e6cd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>countbits_tests</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name>FastRandomContext</name></type> <name>ctx</name></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <literal type="number">64</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <comment type="line">// Check handling of zero.</comment>
            <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>CountBits</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0U</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition> <block>{<block_content>
            <for>for <control>(<init><decl><type><name>uint64_t</name></type> <name>j</name> <init>= <expr><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>i</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</init> <condition><expr><operator>(</operator><name>j</name> <operator>&gt;&gt;</operator> <name>i</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
                <comment type="line">// Exhaustively test up to 10 bits</comment>
                <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>CountBits</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <literal type="number">1000</literal></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <comment type="line">// Randomly test 1000 samples of each length above 10 bits.</comment>
                <decl_stmt><decl><type><name>uint64_t</name></type> <name>j</name> <init>= <expr><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><name>i</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <call><name><name>ctx</name><operator>.</operator><name>randbits</name></name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>CountBits</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>sha256d64</argument>)</argument_list></macro>
<block>{<block_content>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>in</name><index>[<expr><literal type="number">64</literal> <operator>*</operator> <literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>out1</name><index>[<expr><literal type="number">32</literal> <operator>*</operator> <literal type="number">32</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>out2</name><index>[<expr><literal type="number">32</literal> <operator>*</operator> <literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">64</literal> <operator>*</operator> <name>i</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><name><name>in</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>InsecureRandBits</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>CHash256</name><argument_list>()</argument_list></call><operator>.</operator><call><name>Write</name><argument_list>(<argument><expr><name>in</name> <operator>+</operator> <literal type="number">64</literal> <operator>*</operator> <name>j</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>Finalize</name><argument_list>(<argument><expr><name>out1</name> <operator>+</operator> <literal type="number">32</literal> <operator>*</operator> <name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>SHA256D64</name><argument_list>(<argument><expr><name>out2</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name>out1</name></expr></argument>, <argument><expr><name>out2</name></expr></argument>, <argument><expr><literal type="number">32</literal> <operator>*</operator> <name>i</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_SUITE_END</name><argument_list>()</argument_list></macro>
</unit>
