<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C++" filename="/home/mmm/Projects/bitcoin/src/interfaces/chain.cpp"><comment type="line">// Copyright (c) 2018-2019 The Bitcoin Core developers</comment>
<comment type="line">// Distributed under the MIT software license, see the accompanying</comment>
<comment type="line">// file COPYING or http://www.opensource.org/licenses/mit-license.php.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;interfaces/chain.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;chain.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;chainparams.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;interfaces/handler.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;interfaces/wallet.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;net.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;net_processing.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;node/coin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;node/context.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;node/transaction.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;policy/fees.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;policy/policy.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;policy/rbf.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;policy/settings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;primitives/block.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;primitives/transaction.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;rpc/protocol.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;rpc/server.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;shutdown.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sync.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;timedata.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;txmempool.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ui_interface.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;uint256.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;univalue.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/system.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;validation.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;validationinterface.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;memory&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>

<namespace>namespace <name>interfaces</name> <block>{
<namespace>namespace <block>{

<class>class <name>LockImpl</name> <super_list>: <super><specifier>public</specifier> <name><name>Chain</name><operator>::</operator><name>Lock</name></name></super>, <super><specifier>public</specifier> <name><name>UniqueLock</name><argument_list type="generic">&lt;<argument><expr><name>CCriticalSection</name></expr></argument>&gt;</argument_list></name></super></super_list>
<block>{<private type="default">
    <function><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type> <name>getHeight</name><parameter_list>()</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <decl_stmt><decl><type><name>LockAssertion</name></type> <name>lock</name><argument_list>(<argument><expr><name><operator>::</operator><name>cs_main</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>height</name> <init>= <expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Height</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>height</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>height</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>nullopt</name></expr>;</return>
    </block_content>}</block></function>
    <function><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type> <name>getBlockHeight</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint256</name><modifier>&amp;</modifier></type> <name>hash</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <decl_stmt><decl><type><name>LockAssertion</name></type> <name>lock</name><argument_list>(<argument><expr><name><operator>::</operator><name>cs_main</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CBlockIndex</name><modifier>*</modifier></type> <name>block</name> <init>= <expr><call><name>LookupBlockIndex</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>block</name> <operator>&amp;&amp;</operator> <call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Contains</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><name><name>block</name><operator>-&gt;</operator><name>nHeight</name></name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>nullopt</name></expr>;</return>
    </block_content>}</block></function>
    <function><type><name>uint256</name></type> <name>getBlockHash</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <decl_stmt><decl><type><name>LockAssertion</name></type> <name>lock</name><argument_list>(<argument><expr><name><operator>::</operator><name>cs_main</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CBlockIndex</name><modifier>*</modifier></type> <name>block</name> <init>= <expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><index>[<expr><name>height</name></expr>]</index></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>block</name> <operator>!=</operator> <literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>block</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>
    <function><type><name>int64_t</name></type> <name>getBlockTime</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <decl_stmt><decl><type><name>LockAssertion</name></type> <name>lock</name><argument_list>(<argument><expr><name><operator>::</operator><name>cs_main</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CBlockIndex</name><modifier>*</modifier></type> <name>block</name> <init>= <expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><index>[<expr><name>height</name></expr>]</index></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>block</name> <operator>!=</operator> <literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>block</name><operator>-&gt;</operator><name>GetBlockTime</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>
    <function><type><name>int64_t</name></type> <name>getBlockMedianTimePast</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <decl_stmt><decl><type><name>LockAssertion</name></type> <name>lock</name><argument_list>(<argument><expr><name><operator>::</operator><name>cs_main</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CBlockIndex</name><modifier>*</modifier></type> <name>block</name> <init>= <expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><index>[<expr><name>height</name></expr>]</index></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>block</name> <operator>!=</operator> <literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>block</name><operator>-&gt;</operator><name>GetMedianTimePast</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>
    <function><type><name>bool</name></type> <name>haveBlockOnDisk</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <decl_stmt><decl><type><name>LockAssertion</name></type> <name>lock</name><argument_list>(<argument><expr><name><operator>::</operator><name>cs_main</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CBlockIndex</name><modifier>*</modifier></type> <name>block</name> <init>= <expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><index>[<expr><name>height</name></expr>]</index></expr></init></decl>;</decl_stmt>
        <return>return <expr><name>block</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>block</name><operator>-&gt;</operator><name>nStatus</name></name> <operator>&amp;</operator> <name>BLOCK_HAVE_DATA</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>block</name><operator>-&gt;</operator><name>nTx</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
    </block_content>}</block></function>
    <function><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type> <name>findFirstBlockWithTimeAndHeight</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>time</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>, <parameter><decl><type><name>uint256</name><modifier>*</modifier></type> <name>hash</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <decl_stmt><decl><type><name>LockAssertion</name></type> <name>lock</name><argument_list>(<argument><expr><name><operator>::</operator><name>cs_main</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CBlockIndex</name><modifier>*</modifier></type> <name>block</name> <init>= <expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>FindEarliestAtLeast</name><argument_list>(<argument><expr><name>time</name></expr></argument>, <argument><expr><name>height</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>block</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>hash</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>hash</name> <operator>=</operator> <call><name><name>block</name><operator>-&gt;</operator><name>GetBlockHash</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name><name>block</name><operator>-&gt;</operator><name>nHeight</name></name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>nullopt</name></expr>;</return>
    </block_content>}</block></function>
    <function><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type> <name>findPruned</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>start_height</name></decl></parameter>, <parameter><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type> <name>stop_height</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <decl_stmt><decl><type><name>LockAssertion</name></type> <name>lock</name><argument_list>(<argument><expr><name><operator>::</operator><name>cs_main</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><operator>::</operator><name>fPruneMode</name></name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>CBlockIndex</name><modifier>*</modifier></type> <name>block</name> <init>= <expr><ternary><condition><expr><name>stop_height</name></expr> ?</condition><then> <expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><index>[<expr><operator>*</operator><name>stop_height</name></expr>]</index></expr> </then><else>: <expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Tip</name><argument_list>()</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><name>block</name> <operator>&amp;&amp;</operator> <name><name>block</name><operator>-&gt;</operator><name>nHeight</name></name> <operator>&gt;=</operator> <name>start_height</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>block</name><operator>-&gt;</operator><name>nStatus</name></name> <operator>&amp;</operator> <name>BLOCK_HAVE_DATA</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <return>return <expr><name><name>block</name><operator>-&gt;</operator><name>nHeight</name></name></expr>;</return>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>block</name> <operator>=</operator> <name><name>block</name><operator>-&gt;</operator><name>pprev</name></name></expr>;</expr_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>nullopt</name></expr>;</return>
    </block_content>}</block></function>
    <function><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type> <name>findFork</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint256</name><modifier>&amp;</modifier></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name><modifier>*</modifier></type> <name>height</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <decl_stmt><decl><type><name>LockAssertion</name></type> <name>lock</name><argument_list>(<argument><expr><name><operator>::</operator><name>cs_main</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>CBlockIndex</name><modifier>*</modifier></type> <name>block</name> <init>= <expr><call><name>LookupBlockIndex</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>CBlockIndex</name><modifier>*</modifier></type> <name>fork</name> <init>= <expr><ternary><condition><expr><name>block</name></expr> ?</condition><then> <expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>FindFork</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="null">nullptr</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>height</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>block</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>height</name> <operator>=</operator> <name><name>block</name><operator>-&gt;</operator><name>nHeight</name></name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name><name>height</name><operator>-&gt;</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>fork</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><name><name>fork</name><operator>-&gt;</operator><name>nHeight</name></name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>nullopt</name></expr>;</return>
    </block_content>}</block></function>
    <function><type><name>CBlockLocator</name></type> <name>getTipLocator</name><parameter_list>()</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <decl_stmt><decl><type><name>LockAssertion</name></type> <name>lock</name><argument_list>(<argument><expr><name><operator>::</operator><name>cs_main</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <return>return <expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetLocator</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>
    <function><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type> <name>findLocatorFork</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CBlockLocator</name><modifier>&amp;</modifier></type> <name>locator</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <decl_stmt><decl><type><name>LockAssertion</name></type> <name>lock</name><argument_list>(<argument><expr><name><operator>::</operator><name>cs_main</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<decl><type><name>CBlockIndex</name><modifier>*</modifier></type> <name>fork</name> <init>= <expr><call><name>FindForkInGlobalIndex</name><argument_list>(<argument><expr><call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
            <return>return <expr><name><name>fork</name><operator>-&gt;</operator><name>nHeight</name></name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>nullopt</name></expr>;</return>
    </block_content>}</block></function>
    <function><type><name>bool</name></type> <name>checkFinalTx</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CTransaction</name><modifier>&amp;</modifier></type> <name>tx</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <decl_stmt><decl><type><name>LockAssertion</name></type> <name>lock</name><argument_list>(<argument><expr><name><operator>::</operator><name>cs_main</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <return>return <expr><call><name>CheckFinalTx</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <using>using <name><name>UniqueLock</name><operator>::</operator><name>UniqueLock</name></name>;</using>
</private>}</block>;</class>

<class>class <name>NotificationsHandlerImpl</name> <super_list>: <super><specifier>public</specifier> <name>Handler</name></super>, <super><name>CValidationInterface</name></super></super_list>
<block>{<private type="default">
</private><public>public:
    <constructor><specifier>explicit</specifier> <name>NotificationsHandlerImpl</name><parameter_list>(<parameter><decl><type><name>Chain</name><modifier>&amp;</modifier></type> <name>chain</name></decl></parameter>, <parameter><decl><type><name><name>Chain</name><operator>::</operator><name>Notifications</name></name><modifier>&amp;</modifier></type> <name>notifications</name></decl></parameter>)</parameter_list>
        <member_init_list>: <call><name>m_chain</name><argument_list>(<argument><expr><name>chain</name></expr></argument>)</argument_list></call>, <call><name>m_notifications</name><argument_list>(<argument><expr><operator>&amp;</operator><name>notifications</name></expr></argument>)</argument_list></call>
    </member_init_list><block>{<block_content>
        <expr_stmt><expr><call><name>RegisterValidationInterface</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></constructor>
    <destructor><name>~NotificationsHandlerImpl</name><parameter_list>()</parameter_list> <specifier>override</specifier> <block>{<block_content> <expr_stmt><expr><call><name>disconnect</name><argument_list>()</argument_list></call></expr>;</expr_stmt> </block_content>}</block></destructor>
    <function><type><name>void</name></type> <name>disconnect</name><parameter_list>()</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>m_notifications</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>m_notifications</name> <operator>=</operator> <literal type="null">nullptr</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>UnregisterValidationInterface</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>
    <function><type><name>void</name></type> <name>TransactionAddedToMempool</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CTransactionRef</name><modifier>&amp;</modifier></type> <name>tx</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>m_notifications</name><operator>-&gt;</operator><name>TransactionAddedToMempool</name></name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>
    <function><type><name>void</name></type> <name>TransactionRemovedFromMempool</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CTransactionRef</name><modifier>&amp;</modifier></type> <name>tx</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>m_notifications</name><operator>-&gt;</operator><name>TransactionRemovedFromMempool</name></name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>
    <function><type><name>void</name></type> <name>BlockConnected</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CBlock</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>block</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>CBlockIndex</name><modifier>*</modifier></type> <name>index</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CTransactionRef</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>tx_conflicted</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>m_notifications</name><operator>-&gt;</operator><name>BlockConnected</name></name><argument_list>(<argument><expr><operator>*</operator><name>block</name></expr></argument>, <argument><expr><name>tx_conflicted</name></expr></argument>, <argument><expr><name><name>index</name><operator>-&gt;</operator><name>nHeight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>
    <function><type><name>void</name></type> <name>BlockDisconnected</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CBlock</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>block</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CBlockIndex</name><modifier>*</modifier></type> <name>index</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>m_notifications</name><operator>-&gt;</operator><name>BlockDisconnected</name></name><argument_list>(<argument><expr><operator>*</operator><name>block</name></expr></argument>, <argument><expr><name><name>index</name><operator>-&gt;</operator><name>nHeight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>
    <function><type><name>void</name></type> <name>UpdatedBlockTip</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CBlockIndex</name><modifier>*</modifier></type> <name>index</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CBlockIndex</name><modifier>*</modifier></type> <name>fork_index</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_ibd</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>m_notifications</name><operator>-&gt;</operator><name>UpdatedBlockTip</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>
    <function><type><name>void</name></type> <name>ChainStateFlushed</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CBlockLocator</name><modifier>&amp;</modifier></type> <name>locator</name></decl></parameter>)</parameter_list> <specifier>override</specifier> <block>{<block_content> <expr_stmt><expr><call><name><name>m_notifications</name><operator>-&gt;</operator><name>ChainStateFlushed</name></name><argument_list>(<argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>
    <decl_stmt><decl><type><name>Chain</name><modifier>&amp;</modifier></type> <name>m_chain</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Chain</name><operator>::</operator><name>Notifications</name></name><modifier>*</modifier></type> <name>m_notifications</name></decl>;</decl_stmt>
</public>}</block>;</class>

<class>class <name>RpcHandlerImpl</name> <super_list>: <super><specifier>public</specifier> <name>Handler</name></super></super_list>
<block>{<private type="default">
</private><public>public:
    <constructor><specifier>explicit</specifier> <name>RpcHandlerImpl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CRPCCommand</name><modifier>&amp;</modifier></type> <name>command</name></decl></parameter>)</parameter_list> <member_init_list>: <call><name>m_command</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call>, <call><name>m_wrapped_command</name><argument_list>(<argument><expr><operator>&amp;</operator><name>command</name></expr></argument>)</argument_list></call>
    </member_init_list><block>{<block_content>
        <expr_stmt><expr><name><name>m_command</name><operator>.</operator><name>actor</name></name> <operator>=</operator> <lambda><capture>[<argument><name>this</name></argument>]</capture><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>JSONRPCRequest</name><modifier>&amp;</modifier></type> <name>request</name></decl></parameter>, <parameter><decl><type><name>UniValue</name><modifier>&amp;</modifier></type> <name>result</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>last_handler</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>m_wrapped_command</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
            <try>try <block>{<block_content>
                <return>return <expr><call><name><name>m_wrapped_command</name><operator>-&gt;</operator><name>actor</name></name><argument_list>(<argument><expr><name>request</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>last_handler</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UniValue</name><modifier>&amp;</modifier></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
                <comment type="line">// If this is not the last handler and a wallet not found</comment>
                <comment type="line">// exception was thrown, return false so the next handler can</comment>
                <comment type="line">// try to handle the request. Otherwise, reraise the exception.</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>last_handler</name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>UniValue</name><modifier>&amp;</modifier></type> <name>code</name> <init>= <expr><name><name>e</name><index>[<expr><literal type="string">"code"</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name><name>code</name><operator>.</operator><name>isNum</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>code</name><operator>.</operator><name>get_int</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>RPC_WALLET_NOT_FOUND</name></expr>)</condition> <block>{<block_content>
                        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <throw>throw;</throw>
            </block_content>}</block></catch></try>
        </block_content>}</block></lambda></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><operator>::</operator><name>tableRPC</name><operator>.</operator><name>appendCommand</name></name><argument_list>(<argument><expr><name><name>m_command</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>m_command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <function><type><name>void</name></type> <name>disconnect</name><parameter_list>()</parameter_list> <specifier>override</specifier> <specifier>final</specifier>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>m_wrapped_command</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>m_wrapped_command</name> <operator>=</operator> <literal type="null">nullptr</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><operator>::</operator><name>tableRPC</name><operator>.</operator><name>removeCommand</name></name><argument_list>(<argument><expr><name><name>m_command</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>m_command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <destructor><name>~RpcHandlerImpl</name><parameter_list>()</parameter_list> <specifier>override</specifier> <block>{<block_content> <expr_stmt><expr><call><name>disconnect</name><argument_list>()</argument_list></call></expr>;</expr_stmt> </block_content>}</block></destructor>

    <decl_stmt><decl><type><name>CRPCCommand</name></type> <name>m_command</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CRPCCommand</name><modifier>*</modifier></type> <name>m_wrapped_command</name></decl>;</decl_stmt>
</public>}</block>;</class>

<class>class <name>ChainImpl</name> <super_list>: <super><specifier>public</specifier> <name>Chain</name></super></super_list>
<block>{<private type="default">
</private><public>public:
    <constructor><specifier>explicit</specifier> <name>ChainImpl</name><parameter_list>(<parameter><decl><type><name>NodeContext</name><modifier>&amp;</modifier></type> <name>node</name></decl></parameter>)</parameter_list> <member_init_list>: <call><name>m_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> </member_init_list><block>{<block_content/>}</block></constructor>
    <function><type><name><name>std</name><operator>::</operator><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name><name>Chain</name><operator>::</operator><name>Lock</name></name></expr></argument>&gt;</argument_list></name></type> <name>lock</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>try_lock</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>result</name> <init>= <expr><call><name><name>MakeUnique</name><argument_list type="generic">&lt;<argument><expr><name>LockImpl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><operator>::</operator><name>cs_main</name></name></expr></argument>, <argument><expr><literal type="string">"cs_main"</literal></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>, <argument><expr><name>try_lock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>try_lock</name> <operator>&amp;&amp;</operator> <name>result</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>*</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><block>{}</block></expr>;</return></block_content></block></if></if_stmt>
        <comment type="line">// std::move necessary on some compilers due to conversion from</comment>
        <comment type="line">// LockImpl to Lock pointer</comment>
        <return>return <expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>
    <function><type><name>bool</name></type> <name>findBlock</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint256</name><modifier>&amp;</modifier></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>CBlock</name><modifier>*</modifier></type> <name>block</name></decl></parameter>, <parameter><decl><type><name>int64_t</name><modifier>*</modifier></type> <name>time</name></decl></parameter>, <parameter><decl><type><name>int64_t</name><modifier>*</modifier></type> <name>time_max</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CBlockIndex</name><modifier>*</modifier></type> <name>index</name></decl>;</decl_stmt>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>LookupBlockIndex</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>index</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>time</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>time</name> <operator>=</operator> <call><name><name>index</name><operator>-&gt;</operator><name>GetBlockTime</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>time_max</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>time_max</name> <operator>=</operator> <call><name><name>index</name><operator>-&gt;</operator><name>GetBlockTimeMax</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        <if_stmt><if>if <condition>(<expr><name>block</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ReadBlockFromDisk</name><argument_list>(<argument><expr><operator>*</operator><name>block</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><call><name>Params</name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetConsensus</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>block</name><operator>-&gt;</operator><name>SetNull</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></function>
    <function><type><name>void</name></type> <name>findCoins</name><parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>COutPoint</name></expr></argument>, <argument><expr><name>Coin</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>coins</name></decl></parameter>)</parameter_list> <specifier>override</specifier> <block>{<block_content> <return>return <expr><call><name>FindCoins</name><argument_list>(<argument><expr><name>coins</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
    <function><type><name>double</name></type> <name>guessVerificationProgress</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint256</name><modifier>&amp;</modifier></type> <name>block_hash</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>GuessVerificationProgress</name><argument_list>(<argument><expr><call><name>Params</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TxData</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>LookupBlockIndex</name><argument_list>(<argument><expr><name>block_hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>
    <function><type><name>RBFTransactionState</name></type> <name>isRBFOptIn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CTransaction</name><modifier>&amp;</modifier></type> <name>tx</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><operator>::</operator><name>mempool</name><operator>.</operator><name>cs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>IsRBFOptIn</name><argument_list>(<argument><expr><name>tx</name></expr></argument>, <argument><expr><name><operator>::</operator><name>mempool</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>
    <function><type><name>bool</name></type> <name>hasDescendantsInMempool</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint256</name><modifier>&amp;</modifier></type> <name>txid</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><operator>::</operator><name>mempool</name><operator>.</operator><name>cs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>it</name> <init>= <expr><call><name><operator>::</operator><name>mempool</name><operator>.</operator><name>GetIter</name></name><argument_list>(<argument><expr><name>txid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><name>it</name> <operator>&amp;&amp;</operator> <call><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>GetCountWithDescendants</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>;</return>
    </block_content>}</block></function>
    <function><type><name>bool</name></type> <name>broadcastTransaction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CTransactionRef</name><modifier>&amp;</modifier></type> <name>tx</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>err_string</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CAmount</name><modifier>&amp;</modifier></type> <name>max_tx_fee</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>relay</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>TransactionError</name></type> <name>err</name> <init>= <expr><call><name>BroadcastTransaction</name><argument_list>(<argument><expr><name>m_node</name></expr></argument>, <argument><expr><name>tx</name></expr></argument>, <argument><expr><name>err_string</name></expr></argument>, <argument><expr><name>max_tx_fee</name></expr></argument>, <argument><expr><name>relay</name></expr></argument>, <comment type="block">/*wait_callback*/</comment> <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// Chain clients only care about failures to accept the tx to the mempool. Disregard non-mempool related failures.</comment>
        <comment type="line">// Note: this will need to be updated if BroadcastTransactions() is updated to return other non-mempool failures</comment>
        <comment type="line">// that Chain clients do not need to know about.</comment>
        <return>return <expr><name><name>TransactionError</name><operator>::</operator><name>OK</name></name> <operator>==</operator> <name>err</name></expr>;</return>
    </block_content>}</block></function>
    <function><type><name>void</name></type> <name>getTransactionAncestry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint256</name><modifier>&amp;</modifier></type> <name>txid</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>&amp;</modifier></type> <name>ancestors</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>&amp;</modifier></type> <name>descendants</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <expr_stmt><expr><call><name><operator>::</operator><name>mempool</name><operator>.</operator><name>GetTransactionAncestry</name></name><argument_list>(<argument><expr><name>txid</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>descendants</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>
    <function><type><name>void</name></type> <name>getPackageLimits</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name><modifier>&amp;</modifier></type> <name>limit_ancestor_count</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name><modifier>&amp;</modifier></type> <name>limit_descendant_count</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <expr_stmt><expr><name>limit_ancestor_count</name> <operator>=</operator> <call><name><name>gArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-limitancestorcount"</literal></expr></argument>, <argument><expr><name>DEFAULT_ANCESTOR_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>limit_descendant_count</name> <operator>=</operator> <call><name><name>gArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-limitdescendantcount"</literal></expr></argument>, <argument><expr><name>DEFAULT_DESCENDANT_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>
    <function><type><name>bool</name></type> <name>checkChainLimits</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CTransactionRef</name><modifier>&amp;</modifier></type> <name>tx</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <decl_stmt><decl><type><name>LockPoints</name></type> <name>lp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CTxMemPoolEntry</name></type> <name>entry</name><argument_list>(<argument><expr><name>tx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>CTxMemPool</name><operator>::</operator><name>setEntries</name></name></type> <name>ancestors</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>limit_ancestor_count</name> <init>= <expr><call><name><name>gArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-limitancestorcount"</literal></expr></argument>, <argument><expr><name>DEFAULT_ANCESTOR_LIMIT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>limit_ancestor_size</name> <init>= <expr><call><name><name>gArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-limitancestorsize"</literal></expr></argument>, <argument><expr><name>DEFAULT_ANCESTOR_SIZE_LIMIT</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">1000</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>limit_descendant_count</name> <init>= <expr><call><name><name>gArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-limitdescendantcount"</literal></expr></argument>, <argument><expr><name>DEFAULT_DESCENDANT_LIMIT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>limit_descendant_size</name> <init>= <expr><call><name><name>gArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-limitdescendantsize"</literal></expr></argument>, <argument><expr><name>DEFAULT_DESCENDANT_SIZE_LIMIT</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">1000</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>unused_error_string</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><operator>::</operator><name>mempool</name><operator>.</operator><name>cs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><operator>::</operator><name>mempool</name><operator>.</operator><name>CalculateMemPoolAncestors</name></name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>limit_ancestor_count</name></expr></argument>, <argument><expr><name>limit_ancestor_size</name></expr></argument>,
            <argument><expr><name>limit_descendant_count</name></expr></argument>, <argument><expr><name>limit_descendant_size</name></expr></argument>, <argument><expr><name>unused_error_string</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>
    <function><type><name>CFeeRate</name></type> <name>estimateSmartFee</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num_blocks</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>conservative</name></decl></parameter>, <parameter><decl><type><name>FeeCalculation</name><modifier>*</modifier></type> <name>calc</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <return>return <expr><call><name><operator>::</operator><name>feeEstimator</name><operator>.</operator><name>estimateSmartFee</name></name><argument_list>(<argument><expr><name>num_blocks</name></expr></argument>, <argument><expr><name>calc</name></expr></argument>, <argument><expr><name>conservative</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>
    <function><type><name>unsigned</name> <name>int</name></type> <name>estimateMaxBlocks</name><parameter_list>()</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <return>return <expr><call><name><operator>::</operator><name>feeEstimator</name><operator>.</operator><name>HighestTargetTracked</name></name><argument_list>(<argument><expr><name><name>FeeEstimateHorizon</name><operator>::</operator><name>LONG_HALFLIFE</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>
    <function><type><name>CFeeRate</name></type> <name>mempoolMinFee</name><parameter_list>()</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <return>return <expr><call><name><operator>::</operator><name>mempool</name><operator>.</operator><name>GetMinFee</name></name><argument_list>(<argument><expr><call><name><name>gArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-maxmempool"</literal></expr></argument>, <argument><expr><name>DEFAULT_MAX_MEMPOOL_SIZE</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">1000000</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>
    <function><type><name>CFeeRate</name></type> <name>relayMinFee</name><parameter_list>()</parameter_list> <specifier>override</specifier> <block>{<block_content> <return>return <expr><name><operator>::</operator><name>minRelayTxFee</name></name></expr>;</return> </block_content>}</block></function>
    <function><type><name>CFeeRate</name></type> <name>relayIncrementalFee</name><parameter_list>()</parameter_list> <specifier>override</specifier> <block>{<block_content> <return>return <expr><name><operator>::</operator><name>incrementalRelayFee</name></name></expr>;</return> </block_content>}</block></function>
    <function><type><name>CFeeRate</name></type> <name>relayDustFee</name><parameter_list>()</parameter_list> <specifier>override</specifier> <block>{<block_content> <return>return <expr><name><operator>::</operator><name>dustRelayFee</name></name></expr>;</return> </block_content>}</block></function>
    <function><type><name>bool</name></type> <name>havePruned</name><parameter_list>()</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name><operator>::</operator><name>fHavePruned</name></name></expr>;</return>
    </block_content>}</block></function>
    <function><type><name>bool</name></type> <name>isReadyToBroadcast</name><parameter_list>()</parameter_list> <specifier>override</specifier> <block>{<block_content> <return>return <expr><operator>!</operator><name><operator>::</operator><name>fImporting</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><operator>::</operator><name>fReindex</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isInitialBlockDownload</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>
    <function><type><name>bool</name></type> <name>isInitialBlockDownload</name><parameter_list>()</parameter_list> <specifier>override</specifier> <block>{<block_content> <return>return <expr><call><name><operator>::</operator><name>ChainstateActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>IsInitialBlockDownload</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>
    <function><type><name>bool</name></type> <name>shutdownRequested</name><parameter_list>()</parameter_list> <specifier>override</specifier> <block>{<block_content> <return>return <expr><call><name>ShutdownRequested</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>
    <function><type><name>int64_t</name></type> <name>getAdjustedTime</name><parameter_list>()</parameter_list> <specifier>override</specifier> <block>{<block_content> <return>return <expr><call><name>GetAdjustedTime</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>
    <function><type><name>void</name></type> <name>initMessage</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>message</name></decl></parameter>)</parameter_list> <specifier>override</specifier> <block>{<block_content> <expr_stmt><expr><call><name><operator>::</operator><name>uiInterface</name><operator>.</operator><name>InitMessage</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>
    <function><type><name>void</name></type> <name>initWarning</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>message</name></decl></parameter>)</parameter_list> <specifier>override</specifier> <block>{<block_content> <expr_stmt><expr><call><name>InitWarning</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>
    <function><type><name>void</name></type> <name>initError</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>message</name></decl></parameter>)</parameter_list> <specifier>override</specifier> <block>{<block_content> <expr_stmt><expr><call><name>InitError</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>
    <function><type><name>void</name></type> <name>loadWallet</name><parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>Wallet</name></expr></argument>&gt;</argument_list></name></type> <name>wallet</name></decl></parameter>)</parameter_list> <specifier>override</specifier> <block>{<block_content> <expr_stmt><expr><call><name><operator>::</operator><name>uiInterface</name><operator>.</operator><name>LoadWallet</name></name><argument_list>(<argument><expr><name>wallet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>
    <function><type><name>void</name></type> <name>showProgress</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>title</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>progress</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>resume_possible</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <expr_stmt><expr><call><name><operator>::</operator><name>uiInterface</name><operator>.</operator><name>ShowProgress</name></name><argument_list>(<argument><expr><name>title</name></expr></argument>, <argument><expr><name>progress</name></expr></argument>, <argument><expr><name>resume_possible</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>
    <function><type><name><name>std</name><operator>::</operator><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>Handler</name></expr></argument>&gt;</argument_list></name></type> <name>handleNotifications</name><parameter_list>(<parameter><decl><type><name>Notifications</name><modifier>&amp;</modifier></type> <name>notifications</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <return>return <expr><call><name><name>MakeUnique</name><argument_list type="generic">&lt;<argument><expr><name>NotificationsHandlerImpl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>notifications</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>
    <function><type><name>void</name></type> <name>waitForNotificationsIfTipChanged</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint256</name><modifier>&amp;</modifier></type> <name>old_tip</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>old_tip</name><operator>.</operator><name>IsNull</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><operator>::</operator><name>cs_main</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>old_tip</name> <operator>==</operator> <call><name><operator>::</operator><name>ChainActive</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Tip</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>GetBlockHash</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>SyncWithValidationInterfaceQueue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>
    <function><type><name><name>std</name><operator>::</operator><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>Handler</name></expr></argument>&gt;</argument_list></name></type> <name>handleRpc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CRPCCommand</name><modifier>&amp;</modifier></type> <name>command</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <return>return <expr><call><name><name>MakeUnique</name><argument_list type="generic">&lt;<argument><expr><name>RpcHandlerImpl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>
    <function><type><name>bool</name></type> <name>rpcEnableDeprecated</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>method</name></decl></parameter>)</parameter_list> <specifier>override</specifier> <block>{<block_content> <return>return <expr><call><name>IsDeprecatedRPCEnabled</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
    <function><type><name>void</name></type> <name>rpcRunLater</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>name</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>function</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><operator>)</operator></expr></argument>&gt;</argument_list></name></type> <name>fn</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>seconds</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <expr_stmt><expr><call><name>RPCRunLater</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>seconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>
    <function><type><name>int</name></type> <name>rpcSerializationFlags</name><parameter_list>()</parameter_list> <specifier>override</specifier> <block>{<block_content> <return>return <expr><call><name>RPCSerializationFlags</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>
    <function><type><name>void</name></type> <name>requestMempoolTransactions</name><parameter_list>(<parameter><decl><type><name>Notifications</name><modifier>&amp;</modifier></type> <name>notifications</name></decl></parameter>)</parameter_list> <specifier>override</specifier>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK2</name><argument_list>(<argument><expr><name><operator>::</operator><name>cs_main</name></name></expr></argument>, <argument><expr><name><operator>::</operator><name>mempool</name><operator>.</operator><name>cs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CTxMemPoolEntry</name><modifier>&amp;</modifier></type> <name>entry</name> <range>: <expr><name><operator>::</operator><name>mempool</name><operator>.</operator><name>mapTx</name></name></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>notifications</name><operator>.</operator><name>TransactionAddedToMempool</name></name><argument_list>(<argument><expr><call><name><name>entry</name><operator>.</operator><name>GetSharedTx</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></function>
    <decl_stmt><decl><type><name>NodeContext</name><modifier>&amp;</modifier></type> <name>m_node</name></decl>;</decl_stmt>
</public>}</block>;</class>
}</block></namespace> <comment type="line">// namespace</comment>

<function><type><name><name>std</name><operator>::</operator><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>Chain</name></expr></argument>&gt;</argument_list></name></type> <name>MakeChain</name><parameter_list>(<parameter><decl><type><name>NodeContext</name><modifier>&amp;</modifier></type> <name>node</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name><name>MakeUnique</name><argument_list type="generic">&lt;<argument><expr><name>ChainImpl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

}</block></namespace> <comment type="line">// namespace interfaces</comment>
</unit>
