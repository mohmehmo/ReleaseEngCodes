<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C++" filename="/home/mmm/Projects/bitcoin/src/rpc/rawtransaction_util.cpp"><comment type="line">// Copyright (c) 2010 Satoshi Nakamoto</comment>
<comment type="line">// Copyright (c) 2009-2019 The Bitcoin Core developers</comment>
<comment type="line">// Distributed under the MIT software license, see the accompanying</comment>
<comment type="line">// file COPYING or http://www.opensource.org/licenses/mit-license.php.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;rpc/rawtransaction_util.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;coins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;core_io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;key_io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;policy/policy.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;primitives/transaction.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;rpc/request.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;rpc/util.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;script/sign.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;script/signingprovider.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;tinyformat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;univalue.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/rbf.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/strencodings.h&gt;</cpp:file></cpp:include>

<function><type><name>CMutableTransaction</name></type> <name>ConstructTransaction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UniValue</name><modifier>&amp;</modifier></type> <name>inputs_in</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UniValue</name><modifier>&amp;</modifier></type> <name>outputs_in</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UniValue</name><modifier>&amp;</modifier></type> <name>locktime</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rbf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name><name>inputs_in</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>outputs_in</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_PARAMETER</name></expr></argument>, <argument><expr><literal type="string">"Invalid parameter, arguments 1 and 2 must be non-null"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>UniValue</name></type> <name>inputs</name> <init>= <expr><call><name><name>inputs_in</name><operator>.</operator><name>get_array</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>outputs_is_obj</name> <init>= <expr><call><name><name>outputs_in</name><operator>.</operator><name>isObject</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>UniValue</name></type> <name>outputs</name> <init>= <expr><ternary><condition><expr><name>outputs_is_obj</name></expr> ?</condition><then> <expr><call><name><name>outputs_in</name><operator>.</operator><name>get_obj</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name><name>outputs_in</name><operator>.</operator><name>get_array</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>CMutableTransaction</name></type> <name>rawTx</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>locktime</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>nLockTime</name> <init>= <expr><call><name><name>locktime</name><operator>.</operator><name>get_int64</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>nLockTime</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>nLockTime</name></expr></argument> &gt;</argument_list></name> <name>LOCKTIME_MAX</name></expr>)</condition><block type="pseudo"><block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_PARAMETER</name></expr></argument>, <argument><expr><literal type="string">"Invalid parameter, locktime out of range"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>rawTx</name><operator>.</operator><name>nLockTime</name></name> <operator>=</operator> <name>nLockTime</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <call><name><name>inputs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>UniValue</name><modifier>&amp;</modifier></type> <name>input</name> <init>= <expr><name><name>inputs</name><index>[<expr><name>idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>UniValue</name><modifier>&amp;</modifier></type> <name>o</name> <init>= <expr><call><name><name>input</name><operator>.</operator><name>get_obj</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>uint256</name></type> <name>txid</name> <init>= <expr><call><name>ParseHashO</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><literal type="string">"txid"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>const</specifier> <name>UniValue</name><modifier>&amp;</modifier></type> <name>vout_v</name> <init>= <expr><call><name>find_value</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><literal type="string">"vout"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>vout_v</name><operator>.</operator><name>isNum</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_PARAMETER</name></expr></argument>, <argument><expr><literal type="string">"Invalid parameter, missing vout key"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nOutput</name> <init>= <expr><call><name><name>vout_v</name><operator>.</operator><name>get_int</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>nOutput</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_PARAMETER</name></expr></argument>, <argument><expr><literal type="string">"Invalid parameter, vout must be positive"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>uint32_t</name></type> <name>nSequence</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>rbf</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>nSequence</name> <operator>=</operator> <name>MAX_BIP125_RBF_SEQUENCE</name></expr>;</expr_stmt> <comment type="block">/* CTxIn::SEQUENCE_FINAL - 2 */</comment>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>rawTx</name><operator>.</operator><name>nLockTime</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>nSequence</name> <operator>=</operator> <name><name>CTxIn</name><operator>::</operator><name>SEQUENCE_FINAL</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>nSequence</name> <operator>=</operator> <name><name>CTxIn</name><operator>::</operator><name>SEQUENCE_FINAL</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="line">// set the sequence number if passed in the parameters object</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>UniValue</name><modifier>&amp;</modifier></type> <name>sequenceObj</name> <init>= <expr><call><name>find_value</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><literal type="string">"sequence"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>sequenceObj</name><operator>.</operator><name>isNum</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>seqNr64</name> <init>= <expr><call><name><name>sequenceObj</name><operator>.</operator><name>get_int64</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>seqNr64</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>seqNr64</name></expr></argument> &gt;</argument_list></name> <name><name>CTxIn</name><operator>::</operator><name>SEQUENCE_FINAL</name></name></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_PARAMETER</name></expr></argument>, <argument><expr><literal type="string">"Invalid parameter, sequence number is out of range"</literal></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>nSequence</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>seqNr64</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>CTxIn</name></type> <name>in</name><argument_list>(<argument><expr><call><name>COutPoint</name><argument_list>(<argument><expr><name>txid</name></expr></argument>, <argument><expr><name>nOutput</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>CScript</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nSequence</name></expr></argument>)</argument_list></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>rawTx</name><operator>.</operator><name>vin</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>outputs_is_obj</name></expr>)</condition> <block>{<block_content>
        <comment type="line">// Translate array of key-value pairs into dict</comment>
        <decl_stmt><decl><type><name>UniValue</name></type> <name>outputs_dict</name> <init>= <expr><call><name>UniValue</name><argument_list>(<argument><expr><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>outputs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>UniValue</name><modifier>&amp;</modifier></type> <name>output</name> <init>= <expr><name><name>outputs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>output</name><operator>.</operator><name>isObject</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_PARAMETER</name></expr></argument>, <argument><expr><literal type="string">"Invalid parameter, key-value pair not an object as expected"</literal></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>output</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_PARAMETER</name></expr></argument>, <argument><expr><literal type="string">"Invalid parameter, key-value pair must contain exactly one key"</literal></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name><name>outputs_dict</name><operator>.</operator><name>pushKVs</name></name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>outputs</name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>outputs_dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Duplicate checking</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>CTxDestination</name></expr></argument>&gt;</argument_list></name></type> <name>destinations</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>has_data</name><argument_list>{<argument><expr><literal type="boolean">false</literal></expr></argument>}</argument_list></decl>;</decl_stmt>

    <for>for <control>(<init><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>name_</name> <range>: <expr><call><name><name>outputs</name><operator>.</operator><name>getKeys</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>name_</name> <operator>==</operator> <literal type="string">"data"</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>has_data</name></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_PARAMETER</name></expr></argument>, <argument><expr><literal type="string">"Invalid parameter, duplicate key: data"</literal></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>has_data</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>data</name> <init>= <expr><call><name>ParseHexV</name><argument_list>(<argument><expr><name><name>outputs</name><index>[<expr><name>name_</name></expr>]</index></name><operator>.</operator><call><name>getValStr</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Data"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>CTxOut</name></type> <name>out</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>CScript</name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <name>OP_RETURN</name> <operator>&lt;&lt;</operator> <name>data</name></expr></argument>)</argument_list></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>rawTx</name><operator>.</operator><name>vout</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><name>CTxDestination</name></type> <name>destination</name> <init>= <expr><call><name>DecodeDestination</name><argument_list>(<argument><expr><name>name_</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsValidDestination</name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">"Invalid Bitcoin address: "</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>name_</name></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>destinations</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call><operator>.</operator><name>second</name></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_PARAMETER</name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">"Invalid parameter, duplicated address: "</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>name_</name></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>

            <decl_stmt><decl><type><name>CScript</name></type> <name>scriptPubKey</name> <init>= <expr><call><name>GetScriptForDestination</name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>CAmount</name></type> <name>nAmount</name> <init>= <expr><call><name>AmountFromValue</name><argument_list>(<argument><expr><name><name>outputs</name><index>[<expr><name>name_</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>CTxOut</name></type> <name>out</name><argument_list>(<argument><expr><name>nAmount</name></expr></argument>, <argument><expr><name>scriptPubKey</name></expr></argument>)</argument_list></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>rawTx</name><operator>.</operator><name>vout</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>rbf</name> <operator>&amp;&amp;</operator> <call><name><name>rawTx</name><operator>.</operator><name>vin</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SignalsOptInRBF</name><argument_list>(<argument><expr><call><name>CTransaction</name><argument_list>(<argument><expr><name>rawTx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_PARAMETER</name></expr></argument>, <argument><expr><literal type="string">"Invalid parameter combination: Sequence number(s) contradict replaceable option"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>rawTx</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** Pushes a JSON object for script verification or signing errors to vErrorsRet. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>TxInErrorToJSON</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CTxIn</name><modifier>&amp;</modifier></type> <name>txin</name></decl></parameter>, <parameter><decl><type><name>UniValue</name><modifier>&amp;</modifier></type> <name>vErrorsRet</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>strMessage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>UniValue</name></type> <name>entry</name><argument_list>(<argument><expr><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>entry</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"txid"</literal></expr></argument>, <argument><expr><call><name><name>txin</name><operator>.</operator><name>prevout</name><operator>.</operator><name>hash</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>entry</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"vout"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>txin</name><operator>.</operator><name>prevout</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>UniValue</name></type> <name>witness</name><argument_list>(<argument><expr><name><name>UniValue</name><operator>::</operator><name>VARR</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>txin</name><operator>.</operator><name>scriptWitness</name><operator>.</operator><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>witness</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><name><name>txin</name><operator>.</operator><name>scriptWitness</name><operator>.</operator><name>stack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>txin</name><operator>.</operator><name>scriptWitness</name><operator>.</operator><name>stack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name><name>entry</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"witness"</literal></expr></argument>, <argument><expr><name>witness</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>entry</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"scriptSig"</literal></expr></argument>, <argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><call><name><name>txin</name><operator>.</operator><name>scriptSig</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>txin</name><operator>.</operator><name>scriptSig</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>entry</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"sequence"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>txin</name><operator>.</operator><name>nSequence</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>entry</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"error"</literal></expr></argument>, <argument><expr><name>strMessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>vErrorsRet</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>ParsePrevouts</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UniValue</name><modifier>&amp;</modifier></type> <name>prevTxsUnival</name></decl></parameter>, <parameter><decl><type><name>FillableSigningProvider</name><modifier>*</modifier></type> <name>keystore</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>COutPoint</name></expr></argument>, <argument><expr><name>Coin</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>coins</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>prevTxsUnival</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>UniValue</name></type> <name>prevTxs</name> <init>= <expr><call><name><name>prevTxsUnival</name><operator>.</operator><name>get_array</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <call><name><name>prevTxs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>idx</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>UniValue</name><modifier>&amp;</modifier></type> <name>p</name> <init>= <expr><name><name>prevTxs</name><index>[<expr><name>idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>p</name><operator>.</operator><name>isObject</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_DESERIALIZATION_ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected object with {\"txid'\",\"vout\",\"scriptPubKey\"}"</literal></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>

            <decl_stmt><decl><type><name>UniValue</name></type> <name>prevOut</name> <init>= <expr><call><name><name>p</name><operator>.</operator><name>get_obj</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>RPCTypeCheckObj</name><argument_list>(<argument><expr><name>prevOut</name></expr></argument>,
                <block>{<block_content>
                    <block>{<block_content><expr><literal type="string">"txid"</literal></expr><operator>,</operator> <macro><name>UniValueType</name><argument_list>(<argument>UniValue::VSTR</argument>)</argument_list></macro></block_content>}</block><operator>,</operator>
                    <block>{<block_content><expr><literal type="string">"vout"</literal></expr><operator>,</operator> <macro><name>UniValueType</name><argument_list>(<argument>UniValue::VNUM</argument>)</argument_list></macro></block_content>}</block><operator>,</operator>
                    <block>{<block_content><expr><literal type="string">"scriptPubKey"</literal></expr><operator>,</operator> <macro><name>UniValueType</name><argument_list>(<argument>UniValue::VSTR</argument>)</argument_list></macro></block_content>}</block><operator>,</operator>
                </block_content>}</block></argument_list></call></expr></expr_stmt>)</block_content></block><empty_stmt>;</empty_stmt></for>

            <decl_stmt><decl><type><name>uint256</name></type> <name>txid</name> <init>= <expr><call><name>ParseHashO</name><argument_list>(<argument><expr><name>prevOut</name></expr></argument>, <argument><expr><literal type="string">"txid"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>nOut</name> <init>= <expr><call><name>find_value</name><argument_list>(<argument><expr><name>prevOut</name></expr></argument>, <argument><expr><literal type="string">"vout"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>get_int</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>nOut</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_DESERIALIZATION_ERROR</name></expr></argument>, <argument><expr><literal type="string">"vout must be positive"</literal></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>

            <decl_stmt><decl><type><name>COutPoint</name></type> <name>out</name><argument_list>(<argument><expr><name>txid</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>)</argument_list></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>pkData</name><argument_list>(<argument><expr><call><name>ParseHexO</name><argument_list>(<argument><expr><name>prevOut</name></expr></argument>, <argument><expr><literal type="string">"scriptPubKey"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>CScript</name></type> <name>scriptPubKey</name><argument_list>(<argument><expr><call><name><name>pkData</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pkData</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

            <block>{<block_content>
                <decl_stmt><decl><type><name>auto</name></type> <name>coin</name> <init>= <expr><call><name><name>coins</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>coin</name> <operator>!=</operator> <call><name><name>coins</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>coin</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>IsSpent</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>coin</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>out</name><operator>.</operator><name>scriptPubKey</name></name> <operator>!=</operator> <name>scriptPubKey</name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>err</name><argument_list>(<argument><expr><literal type="string">"Previous output scriptPubKey mismatch:\n"</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
                    <expr_stmt><expr><name>err</name> <operator>=</operator> <name>err</name> <operator>+</operator> <call><name>ScriptToAsmStr</name><argument_list>(<argument><expr><name><name>coin</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>out</name><operator>.</operator><name>scriptPubKey</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="string">"\nvs:\n"</literal><operator>+</operator>
                        <call><name>ScriptToAsmStr</name><argument_list>(<argument><expr><name>scriptPubKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_DESERIALIZATION_ERROR</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</throw>
                </block_content>}</block></if></if_stmt>
                <decl_stmt><decl><type><name>Coin</name></type> <name>newcoin</name></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>newcoin</name><operator>.</operator><name>out</name><operator>.</operator><name>scriptPubKey</name></name> <operator>=</operator> <name>scriptPubKey</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>newcoin</name><operator>.</operator><name>out</name><operator>.</operator><name>nValue</name></name> <operator>=</operator> <name>MAX_MONEY</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>prevOut</name><operator>.</operator><name>exists</name></name><argument_list>(<argument><expr><literal type="string">"amount"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>newcoin</name><operator>.</operator><name>out</name><operator>.</operator><name>nValue</name></name> <operator>=</operator> <call><name>AmountFromValue</name><argument_list>(<argument><expr><call><name>find_value</name><argument_list>(<argument><expr><name>prevOut</name></expr></argument>, <argument><expr><literal type="string">"amount"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>newcoin</name><operator>.</operator><name>nHeight</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>coins</name><index>[<expr><name>out</name></expr>]</index></name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>newcoin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>

            <comment type="line">// if redeemScript and private keys were given, add redeemScript to the keystore so it can be signed</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>is_p2sh</name> <init>= <expr><call><name><name>scriptPubKey</name><operator>.</operator><name>IsPayToScriptHash</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>is_p2wsh</name> <init>= <expr><call><name><name>scriptPubKey</name><operator>.</operator><name>IsPayToWitnessScriptHash</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>keystore</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>is_p2sh</name> <operator>||</operator> <name>is_p2wsh</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>RPCTypeCheckObj</name><argument_list>(<argument><expr><name>prevOut</name></expr></argument>,
                    <block>{<block_content>
                        <block>{<block_content><expr><literal type="string">"redeemScript"</literal></expr><operator>,</operator> <macro><name>UniValueType</name><argument_list>(<argument>UniValue::VSTR</argument>)</argument_list></macro></block_content>}</block><operator>,</operator>
                        <block>{<block_content><expr><literal type="string">"witnessScript"</literal></expr><operator>,</operator> <macro><name>UniValueType</name><argument_list>(<argument>UniValue::VSTR</argument>)</argument_list></macro></block_content>}</block><operator>,</operator>
                    </block_content>}</block></argument_list></call></expr></expr_stmt><operator>,</operator> <expr_stmt><expr><literal type="boolean">true</literal></expr></expr_stmt>)</block_content></block><empty_stmt>;</empty_stmt></if></if_stmt>
                <decl_stmt><decl><type><name>UniValue</name></type> <name>rs</name> <init>= <expr><call><name>find_value</name><argument_list>(<argument><expr><name>prevOut</name></expr></argument>, <argument><expr><literal type="string">"redeemScript"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>UniValue</name></type> <name>ws</name> <init>= <expr><call><name>find_value</name><argument_list>(<argument><expr><name>prevOut</name></expr></argument>, <argument><expr><literal type="string">"witnessScript"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>rs</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>ws</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_PARAMETER</name></expr></argument>, <argument><expr><literal type="string">"Missing redeemScript/witnessScript"</literal></expr></argument>)</argument_list></call></expr>;</throw>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// work from witnessScript when possible</comment>
                <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>scriptData</name><argument_list>(<argument><expr><ternary><condition><expr><operator>!</operator><call><name><name>ws</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>ParseHexV</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><literal type="string">"witnessScript"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>ParseHexV</name><argument_list>(<argument><expr><name>rs</name></expr></argument>, <argument><expr><literal type="string">"redeemScript"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>CScript</name></type> <name>script</name><argument_list>(<argument><expr><call><name><name>scriptData</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>scriptData</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>keystore</name><operator>-&gt;</operator><name>AddCScript</name></name><argument_list>(<argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// Automatically also add the P2WSH wrapped version of the script (to deal with P2SH-P2WSH).</comment>
                <comment type="line">// This is done for redeemScript only for compatibility, it is encouraged to use the explicit witnessScript field instead.</comment>
                <decl_stmt><decl><type><name>CScript</name></type> <name>witness_output_script</name><argument_list>{<argument><expr><macro><name>GetScriptForWitness</name><argument_list>(<argument>script</argument>)</argument_list></macro></expr></argument>}</argument_list></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>keystore</name><operator>-&gt;</operator><name>AddCScript</name></name><argument_list>(<argument><expr><name>witness_output_script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>ws</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>rs</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <comment type="line">// if both witnessScript and redeemScript are provided,</comment>
                    <comment type="line">// they should either be the same (for backwards compat),</comment>
                    <comment type="line">// or the redeemScript should be the encoded form of</comment>
                    <comment type="line">// the witnessScript (ie, for p2sh-p2wsh)</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>ws</name><operator>.</operator><name>get_str</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>rs</name><operator>.</operator><name>get_str</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>redeemScriptData</name><argument_list>(<argument><expr><call><name>ParseHexV</name><argument_list>(<argument><expr><name>rs</name></expr></argument>, <argument><expr><literal type="string">"redeemScript"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>CScript</name></type> <name>redeemScript</name><argument_list>(<argument><expr><call><name><name>redeemScriptData</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>redeemScriptData</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><name>redeemScript</name> <operator>!=</operator> <name>witness_output_script</name></expr>)</condition> <block>{<block_content>
                            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_PARAMETER</name></expr></argument>, <argument><expr><literal type="string">"redeemScript does not correspond to witnessScript"</literal></expr></argument>)</argument_list></call></expr>;</throw>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>is_p2sh</name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>CTxDestination</name></type> <name>p2sh</name><argument_list>{<argument><expr><macro><name>ScriptHash</name><argument_list>(<argument>script</argument>)</argument_list></macro></expr></argument>}</argument_list></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>CTxDestination</name></type> <name>p2sh_p2wsh</name><argument_list>{<argument><expr><macro><name>ScriptHash</name><argument_list>(<argument>witness_output_script</argument>)</argument_list></macro></expr></argument>}</argument_list></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>scriptPubKey</name> <operator>==</operator> <call><name>GetScriptForDestination</name><argument_list>(<argument><expr><name>p2sh</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <comment type="line">// traditional p2sh; arguably an error if</comment>
                        <comment type="line">// we got here with rs.IsNull(), because</comment>
                        <comment type="line">// that means the p2sh script was specified</comment>
                        <comment type="line">// via witnessScript param, but for now</comment>
                        <comment type="line">// we'll just quietly accept it</comment>
                    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>scriptPubKey</name> <operator>==</operator> <call><name>GetScriptForDestination</name><argument_list>(<argument><expr><name>p2sh_p2wsh</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <comment type="line">// p2wsh encoded as p2sh; ideally the witness</comment>
                        <comment type="line">// script was specified in the witnessScript</comment>
                        <comment type="line">// param, but also support specifying it via</comment>
                        <comment type="line">// redeemScript param for backwards compat</comment>
                        <comment type="line">// (in which case ws.IsNull() == true)</comment>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <comment type="line">// otherwise, can't generate scriptPubKey from</comment>
                        <comment type="line">// either script, so we got unusable parameters</comment>
                        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_PARAMETER</name></expr></argument>, <argument><expr><literal type="string">"redeemScript/witnessScript does not match scriptPubKey"</literal></expr></argument>)</argument_list></call></expr>;</throw>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>is_p2wsh</name></expr>)</condition> <block>{<block_content>
                    <comment type="line">// plain p2wsh; could throw an error if script</comment>
                    <comment type="line">// was specified by redeemScript rather than</comment>
                    <comment type="line">// witnessScript (ie, ws.IsNull() == true), but</comment>
                    <comment type="line">// accept it for backwards compat</comment>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>CTxDestination</name></type> <name>p2wsh</name><argument_list>{<argument><expr><macro><name>WitnessV0ScriptHash</name><argument_list>(<argument>script</argument>)</argument_list></macro></expr></argument>}</argument_list></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>scriptPubKey</name> <operator>!=</operator> <call><name>GetScriptForDestination</name><argument_list>(<argument><expr><name>p2wsh</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_PARAMETER</name></expr></argument>, <argument><expr><literal type="string">"redeemScript/witnessScript does not match scriptPubKey"</literal></expr></argument>)</argument_list></call></expr>;</throw>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></function>
    }
}

<function><type><name>void</name></type> <name>SignTransaction</name><parameter_list>(<parameter><decl><type><name>CMutableTransaction</name><modifier>&amp;</modifier></type> <name>mtx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SigningProvider</name><modifier>*</modifier></type> <name>keystore</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>COutPoint</name></expr></argument>, <argument><expr><name>Coin</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>coins</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UniValue</name><modifier>&amp;</modifier></type> <name>hashType</name></decl></parameter>, <parameter><decl><type><name>UniValue</name><modifier>&amp;</modifier></type> <name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nHashType</name> <init>= <expr><call><name>ParseSighashString</name><argument_list>(<argument><expr><name>hashType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>fHashSingle</name> <init>= <expr><operator>(</operator><operator>(</operator><name>nHashType</name> <operator>&amp;</operator> <operator>~</operator><name>SIGHASH_ANYONECANPAY</name><operator>)</operator> <operator>==</operator> <name>SIGHASH_SINGLE</name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <comment type="line">// Script verification errors</comment>
    <decl_stmt><decl><type><name>UniValue</name></type> <name>vErrors</name><argument_list>(<argument><expr><name><name>UniValue</name><operator>::</operator><name>VARR</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>

    <comment type="line">// Use CTransaction for the constant parts of the</comment>
    <comment type="line">// transaction to avoid rehashing.</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CTransaction</name></type> <name>txConst</name><argument_list>(<argument><expr><name>mtx</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <comment type="line">// Sign what we can:</comment>
    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>mtx</name><operator>.</operator><name>vin</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>CTxIn</name><modifier>&amp;</modifier></type> <name>txin</name> <init>= <expr><name><name>mtx</name><operator>.</operator><name>vin</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>coin</name> <init>= <expr><call><name><name>coins</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name><name>txin</name><operator>.</operator><name>prevout</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>coin</name> <operator>==</operator> <call><name><name>coins</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>coin</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>IsSpent</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>TxInErrorToJSON</name><argument_list>(<argument><expr><name>txin</name></expr></argument>, <argument><expr><name>vErrors</name></expr></argument>, <argument><expr><literal type="string">"Input not found or already spent"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>CScript</name><modifier>&amp;</modifier></type> <name>prevPubKey</name> <init>= <expr><name><name>coin</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>out</name><operator>.</operator><name>scriptPubKey</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>CAmount</name><modifier>&amp;</modifier></type> <name>amount</name> <init>= <expr><name><name>coin</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>out</name><operator>.</operator><name>nValue</name></name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>SignatureData</name></type> <name>sigdata</name> <init>= <expr><call><name>DataFromTransaction</name><argument_list>(<argument><expr><name>mtx</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>coin</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>out</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// Only sign SIGHASH_SINGLE if there's a corresponding output:</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fHashSingle</name> <operator>||</operator> <operator>(</operator><name>i</name> <operator>&lt;</operator> <call><name><name>mtx</name><operator>.</operator><name>vout</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>ProduceSignature</name><argument_list>(<argument><expr><operator>*</operator><name>keystore</name></expr></argument>, <argument><expr><call><name>MutableTransactionSignatureCreator</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mtx</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>nHashType</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>prevPubKey</name></expr></argument>, <argument><expr><name>sigdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>UpdateInput</name><argument_list>(<argument><expr><name>txin</name></expr></argument>, <argument><expr><name>sigdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// amount must be specified for valid segwit signature</comment>
        <if_stmt><if>if <condition>(<expr><name>amount</name> <operator>==</operator> <name>MAX_MONEY</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>txin</name><operator>.</operator><name>scriptWitness</name><operator>.</operator><name>IsNull</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_TYPE_ERROR</name></expr></argument>, <argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"Missing amount for %s"</literal></expr></argument>, <argument><expr><call><name><name>coin</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>out</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>ScriptError</name></type> <name>serror</name> <init>= <expr><name>SCRIPT_ERR_OK</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VerifyScript</name><argument_list>(<argument><expr><name><name>txin</name><operator>.</operator><name>scriptSig</name></name></expr></argument>, <argument><expr><name>prevPubKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>txin</name><operator>.</operator><name>scriptWitness</name></name></expr></argument>, <argument><expr><name>STANDARD_SCRIPT_VERIFY_FLAGS</name></expr></argument>, <argument><expr><call><name>TransactionSignatureChecker</name><argument_list>(<argument><expr><operator>&amp;</operator><name>txConst</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>serror</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>serror</name> <operator>==</operator> <name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr>)</condition> <block>{<block_content>
                <comment type="line">// Unable to sign input and verification failed (possible attempt to partially sign).</comment>
                <expr_stmt><expr><call><name>TxInErrorToJSON</name><argument_list>(<argument><expr><name>txin</name></expr></argument>, <argument><expr><name>vErrors</name></expr></argument>, <argument><expr><literal type="string">"Unable to sign input, invalid stack size (possibly missing key)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>serror</name> <operator>==</operator> <name>SCRIPT_ERR_SIG_NULLFAIL</name></expr>)</condition> <block>{<block_content>
                <comment type="line">// Verification failed (possibly due to insufficient signatures).</comment>
                <expr_stmt><expr><call><name>TxInErrorToJSON</name><argument_list>(<argument><expr><name>txin</name></expr></argument>, <argument><expr><name>vErrors</name></expr></argument>, <argument><expr><literal type="string">"CHECK(MULTI)SIG failing with non-zero signature (possibly need more signatures)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>TxInErrorToJSON</name><argument_list>(<argument><expr><name>txin</name></expr></argument>, <argument><expr><name>vErrors</name></expr></argument>, <argument><expr><call><name>ScriptErrorString</name><argument_list>(<argument><expr><name>serror</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <decl_stmt><decl><type><name>bool</name></type> <name>fComplete</name> <init>= <expr><call><name><name>vErrors</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"hex"</literal></expr></argument>, <argument><expr><call><name>EncodeHexTx</name><argument_list>(<argument><expr><call><name>CTransaction</name><argument_list>(<argument><expr><name>mtx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"complete"</literal></expr></argument>, <argument><expr><name>fComplete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>vErrors</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>result</name><operator>.</operator><name>exists</name></name><argument_list>(<argument><expr><literal type="string">"errors"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>vErrors</name><operator>.</operator><name>push_backV</name></name><argument_list>(<argument><expr><name><name>result</name><index>[<expr><literal type="string">"errors"</literal></expr>]</index></name><operator>.</operator><call><name>getValues</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"errors"</literal></expr></argument>, <argument><expr><name>vErrors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
