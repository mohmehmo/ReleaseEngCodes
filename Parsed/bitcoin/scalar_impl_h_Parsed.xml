<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/mmm/Projects/bitcoin/src/secp256k1/src/scalar_impl.h"><comment type="block" format="doxygen">/**********************************************************************
 * Copyright (c) 2014 Pieter Wuille                                   *
 * Distributed under the MIT software license, see the accompanying   *
 * file COPYING or http://www.opensource.org/licenses/mit-license.php.*
 **********************************************************************/</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SECP256K1_SCALAR_IMPL_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_SCALAR_IMPL_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"group.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scalar.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>HAVE_CONFIG_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libsecp256k1-config.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXHAUSTIVE_TEST_ORDER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scalar_low_impl.h"</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SCALAR_4X64</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scalar_4x64_impl.h"</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SCALAR_8X32</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scalar_8x32_impl.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"Please select scalar implementation"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>USE_NUM_NONE</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>secp256k1_scalar_get_num</name><parameter_list>(<parameter><decl><type><name>secp256k1_num</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>secp256k1_scalar</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>c</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>secp256k1_scalar_get_b32</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_num_set_bin</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** secp256k1 curve order, see secp256k1_ecdsa_const_order_as_fe in ecdsa_impl.h */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>secp256k1_scalar_order_get_num</name><parameter_list>(<parameter><decl><type><name>secp256k1_num</name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXHAUSTIVE_TEST_ORDER</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>order</name><index>[<expr><literal type="number">32</literal></expr>]</index></name> <init>= <expr><block>{
        <expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
        <expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
        <expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
        <expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><name>EXHAUSTIVE_TEST_ORDER</name></expr>
    }</block></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>order</name><index>[<expr><literal type="number">32</literal></expr>]</index></name> <init>= <expr><block>{
        <expr><literal type="number">0xFF</literal></expr>,<expr><literal type="number">0xFF</literal></expr>,<expr><literal type="number">0xFF</literal></expr>,<expr><literal type="number">0xFF</literal></expr>,<expr><literal type="number">0xFF</literal></expr>,<expr><literal type="number">0xFF</literal></expr>,<expr><literal type="number">0xFF</literal></expr>,<expr><literal type="number">0xFF</literal></expr>,
        <expr><literal type="number">0xFF</literal></expr>,<expr><literal type="number">0xFF</literal></expr>,<expr><literal type="number">0xFF</literal></expr>,<expr><literal type="number">0xFF</literal></expr>,<expr><literal type="number">0xFF</literal></expr>,<expr><literal type="number">0xFF</literal></expr>,<expr><literal type="number">0xFF</literal></expr>,<expr><literal type="number">0xFE</literal></expr>,
        <expr><literal type="number">0xBA</literal></expr>,<expr><literal type="number">0xAE</literal></expr>,<expr><literal type="number">0xDC</literal></expr>,<expr><literal type="number">0xE6</literal></expr>,<expr><literal type="number">0xAF</literal></expr>,<expr><literal type="number">0x48</literal></expr>,<expr><literal type="number">0xA0</literal></expr>,<expr><literal type="number">0x3B</literal></expr>,
        <expr><literal type="number">0xBF</literal></expr>,<expr><literal type="number">0xD2</literal></expr>,<expr><literal type="number">0x5E</literal></expr>,<expr><literal type="number">0x8C</literal></expr>,<expr><literal type="number">0xD0</literal></expr>,<expr><literal type="number">0x36</literal></expr>,<expr><literal type="number">0x41</literal></expr>,<expr><literal type="number">0x41</literal></expr>
    }</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>secp256k1_num_set_bin</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type> <name>secp256k1_scalar_inverse</name><parameter_list>(<parameter><decl><type><name>secp256k1_scalar</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>secp256k1_scalar</name> <modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXHAUSTIVE_TEST_ORDER</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>r</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>EXHAUSTIVE_TEST_ORDER</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>*</operator> <operator>*</operator><name>x</name><operator>)</operator> <operator>%</operator> <name>EXHAUSTIVE_TEST_ORDER</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>r</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
    <comment type="block">/* If this VERIFY_CHECK triggers we were given a noninvertible scalar (and thus
     * have a composite group order; fix it in exhaustive_tests.c). */</comment>
    <expr_stmt><expr><call><name>VERIFY_CHECK</name><argument_list>(<argument><expr><operator>*</operator><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>secp256k1_scalar</name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <comment type="block">/* First compute xN as x ^ (2^N - 1) for some values of N,
     * and uM as x ^ M for some values of M. */</comment>
    <decl_stmt><decl><type><name>secp256k1_scalar</name></type> <name>x2</name></decl>, <decl><type ref="prev"/><name>x3</name></decl>, <decl><type ref="prev"/><name>x6</name></decl>, <decl><type ref="prev"/><name>x8</name></decl>, <decl><type ref="prev"/><name>x14</name></decl>, <decl><type ref="prev"/><name>x28</name></decl>, <decl><type ref="prev"/><name>x56</name></decl>, <decl><type ref="prev"/><name>x112</name></decl>, <decl><type ref="prev"/><name>x126</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>secp256k1_scalar</name></type> <name>u2</name></decl>, <decl><type ref="prev"/><name>u5</name></decl>, <decl><type ref="prev"/><name>u9</name></decl>, <decl><type ref="prev"/><name>u11</name></decl>, <decl><type ref="prev"/><name>u13</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>u2</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u2</name></expr></argument>,  <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>u5</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x3</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u5</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>u2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>u9</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x3</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>u11</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u9</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>u13</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u11</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x6</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u13</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x6</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x6</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x6</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u11</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x8</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x8</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x8</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x8</name></expr></argument>,  <argument><expr><operator>&amp;</operator><name>x2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x14</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x14</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x14</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x14</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x14</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x28</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x14</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">13</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x28</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x28</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x28</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x28</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x14</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x56</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x28</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">27</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x56</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x56</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x56</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x56</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x28</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x112</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x56</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">55</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x112</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x112</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x112</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x112</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x56</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x126</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x112</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">13</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x126</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x126</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x126</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x126</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x14</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Then accumulate the final result (t starts at x126). */</comment>
    <expr_stmt><expr><name>t</name> <operator>=</operator> <operator>&amp;</operator><name>x126</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 101 */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content> <comment type="block">/* 0 */</comment>
        <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 111 */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content> <comment type="block">/* 0 */</comment>
        <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 101 */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content> <comment type="block">/* 0 */</comment>
        <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u11</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 1011 */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u11</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 1011 */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content> <comment type="block">/* 0 */</comment>
        <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 111 */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content> <comment type="block">/* 00 */</comment>
        <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 111 */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">6</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content> <comment type="block">/* 00 */</comment>
        <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u13</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 1101 */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content> <comment type="block">/* 0 */</comment>
        <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 101 */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 111 */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content> <comment type="block">/* 0 */</comment>
        <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u9</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 1001 */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">6</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content> <comment type="block">/* 000 */</comment>
        <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 101 */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content> <comment type="block">/* 0000000 */</comment>
        <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 111 */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content> <comment type="block">/* 0 */</comment>
        <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 111 */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">9</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content> <comment type="block">/* 0 */</comment>
        <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 11111111 */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content> <comment type="block">/* 0 */</comment>
        <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u9</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 1001 */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">6</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content> <comment type="block">/* 00 */</comment>
        <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u11</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 1011 */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u13</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 1101 */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 11 */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">6</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content> <comment type="block">/* 00 */</comment>
        <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u13</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 1101 */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content> <comment type="block">/* 000000 */</comment>
        <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u13</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 1101 */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u9</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 1001 */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">6</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content> <comment type="block">/* 00000 */</comment>
        <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 1 */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content> <comment type="block">/* 00 */</comment>
        <expr_stmt><expr><call><name>secp256k1_scalar_sqr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 111111 */</comment>
}

SECP256K1_INLINE <function><type><specifier>static</specifier> <name>int</name></type> <name>secp256k1_scalar_is_even</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>secp256k1_scalar</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><operator>!</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type> <name>secp256k1_scalar_inverse_var</name><parameter_list>(<parameter><decl><type><name>secp256k1_scalar</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>secp256k1_scalar</name> <modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SCALAR_INV_BUILTIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>secp256k1_scalar_inverse</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SCALAR_INV_NUM</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>b</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>secp256k1_num</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>m</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>secp256k1_scalar</name></type> <name>t</name> <init>= <expr><operator>*</operator><name>x</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>secp256k1_scalar_get_b32</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_num_set_bin</name><argument_list>(<argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_scalar_order_get_num</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_num_mod_inverse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_num_get_bin</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_scalar_set_b32</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Verify that the inverse was computed correctly, without GMP code. */</comment>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>secp256k1_scalar_is_one</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"Please select scalar inverse implementation"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ENDOMORPHISM</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXHAUSTIVE_TEST_ORDER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block" format="doxygen">/**
 * Find k1 and k2 given k, such that k1 + k2 * lambda == k mod n; unlike in the
 * full case we don't bother making k1 and k2 be small, we just want them to be
 * nontrivial to get full test coverage for the exhaustive tests. We therefore
 * (arbitrarily) set k2 = k + 5 and k1 = k - k2 * lambda.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>secp256k1_scalar_split_lambda</name><parameter_list>(<parameter><decl><type><name>secp256k1_scalar</name> <modifier>*</modifier></type><name>r1</name></decl></parameter>, <parameter><decl><type><name>secp256k1_scalar</name> <modifier>*</modifier></type><name>r2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>secp256k1_scalar</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>r2</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>a</name> <operator>+</operator> <literal type="number">5</literal><operator>)</operator> <operator>%</operator> <name>EXHAUSTIVE_TEST_ORDER</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>r1</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>a</name> <operator>+</operator> <operator>(</operator><name>EXHAUSTIVE_TEST_ORDER</name> <operator>-</operator> <operator>*</operator><name>r2</name><operator>)</operator> <operator>*</operator> <name>EXHAUSTIVE_TEST_LAMBDA</name><operator>)</operator> <operator>%</operator> <name>EXHAUSTIVE_TEST_ORDER</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<comment type="block" format="doxygen">/**
 * The Secp256k1 curve has an endomorphism, where lambda * (x, y) = (beta * x, y), where
 * lambda is {0x53,0x63,0xad,0x4c,0xc0,0x5c,0x30,0xe0,0xa5,0x26,0x1c,0x02,0x88,0x12,0x64,0x5a,
 *            0x12,0x2e,0x22,0xea,0x20,0x81,0x66,0x78,0xdf,0x02,0x96,0x7c,0x1b,0x23,0xbd,0x72}
 *
 * "Guide to Elliptic Curve Cryptography" (Hankerson, Menezes, Vanstone) gives an algorithm
 * (algorithm 3.74) to find k1 and k2 given k, such that k1 + k2 * lambda == k mod n, and k1
 * and k2 have a small size.
 * It relies on constants a1, b1, a2, b2. These constants for the value of lambda above are:
 *
 * - a1 =      {0x30,0x86,0xd2,0x21,0xa7,0xd4,0x6b,0xcd,0xe8,0x6c,0x90,0xe4,0x92,0x84,0xeb,0x15}
 * - b1 =     -{0xe4,0x43,0x7e,0xd6,0x01,0x0e,0x88,0x28,0x6f,0x54,0x7f,0xa9,0x0a,0xbf,0xe4,0xc3}
 * - a2 = {0x01,0x14,0xca,0x50,0xf7,0xa8,0xe2,0xf3,0xf6,0x57,0xc1,0x10,0x8d,0x9d,0x44,0xcf,0xd8}
 * - b2 =      {0x30,0x86,0xd2,0x21,0xa7,0xd4,0x6b,0xcd,0xe8,0x6c,0x90,0xe4,0x92,0x84,0xeb,0x15}
 *
 * The algorithm then computes c1 = round(b1 * k / n) and c2 = round(b2 * k / n), and gives
 * k1 = k - (c1*a1 + c2*a2) and k2 = -(c1*b1 + c2*b2). Instead, we use modular arithmetic, and
 * compute k1 as k - k2 * lambda, avoiding the need for constants a1 and a2.
 *
 * g1, g2 are precomputed constants used to replace division with a rounded multiplication
 * when decomposing the scalar for an endomorphism-based point multiplication.
 *
 * The possibility of using precomputed estimates is mentioned in "Guide to Elliptic Curve
 * Cryptography" (Hankerson, Menezes, Vanstone) in section 3.5.
 *
 * The derivation is described in the paper "Efficient Software Implementation of Public-Key
 * Cryptography on Sensor Networks Using the MSP430X Microcontroller" (Gouvea, Oliveira, Lopez),
 * Section 4.3 (here we use a somewhat higher-precision estimate):
 * d = a1*b2 - b1*a2
 * g1 = round((2^272)*b2/d)
 * g2 = round((2^272)*b1/d)
 *
 * (Note that 'd' is also equal to the curve order here because [a1,b1] and [a2,b2] are found
 * as outputs of the Extended Euclidean Algorithm on inputs 'order' and 'lambda').
 *
 * The function below splits a in r1 and r2, such that r1 + lambda * r2 == a (mod order).
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>secp256k1_scalar_split_lambda</name><parameter_list>(<parameter><decl><type><name>secp256k1_scalar</name> <modifier>*</modifier></type><name>r1</name></decl></parameter>, <parameter><decl><type><name>secp256k1_scalar</name> <modifier>*</modifier></type><name>r2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>secp256k1_scalar</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>secp256k1_scalar</name></type> <name>c1</name></decl>, <decl><type ref="prev"/><name>c2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>secp256k1_scalar</name></type> <name>minus_lambda</name> <init>= <expr><call><name>SECP256K1_SCALAR_CONST</name><argument_list>(
        <argument><expr><literal type="number">0xAC9C52B3UL</literal></expr></argument>, <argument><expr><literal type="number">0x3FA3CF1FUL</literal></expr></argument>, <argument><expr><literal type="number">0x5AD9E3FDUL</literal></expr></argument>, <argument><expr><literal type="number">0x77ED9BA4UL</literal></expr></argument>,
        <argument><expr><literal type="number">0xA880B9FCUL</literal></expr></argument>, <argument><expr><literal type="number">0x8EC739C2UL</literal></expr></argument>, <argument><expr><literal type="number">0xE0CFC810UL</literal></expr></argument>, <argument><expr><literal type="number">0xB51283CFUL</literal></expr></argument>
    )</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>secp256k1_scalar</name></type> <name>minus_b1</name> <init>= <expr><call><name>SECP256K1_SCALAR_CONST</name><argument_list>(
        <argument><expr><literal type="number">0x00000000UL</literal></expr></argument>, <argument><expr><literal type="number">0x00000000UL</literal></expr></argument>, <argument><expr><literal type="number">0x00000000UL</literal></expr></argument>, <argument><expr><literal type="number">0x00000000UL</literal></expr></argument>,
        <argument><expr><literal type="number">0xE4437ED6UL</literal></expr></argument>, <argument><expr><literal type="number">0x010E8828UL</literal></expr></argument>, <argument><expr><literal type="number">0x6F547FA9UL</literal></expr></argument>, <argument><expr><literal type="number">0x0ABFE4C3UL</literal></expr></argument>
    )</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>secp256k1_scalar</name></type> <name>minus_b2</name> <init>= <expr><call><name>SECP256K1_SCALAR_CONST</name><argument_list>(
        <argument><expr><literal type="number">0xFFFFFFFFUL</literal></expr></argument>, <argument><expr><literal type="number">0xFFFFFFFFUL</literal></expr></argument>, <argument><expr><literal type="number">0xFFFFFFFFUL</literal></expr></argument>, <argument><expr><literal type="number">0xFFFFFFFEUL</literal></expr></argument>,
        <argument><expr><literal type="number">0x8A280AC5UL</literal></expr></argument>, <argument><expr><literal type="number">0x0774346DUL</literal></expr></argument>, <argument><expr><literal type="number">0xD765CDA8UL</literal></expr></argument>, <argument><expr><literal type="number">0x3DB1562CUL</literal></expr></argument>
    )</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>secp256k1_scalar</name></type> <name>g1</name> <init>= <expr><call><name>SECP256K1_SCALAR_CONST</name><argument_list>(
        <argument><expr><literal type="number">0x00000000UL</literal></expr></argument>, <argument><expr><literal type="number">0x00000000UL</literal></expr></argument>, <argument><expr><literal type="number">0x00000000UL</literal></expr></argument>, <argument><expr><literal type="number">0x00003086UL</literal></expr></argument>,
        <argument><expr><literal type="number">0xD221A7D4UL</literal></expr></argument>, <argument><expr><literal type="number">0x6BCDE86CUL</literal></expr></argument>, <argument><expr><literal type="number">0x90E49284UL</literal></expr></argument>, <argument><expr><literal type="number">0xEB153DABUL</literal></expr></argument>
    )</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>secp256k1_scalar</name></type> <name>g2</name> <init>= <expr><call><name>SECP256K1_SCALAR_CONST</name><argument_list>(
        <argument><expr><literal type="number">0x00000000UL</literal></expr></argument>, <argument><expr><literal type="number">0x00000000UL</literal></expr></argument>, <argument><expr><literal type="number">0x00000000UL</literal></expr></argument>, <argument><expr><literal type="number">0x0000E443UL</literal></expr></argument>,
        <argument><expr><literal type="number">0x7ED6010EUL</literal></expr></argument>, <argument><expr><literal type="number">0x88286F54UL</literal></expr></argument>, <argument><expr><literal type="number">0x7FA90ABFUL</literal></expr></argument>, <argument><expr><literal type="number">0xE4C42212UL</literal></expr></argument>
    )</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>VERIFY_CHECK</name><argument_list>(<argument><expr><name>r1</name> <operator>!=</operator> <name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VERIFY_CHECK</name><argument_list>(<argument><expr><name>r2</name> <operator>!=</operator> <name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* these _var calls are constant time since the shift amount is constant */</comment>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul_shift_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c1</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>g1</name></expr></argument>, <argument><expr><literal type="number">272</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul_shift_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c2</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>g2</name></expr></argument>, <argument><expr><literal type="number">272</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>minus_b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>minus_b2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_scalar_add</name><argument_list>(<argument><expr><name>r2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_scalar_mul</name><argument_list>(<argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>minus_lambda</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_scalar_add</name><argument_list>(<argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SECP256K1_SCALAR_IMPL_H */</comment>
</unit>
