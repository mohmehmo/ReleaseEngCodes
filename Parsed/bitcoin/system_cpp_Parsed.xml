<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C++" filename="/home/mmm/Projects/bitcoin/src/util/system.cpp"><comment type="line">// Copyright (c) 2009-2010 Satoshi Nakamoto</comment>
<comment type="line">// Copyright (c) 2009-2019 The Bitcoin Core developers</comment>
<comment type="line">// Distributed under the MIT software license, see the accompanying</comment>
<comment type="line">// file COPYING or http://www.opensource.org/licenses/mit-license.php.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/system.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;chainparamsbase.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/strencodings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/translation.h&gt;</cpp:file></cpp:include>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__OpenBSD__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__DragonFly__</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread_np.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<comment type="line">// for posix_fallocate</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__linux__</name></cpp:ifdef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_POSIX_C_SOURCE</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_POSIX_C_SOURCE</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_POSIX_C_SOURCE</name></cpp:macro> <cpp:value>200112L</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// __linux__</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;algorithm&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sched.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name><name>:</name><name>4786</name><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name><name>:</name><name>4804</name><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name><name>:</name><name>4805</name><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name><name>:</name><name>4717</name><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32_IE</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_WIN32_IE</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_WIN32_IE</name></cpp:macro> <cpp:value>0x0501</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIN32_LEAN_AND_MEAN</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NOMINMAX</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NOMINMAX</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;codecvt&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include> <comment type="block">/* for _commit */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;shellapi.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;shlobj.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_MALLOPT_ARENA_MAX</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;malloc.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;thread&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;univalue.h&gt;</cpp:file></cpp:include>

<comment type="line">// Application startup time (used for uptime calculation)</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>nStartupTime</name> <init>= <expr><call><name>GetTime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>BITCOIN_CONF_FILENAME</name> <init>= <expr><literal type="string">"bitcoin.conf"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ArgsManager</name></type> <name>gArgs</name></decl>;</decl_stmt>

<comment type="block" format="doxygen">/** A map that contains all the currently held directory locks. After
 * successful locking, these will be held here until the global destructor
 * cleans them up and thus automatically unlocks them, or ReleaseDirectoryLocks
 * is called.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name><name>fsbridge</name><operator>::</operator><name>FileLock</name></name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>dir_locks</name></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** Mutex to protect dir_locks. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>std</name><operator>::</operator><name>mutex</name></name></type> <name>cs_dir_locks</name></decl>;</decl_stmt>

<function><type><name>bool</name></type> <name>LockDirectory</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>fs</name><operator>::</operator><name>path</name></name><modifier>&amp;</modifier></type> <name>directory</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name></type> <name>lockfile_name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>probe_only</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>lock_guard</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>mutex</name></name></expr></argument>&gt;</argument_list></name></type> <name>ulock</name><argument_list>(<argument><expr><name>cs_dir_locks</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>fs</name><operator>::</operator><name>path</name></name></type> <name>pathLockFile</name> <init>= <expr><name>directory</name> <operator>/</operator> <name>lockfile_name</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// If a lock for this directory already exists in the map, don't try to re-lock it</comment>
    <if_stmt><if>if <condition>(<expr><call><name><name>dir_locks</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><call><name><name>pathLockFile</name><operator>.</operator><name>string</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Create empty lock file if it doesn't exist.</comment>
    <decl_stmt><decl><type><name>FILE</name><modifier>*</modifier></type> <name>file</name> <init>= <expr><call><name><name>fsbridge</name><operator>::</operator><name>fopen</name></name><argument_list>(<argument><expr><name>pathLockFile</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>file</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>lock</name> <init>= <expr><call><name><name>MakeUnique</name><argument_list type="generic">&lt;<argument><expr><name><name>fsbridge</name><operator>::</operator><name>FileLock</name></name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>pathLockFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>lock</name><operator>-&gt;</operator><name>TryLock</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"Error while attempting to lock directory %s: %s"</literal></expr></argument>, <argument><expr><call><name><name>directory</name><operator>.</operator><name>string</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>lock</name><operator>-&gt;</operator><name>GetReason</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>probe_only</name></expr>)</condition> <block>{<block_content>
        <comment type="line">// Lock successful and we're not just probing, put it into the map</comment>
        <expr_stmt><expr><call><name><name>dir_locks</name><operator>.</operator><name>emplace</name></name><argument_list>(<argument><expr><call><name><name>pathLockFile</name><operator>.</operator><name>string</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>UnlockDirectory</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>fs</name><operator>::</operator><name>path</name></name><modifier>&amp;</modifier></type> <name>directory</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>lockfile_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>lock_guard</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>mutex</name></name></expr></argument>&gt;</argument_list></name></type> <name>lock</name><argument_list>(<argument><expr><name>cs_dir_locks</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>dir_locks</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><operator>(</operator><name>directory</name> <operator>/</operator> <name>lockfile_name</name><operator>)</operator><operator>.</operator><call><name>string</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>ReleaseDirectoryLocks</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>lock_guard</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>mutex</name></name></expr></argument>&gt;</argument_list></name></type> <name>ulock</name><argument_list>(<argument><expr><name>cs_dir_locks</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>dir_locks</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>DirIsWritable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>fs</name><operator>::</operator><name>path</name></name><modifier>&amp;</modifier></type> <name>directory</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>fs</name><operator>::</operator><name>path</name></name></type> <name>tmpFile</name> <init>= <expr><name>directory</name> <operator>/</operator> <call><name><name>fs</name><operator>::</operator><name>unique_path</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>FILE</name><modifier>*</modifier></type> <name>file</name> <init>= <expr><call><name><name>fsbridge</name><operator>::</operator><name>fopen</name></name><argument_list>(<argument><expr><name>tmpFile</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>file</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>remove</name><argument_list>(<argument><expr><name>tmpFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>CheckDiskSpace</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>fs</name><operator>::</operator><name>path</name></name><modifier>&amp;</modifier></type> <name>dir</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>additional_bytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>constexpr</specifier> <name>uint64_t</name></type> <name>min_disk_space</name> <init>= <expr><literal type="number">52428800</literal></expr></init></decl>;</decl_stmt> <comment type="line">// 50 MiB</comment>

    <decl_stmt><decl><type><name>uint64_t</name></type> <name>free_bytes_available</name> <init>= <expr><call><name><name>fs</name><operator>::</operator><name>space</name></name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call><operator>.</operator><name>available</name></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>free_bytes_available</name> <operator>&gt;=</operator> <name>min_disk_space</name> <operator>+</operator> <name>additional_bytes</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Interpret a string argument as a boolean.
 *
 * The definition of atoi() requires that non-numeric string values like "foo",
 * return 0. This means that if a user unintentionally supplies a non-integer
 * argument here, the return value is always false. This means that -foo=false
 * does what the user probably expects, but -foo=true is well defined but does
 * not do what they probably expected.
 *
 * The return value of atoi() is undefined when given input not representable as
 * an int. On most systems this means string value between "-2147483648" and
 * "2147483647" are well defined (this method will return true). Setting
 * -txindex=2147483648 on most systems, however, is probably undefined.
 *
 * For a more extensive discussion of this topic (and a wide range of opinions
 * on the Right Way to change this code), see PR12713.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>InterpretBool</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>strValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name><name>strValue</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><operator>(</operator><call><name>atoi</name><argument_list>(<argument><expr><name>strValue</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>std</name><operator>::</operator><name>string</name></name></type> <name>SettingName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><ternary><condition><expr><call><name><name>arg</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr> ?</condition><then> <expr><call><name><name>arg</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>arg</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** Internal helper functions for ArgsManager */</comment>
<class>class <name>ArgsManagerHelper</name> <block>{<private type="default">
</private><public>public:
    <comment type="block" format="doxygen">/** Determine whether to use config settings in the default section,
     *  See also comments around ArgsManager::ArgsManager() below. */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>UseDefaultSection</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ArgsManager</name><operator>&amp;</operator> <name>am</name></expr></argument>, <argument><expr><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><operator>&amp;</operator> <name>arg</name></expr></argument>)</argument_list> <name>EXCLUSIVE_LOCKS_REQUIRED</name><argument_list>(<argument><expr><name><name>am</name><operator>.</operator><name>cs_args</name></name></expr></argument>)</argument_list>
    <argument_list>{
        return <argument><expr><operator>(</operator><name><name>am</name><operator>.</operator><name>m_network</name></name> <operator>==</operator> <name><name>CBaseChainParams</name><operator>::</operator><name>MAIN</name></name> <operator>||</operator> <call><name><name>am</name><operator>.</operator><name>m_network_only_args</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>;
    }</argument_list>

    static <name><name>util</name><operator>::</operator><name>SettingsValue</name></name> <name>Get</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ArgsManager</name><operator>&amp;</operator> <name>am</name></expr></argument>, <argument><expr><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><operator>&amp;</operator> <name>arg</name></expr></argument>)</argument_list>
    <argument_list>{
        <argument><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>am</name><operator>.</operator><name>cs_args</name></name></expr></argument>)</argument_list></call></expr></argument>;
        return <argument><expr><call><name>GetSetting</name><argument_list>(<argument><expr><name><name>am</name><operator>.</operator><name>m_settings</name></name></expr></argument>, <argument><expr><name><name>am</name><operator>.</operator><name>m_network</name></name></expr></argument>, <argument><expr><call><name>SettingName</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>!</operator><call><name>UseDefaultSection</name><argument_list>(<argument><expr><name>am</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>, <comment type="block">/* get_chain_name= */</comment> <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>;
    }</argument_list></decl></decl_stmt>
</public>}</block>;</class>

<comment type="block" format="doxygen">/**
 * Interpret -nofoo as if the user supplied -foo=0.
 *
 * This method also tracks when the -no form was supplied, and if so,
 * checks whether there was a double-negative (-nofoo=0 -&gt; -foo=1).
 *
 * If there was not a double negative, it removes the "no" from the key
 * and returns false.
 *
 * If there was a double negative, it removes "no" from the key, and
 * returns true.
 *
 * If there was no "no", it returns the string value untouched.
 *
 * Where an option was negated can be later checked using the
 * IsArgNegated() method. One use case for this is to have a way to disable
 * options that are not normally boolean (e.g. using -nodebuglogfile to request
 * that debug log output is not sent to any file at all).
 */</comment>

<function><type><specifier>static</specifier> <name><name>util</name><operator>::</operator><name>SettingsValue</name></name></type> <name>InterpretOption</name><parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>section</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">// Split section name from key name for keys like "testnet.foo" or "regtest.bar"</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>option_index</name> <init>= <expr><call><name><name>key</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>option_index</name> <operator>!=</operator> <name><name>std</name><operator>::</operator><name>string</name><operator>::</operator><name>npos</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>section</name> <operator>=</operator> <call><name><name>key</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>option_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>key</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>option_index</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>key</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"no"</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>key</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// Double negatives like -nofoo=0 are supported (but discouraged)</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>InterpretBool</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"Warning: parsed potentially confusing double-negative -%s=%s\n"</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Check settings value validity according to flags.
 *
 * TODO: Add more meaningful error checks here in the future
 * See "here's how the flags are meant to behave" in
 * https://github.com/bitcoin/bitcoin/pull/16097#issuecomment-514627823
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>CheckValid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>util</name><operator>::</operator><name>SettingsValue</name></name><modifier>&amp;</modifier></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>error</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name><name>val</name><operator>.</operator><name>isBool</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name><name>ArgsManager</name><operator>::</operator><name>ALLOW_BOOL</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"Negating of -%s is meaningless and therefore forbidden"</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<constructor><name><name>ArgsManager</name><operator>::</operator><name>ArgsManager</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <comment type="line">// nothing to do</comment>
</block_content>}</block></constructor>

<function><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>&gt;</argument_list></name></type> <name><name>ArgsManager</name><operator>::</operator><name>GetUnsuitableSectionOnlyArgs</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>&gt;</argument_list></name></type> <name>unsuitables</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// if there's no section selected, don't worry</comment>
    <if_stmt><if>if <condition>(<expr><call><name><name>m_network</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>&gt;</argument_list></name> <argument_list>{}</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// if it's okay to use the default section for this network, don't worry</comment>
    <if_stmt><if>if <condition>(<expr><name>m_network</name> <operator>==</operator> <name><name>CBaseChainParams</name><operator>::</operator><name>MAIN</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>&gt;</argument_list></name> <argument_list>{}</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>arg</name> <range>: <expr><name>m_network_only_args</name></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>OnlyHasDefaultSectionSetting</name><argument_list>(<argument><expr><name>m_settings</name></expr></argument>, <argument><expr><name>m_network</name></expr></argument>, <argument><expr><call><name>SettingName</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>unsuitables</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>unsuitables</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>list</name><argument_list type="generic">&lt;<argument><expr><name>SectionInfo</name></expr></argument>&gt;</argument_list></name></type> <name><name>ArgsManager</name><operator>::</operator><name>GetUnrecognizedSections</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <comment type="line">// Section names to be recognized in the config file.</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>&gt;</argument_list></name></type> <name>available_sections</name><argument_list>{
        <argument><expr><name><name>CBaseChainParams</name><operator>::</operator><name>REGTEST</name></name></expr></argument>,
        <argument><expr><name><name>CBaseChainParams</name><operator>::</operator><name>TESTNET</name></name></expr></argument>,
        <argument><expr><name><name>CBaseChainParams</name><operator>::</operator><name>MAIN</name></name></expr></argument>
    }</argument_list></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>list</name><argument_list type="generic">&lt;<argument><expr><name>SectionInfo</name></expr></argument>&gt;</argument_list></name></type> <name>unrecognized</name> <init>= <expr><name>m_config_sections</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>unrecognized</name><operator>.</operator><name>remove_if</name></name><argument_list>(<argument><expr><lambda><capture>[]</capture><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SectionInfo</name><modifier>&amp;</modifier></type> <name>appeared</name></decl></parameter>)</parameter_list><block>{<block_content> <return>return <expr><call><name><name>available_sections</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name><name>appeared</name><operator>.</operator><name>m_name</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name><name>available_sections</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>unrecognized</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>ArgsManager</name><operator>::</operator><name>SelectConfigNetwork</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>network</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>m_network</name> <operator>=</operator> <name>network</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>ArgsManager</name><operator>::</operator><name>ParseParameters</name></name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name><name>argv</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>error</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>m_settings</name><operator>.</operator><name>command_line_options</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>key</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MAC_OSX</name></cpp:ifdef>
        <comment type="line">// At the first time when a user gets the "App downloaded from the</comment>
        <comment type="line">// internet" warning, and clicks the Open button, macOS passes</comment>
        <comment type="line">// a unique process serial number (PSN) as -psn_... command-line</comment>
        <comment type="line">// argument, which we filter out.</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>key</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"-psn_"</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if_stmt><if>if <condition>(<expr><name>key</name> <operator>==</operator> <literal type="string">"-"</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <comment type="line">//bitcoin-tx using stdin</comment>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>val</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>is_index</name> <init>= <expr><call><name><name>key</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>is_index</name> <operator>!=</operator> <name><name>std</name><operator>::</operator><name>string</name><operator>::</operator><name>npos</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name><name>key</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><name>is_index</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>key</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>is_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
        <expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>ToLower</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if_stmt><if>if <condition>(<expr><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <comment type="line">// Transform --foo to -foo</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>key</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>key</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Transform -foo to foo</comment>
        <expr_stmt><expr><call><name><name>key</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>section</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>util</name><operator>::</operator><name>SettingsValue</name></name></type> <name>value</name> <init>= <expr><call><name>InterpretOption</name><argument_list>(<argument><expr><name>section</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>flags</name> <init>= <expr><call><name>FlagsOfKnownArg</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>flags</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckValid</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <comment type="line">// Weird behavior preserved for backwards compatibility: command</comment>
            <comment type="line">// line options with section prefixes are allowed but ignored. It</comment>
            <comment type="line">// would be better if these options triggered the Invalid parameter</comment>
            <comment type="line">// error below.</comment>
            <if_stmt><if>if <condition>(<expr><call><name><name>section</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>m_settings</name><operator>.</operator><name>command_line_options</name><index>[<expr><name>key</name></expr>]</index></name><operator>.</operator><call><name>push_back</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"Invalid parameter -%s"</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="line">// we do not allow -includeconf from command line, so we clear it here</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>success</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>auto</name><operator>*</operator> <name>includes</name> <operator>=</operator> <call><name><name>util</name><operator>::</operator><name>FindKey</name></name><argument_list>(<argument><expr><name><name>m_settings</name><operator>.</operator><name>command_line_options</name></name></expr></argument>, <argument><expr><literal type="string">"includeconf"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>include</name> <range>: <expr><call><name><name>util</name><operator>::</operator><name>SettingsSpan</name></name><argument_list>(<argument><expr><operator>*</operator><name>includes</name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><name>error</name> <operator>+=</operator> <literal type="string">"-includeconf cannot be used from commandline; -includeconf="</literal> <operator>+</operator> <call><name><name>include</name><operator>.</operator><name>get_str</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="string">"\n"</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>int</name></type> <name><name>ArgsManager</name><operator>::</operator><name>FlagsOfKnownArg</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>key</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>arg_map</name> <range>: <expr><name>m_available_args</name></expr></range></decl></init>)</control> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>search</name> <init>= <expr><call><name><name>arg_map</name><operator>.</operator><name>second</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><literal type="char">'-'</literal> <operator>+</operator> <name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>search</name> <operator>!=</operator> <call><name><name>arg_map</name><operator>.</operator><name>second</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><name><name>search</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>m_flags</name></name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name><name>ArgsManager</name><operator>::</operator><name>NONE</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>&gt;</argument_list></name></type> <name><name>ArgsManager</name><operator>::</operator><name>GetArgs</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>strArg</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>ignore_default_section_config</name> <init>= <expr><operator>!</operator><call><name><name>ArgsManagerHelper</name><operator>::</operator><name>UseDefaultSection</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>strArg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>&gt;</argument_list></name></type> <name>result</name></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <name><name>util</name><operator>::</operator><name>SettingsValue</name></name><modifier>&amp;</modifier></type> <name>value</name> <range>:
        <expr><call><name><name>util</name><operator>::</operator><name>GetSettingsList</name></name><argument_list>(<argument><expr><name>m_settings</name></expr></argument>, <argument><expr><name>m_network</name></expr></argument>, <argument><expr><call><name>SettingName</name><argument_list>(<argument><expr><name>strArg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ignore_default_section_config</name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><ternary><condition><expr><call><name><name>value</name><operator>.</operator><name>isFalse</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"0"</literal></expr> </then><else>: <expr><ternary><condition><expr><call><name><name>value</name><operator>.</operator><name>isTrue</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"1"</literal></expr> </then><else>: <expr><call><name><name>value</name><operator>.</operator><name>get_str</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>ArgsManager</name><operator>::</operator><name>IsArgSet</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>strArg</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <return>return <expr><operator>!</operator><call><name><name>ArgsManagerHelper</name><operator>::</operator><name>Get</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>strArg</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>ArgsManager</name><operator>::</operator><name>IsArgNegated</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>strArg</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <return>return <expr><call><name><name>ArgsManagerHelper</name><operator>::</operator><name>Get</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>strArg</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>isFalse</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name><name>ArgsManager</name><operator>::</operator><name>GetArg</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>strArg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>strDefault</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>util</name><operator>::</operator><name>SettingsValue</name></name></type> <name>value</name> <init>= <expr><call><name><name>ArgsManagerHelper</name><operator>::</operator><name>Get</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>strArg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><ternary><condition><expr><call><name><name>value</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>strDefault</name></expr> </then><else>: <expr><ternary><condition><expr><call><name><name>value</name><operator>.</operator><name>isFalse</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"0"</literal></expr> </then><else>: <expr><ternary><condition><expr><call><name><name>value</name><operator>.</operator><name>isTrue</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"1"</literal></expr> </then><else>: <expr><call><name><name>value</name><operator>.</operator><name>get_str</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int64_t</name></type> <name><name>ArgsManager</name><operator>::</operator><name>GetArg</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>strArg</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>nDefault</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>util</name><operator>::</operator><name>SettingsValue</name></name></type> <name>value</name> <init>= <expr><call><name><name>ArgsManagerHelper</name><operator>::</operator><name>Get</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>strArg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><ternary><condition><expr><call><name><name>value</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>nDefault</name></expr> </then><else>: <expr><ternary><condition><expr><call><name><name>value</name><operator>.</operator><name>isFalse</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><ternary><condition><expr><call><name><name>value</name><operator>.</operator><name>isTrue</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><ternary><condition><expr><call><name><name>value</name><operator>.</operator><name>isNum</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name><name>value</name><operator>.</operator><name>get_int64</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>atoi64</name><argument_list>(<argument><expr><call><name><name>value</name><operator>.</operator><name>get_str</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>ArgsManager</name><operator>::</operator><name>GetBoolArg</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>strArg</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fDefault</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>util</name><operator>::</operator><name>SettingsValue</name></name></type> <name>value</name> <init>= <expr><call><name><name>ArgsManagerHelper</name><operator>::</operator><name>Get</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>strArg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><ternary><condition><expr><call><name><name>value</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>fDefault</name></expr> </then><else>: <expr><ternary><condition><expr><call><name><name>value</name><operator>.</operator><name>isBool</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name><name>value</name><operator>.</operator><name>get_bool</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>InterpretBool</name><argument_list>(<argument><expr><call><name><name>value</name><operator>.</operator><name>get_str</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>ArgsManager</name><operator>::</operator><name>SoftSetArg</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>strArg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>strValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsArgSet</name><argument_list>(<argument><expr><name>strArg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>ForceSetArg</name><argument_list>(<argument><expr><name>strArg</name></expr></argument>, <argument><expr><name>strValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>ArgsManager</name><operator>::</operator><name>SoftSetBoolArg</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>strArg</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>fValue</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>SoftSetArg</name><argument_list>(<argument><expr><name>strArg</name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><call><name>SoftSetArg</name><argument_list>(<argument><expr><name>strArg</name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>ArgsManager</name><operator>::</operator><name>ForceSetArg</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>strArg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>strValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>m_settings</name><operator>.</operator><name>forced_settings</name><index>[<expr><call><name>SettingName</name><argument_list>(<argument><expr><name>strArg</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>strValue</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>ArgsManager</name><operator>::</operator><name>AddArg</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>help</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OptionsCategory</name><modifier>&amp;</modifier></type> <name>cat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">// Split arg name from its help param</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>eq_index</name> <init>= <expr><call><name><name>name</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>eq_index</name> <operator>==</operator> <name><name>std</name><operator>::</operator><name>string</name><operator>::</operator><name>npos</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>eq_index</name> <operator>=</operator> <call><name><name>name</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>arg_name</name> <init>= <expr><call><name><name>name</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>eq_index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>, <argument><expr><name>Arg</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>arg_map</name> <init>= <expr><name><name>m_available_args</name><index>[<expr><name>cat</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>ret</name> <init>= <expr><call><name><name>arg_map</name><operator>.</operator><name>emplace</name></name><argument_list>(<argument><expr><name>arg_name</name></expr></argument>, <argument><expr><call><name>Arg</name><argument_list>{<argument><expr><call><name><name>name</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><name>eq_index</name></expr></argument>, <argument><expr><call><name><name>name</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>eq_index</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>help</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>}</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ret</name><operator>.</operator><name>second</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Make sure an insertion actually happened</comment>

    <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name><name>ArgsManager</name><operator>::</operator><name>NETWORK_ONLY</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>m_network_only_args</name><operator>.</operator><name>emplace</name></name><argument_list>(<argument><expr><name>arg_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>ArgsManager</name><operator>::</operator><name>AddHiddenArgs</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>names</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>name</name> <range>: <expr><name>names</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>AddArg</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>ArgsManager</name><operator>::</operator><name>ALLOW_ANY</name></name></expr></argument>, <argument><expr><name><name>OptionsCategory</name><operator>::</operator><name>HIDDEN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name><name>ArgsManager</name><operator>::</operator><name>GetHelpMessage</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>show_debug</name> <init>= <expr><call><name><name>gArgs</name><operator>.</operator><name>GetBoolArg</name></name><argument_list>(<argument><expr><literal type="string">"-help-debug"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>usage</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>arg_map</name> <range>: <expr><name>m_available_args</name></expr></range></decl></init>)</control> <block>{<block_content>
        <switch>switch<condition>(<expr><name><name>arg_map</name><operator>.</operator><name>first</name></name></expr>)</condition> <block>{<block_content>
            <case>case <expr><name><name>OptionsCategory</name><operator>::</operator><name>OPTIONS</name></name></expr>:</case>
                <expr_stmt><expr><name>usage</name> <operator>+=</operator> <call><name>HelpMessageGroup</name><argument_list>(<argument><expr><literal type="string">"Options:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name><name>OptionsCategory</name><operator>::</operator><name>CONNECTION</name></name></expr>:</case>
                <expr_stmt><expr><name>usage</name> <operator>+=</operator> <call><name>HelpMessageGroup</name><argument_list>(<argument><expr><literal type="string">"Connection options:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name><name>OptionsCategory</name><operator>::</operator><name>ZMQ</name></name></expr>:</case>
                <expr_stmt><expr><name>usage</name> <operator>+=</operator> <call><name>HelpMessageGroup</name><argument_list>(<argument><expr><literal type="string">"ZeroMQ notification options:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name><name>OptionsCategory</name><operator>::</operator><name>DEBUG_TEST</name></name></expr>:</case>
                <expr_stmt><expr><name>usage</name> <operator>+=</operator> <call><name>HelpMessageGroup</name><argument_list>(<argument><expr><literal type="string">"Debugging/Testing options:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name><name>OptionsCategory</name><operator>::</operator><name>NODE_RELAY</name></name></expr>:</case>
                <expr_stmt><expr><name>usage</name> <operator>+=</operator> <call><name>HelpMessageGroup</name><argument_list>(<argument><expr><literal type="string">"Node relay options:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name><name>OptionsCategory</name><operator>::</operator><name>BLOCK_CREATION</name></name></expr>:</case>
                <expr_stmt><expr><name>usage</name> <operator>+=</operator> <call><name>HelpMessageGroup</name><argument_list>(<argument><expr><literal type="string">"Block creation options:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name><name>OptionsCategory</name><operator>::</operator><name>RPC</name></name></expr>:</case>
                <expr_stmt><expr><name>usage</name> <operator>+=</operator> <call><name>HelpMessageGroup</name><argument_list>(<argument><expr><literal type="string">"RPC server options:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name><name>OptionsCategory</name><operator>::</operator><name>WALLET</name></name></expr>:</case>
                <expr_stmt><expr><name>usage</name> <operator>+=</operator> <call><name>HelpMessageGroup</name><argument_list>(<argument><expr><literal type="string">"Wallet options:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name><name>OptionsCategory</name><operator>::</operator><name>WALLET_DEBUG_TEST</name></name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name>show_debug</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>usage</name> <operator>+=</operator> <call><name>HelpMessageGroup</name><argument_list>(<argument><expr><literal type="string">"Wallet debugging/testing options:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><name><name>OptionsCategory</name><operator>::</operator><name>CHAINPARAMS</name></name></expr>:</case>
                <expr_stmt><expr><name>usage</name> <operator>+=</operator> <call><name>HelpMessageGroup</name><argument_list>(<argument><expr><literal type="string">"Chain selection options:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name><name>OptionsCategory</name><operator>::</operator><name>GUI</name></name></expr>:</case>
                <expr_stmt><expr><name>usage</name> <operator>+=</operator> <call><name>HelpMessageGroup</name><argument_list>(<argument><expr><literal type="string">"UI Options:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name><name>OptionsCategory</name><operator>::</operator><name>COMMANDS</name></name></expr>:</case>
                <expr_stmt><expr><name>usage</name> <operator>+=</operator> <call><name>HelpMessageGroup</name><argument_list>(<argument><expr><literal type="string">"Commands:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name><name>OptionsCategory</name><operator>::</operator><name>REGISTER_COMMANDS</name></name></expr>:</case>
                <expr_stmt><expr><name>usage</name> <operator>+=</operator> <call><name>HelpMessageGroup</name><argument_list>(<argument><expr><literal type="string">"Register Commands:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <break>break;</break>
        </block_content>}</block></switch>

        <comment type="line">// When we get to the hidden options, stop</comment>
        <if_stmt><if>if <condition>(<expr><name><name>arg_map</name><operator>.</operator><name>first</name></name> <operator>==</operator> <name><name>OptionsCategory</name><operator>::</operator><name>HIDDEN</name></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

        <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>arg</name> <range>: <expr><name><name>arg_map</name><operator>.</operator><name>second</name></name></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>show_debug</name> <operator>||</operator> <operator>!</operator><operator>(</operator><name><name>arg</name><operator>.</operator><name>second</name><operator>.</operator><name>m_flags</name></name> <operator>&amp;</operator> <name><name>ArgsManager</name><operator>::</operator><name>DEBUG_ONLY</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>name</name></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>arg</name><operator>.</operator><name>second</name><operator>.</operator><name>m_help_param</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>arg</name><operator>.</operator><name>first</name></name></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>arg</name><operator>.</operator><name>first</name></name> <operator>+</operator> <name><name>arg</name><operator>.</operator><name>second</name><operator>.</operator><name>m_help_param</name></name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><name>usage</name> <operator>+=</operator> <call><name>HelpMessageOpt</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>arg</name><operator>.</operator><name>second</name><operator>.</operator><name>m_help_text</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>
    <return>return <expr><name>usage</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>HelpRequested</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ArgsManager</name><modifier>&amp;</modifier></type> <name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name><name>args</name><operator>.</operator><name>IsArgSet</name></name><argument_list>(<argument><expr><literal type="string">"-?"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>args</name><operator>.</operator><name>IsArgSet</name></name><argument_list>(<argument><expr><literal type="string">"-h"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>args</name><operator>.</operator><name>IsArgSet</name></name><argument_list>(<argument><expr><literal type="string">"-help"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>args</name><operator>.</operator><name>IsArgSet</name></name><argument_list>(<argument><expr><literal type="string">"-help-debug"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>SetupHelpOptions</name><parameter_list>(<parameter><decl><type><name>ArgsManager</name><modifier>&amp;</modifier></type> <name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name><name>args</name><operator>.</operator><name>AddArg</name></name><argument_list>(<argument><expr><literal type="string">"-?"</literal></expr></argument>, <argument><expr><literal type="string">"Print this help message and exit"</literal></expr></argument>, <argument><expr><name><name>ArgsManager</name><operator>::</operator><name>ALLOW_ANY</name></name></expr></argument>, <argument><expr><name><name>OptionsCategory</name><operator>::</operator><name>OPTIONS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>args</name><operator>.</operator><name>AddHiddenArgs</name></name><argument_list>(<argument><expr><block>{<expr><literal type="string">"-h"</literal></expr>, <expr><literal type="string">"-help"</literal></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>screenWidth</name> <init>= <expr><literal type="number">79</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>optIndent</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>msgIndent</name> <init>= <expr><literal type="number">7</literal></expr></init></decl>;</decl_stmt>

<function><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>HelpMessageGroup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>message</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">"\n\n"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>HelpMessageOpt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>option</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>message</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><name>optIndent</name></expr></argument>,<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call> <operator>+</operator> <call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call> <operator>+</operator>
           <call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call> <operator>+</operator> <call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><name>msgIndent</name></expr></argument>,<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call> <operator>+</operator>
           <call><name>FormatParagraph</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>screenWidth</name> <operator>-</operator> <name>msgIndent</name></expr></argument>, <argument><expr><name>msgIndent</name></expr></argument>)</argument_list></call> <operator>+</operator>
           <call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">"\n\n"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>std</name><operator>::</operator><name>string</name></name></type> <name>FormatException</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>exception</name></name><modifier>*</modifier></type> <name>pex</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>pszThread</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <decl_stmt><decl><type><name>char</name></type> <name><name>pszModule</name><index>[<expr><name>MAX_PATH</name></expr>]</index></name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>GetModuleFileNameA</name><argument_list>(<argument><expr><literal type="null">nullptr</literal></expr></argument>, <argument><expr><name>pszModule</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pszModule</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>pszModule</name> <init>= <expr><literal type="string">"bitcoin"</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name>pex</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>strprintf</name><argument_list>(
            <argument><expr><literal type="string">"EXCEPTION: %s       \n%s       \n%s in %s       \n"</literal></expr></argument>, <argument><expr><typeid>typeid<argument_list>(<argument><expr><operator>*</operator><name>pex</name></expr></argument>)</argument_list></typeid><operator>.</operator><call><name>name</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pex</name><operator>-&gt;</operator><name>what</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pszModule</name></expr></argument>, <argument><expr><name>pszThread</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><call><name>strprintf</name><argument_list>(
            <argument><expr><literal type="string">"UNKNOWN EXCEPTION       \n%s in %s       \n"</literal></expr></argument>, <argument><expr><name>pszModule</name></expr></argument>, <argument><expr><name>pszThread</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>PrintExceptionContinue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>exception</name></name><modifier>*</modifier></type> <name>pex</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>pszThread</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>message</name> <init>= <expr><call><name>FormatException</name><argument_list>(<argument><expr><name>pex</name></expr></argument>, <argument><expr><name>pszThread</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"\n\n************************\n%s\n"</literal></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>tfm</name><operator>::</operator><name>format</name></name><argument_list>(<argument><expr><name><name>std</name><operator>::</operator><name>cerr</name></name></expr></argument>, <argument><expr><literal type="string">"\n\n************************\n%s\n"</literal></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name><name>fs</name><operator>::</operator><name>path</name></name></type> <name>GetDefaultDataDir</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <comment type="line">// Windows &lt; Vista: C:\Documents and Settings\Username\Application Data\Bitcoin</comment>
    <comment type="line">// Windows &gt;= Vista: C:\Users\Username\AppData\Roaming\Bitcoin</comment>
    <comment type="line">// Mac: ~/Library/Application Support/Bitcoin</comment>
    <comment type="line">// Unix: ~/.bitcoin</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <comment type="line">// Windows</comment>
    <return>return <expr><call><name>GetSpecialFolderPath</name><argument_list>(<argument><expr><name>CSIDL_APPDATA</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="string">"Bitcoin"</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name><name>fs</name><operator>::</operator><name>path</name></name></type> <name>pathRet</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>pszHome</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"HOME"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>pszHome</name> <operator>==</operator> <literal type="null">nullptr</literal> <operator>||</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>pszHome</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>pathRet</name> <operator>=</operator> <call><name><name>fs</name><operator>::</operator><name>path</name></name><argument_list>(<argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>pathRet</name> <operator>=</operator> <call><name><name>fs</name><operator>::</operator><name>path</name></name><argument_list>(<argument><expr><name>pszHome</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MAC_OSX</name></cpp:ifdef>
    <comment type="line">// Mac</comment>
    <return>return <expr><name>pathRet</name> <operator>/</operator> <literal type="string">"Library/Application Support/Bitcoin"</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="line">// Unix</comment>
    <return>return <expr><name>pathRet</name> <operator>/</operator> <literal type="string">".bitcoin"</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>fs</name><operator>::</operator><name>path</name></name></type> <name>g_blocks_path_cache_net_specific</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>fs</name><operator>::</operator><name>path</name></name></type> <name>pathCached</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>fs</name><operator>::</operator><name>path</name></name></type> <name>pathCachedNetSpecific</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>RecursiveMutex</name></type> <name>csPathCached</name></decl>;</decl_stmt>

<function><type><specifier>const</specifier> <name><name>fs</name><operator>::</operator><name>path</name></name> <modifier>&amp;</modifier></type><name>GetBlocksDir</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>csPathCached</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>fs</name><operator>::</operator><name>path</name></name> <modifier>&amp;</modifier></type><name>path</name> <init>= <expr><name>g_blocks_path_cache_net_specific</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// Cache the path to avoid calling fs::create_directories on every call of</comment>
    <comment type="line">// this function</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>path</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>path</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name><name>gArgs</name><operator>.</operator><name>IsArgSet</name></name><argument_list>(<argument><expr><literal type="string">"-blocksdir"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name><name>fs</name><operator>::</operator><name>system_complete</name></name><argument_list>(<argument><expr><call><name><name>gArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-blocksdir"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>fs</name><operator>::</operator><name>is_directory</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>path</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
            <return>return <expr><name>path</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>GetDataDir</name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>path</name> <operator>/=</operator> <call><name>BaseParams</name><argument_list>()</argument_list></call><operator>.</operator><call><name>DataDir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>path</name> <operator>/=</operator> <literal type="string">"blocks"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>fs</name><operator>::</operator><name>create_directories</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>path</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name><name>fs</name><operator>::</operator><name>path</name></name> <modifier>&amp;</modifier></type><name>GetDataDir</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>fNetSpecific</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>csPathCached</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>fs</name><operator>::</operator><name>path</name></name> <modifier>&amp;</modifier></type><name>path</name> <init>= <expr><ternary><condition><expr><name>fNetSpecific</name></expr> ?</condition><then> <expr><name>pathCachedNetSpecific</name></expr> </then><else>: <expr><name>pathCached</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <comment type="line">// Cache the path to avoid calling fs::create_directories on every call of</comment>
    <comment type="line">// this function</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>path</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>path</name></expr>;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>datadir</name> <init>= <expr><call><name><name>gArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-datadir"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>datadir</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name><name>fs</name><operator>::</operator><name>system_complete</name></name><argument_list>(<argument><expr><name>datadir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>fs</name><operator>::</operator><name>is_directory</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>path</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
            <return>return <expr><name>path</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>GetDefaultDataDir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>fNetSpecific</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>path</name> <operator>/=</operator> <call><name>BaseParams</name><argument_list>()</argument_list></call><operator>.</operator><call><name>DataDir</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name><name>fs</name><operator>::</operator><name>create_directories</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="line">// This is the first run, create wallets subdirectory too</comment>
        <expr_stmt><expr><call><name><name>fs</name><operator>::</operator><name>create_directories</name></name><argument_list>(<argument><expr><name>path</name> <operator>/</operator> <literal type="string">"wallets"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>path</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>CheckDataDirOption</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>datadir</name> <init>= <expr><call><name><name>gArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-datadir"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name><name>datadir</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>fs</name><operator>::</operator><name>is_directory</name></name><argument_list>(<argument><expr><call><name><name>fs</name><operator>::</operator><name>system_complete</name></name><argument_list>(<argument><expr><name>datadir</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>ClearDatadirCache</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>csPathCached</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pathCached</name> <operator>=</operator> <call><name><name>fs</name><operator>::</operator><name>path</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pathCachedNetSpecific</name> <operator>=</operator> <call><name><name>fs</name><operator>::</operator><name>path</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>g_blocks_path_cache_net_specific</name> <operator>=</operator> <call><name><name>fs</name><operator>::</operator><name>path</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name><name>fs</name><operator>::</operator><name>path</name></name></type> <name>GetConfigFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>confPath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>AbsPathForConfigVal</name><argument_list>(<argument><expr><call><name><name>fs</name><operator>::</operator><name>path</name></name><argument_list>(<argument><expr><name>confPath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>std</name><operator>::</operator><name>string</name></name></type> <name>TrimString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name><operator>::</operator><name>size_type</name></name></type> <name>front</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>find_first_not_of</name></name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>front</name> <operator>==</operator> <name><name>std</name><operator>::</operator><name>string</name><operator>::</operator><name>npos</name></name></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name><operator>::</operator><name>size_type</name></name></type> <name>end</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>find_last_not_of</name></name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name><name>str</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><name>front</name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>front</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>GetConfigOptions</name><parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>istream</name></name><modifier>&amp;</modifier></type> <name>stream</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>filepath</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>error</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>pair</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>options</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>list</name><argument_list type="generic">&lt;<argument><expr><name>SectionInfo</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>sections</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>str</name></decl>, <decl><type ref="prev"/><name>prefix</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name><operator>::</operator><name>size_type</name></name></type> <name>pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>linenr</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><call><name><name>std</name><operator>::</operator><name>getline</name></name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type> <name>used_hash</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pos</name> <operator>=</operator> <call><name><name>str</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><literal type="char">'#'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name><name>std</name><operator>::</operator><name>string</name><operator>::</operator><name>npos</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>str</name> <operator>=</operator> <call><name><name>str</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>used_hash</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <specifier>static</specifier> <name><name>std</name><operator>::</operator><name>string</name></name></type> <name>pattern</name> <init>= <expr><literal type="string">" \t\r\n"</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>TrimString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>str</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><call><name><name>str</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="char">'['</literal> <operator>&amp;&amp;</operator> <operator>*</operator><call><name><name>str</name><operator>.</operator><name>rbegin</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="char">']'</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name></type> <name>section</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>str</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>sections</name><operator>.</operator><name>emplace_back</name></name><argument_list>(<argument><expr><call><name>SectionInfo</name><argument_list>{<argument><expr><name>section</name></expr></argument>, <argument><expr><name>filepath</name></expr></argument>, <argument><expr><name>linenr</name></expr></argument>}</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>prefix</name> <operator>=</operator> <name>section</name> <operator>+</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><call><name><name>str</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"parse error on line %i: %s, options in configuration file must be specified without leading -"</literal></expr></argument>, <argument><expr><name>linenr</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>pos</name> <operator>=</operator> <call><name><name>str</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name><name>std</name><operator>::</operator><name>string</name><operator>::</operator><name>npos</name></name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>name</name> <init>= <expr><name>prefix</name> <operator>+</operator> <call><name>TrimString</name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>value</name> <init>= <expr><call><name>TrimString</name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>used_hash</name> <operator>&amp;&amp;</operator> <call><name><name>name</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><literal type="string">"rpcpassword"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>std</name><operator>::</operator><name>string</name><operator>::</operator><name>npos</name></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"parse error on line %i, using # in rpcpassword can be ambiguous and should be avoided"</literal></expr></argument>, <argument><expr><name>linenr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name><name>options</name><operator>.</operator><name>emplace_back</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pos</name> <operator>=</operator> <call><name><name>name</name><operator>.</operator><name>rfind</name></name><argument_list>(<argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name><name>std</name><operator>::</operator><name>string</name><operator>::</operator><name>npos</name></name> <operator>&amp;&amp;</operator> <call><name><name>prefix</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>pos</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>sections</name><operator>.</operator><name>emplace_back</name></name><argument_list>(<argument><expr><call><name>SectionInfo</name><argument_list>{<argument><expr><call><name><name>name</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>filepath</name></expr></argument>, <argument><expr><name>linenr</name></expr></argument>}</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"parse error on line %i: %s"</literal></expr></argument>, <argument><expr><name>linenr</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>str</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name><name>str</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"no"</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>error</name> <operator>+=</operator> <call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">", if you intended to specify a negated option, use %s=1 instead"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>++</operator><name>linenr</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>ArgsManager</name><operator>::</operator><name>ReadConfigStream</name></name><parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>istream</name></name><modifier>&amp;</modifier></type> <name>stream</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>filepath</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>error</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ignore_invalid_keys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>pair</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>options</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetConfigOptions</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>filepath</name></expr></argument>, <argument><expr><name>error</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>m_config_sections</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>pair</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>option</name> <range>: <expr><name>options</name></expr></range></decl></init>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>section</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>key</name> <init>= <expr><name><name>option</name><operator>.</operator><name>first</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>util</name><operator>::</operator><name>SettingsValue</name></name></type> <name>value</name> <init>= <expr><call><name>InterpretOption</name><argument_list>(<argument><expr><name>section</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>option</name><operator>.</operator><name>second</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>flags</name> <init>= <expr><call><name>FlagsOfKnownArg</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>flags</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckValid</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>m_settings</name><operator>.</operator><name>ro_config</name><index>[<expr><name>section</name></expr>]</index><index>[<expr><name>key</name></expr>]</index></name><operator>.</operator><call><name>push_back</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>ignore_invalid_keys</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"Ignoring unknown configuration value %s\n"</literal></expr></argument>, <argument><expr><name><name>option</name><operator>.</operator><name>first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"Invalid configuration value %s"</literal></expr></argument>, <argument><expr><name><name>option</name><operator>.</operator><name>first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>ArgsManager</name><operator>::</operator><name>ReadConfigFiles</name></name><parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>error</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ignore_invalid_keys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>m_settings</name><operator>.</operator><name>ro_config</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>m_config_sections</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <decl_stmt><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name></type> <name>confPath</name> <init>= <expr><call><name>GetArg</name><argument_list>(<argument><expr><literal type="string">"-conf"</literal></expr></argument>, <argument><expr><name>BITCOIN_CONF_FILENAME</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>fsbridge</name><operator>::</operator><name>ifstream</name></name></type> <name>stream</name><argument_list>(<argument><expr><call><name>GetConfigFile</name><argument_list>(<argument><expr><name>confPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

    <comment type="line">// ok to not have a config file</comment>
    <if_stmt><if>if <condition>(<expr><call><name><name>stream</name><operator>.</operator><name>good</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReadConfigStream</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>confPath</name></expr></argument>, <argument><expr><name>error</name></expr></argument>, <argument><expr><name>ignore_invalid_keys</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <comment type="line">// `-includeconf` cannot be included in the command line arguments except</comment>
        <comment type="line">// as `-noincludeconf` (which indicates that no conf file should be used).</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>use_conf_file</name><argument_list>{<argument><expr><literal type="boolean">true</literal></expr></argument>}</argument_list></decl>;</decl_stmt>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>auto</name><operator>*</operator> <name>includes</name> <operator>=</operator> <call><name><name>util</name><operator>::</operator><name>FindKey</name></name><argument_list>(<argument><expr><name><name>m_settings</name><operator>.</operator><name>command_line_options</name></name></expr></argument>, <argument><expr><literal type="string">"includeconf"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <comment type="line">// ParseParameters() fails if a non-negated -includeconf is passed on the command-line</comment>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>util</name><operator>::</operator><name>SettingsSpan</name></name><argument_list>(<argument><expr><operator>*</operator><name>includes</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>last_negated</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>use_conf_file</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        <if_stmt><if>if <condition>(<expr><name>use_conf_file</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>chain_id</name> <init>= <expr><call><name>GetChainName</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>&gt;</argument_list></name></type> <name>conf_file_names</name></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>auto</name></type> <name>add_includes</name> <init>= <expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>network</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>skip</name> <init>= <expr><literal type="number">0</literal></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
                <decl_stmt><decl><type><name>size_t</name></type> <name>num_values</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>auto</name><operator>*</operator> <name>section</name> <operator>=</operator> <call><name><name>util</name><operator>::</operator><name>FindKey</name></name><argument_list>(<argument><expr><name><name>m_settings</name><operator>.</operator><name>ro_config</name></name></expr></argument>, <argument><expr><name>network</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>auto</name><operator>*</operator> <name>values</name> <operator>=</operator> <call><name><name>util</name><operator>::</operator><name>FindKey</name></name><argument_list>(<argument><expr><operator>*</operator><name>section</name></expr></argument>, <argument><expr><literal type="string">"includeconf"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>max</name></name><argument_list>(<argument><expr><name>skip</name></expr></argument>, <argument><expr><call><name><name>util</name><operator>::</operator><name>SettingsSpan</name></name><argument_list>(<argument><expr><operator>*</operator><name>values</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>negated</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>values</name><operator>-&gt;</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
                            <expr_stmt><expr><call><name><name>conf_file_names</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>values</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></for>
                        <expr_stmt><expr><name>num_values</name> <operator>=</operator> <call><name><name>values</name><operator>-&gt;</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <return>return <expr><name>num_values</name></expr>;</return>
            </block_content>}</block></lambda></expr></init></decl>;</decl_stmt>

            <comment type="line">// We haven't set m_network yet (that happens in SelectParams()), so manually check</comment>
            <comment type="line">// for network.includeconf args.</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>chain_includes</name> <init>= <expr><call><name>add_includes</name><argument_list>(<argument><expr><name>chain_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>default_includes</name> <init>= <expr><call><name>add_includes</name><argument_list>(<argument><expr><block>{}</block></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>conf_file_name</name> <range>: <expr><name>conf_file_names</name></expr></range></decl></init>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name><name>fsbridge</name><operator>::</operator><name>ifstream</name></name></type> <name>conf_file_stream</name><argument_list>(<argument><expr><call><name>GetConfigFile</name><argument_list>(<argument><expr><name>conf_file_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>conf_file_stream</name><operator>.</operator><name>good</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReadConfigStream</name><argument_list>(<argument><expr><name>conf_file_stream</name></expr></argument>, <argument><expr><name>conf_file_name</name></expr></argument>, <argument><expr><name>error</name></expr></argument>, <argument><expr><name>ignore_invalid_keys</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"Included configuration file %s\n"</literal></expr></argument>, <argument><expr><name>conf_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><name>error</name> <operator>=</operator> <literal type="string">"Failed to include configuration file "</literal> <operator>+</operator> <name>conf_file_name</name></expr>;</expr_stmt>
                    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></for>

            <comment type="line">// Warn about recursive -includeconf</comment>
            <expr_stmt><expr><call><name><name>conf_file_names</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>add_includes</name><argument_list>(<argument><expr><name>chain_id</name></expr></argument>, <comment type="block">/* skip= */</comment> <argument><expr><name>chain_includes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>add_includes</name><argument_list>(<argument><expr><block>{}</block></expr></argument>, <comment type="block">/* skip= */</comment> <argument><expr><name>default_includes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>chain_id_final</name> <init>= <expr><call><name>GetChainName</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>chain_id_final</name> <operator>!=</operator> <name>chain_id</name></expr>)</condition> <block>{<block_content>
                <comment type="line">// Also warn about recursive includeconf for the chain that was specified in one of the includeconfs</comment>
                <expr_stmt><expr><call><name>add_includes</name><argument_list>(<argument><expr><name>chain_id_final</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <for>for <control>(<init><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>conf_file_name</name> <range>: <expr><name>conf_file_names</name></expr></range></decl></init>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name><name>tfm</name><operator>::</operator><name>format</name></name><argument_list>(<argument><expr><name><name>std</name><operator>::</operator><name>cerr</name></name></expr></argument>, <argument><expr><literal type="string">"warning: -includeconf cannot be used from included files; ignoring -includeconf=%s\n"</literal></expr></argument>, <argument><expr><name>conf_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// If datadir is changed in .conf file:</comment>
    <expr_stmt><expr><call><name>ClearDatadirCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckDataDirOption</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"specified data directory \"%s\" does not exist."</literal></expr></argument>, <argument><expr><call><name><name>gArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-datadir"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name><name>ArgsManager</name><operator>::</operator><name>GetChainName</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <decl_stmt><decl><type><name>auto</name></type> <name>get_net</name> <init>= <expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>util</name><operator>::</operator><name>SettingsValue</name></name></type> <name>value</name> <init>= <expr><call><name>GetSetting</name><argument_list>(<argument><expr><name>m_settings</name></expr></argument>, <comment type="block">/* section= */</comment> <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><call><name>SettingName</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>,
                                               <comment type="block">/* ignore_default_section_config= */</comment> <argument><expr><literal type="boolean">false</literal></expr></argument>,
                                               <comment type="block">/* get_chain_name= */</comment> <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><ternary><condition><expr><call><name><name>value</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="boolean">false</literal></expr> </then><else>: <expr><ternary><condition><expr><call><name><name>value</name><operator>.</operator><name>isBool</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name><name>value</name><operator>.</operator><name>get_bool</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>InterpretBool</name><argument_list>(<argument><expr><call><name><name>value</name><operator>.</operator><name>get_str</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></else></ternary></expr>;</return>
    </block_content>}</block></lambda></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>fRegTest</name> <init>= <expr><call><name>get_net</name><argument_list>(<argument><expr><literal type="string">"-regtest"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>fTestNet</name> <init>= <expr><call><name>get_net</name><argument_list>(<argument><expr><literal type="string">"-testnet"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>is_chain_arg_set</name> <init>= <expr><call><name>IsArgSet</name><argument_list>(<argument><expr><literal type="string">"-chain"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name>is_chain_arg_set</name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><name>fRegTest</name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><name>fTestNet</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name><name>std</name><operator>::</operator><name>runtime_error</name></name><argument_list>(<argument><expr><literal type="string">"Invalid combination of -regtest, -testnet and -chain. Can use at most one."</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>fRegTest</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name><name>CBaseChainParams</name><operator>::</operator><name>REGTEST</name></name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>fTestNet</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name><name>CBaseChainParams</name><operator>::</operator><name>TESTNET</name></name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>GetArg</name><argument_list>(<argument><expr><literal type="string">"-chain"</literal></expr></argument>, <argument><expr><name><name>CBaseChainParams</name><operator>::</operator><name>MAIN</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>RenameOver</name><parameter_list>(<parameter><decl><type><name><name>fs</name><operator>::</operator><name>path</name></name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name><name>fs</name><operator>::</operator><name>path</name></name></type> <name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <return>return <expr><call><name>MoveFileExW</name><argument_list>(<argument><expr><call><name><name>src</name><operator>.</operator><name>wstring</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>c_str</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>dest</name><operator>.</operator><name>wstring</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>c_str</name><argument_list>()</argument_list></call></expr></argument>,
                       <argument><expr><name>MOVEFILE_REPLACE_EXISTING</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>rename</name></name><argument_list>(<argument><expr><call><name><name>src</name><operator>.</operator><name>string</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>c_str</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>dest</name><operator>.</operator><name>string</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>c_str</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><operator>(</operator><name>rc</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WIN32 */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Ignores exceptions thrown by Boost's create_directories if the requested directory exists.
 * Specifically handles case where path p exists, but it wasn't possible for the user to
 * write to the parent directory.
 */</comment>
<function><type><name>bool</name></type> <name>TryCreateDirectories</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>fs</name><operator>::</operator><name>path</name></name><modifier>&amp;</modifier></type> <name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <try>try
    <block>{<block_content>
        <return>return <expr><call><name><name>fs</name><operator>::</operator><name>create_directories</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>fs</name><operator>::</operator><name>filesystem_error</name></name><modifier>&amp;</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>fs</name><operator>::</operator><name>exists</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name><name>fs</name><operator>::</operator><name>is_directory</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <throw>throw;</throw></block_content></block></if></if_stmt>
    </block_content>}</block></catch></try>

    <comment type="line">// create_directories didn't create the directory, it had to have existed already</comment>
    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>FileCommit</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>fflush</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <comment type="line">// harmless if redundantly called</comment>
        <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"%s: fflush failed: %d\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <decl_stmt><decl><type><name>HANDLE</name></type> <name>hFile</name> <init>= <expr><operator>(</operator><name>HANDLE</name><operator>)</operator><call><name>_get_osfhandle</name><argument_list>(<argument><expr><call><name>_fileno</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>FlushFileBuffers</name><argument_list>(<argument><expr><name>hFile</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"%s: FlushFileBuffers failed: %d\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__NetBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><call><name>fdatasync</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EINVAL</name></expr>)</condition> <block>{<block_content> <comment type="line">// Ignore EINVAL for filesystems that don't support sync</comment>
        <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"%s: fdatasync failed: %d\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MAC_OSX</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>F_FULLFSYNC</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <if_stmt><if>if <condition>(<expr><call><name>fcntl</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>F_FULLFSYNC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content> <comment type="line">// Manpage says "value other than -1" is returned on success</comment>
        <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"%s: fcntl F_FULLFSYNC failed: %d\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><call><name>fsync</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EINVAL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"%s: fsync failed: %d\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>TruncateFile</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <return>return <expr><call><name>_chsize</name><argument_list>(<argument><expr><call><name>_fileno</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><call><name>ftruncate</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * this function tries to raise the file descriptor limit to the requested number.
 * It returns the actual file descriptor limit (which may be more or less than nMinFD)
 */</comment>
<function><type><name>int</name></type> <name>RaiseFileDescriptorLimit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nMinFD</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <return>return <expr><literal type="number">2048</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name><name>struct</name> <name>rlimit</name></name></type> <name>limitFD</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>getrlimit</name><argument_list>(<argument><expr><name>RLIMIT_NOFILE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>limitFD</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>limitFD</name><operator>.</operator><name>rlim_cur</name></name> <operator>&lt;</operator> <operator>(</operator><name>rlim_t</name><operator>)</operator><name>nMinFD</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>limitFD</name><operator>.</operator><name>rlim_cur</name></name> <operator>=</operator> <name>nMinFD</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>limitFD</name><operator>.</operator><name>rlim_cur</name></name> <operator>&gt;</operator> <name><name>limitFD</name><operator>.</operator><name>rlim_max</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>limitFD</name><operator>.</operator><name>rlim_cur</name></name> <operator>=</operator> <name><name>limitFD</name><operator>.</operator><name>rlim_max</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>setrlimit</name><argument_list>(<argument><expr><name>RLIMIT_NOFILE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>limitFD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>getrlimit</name><argument_list>(<argument><expr><name>RLIMIT_NOFILE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>limitFD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name><name>limitFD</name><operator>.</operator><name>rlim_cur</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>nMinFD</name></expr>;</return> <comment type="line">// getrlimit failed, assume it's fine</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * this function tries to make a particular range of a file allocated (corresponding to disk space)
 * it is advisory, and the range specified in the arguments will never contain live data
 */</comment>
<function><type><name>void</name></type> <name>AllocateFileRange</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="line">// Windows-specific version</comment>
    <decl_stmt><decl><type><name>HANDLE</name></type> <name>hFile</name> <init>= <expr><operator>(</operator><name>HANDLE</name><operator>)</operator><call><name>_get_osfhandle</name><argument_list>(<argument><expr><call><name>_fileno</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LARGE_INTEGER</name></type> <name>nFileSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>nEndPos</name> <init>= <expr><operator>(</operator><name>int64_t</name><operator>)</operator><name>offset</name> <operator>+</operator> <name>length</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>nFileSize</name><operator>.</operator><name>u</name><operator>.</operator><name>LowPart</name></name> <operator>=</operator> <name>nEndPos</name> <operator>&amp;</operator> <literal type="number">0xFFFFFFFF</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nFileSize</name><operator>.</operator><name>u</name><operator>.</operator><name>HighPart</name></name> <operator>=</operator> <name>nEndPos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetFilePointerEx</name><argument_list>(<argument><expr><name>hFile</name></expr></argument>, <argument><expr><name>nFileSize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FILE_BEGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetEndOfFile</name><argument_list>(<argument><expr><name>hFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MAC_OSX</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <comment type="line">// OSX specific version</comment>
    <decl_stmt><decl><type><name>fstore_t</name></type> <name>fst</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>fst</name><operator>.</operator><name>fst_flags</name></name> <operator>=</operator> <name>F_ALLOCATECONTIG</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fst</name><operator>.</operator><name>fst_posmode</name></name> <operator>=</operator> <name>F_PEOFPOSMODE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fst</name><operator>.</operator><name>fst_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fst</name><operator>.</operator><name>fst_length</name></name> <operator>=</operator> <operator>(</operator><name>off_t</name><operator>)</operator><name>offset</name> <operator>+</operator> <name>length</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fst</name><operator>.</operator><name>fst_bytesalloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>fcntl</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>F_PREALLOCATE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fst</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>fst</name><operator>.</operator><name>fst_flags</name></name> <operator>=</operator> <name>F_ALLOCATEALL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fcntl</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>F_PREALLOCATE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ftruncate</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>fst</name><operator>.</operator><name>fst_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="line">// Version using posix_fallocate</comment>
    <decl_stmt><decl><type><name>off_t</name></type> <name>nEndPos</name> <init>= <expr><operator>(</operator><name>off_t</name><operator>)</operator><name>offset</name> <operator>+</operator> <name>length</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>posix_fallocate</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nEndPos</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="line">// Fallback version</comment>
    <comment type="line">// TODO: just write one byte per block</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">65536</literal></expr>]</index></name> <init>= <expr><block>{}</block></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>fseek</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <while>while <condition>(<expr><name>length</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>now</name> <init>= <expr><literal type="number">65536</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>length</name> <operator>&lt;</operator> <name>now</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>now</name> <operator>=</operator> <name>length</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// allowed to fail; this function is advisory anyway</comment>
        <expr_stmt><expr><name>length</name> <operator>-=</operator> <name>now</name></expr>;</expr_stmt>
    </block_content>}</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<function><type><name><name>fs</name><operator>::</operator><name>path</name></name></type> <name>GetSpecialFolderPath</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nFolder</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fCreate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>WCHAR</name></type> <name><name>pszPath</name><index>[<expr><name>MAX_PATH</name></expr>]</index></name> <init>= <expr><literal type="string">L""</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>SHGetSpecialFolderPathW</name><argument_list>(<argument><expr><literal type="null">nullptr</literal></expr></argument>, <argument><expr><name>pszPath</name></expr></argument>, <argument><expr><name>nFolder</name></expr></argument>, <argument><expr><name>fCreate</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><call><name><name>fs</name><operator>::</operator><name>path</name></name><argument_list>(<argument><expr><name>pszPath</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"SHGetSpecialFolderPathW() failed, could not obtain requested path.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name><name>fs</name><operator>::</operator><name>path</name></name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_SYSTEM</name></expr></cpp:if>
<function><type><name>void</name></type> <name>runCommand</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>strCommand</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name><name>strCommand</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
    <decl_stmt><decl><type><name>int</name></type> <name>nErr</name> <init>= <expr><call><name><operator>::</operator><name>system</name></name><argument_list>(<argument><expr><call><name><name>strCommand</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>int</name></type> <name>nErr</name> <init>= <expr><call><name><operator>::</operator><name>_wsystem</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>wstring_convert</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>codecvt_utf8_utf16</name><argument_list type="generic">&lt;<argument><expr><name>wchar_t</name></expr></argument>&gt;</argument_list></name></expr></argument>,<argument><expr><name>wchar_t</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>.</operator><call><name>from_bytes</name><argument_list>(<argument><expr><name>strCommand</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>c_str</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name>nErr</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"runCommand error: system(%s) returned %d\n"</literal></expr></argument>, <argument><expr><name>strCommand</name></expr></argument>, <argument><expr><name>nErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name>SetupEnvironment</name><parameter_list>()</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_MALLOPT_ARENA_MAX</name></cpp:ifdef>
    <comment type="line">// glibc-specific: On 32-bit systems set the number of arenas to 1.</comment>
    <comment type="line">// By default, since glibc 2.10, the C library will create up to two heap</comment>
    <comment type="line">// arenas per core. This is known to cause excessive virtual address space</comment>
    <comment type="line">// usage in our usage. Work around it by setting the maximum number of</comment>
    <comment type="line">// arenas to 1.</comment>
    <if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>mallopt</name><argument_list>(<argument><expr><name>M_ARENA_MAX</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="line">// On most POSIX systems (e.g. Linux, but not BSD) the environment's locale</comment>
    <comment type="line">// may be invalid, in which case the "C.UTF-8" locale is used as fallback.</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MAC_OSX</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__OpenBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <try>try <block>{<block_content>
        <expr_stmt><expr><call><name><name>std</name><operator>::</operator><name>locale</name></name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Raises a runtime error if current locale is invalid</comment>
    </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>runtime_error</name></name><modifier>&amp;</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>setenv</name><argument_list>(<argument><expr><literal type="string">"LC_ALL"</literal></expr></argument>, <argument><expr><literal type="string">"C.UTF-8"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></catch></try>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <comment type="line">// Set the default input/output charset is utf-8</comment>
    <expr_stmt><expr><call><name>SetConsoleCP</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetConsoleOutputCP</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="line">// The path locale is lazy initialized and to avoid deinitialization errors</comment>
    <comment type="line">// in multithreading environments, it is set explicitly by the main thread.</comment>
    <comment type="line">// A dummy locale is used to extract the internal default locale, used by</comment>
    <comment type="line">// fs::path, which is then used to explicitly imbue the path.</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>locale</name></name></type> <name>loc</name> <init>= <expr><call><name><name>fs</name><operator>::</operator><name>path</name><operator>::</operator><name>imbue</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>locale</name><operator>::</operator><name>classic</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
    <expr_stmt><expr><call><name><name>fs</name><operator>::</operator><name>path</name><operator>::</operator><name>imbue</name></name><argument_list>(<argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name><name>fs</name><operator>::</operator><name>path</name><operator>::</operator><name>imbue</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>locale</name></name><argument_list>(<argument><expr><name>loc</name></expr></argument>, <argument><expr><operator>new</operator> <call><name><name>std</name><operator>::</operator><name>codecvt_utf8_utf16</name><argument_list type="generic">&lt;<argument><expr><name>wchar_t</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>SetupNetworking</name><parameter_list>()</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <comment type="line">// Initialize Windows Sockets</comment>
    <decl_stmt><decl><type><name>WSADATA</name></type> <name>wsadata</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>WSAStartup</name><argument_list>(<argument><expr><call><name>MAKEWORD</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>wsadata</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>NO_ERROR</name> <operator>||</operator> <call><name>LOBYTE</name><argument_list>(<argument><expr><name><name>wsadata</name><operator>.</operator><name>wVersion</name></name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">2</literal> <operator>||</operator> <call><name>HIBYTE</name><argument_list>(<argument><expr><name><name>wsadata</name><operator>.</operator><name>wVersion</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>GetNumCores</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name><name>std</name><operator>::</operator><name>thread</name><operator>::</operator><name>hardware_concurrency</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>CopyrightHolders</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>strPrefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>copyright_devs</name> <init>= <expr><call><name>strprintf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>COPYRIGHT_HOLDERS</name></expr></argument>)</argument_list></call><operator>.</operator><name>translated</name></expr></argument>, <argument><expr><name>COPYRIGHT_HOLDERS_SUBSTITUTION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>strCopyrightHolders</name> <init>= <expr><name>strPrefix</name> <operator>+</operator> <name>copyright_devs</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// Make sure Bitcoin Core copyright is not removed by accident</comment>
    <if_stmt><if>if <condition>(<expr><call><name><name>copyright_devs</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><literal type="string">"Bitcoin Core"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>std</name><operator>::</operator><name>string</name><operator>::</operator><name>npos</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>strCopyrightHolders</name> <operator>+=</operator> <literal type="string">"\n"</literal> <operator>+</operator> <name>strPrefix</name> <operator>+</operator> <literal type="string">"The Bitcoin Core developers"</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>strCopyrightHolders</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Obtain the application startup time (used for uptime calculation)</comment>
<function><type><name>int64_t</name></type> <name>GetStartupTime</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <return>return <expr><name>nStartupTime</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>fs</name><operator>::</operator><name>path</name></name></type> <name>AbsPathForConfigVal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>fs</name><operator>::</operator><name>path</name></name><modifier>&amp;</modifier></type> <name>path</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>net_specific</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name><name>path</name><operator>.</operator><name>is_absolute</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>path</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name><name>fs</name><operator>::</operator><name>absolute</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>GetDataDir</name><argument_list>(<argument><expr><name>net_specific</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>ScheduleBatchPriority</name><parameter_list>()</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SCHED_BATCH</name></cpp:ifdef>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>static</specifier> <name>sched_param</name></type> <name>param</name><argument_list>{}</argument_list></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>pthread_setschedparam</name><argument_list>(<argument><expr><call><name>pthread_self</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SCHED_BATCH</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"Failed to pthread_setschedparam: %s\n"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<namespace>namespace <name>util</name> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<constructor><name><name>WinCmdLineArgs</name><operator>::</operator><name>WinCmdLineArgs</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>wchar_t</name><modifier>*</modifier><modifier>*</modifier></type> <name>wargv</name> <init>= <expr><call><name>CommandLineToArgvW</name><argument_list>(<argument><expr><call><name>GetCommandLineW</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>argc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>wstring_convert</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>codecvt_utf8_utf16</name><argument_list type="generic">&lt;<argument><expr><name>wchar_t</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>wchar_t</name></expr></argument>&gt;</argument_list></name></type> <name>utf8_cvt</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>argv</name> <operator>=</operator> <operator>new</operator> <name>char</name><operator>*</operator><index>[<expr><name>argc</name></expr>]</index></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>args</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>utf8_cvt</name><operator>.</operator><name>to_bytes</name></name><argument_list>(<argument><expr><name><name>wargv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><operator>*</operator><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>LocalFree</name><argument_list>(<argument><expr><name>wargv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></constructor>

<destructor><name><name>WinCmdLineArgs</name><operator>::</operator><name>~WinCmdLineArgs</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><operator>delete</operator><index>[]</index> <name>argv</name></expr>;</expr_stmt>
</block_content>}</block></destructor>

<function><type><name><name>std</name><operator>::</operator><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>, <argument><expr><name>char</name><modifier>*</modifier><modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name><name>WinCmdLineArgs</name><operator>::</operator><name>get</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></namespace> <comment type="line">// namespace util</comment>
</unit>
