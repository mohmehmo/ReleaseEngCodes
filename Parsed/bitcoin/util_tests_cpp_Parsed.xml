<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C++" filename="/home/mmm/Projects/bitcoin/src/test/util_tests.cpp"><comment type="line">// Copyright (c) 2011-2019 The Bitcoin Core developers</comment>
<comment type="line">// Distributed under the MIT software license, see the accompanying</comment>
<comment type="line">// file COPYING or http://www.opensource.org/licenses/mit-license.php.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/system.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;clientversion.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sync.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;test/util/setup_common.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;test/util.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/moneystr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/strencodings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/spanparsing.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/vector.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;thread&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;univalue.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;boost/test/unit_test.hpp&gt;</cpp:file></cpp:include>

<comment type="block">/* defined in logging.cpp */</comment>
<namespace>namespace <name>BCLog</name> <block>{
    <function_decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>LogEscapeMessage</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>str</name></decl></parameter>)</parameter_list>;</function_decl>
}</block></namespace>

<macro><name>BOOST_FIXTURE_TEST_SUITE</name><argument_list>(<argument>util_tests</argument>, <argument>BasicTestingSetup</argument>)</argument_list></macro>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>util_criticalsection</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name>CCriticalSection</name></type> <name>cs</name></decl>;</decl_stmt>

    <do>do <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

        <expr_stmt><expr><call><name>BOOST_ERROR</name><argument_list>(<argument><expr><literal type="string">"break was swallowed!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> while<condition>(<expr><literal type="number">0</literal></expr>)</condition>;</do>

    <do>do <block>{<block_content>
        <expr_stmt><expr><call><name>TRY_LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><name>lockTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>lockTest</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Needed to suppress "Test case [...] did not check any assertions"</comment>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>BOOST_ERROR</name><argument_list>(<argument><expr><literal type="string">"break was swallowed!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> while<condition>(<expr><literal type="number">0</literal></expr>)</condition>;</do>
</block_content>}</block>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>ParseHex_expected</name><index>[<expr><literal type="number">65</literal></expr>]</index></name> <init>= <expr><block>{
    <expr><literal type="number">0x04</literal></expr>, <expr><literal type="number">0x67</literal></expr>, <expr><literal type="number">0x8a</literal></expr>, <expr><literal type="number">0xfd</literal></expr>, <expr><literal type="number">0xb0</literal></expr>, <expr><literal type="number">0xfe</literal></expr>, <expr><literal type="number">0x55</literal></expr>, <expr><literal type="number">0x48</literal></expr>, <expr><literal type="number">0x27</literal></expr>, <expr><literal type="number">0x19</literal></expr>, <expr><literal type="number">0x67</literal></expr>, <expr><literal type="number">0xf1</literal></expr>, <expr><literal type="number">0xa6</literal></expr>, <expr><literal type="number">0x71</literal></expr>, <expr><literal type="number">0x30</literal></expr>, <expr><literal type="number">0xb7</literal></expr>,
    <expr><literal type="number">0x10</literal></expr>, <expr><literal type="number">0x5c</literal></expr>, <expr><literal type="number">0xd6</literal></expr>, <expr><literal type="number">0xa8</literal></expr>, <expr><literal type="number">0x28</literal></expr>, <expr><literal type="number">0xe0</literal></expr>, <expr><literal type="number">0x39</literal></expr>, <expr><literal type="number">0x09</literal></expr>, <expr><literal type="number">0xa6</literal></expr>, <expr><literal type="number">0x79</literal></expr>, <expr><literal type="number">0x62</literal></expr>, <expr><literal type="number">0xe0</literal></expr>, <expr><literal type="number">0xea</literal></expr>, <expr><literal type="number">0x1f</literal></expr>, <expr><literal type="number">0x61</literal></expr>, <expr><literal type="number">0xde</literal></expr>,
    <expr><literal type="number">0xb6</literal></expr>, <expr><literal type="number">0x49</literal></expr>, <expr><literal type="number">0xf6</literal></expr>, <expr><literal type="number">0xbc</literal></expr>, <expr><literal type="number">0x3f</literal></expr>, <expr><literal type="number">0x4c</literal></expr>, <expr><literal type="number">0xef</literal></expr>, <expr><literal type="number">0x38</literal></expr>, <expr><literal type="number">0xc4</literal></expr>, <expr><literal type="number">0xf3</literal></expr>, <expr><literal type="number">0x55</literal></expr>, <expr><literal type="number">0x04</literal></expr>, <expr><literal type="number">0xe5</literal></expr>, <expr><literal type="number">0x1e</literal></expr>, <expr><literal type="number">0xc1</literal></expr>, <expr><literal type="number">0x12</literal></expr>,
    <expr><literal type="number">0xde</literal></expr>, <expr><literal type="number">0x5c</literal></expr>, <expr><literal type="number">0x38</literal></expr>, <expr><literal type="number">0x4d</literal></expr>, <expr><literal type="number">0xf7</literal></expr>, <expr><literal type="number">0xba</literal></expr>, <expr><literal type="number">0x0b</literal></expr>, <expr><literal type="number">0x8d</literal></expr>, <expr><literal type="number">0x57</literal></expr>, <expr><literal type="number">0x8a</literal></expr>, <expr><literal type="number">0x4c</literal></expr>, <expr><literal type="number">0x70</literal></expr>, <expr><literal type="number">0x2b</literal></expr>, <expr><literal type="number">0x6b</literal></expr>, <expr><literal type="number">0xf1</literal></expr>, <expr><literal type="number">0x1d</literal></expr>,
    <expr><literal type="number">0x5f</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>util_ParseHex</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>expected</name><argument_list>(<argument><expr><name>ParseHex_expected</name></expr></argument>, <argument><expr><name>ParseHex_expected</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ParseHex_expected</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></decl>;</decl_stmt>
    <comment type="line">// Basic test vector</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ParseHex</name><argument_list>(<argument><expr><literal type="string">"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL_COLLECTIONS</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>result</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>expected</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>expected</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Spaces between bytes must be supported</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ParseHex</name><argument_list>(<argument><expr><literal type="string">"12 34 56 78"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x12</literal> <operator>&amp;&amp;</operator> <name><name>result</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x34</literal> <operator>&amp;&amp;</operator> <name><name>result</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x56</literal> <operator>&amp;&amp;</operator> <name><name>result</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x78</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Leading space must be supported (used in BerkeleyEnvironment::Salvage)</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ParseHex</name><argument_list>(<argument><expr><literal type="string">" 89 34 56 78"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x89</literal> <operator>&amp;&amp;</operator> <name><name>result</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x34</literal> <operator>&amp;&amp;</operator> <name><name>result</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x56</literal> <operator>&amp;&amp;</operator> <name><name>result</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x78</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Stop parsing at invalid value</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ParseHex</name><argument_list>(<argument><expr><literal type="string">"1234 invalid 1234"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x12</literal> <operator>&amp;&amp;</operator> <name><name>result</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x34</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>util_HexStr</argument>)</argument_list></macro>
<block>{<block_content>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(
        <argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><name>ParseHex_expected</name></expr></argument>, <argument><expr><name>ParseHex_expected</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ParseHex_expected</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><literal type="string">"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(
        <argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><name>ParseHex_expected</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ParseHex_expected</name></expr></argument>)</argument_list></sizeof></expr></argument>,
               <argument><expr><name>ParseHex_expected</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ParseHex_expected</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(
        <argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><name>ParseHex_expected</name></expr></argument>, <argument><expr><name>ParseHex_expected</name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>ParseHex_vec</name><argument_list>(<argument><expr><name>ParseHex_expected</name></expr></argument>, <argument><expr><name>ParseHex_expected</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>)</argument_list></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(
        <argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><call><name><name>ParseHex_vec</name><operator>.</operator><name>rbegin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>ParseHex_vec</name><operator>.</operator><name>rend</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><literal type="string">"b0fd8a6704"</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(
        <argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>reverse_iterator</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ParseHex_expected</name></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><call><name><name>std</name><operator>::</operator><name>reverse_iterator</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ParseHex_expected</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><literal type="string">""</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(
        <argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>reverse_iterator</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ParseHex_expected</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><call><name><name>std</name><operator>::</operator><name>reverse_iterator</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ParseHex_expected</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><literal type="string">"04"</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(
        <argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>reverse_iterator</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ParseHex_expected</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><call><name><name>std</name><operator>::</operator><name>reverse_iterator</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ParseHex_expected</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><literal type="string">"b0fd8a6704"</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(
        <argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>reverse_iterator</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ParseHex_expected</name> <operator>+</operator> <literal type="number">65</literal></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><call><name><name>std</name><operator>::</operator><name>reverse_iterator</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ParseHex_expected</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><literal type="string">"5f1df16b2b704c8a578d0bbaf74d385cde12c11ee50455f3c438ef4c3fbcf649b6de611feae06279a60939e028a8d65c10b73071a6f16719274855feb0fd8a6704"</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>util_Join</argument>)</argument_list></macro>
<block>{<block_content>
    <comment type="line">// Normal version</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>Join</name><argument_list>(<argument><expr><block>{}</block></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>Join</name><argument_list>(<argument><expr><block>{<expr><literal type="string">"foo"</literal></expr>}</block></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"foo"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>Join</name><argument_list>(<argument><expr><block>{<expr><literal type="string">"foo"</literal></expr>, <expr><literal type="string">"bar"</literal></expr>}</block></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"foo, bar"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Version with unary operator</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>op_upper</name> <init>= <expr><lambda><capture>[]</capture><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>ToUpper</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></lambda></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>Join</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><block>{}</block></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><name>op_upper</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>Join</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><block>{<expr><literal type="string">"foo"</literal></expr>}</block></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><name>op_upper</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"FOO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>Join</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><block>{<expr><literal type="string">"foo"</literal></expr>, <expr><literal type="string">"bar"</literal></expr>}</block></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><name>op_upper</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"FOO, BAR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>util_FormatParseISO8601DateTime</argument>)</argument_list></macro>
<block>{<block_content>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatISO8601DateTime</name><argument_list>(<argument><expr><literal type="number">1317425777</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"2011-09-30T23:36:17Z"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatISO8601DateTime</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"1970-01-01T00:00:00Z"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>ParseISO8601DateTime</name><argument_list>(<argument><expr><literal type="string">"1970-01-01T00:00:00Z"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>ParseISO8601DateTime</name><argument_list>(<argument><expr><literal type="string">"1960-01-01T00:00:00Z"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>ParseISO8601DateTime</name><argument_list>(<argument><expr><literal type="string">"2011-09-30T23:36:17Z"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1317425777</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>time</name> <init>= <expr><call><name>GetSystemTimeInSeconds</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>ParseISO8601DateTime</name><argument_list>(<argument><expr><call><name>FormatISO8601DateTime</name><argument_list>(<argument><expr><name>time</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>util_FormatISO8601Date</argument>)</argument_list></macro>
<block>{<block_content>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatISO8601Date</name><argument_list>(<argument><expr><literal type="number">1317425777</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"2011-09-30"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<struct>struct <name>TestArgsManager</name> <super_list>: <super><specifier>public</specifier> <name>ArgsManager</name></super></super_list>
<block>{<public type="default">
    <constructor><name>TestArgsManager</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name><name>m_network_only_args</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> </block_content>}</block></constructor>
    <function><type><name>void</name></type> <name>ReadConfigString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name></type> <name>str_config</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>istringstream</name></name></type> <name>streamConfig</name><argument_list>(<argument><expr><name>str_config</name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>m_settings</name><operator>.</operator><name>ro_config</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>m_config_sections</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>error</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>BOOST_REQUIRE</name><argument_list>(<argument><expr><call><name>ReadConfigStream</name><argument_list>(<argument><expr><name>streamConfig</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>
    <function><type><name>void</name></type> <name>SetNetworkOnlyArg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name></type> <name>arg</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>m_network_only_args</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>
    <function><type><name>void</name></type> <name>SetupArgs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>pair</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>, <argument><expr><name>unsigned</name> <name>int</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>args</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>arg</name> <range>: <expr><name>args</name></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>AddArg</name><argument_list>(<argument><expr><name><name>arg</name><operator>.</operator><name>first</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>arg</name><operator>.</operator><name>second</name></name></expr></argument>, <argument><expr><name><name>OptionsCategory</name><operator>::</operator><name>OPTIONS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></function>
    <using>using <name><name>ArgsManager</name><operator>::</operator><name>ReadConfigStream</name></name>;</using>
    <using>using <name><name>ArgsManager</name><operator>::</operator><name>cs_args</name></name>;</using>
    <using>using <name><name>ArgsManager</name><operator>::</operator><name>m_network</name></name>;</using>
    <using>using <name><name>ArgsManager</name><operator>::</operator><name>m_settings</name></name>;</using>
</public>}</block>;</struct>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>util_ParseParameters</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name>TestArgsManager</name></type> <name>testArgs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>a</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><literal type="string">"-a"</literal></expr></argument>, <argument><expr><name><name>ArgsManager</name><operator>::</operator><name>ALLOW_ANY</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>b</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><literal type="string">"-b"</literal></expr></argument>, <argument><expr><name><name>ArgsManager</name><operator>::</operator><name>ALLOW_ANY</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>ccc</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><literal type="string">"-ccc"</literal></expr></argument>, <argument><expr><name><name>ArgsManager</name><operator>::</operator><name>ALLOW_ANY</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>d</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><literal type="string">"-d"</literal></expr></argument>, <argument><expr><name><name>ArgsManager</name><operator>::</operator><name>ALLOW_ANY</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>argv_test</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"-ignored"</literal></expr>, <expr><literal type="string">"-a"</literal></expr>, <expr><literal type="string">"-b"</literal></expr>, <expr><literal type="string">"-ccc=argument"</literal></expr>, <expr><literal type="string">"-ccc=multiple"</literal></expr>, <expr><literal type="string">"f"</literal></expr>, <expr><literal type="string">"-d=e"</literal></expr>}</block></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>error</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>testArgs</name><operator>.</operator><name>cs_args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>testArgs</name><operator>.</operator><name>SetupArgs</name></name><argument_list>(<argument><expr><block>{<expr><name>a</name></expr>, <expr><name>b</name></expr>, <expr><name>ccc</name></expr>, <expr><name>d</name></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>ParseParameters</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>argv_test</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>command_line_options</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>ro_config</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>ParseParameters</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>argv_test</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>command_line_options</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>ro_config</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>ParseParameters</name></name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>argv_test</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// expectation: -ignored is ignored (program name argument),</comment>
    <comment type="line">// -a, -b and -ccc end up in map, -d ignored because it is after</comment>
    <comment type="line">// a non-option argument (non-GNU option parsing)</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>command_line_options</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>ro_config</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>IsArgSet</name></name><argument_list>(<argument><expr><literal type="string">"-a"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>testArgs</name><operator>.</operator><name>IsArgSet</name></name><argument_list>(<argument><expr><literal type="string">"-b"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>testArgs</name><operator>.</operator><name>IsArgSet</name></name><argument_list>(<argument><expr><literal type="string">"-ccc"</literal></expr></argument>)</argument_list></call>
                <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>testArgs</name><operator>.</operator><name>IsArgSet</name></name><argument_list>(<argument><expr><literal type="string">"f"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>testArgs</name><operator>.</operator><name>IsArgSet</name></name><argument_list>(<argument><expr><literal type="string">"-d"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>command_line_options</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>command_line_options</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><literal type="string">"b"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>command_line_options</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><literal type="string">"ccc"</literal></expr></argument>)</argument_list></call>
                <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>command_line_options</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><literal type="string">"f"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>command_line_options</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><literal type="string">"d"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>command_line_options</name><index>[<expr><literal type="string">"a"</literal></expr>]</index></name><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>command_line_options</name><index>[<expr><literal type="string">"a"</literal></expr>]</index></name><operator>.</operator><call><name>front</name><argument_list>()</argument_list></call><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>command_line_options</name><index>[<expr><literal type="string">"ccc"</literal></expr>]</index></name><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>command_line_options</name><index>[<expr><literal type="string">"ccc"</literal></expr>]</index></name><operator>.</operator><call><name>front</name><argument_list>()</argument_list></call><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="string">"argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>command_line_options</name><index>[<expr><literal type="string">"ccc"</literal></expr>]</index></name><operator>.</operator><call><name>back</name><argument_list>()</argument_list></call><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="string">"multiple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><literal type="string">"-ccc"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<function><type><specifier>static</specifier> <name>void</name></type> <name>TestParse</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>expected_bool</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>expected_int</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TestArgsManager</name></type> <name>test</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>test</name><operator>.</operator><name>SetupArgs</name></name><argument_list>(<argument><expr><block>{<expr><block>{<expr><literal type="string">"-value"</literal></expr>, <expr><name><name>ArgsManager</name><operator>::</operator><name>ALLOW_ANY</name></name></expr>}</block></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>arg</name> <init>= <expr><literal type="string">"-value="</literal> <operator>+</operator> <name>str</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name><name>argv</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"ignored"</literal></expr>, <macro><name>arg</name></macro><expr><operator>.</operator><macro><name>c_str</name><argument_list>()</argument_list></macro></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>error</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test</name><operator>.</operator><name>ParseParameters</name></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>argv</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>test</name><operator>.</operator><name>GetBoolArg</name></name><argument_list>(<argument><expr><literal type="string">"-value"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>expected_bool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>test</name><operator>.</operator><name>GetBoolArg</name></name><argument_list>(<argument><expr><literal type="string">"-value"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>expected_bool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>test</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-value"</literal></expr></argument>, <argument><expr><literal type="number">99998</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>expected_int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>test</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-value"</literal></expr></argument>, <argument><expr><literal type="number">99999</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>expected_int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Test bool and int parsing.</comment>
<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>util_ArgParsing</argument>)</argument_list></macro>
<block>{<block_content>
    <comment type="line">// Some of these cases could be ambiguous or surprising to users, and might</comment>
    <comment type="line">// be worth triggering errors or warnings in the future. But for now basic</comment>
    <comment type="line">// test coverage is useful to avoid breaking backwards compatibility</comment>
    <comment type="line">// unintentionally.</comment>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">"0"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">"0 "</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">" 0"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">"+0"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">"-0"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">"5"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">"5 "</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">" 5"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">"+5"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">"-5"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">"0 5"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">"5 0"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">"050"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="number">50</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">"0."</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">"5."</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">"0.0"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">"0.5"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">"5.0"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">"5.5"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">"x"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">"x0"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">"x5"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">"0x"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">"5x"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">"0x5"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">"false"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">"yes"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TestParse</name><argument_list>(<argument><expr><literal type="string">"no"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>util_GetBoolArg</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name>TestArgsManager</name></type> <name>testArgs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>a</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><literal type="string">"-a"</literal></expr></argument>, <argument><expr><name><name>ArgsManager</name><operator>::</operator><name>ALLOW_BOOL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>b</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><literal type="string">"-b"</literal></expr></argument>, <argument><expr><name><name>ArgsManager</name><operator>::</operator><name>ALLOW_BOOL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>c</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><literal type="string">"-c"</literal></expr></argument>, <argument><expr><name><name>ArgsManager</name><operator>::</operator><name>ALLOW_BOOL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>d</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><literal type="string">"-d"</literal></expr></argument>, <argument><expr><name><name>ArgsManager</name><operator>::</operator><name>ALLOW_BOOL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>e</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><literal type="string">"-e"</literal></expr></argument>, <argument><expr><name><name>ArgsManager</name><operator>::</operator><name>ALLOW_BOOL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>f</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><literal type="string">"-f"</literal></expr></argument>, <argument><expr><name><name>ArgsManager</name><operator>::</operator><name>ALLOW_BOOL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>argv_test</name><index>[]</index></name> <init>= <expr><block>{
        <expr><literal type="string">"ignored"</literal></expr>, <expr><literal type="string">"-a"</literal></expr>, <expr><literal type="string">"-nob"</literal></expr>, <expr><literal type="string">"-c=0"</literal></expr>, <expr><literal type="string">"-d=1"</literal></expr>, <expr><literal type="string">"-e=false"</literal></expr>, <expr><literal type="string">"-f=true"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>error</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>testArgs</name><operator>.</operator><name>cs_args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>testArgs</name><operator>.</operator><name>SetupArgs</name></name><argument_list>(<argument><expr><block>{<expr><name>a</name></expr>, <expr><name>b</name></expr>, <expr><name>c</name></expr>, <expr><name>d</name></expr>, <expr><name>e</name></expr>, <expr><name>f</name></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>ParseParameters</name></name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>argv_test</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Each letter should be set.</comment>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <name>char</name></type> <name>opt</name> <range>: <expr><literal type="string">"abcdef"</literal></expr></range></decl></init>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>IsArgSet</name></name><argument_list>(<argument><expr><block>{<expr><literal type="char">'-'</literal></expr>, <expr><name>opt</name></expr>}</block></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <comment type="line">// Nothing else should be in the map</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>command_line_options</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator>
                <call><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>ro_config</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// The -no prefix should get stripped on the way in.</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>testArgs</name><operator>.</operator><name>IsArgSet</name></name><argument_list>(<argument><expr><literal type="string">"-nob"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// The -b option is flagged as negated, and nothing else is</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>IsArgNegated</name></name><argument_list>(<argument><expr><literal type="string">"-b"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>testArgs</name><operator>.</operator><name>IsArgNegated</name></name><argument_list>(<argument><expr><literal type="string">"-a"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Check expected values.</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>GetBoolArg</name></name><argument_list>(<argument><expr><literal type="string">"-a"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>GetBoolArg</name></name><argument_list>(<argument><expr><literal type="string">"-b"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>GetBoolArg</name></name><argument_list>(<argument><expr><literal type="string">"-c"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>GetBoolArg</name></name><argument_list>(<argument><expr><literal type="string">"-d"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>GetBoolArg</name></name><argument_list>(<argument><expr><literal type="string">"-e"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>GetBoolArg</name></name><argument_list>(<argument><expr><literal type="string">"-f"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>util_GetBoolArgEdgeCases</argument>)</argument_list></macro>
<block>{<block_content>
    <comment type="line">// Test some awful edge cases that hopefully no user will ever exercise.</comment>
    <decl_stmt><decl><type><name>TestArgsManager</name></type> <name>testArgs</name></decl>;</decl_stmt>

    <comment type="line">// Params test</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>foo</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><literal type="string">"-foo"</literal></expr></argument>, <argument><expr><name><name>ArgsManager</name><operator>::</operator><name>ALLOW_BOOL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>bar</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><literal type="string">"-bar"</literal></expr></argument>, <argument><expr><name><name>ArgsManager</name><operator>::</operator><name>ALLOW_BOOL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>argv_test</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"ignored"</literal></expr>, <expr><literal type="string">"-nofoo"</literal></expr>, <expr><literal type="string">"-foo"</literal></expr>, <expr><literal type="string">"-nobar=0"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>testArgs</name><operator>.</operator><name>SetupArgs</name></name><argument_list>(<argument><expr><block>{<expr><name>foo</name></expr>, <expr><name>bar</name></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>error</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>ParseParameters</name></name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>argv_test</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// This was passed twice, second one overrides the negative setting.</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>testArgs</name><operator>.</operator><name>IsArgNegated</name></name><argument_list>(<argument><expr><literal type="string">"-foo"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-foo"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// A double negative is a positive, and not marked as negated.</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>testArgs</name><operator>.</operator><name>IsArgNegated</name></name><argument_list>(<argument><expr><literal type="string">"-bar"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-bar"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Config test</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conf_test</name> <init>= <expr><literal type="string">"nofoo=1\nfoo=1\nnobar=0\n"</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>ParseParameters</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>argv_test</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>testArgs</name><operator>.</operator><name>ReadConfigString</name></name><argument_list>(<argument><expr><name>conf_test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// This was passed twice, second one overrides the negative setting,</comment>
    <comment type="line">// and the value.</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>testArgs</name><operator>.</operator><name>IsArgNegated</name></name><argument_list>(<argument><expr><literal type="string">"-foo"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-foo"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// A double negative is a positive, and does not count as negated.</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>testArgs</name><operator>.</operator><name>IsArgNegated</name></name><argument_list>(<argument><expr><literal type="string">"-bar"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-bar"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Combined test</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>combo_test_args</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"ignored"</literal></expr>, <expr><literal type="string">"-nofoo"</literal></expr>, <expr><literal type="string">"-bar"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>combo_test_conf</name> <init>= <expr><literal type="string">"foo=1\nnobar=1\n"</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>ParseParameters</name></name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>combo_test_args</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>testArgs</name><operator>.</operator><name>ReadConfigString</name></name><argument_list>(<argument><expr><name>combo_test_conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Command line overrides, but doesn't erase old setting</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>IsArgNegated</name></name><argument_list>(<argument><expr><literal type="string">"-foo"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-foo"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><literal type="string">"-foo"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Command line overrides, but doesn't erase old setting</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>testArgs</name><operator>.</operator><name>IsArgNegated</name></name><argument_list>(<argument><expr><literal type="string">"-bar"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-bar"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><literal type="string">"-bar"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal>
                <operator>&amp;&amp;</operator> <call><name><name>testArgs</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><literal type="string">"-bar"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>front</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>util_ReadConfigStream</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str_config</name> <init>=
       <expr><literal type="string">"a=\n"</literal>
       <literal type="string">"b=1\n"</literal>
       <literal type="string">"ccc=argument\n"</literal>
       <literal type="string">"ccc=multiple\n"</literal>
       <literal type="string">"d=e\n"</literal>
       <literal type="string">"nofff=1\n"</literal>
       <literal type="string">"noggg=0\n"</literal>
       <literal type="string">"h=1\n"</literal>
       <literal type="string">"noh=1\n"</literal>
       <literal type="string">"noi=1\n"</literal>
       <literal type="string">"i=1\n"</literal>
       <literal type="string">"sec1.ccc=extend1\n"</literal>
       <literal type="string">"\n"</literal>
       <literal type="string">"[sec1]\n"</literal>
       <literal type="string">"ccc=extend2\n"</literal>
       <literal type="string">"d=eee\n"</literal>
       <literal type="string">"h=1\n"</literal>
       <literal type="string">"[sec2]\n"</literal>
       <literal type="string">"ccc=extend3\n"</literal>
       <literal type="string">"iii=2\n"</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>TestArgsManager</name></type> <name>test_args</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>test_args</name><operator>.</operator><name>cs_args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>a</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><literal type="string">"-a"</literal></expr></argument>, <argument><expr><name><name>ArgsManager</name><operator>::</operator><name>ALLOW_BOOL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>b</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><literal type="string">"-b"</literal></expr></argument>, <argument><expr><name><name>ArgsManager</name><operator>::</operator><name>ALLOW_BOOL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>ccc</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><literal type="string">"-ccc"</literal></expr></argument>, <argument><expr><name><name>ArgsManager</name><operator>::</operator><name>ALLOW_STRING</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>d</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><literal type="string">"-d"</literal></expr></argument>, <argument><expr><name><name>ArgsManager</name><operator>::</operator><name>ALLOW_STRING</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>e</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><literal type="string">"-e"</literal></expr></argument>, <argument><expr><name><name>ArgsManager</name><operator>::</operator><name>ALLOW_ANY</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>fff</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><literal type="string">"-fff"</literal></expr></argument>, <argument><expr><name><name>ArgsManager</name><operator>::</operator><name>ALLOW_BOOL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>ggg</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><literal type="string">"-ggg"</literal></expr></argument>, <argument><expr><name><name>ArgsManager</name><operator>::</operator><name>ALLOW_BOOL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>h</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><literal type="string">"-h"</literal></expr></argument>, <argument><expr><name><name>ArgsManager</name><operator>::</operator><name>ALLOW_BOOL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>i</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><literal type="string">"-i"</literal></expr></argument>, <argument><expr><name><name>ArgsManager</name><operator>::</operator><name>ALLOW_BOOL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>iii</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><literal type="string">"-iii"</literal></expr></argument>, <argument><expr><name><name>ArgsManager</name><operator>::</operator><name>ALLOW_INT</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>test_args</name><operator>.</operator><name>SetupArgs</name></name><argument_list>(<argument><expr><block>{<expr><name>a</name></expr>, <expr><name>b</name></expr>, <expr><name>ccc</name></expr>, <expr><name>d</name></expr>, <expr><name>e</name></expr>, <expr><name>fff</name></expr>, <expr><name>ggg</name></expr>, <expr><name>h</name></expr>, <expr><name>i</name></expr>, <expr><name>iii</name></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>test_args</name><operator>.</operator><name>ReadConfigString</name></name><argument_list>(<argument><expr><name>str_config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// expectation: a, b, ccc, d, fff, ggg, h, i end up in map</comment>
    <comment type="line">// so do sec1.ccc, sec1.d, sec1.h, sec2.ccc, sec2.iii</comment>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>command_line_options</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>ro_config</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>test_args</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>ro_config</name><index>[<expr><literal type="string">""</literal></expr>]</index></name><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>test_args</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>ro_config</name><index>[<expr><literal type="string">"sec1"</literal></expr>]</index></name><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>test_args</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>ro_config</name><index>[<expr><literal type="string">"sec2"</literal></expr>]</index></name><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>test_args</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>ro_config</name><index>[<expr><literal type="string">""</literal></expr>]</index></name><operator>.</operator><call><name>count</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call>
                <operator>&amp;&amp;</operator> <name><name>test_args</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>ro_config</name><index>[<expr><literal type="string">""</literal></expr>]</index></name><operator>.</operator><call><name>count</name><argument_list>(<argument><expr><literal type="string">"b"</literal></expr></argument>)</argument_list></call>
                <operator>&amp;&amp;</operator> <name><name>test_args</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>ro_config</name><index>[<expr><literal type="string">""</literal></expr>]</index></name><operator>.</operator><call><name>count</name><argument_list>(<argument><expr><literal type="string">"ccc"</literal></expr></argument>)</argument_list></call>
                <operator>&amp;&amp;</operator> <name><name>test_args</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>ro_config</name><index>[<expr><literal type="string">""</literal></expr>]</index></name><operator>.</operator><call><name>count</name><argument_list>(<argument><expr><literal type="string">"d"</literal></expr></argument>)</argument_list></call>
                <operator>&amp;&amp;</operator> <name><name>test_args</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>ro_config</name><index>[<expr><literal type="string">""</literal></expr>]</index></name><operator>.</operator><call><name>count</name><argument_list>(<argument><expr><literal type="string">"fff"</literal></expr></argument>)</argument_list></call>
                <operator>&amp;&amp;</operator> <name><name>test_args</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>ro_config</name><index>[<expr><literal type="string">""</literal></expr>]</index></name><operator>.</operator><call><name>count</name><argument_list>(<argument><expr><literal type="string">"ggg"</literal></expr></argument>)</argument_list></call>
                <operator>&amp;&amp;</operator> <name><name>test_args</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>ro_config</name><index>[<expr><literal type="string">""</literal></expr>]</index></name><operator>.</operator><call><name>count</name><argument_list>(<argument><expr><literal type="string">"h"</literal></expr></argument>)</argument_list></call>
                <operator>&amp;&amp;</operator> <name><name>test_args</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>ro_config</name><index>[<expr><literal type="string">""</literal></expr>]</index></name><operator>.</operator><call><name>count</name><argument_list>(<argument><expr><literal type="string">"i"</literal></expr></argument>)</argument_list></call></expr></argument>
               )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>test_args</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>ro_config</name><index>[<expr><literal type="string">"sec1"</literal></expr>]</index></name><operator>.</operator><call><name>count</name><argument_list>(<argument><expr><literal type="string">"ccc"</literal></expr></argument>)</argument_list></call>
                <operator>&amp;&amp;</operator> <name><name>test_args</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>ro_config</name><index>[<expr><literal type="string">"sec1"</literal></expr>]</index></name><operator>.</operator><call><name>count</name><argument_list>(<argument><expr><literal type="string">"h"</literal></expr></argument>)</argument_list></call>
                <operator>&amp;&amp;</operator> <name><name>test_args</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>ro_config</name><index>[<expr><literal type="string">"sec2"</literal></expr>]</index></name><operator>.</operator><call><name>count</name><argument_list>(<argument><expr><literal type="string">"ccc"</literal></expr></argument>)</argument_list></call>
                <operator>&amp;&amp;</operator> <name><name>test_args</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>ro_config</name><index>[<expr><literal type="string">"sec2"</literal></expr>]</index></name><operator>.</operator><call><name>count</name><argument_list>(<argument><expr><literal type="string">"iii"</literal></expr></argument>)</argument_list></call></expr></argument>
               )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>IsArgSet</name></name><argument_list>(<argument><expr><literal type="string">"-a"</literal></expr></argument>)</argument_list></call>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>IsArgSet</name></name><argument_list>(<argument><expr><literal type="string">"-b"</literal></expr></argument>)</argument_list></call>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>IsArgSet</name></name><argument_list>(<argument><expr><literal type="string">"-ccc"</literal></expr></argument>)</argument_list></call>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>IsArgSet</name></name><argument_list>(<argument><expr><literal type="string">"-d"</literal></expr></argument>)</argument_list></call>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>IsArgSet</name></name><argument_list>(<argument><expr><literal type="string">"-fff"</literal></expr></argument>)</argument_list></call>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>IsArgSet</name></name><argument_list>(<argument><expr><literal type="string">"-ggg"</literal></expr></argument>)</argument_list></call>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>IsArgSet</name></name><argument_list>(<argument><expr><literal type="string">"-h"</literal></expr></argument>)</argument_list></call>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>IsArgSet</name></name><argument_list>(<argument><expr><literal type="string">"-i"</literal></expr></argument>)</argument_list></call>
                <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>test_args</name><operator>.</operator><name>IsArgSet</name></name><argument_list>(<argument><expr><literal type="string">"-zzz"</literal></expr></argument>)</argument_list></call>
                <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>test_args</name><operator>.</operator><name>IsArgSet</name></name><argument_list>(<argument><expr><literal type="string">"-iii"</literal></expr></argument>)</argument_list></call></expr></argument>
               )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-a"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">""</literal>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-b"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"1"</literal>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-ccc"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"argument"</literal>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-d"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"e"</literal>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-fff"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"0"</literal>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-ggg"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"1"</literal>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-h"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"0"</literal>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-i"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"1"</literal>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-zzz"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"xxx"</literal>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-iii"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"xxx"</literal></expr></argument>
               )</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><decl><type><specifier>const</specifier> <name>bool</name></type> <name>def</name> <range>: <expr><block>{<expr><literal type="boolean">false</literal></expr>, <expr><literal type="boolean">true</literal></expr>}</block></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetBoolArg</name></name><argument_list>(<argument><expr><literal type="string">"-a"</literal></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call>
                     <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetBoolArg</name></name><argument_list>(<argument><expr><literal type="string">"-b"</literal></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call>
                     <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>test_args</name><operator>.</operator><name>GetBoolArg</name></name><argument_list>(<argument><expr><literal type="string">"-ccc"</literal></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call>
                     <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>test_args</name><operator>.</operator><name>GetBoolArg</name></name><argument_list>(<argument><expr><literal type="string">"-d"</literal></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call>
                     <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>test_args</name><operator>.</operator><name>GetBoolArg</name></name><argument_list>(<argument><expr><literal type="string">"-fff"</literal></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call>
                     <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetBoolArg</name></name><argument_list>(<argument><expr><literal type="string">"-ggg"</literal></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call>
                     <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>test_args</name><operator>.</operator><name>GetBoolArg</name></name><argument_list>(<argument><expr><literal type="string">"-h"</literal></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call>
                     <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetBoolArg</name></name><argument_list>(<argument><expr><literal type="string">"-i"</literal></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call>
                     <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetBoolArg</name></name><argument_list>(<argument><expr><literal type="string">"-zzz"</literal></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>def</name>
                     <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetBoolArg</name></name><argument_list>(<argument><expr><literal type="string">"-iii"</literal></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>def</name></expr></argument>
                   )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><literal type="string">"-a"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><literal type="string">"-a"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>front</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><literal type="string">"-b"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><literal type="string">"-b"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>front</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><literal type="string">"-ccc"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">2</literal>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><literal type="string">"-ccc"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>front</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="string">"argument"</literal>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><literal type="string">"-ccc"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>back</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="string">"multiple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><literal type="string">"-fff"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><literal type="string">"-nofff"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><literal type="string">"-ggg"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><literal type="string">"-ggg"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>front</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><literal type="string">"-noggg"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><literal type="string">"-h"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><literal type="string">"-noh"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><literal type="string">"-i"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><literal type="string">"-i"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>front</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><literal type="string">"-noi"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><literal type="string">"-zzz"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>test_args</name><operator>.</operator><name>IsArgNegated</name></name><argument_list>(<argument><expr><literal type="string">"-a"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>test_args</name><operator>.</operator><name>IsArgNegated</name></name><argument_list>(<argument><expr><literal type="string">"-b"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>test_args</name><operator>.</operator><name>IsArgNegated</name></name><argument_list>(<argument><expr><literal type="string">"-ccc"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>test_args</name><operator>.</operator><name>IsArgNegated</name></name><argument_list>(<argument><expr><literal type="string">"-d"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>IsArgNegated</name></name><argument_list>(<argument><expr><literal type="string">"-fff"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>test_args</name><operator>.</operator><name>IsArgNegated</name></name><argument_list>(<argument><expr><literal type="string">"-ggg"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>IsArgNegated</name></name><argument_list>(<argument><expr><literal type="string">"-h"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// last setting takes precedence</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>test_args</name><operator>.</operator><name>IsArgNegated</name></name><argument_list>(<argument><expr><literal type="string">"-i"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// last setting takes precedence</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>test_args</name><operator>.</operator><name>IsArgNegated</name></name><argument_list>(<argument><expr><literal type="string">"-zzz"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Test sections work</comment>
    <expr_stmt><expr><call><name><name>test_args</name><operator>.</operator><name>SelectConfigNetwork</name></name><argument_list>(<argument><expr><literal type="string">"sec1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// same as original</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-a"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">""</literal>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-b"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"1"</literal>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-fff"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"0"</literal>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-ggg"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"1"</literal>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-zzz"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"xxx"</literal>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-iii"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"xxx"</literal></expr></argument>
               )</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// d is overridden</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-d"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"eee"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// section-specific setting</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-h"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// section takes priority for multiple values</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-ccc"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"extend1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// check multiple values works</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>&gt;</argument_list></name></type> <name>sec1_ccc_expected</name> <init>= <expr><block>{<expr><literal type="string">"extend1"</literal></expr>,<expr><literal type="string">"extend2"</literal></expr>,<expr><literal type="string">"argument"</literal></expr>,<expr><literal type="string">"multiple"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>sec1_ccc_res</name> <init>= <expr><call><name><name>test_args</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><literal type="string">"-ccc"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL_COLLECTIONS</name><argument_list>(<argument><expr><call><name><name>sec1_ccc_res</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>sec1_ccc_res</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>sec1_ccc_expected</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>sec1_ccc_expected</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>test_args</name><operator>.</operator><name>SelectConfigNetwork</name></name><argument_list>(<argument><expr><literal type="string">"sec2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// same as original</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-a"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">""</literal>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-b"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"1"</literal>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-d"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"e"</literal>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-fff"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"0"</literal>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-ggg"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"1"</literal>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-zzz"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"xxx"</literal>
                <operator>&amp;&amp;</operator> <call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-h"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"0"</literal></expr></argument>
               )</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// section-specific setting</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-iii"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// section takes priority for multiple values</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-ccc"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"extend3"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// check multiple values works</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>&gt;</argument_list></name></type> <name>sec2_ccc_expected</name> <init>= <expr><block>{<expr><literal type="string">"extend3"</literal></expr>,<expr><literal type="string">"argument"</literal></expr>,<expr><literal type="string">"multiple"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>sec2_ccc_res</name> <init>= <expr><call><name><name>test_args</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><literal type="string">"-ccc"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL_COLLECTIONS</name><argument_list>(<argument><expr><call><name><name>sec2_ccc_res</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>sec2_ccc_res</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>sec2_ccc_expected</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>sec2_ccc_expected</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Test section only options</comment>

    <expr_stmt><expr><call><name><name>test_args</name><operator>.</operator><name>SetNetworkOnlyArg</name></name><argument_list>(<argument><expr><literal type="string">"-d"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>test_args</name><operator>.</operator><name>SetNetworkOnlyArg</name></name><argument_list>(<argument><expr><literal type="string">"-ccc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>test_args</name><operator>.</operator><name>SetNetworkOnlyArg</name></name><argument_list>(<argument><expr><literal type="string">"-h"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>test_args</name><operator>.</operator><name>SelectConfigNetwork</name></name><argument_list>(<argument><expr><name><name>CBaseChainParams</name><operator>::</operator><name>MAIN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-d"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"e"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><literal type="string">"-ccc"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-h"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>test_args</name><operator>.</operator><name>SelectConfigNetwork</name></name><argument_list>(<argument><expr><literal type="string">"sec1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-d"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"eee"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><literal type="string">"-d"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><literal type="string">"-ccc"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-h"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>test_args</name><operator>.</operator><name>SelectConfigNetwork</name></name><argument_list>(<argument><expr><literal type="string">"sec2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-d"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"xxx"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><literal type="string">"-d"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><literal type="string">"-ccc"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-h"</literal></expr></argument>, <argument><expr><literal type="string">"xxx"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>util_GetArg</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name>TestArgsManager</name></type> <name>testArgs</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>testArgs</name><operator>.</operator><name>cs_args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>command_line_options</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>command_line_options</name><index>[<expr><literal type="string">"strtest1"</literal></expr>]</index></name> <operator>=</operator> <block>{<expr><literal type="string">"string..."</literal></expr>}</block></expr>;</expr_stmt>
    <comment type="line">// strtest2 undefined on purpose</comment>
    <expr_stmt><expr><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>command_line_options</name><index>[<expr><literal type="string">"inttest1"</literal></expr>]</index></name> <operator>=</operator> <block>{<expr><literal type="string">"12345"</literal></expr>}</block></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>command_line_options</name><index>[<expr><literal type="string">"inttest2"</literal></expr>]</index></name> <operator>=</operator> <block>{<expr><literal type="string">"81985529216486895"</literal></expr>}</block></expr>;</expr_stmt>
    <comment type="line">// inttest3 undefined on purpose</comment>
    <expr_stmt><expr><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>command_line_options</name><index>[<expr><literal type="string">"booltest1"</literal></expr>]</index></name> <operator>=</operator> <block>{<expr><literal type="string">""</literal></expr>}</block></expr>;</expr_stmt>
    <comment type="line">// booltest2 undefined on purpose</comment>
    <expr_stmt><expr><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>command_line_options</name><index>[<expr><literal type="string">"booltest3"</literal></expr>]</index></name> <operator>=</operator> <block>{<expr><literal type="string">"0"</literal></expr>}</block></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>command_line_options</name><index>[<expr><literal type="string">"booltest4"</literal></expr>]</index></name> <operator>=</operator> <block>{<expr><literal type="string">"1"</literal></expr>}</block></expr>;</expr_stmt>

    <comment type="line">// priorities</comment>
    <expr_stmt><expr><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>command_line_options</name><index>[<expr><literal type="string">"pritest1"</literal></expr>]</index></name> <operator>=</operator> <block>{<expr><literal type="string">"a"</literal></expr>, <expr><literal type="string">"b"</literal></expr>}</block></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>ro_config</name><index>[<expr><literal type="string">""</literal></expr>]</index><index>[<expr><literal type="string">"pritest2"</literal></expr>]</index></name> <operator>=</operator> <block>{<expr><literal type="string">"a"</literal></expr>, <expr><literal type="string">"b"</literal></expr>}</block></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>command_line_options</name><index>[<expr><literal type="string">"pritest3"</literal></expr>]</index></name> <operator>=</operator> <block>{<expr><literal type="string">"a"</literal></expr>}</block></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>ro_config</name><index>[<expr><literal type="string">""</literal></expr>]</index><index>[<expr><literal type="string">"pritest3"</literal></expr>]</index></name> <operator>=</operator> <block>{<expr><literal type="string">"b"</literal></expr>}</block></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>command_line_options</name><index>[<expr><literal type="string">"pritest4"</literal></expr>]</index></name> <operator>=</operator> <block>{<expr><literal type="string">"a"</literal></expr>,<expr><literal type="string">"b"</literal></expr>}</block></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>testArgs</name><operator>.</operator><name>m_settings</name><operator>.</operator><name>ro_config</name><index>[<expr><literal type="string">""</literal></expr>]</index><index>[<expr><literal type="string">"pritest4"</literal></expr>]</index></name> <operator>=</operator> <block>{<expr><literal type="string">"c"</literal></expr>,<expr><literal type="string">"d"</literal></expr>}</block></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"strtest1"</literal></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"string..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"strtest2"</literal></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"inttest1"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">12345</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"inttest2"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">81985529216486895LL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"inttest3"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>GetBoolArg</name></name><argument_list>(<argument><expr><literal type="string">"booltest1"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>GetBoolArg</name></name><argument_list>(<argument><expr><literal type="string">"booltest2"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>GetBoolArg</name></name><argument_list>(<argument><expr><literal type="string">"booltest3"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>GetBoolArg</name></name><argument_list>(<argument><expr><literal type="string">"booltest4"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"pritest1"</literal></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"b"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"pritest2"</literal></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"pritest3"</literal></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>testArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"pritest4"</literal></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"b"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>util_GetChainName</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name>TestArgsManager</name></type> <name>test_args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>testnet</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><literal type="string">"-testnet"</literal></expr></argument>, <argument><expr><name><name>ArgsManager</name><operator>::</operator><name>ALLOW_BOOL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>regtest</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><literal type="string">"-regtest"</literal></expr></argument>, <argument><expr><name><name>ArgsManager</name><operator>::</operator><name>ALLOW_BOOL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>test_args</name><operator>.</operator><name>SetupArgs</name></name><argument_list>(<argument><expr><block>{<expr><name>testnet</name></expr>, <expr><name>regtest</name></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name><name>argv_testnet</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"cmd"</literal></expr>, <expr><literal type="string">"-testnet"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name><name>argv_regtest</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"cmd"</literal></expr>, <expr><literal type="string">"-regtest"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name><name>argv_test_no_reg</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"cmd"</literal></expr>, <expr><literal type="string">"-testnet"</literal></expr>, <expr><literal type="string">"-noregtest"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name><name>argv_both</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"cmd"</literal></expr>, <expr><literal type="string">"-testnet"</literal></expr>, <expr><literal type="string">"-regtest"</literal></expr>}</block></expr></init></decl>;</decl_stmt>

    <comment type="line">// equivalent to "-testnet"</comment>
    <comment type="line">// regtest in testnet section is ignored</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>testnetconf</name> <init>= <expr><literal type="string">"testnet=1\nregtest=0\n[test]\nregtest=1"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>error</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>ParseParameters</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>argv_testnet</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetChainName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>ParseParameters</name></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>argv_testnet</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetChainName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>ParseParameters</name></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>argv_regtest</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetChainName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"regtest"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>ParseParameters</name></name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>argv_test_no_reg</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetChainName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>ParseParameters</name></name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>argv_both</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_THROW</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetChainName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>runtime_error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>ParseParameters</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>argv_testnet</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>test_args</name><operator>.</operator><name>ReadConfigString</name></name><argument_list>(<argument><expr><name>testnetconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetChainName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>ParseParameters</name></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>argv_testnet</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>test_args</name><operator>.</operator><name>ReadConfigString</name></name><argument_list>(<argument><expr><name>testnetconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetChainName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>ParseParameters</name></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>argv_regtest</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>test_args</name><operator>.</operator><name>ReadConfigString</name></name><argument_list>(<argument><expr><name>testnetconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_THROW</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetChainName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>runtime_error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>ParseParameters</name></name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>argv_test_no_reg</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>test_args</name><operator>.</operator><name>ReadConfigString</name></name><argument_list>(<argument><expr><name>testnetconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetChainName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>ParseParameters</name></name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>argv_both</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>test_args</name><operator>.</operator><name>ReadConfigString</name></name><argument_list>(<argument><expr><name>testnetconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_THROW</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetChainName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>runtime_error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// check setting the network to test (and thus making</comment>
    <comment type="line">// [test] regtest=1 potentially relevant) doesn't break things</comment>
    <expr_stmt><expr><call><name><name>test_args</name><operator>.</operator><name>SelectConfigNetwork</name></name><argument_list>(<argument><expr><literal type="string">"test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>ParseParameters</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>argv_testnet</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>test_args</name><operator>.</operator><name>ReadConfigString</name></name><argument_list>(<argument><expr><name>testnetconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetChainName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>ParseParameters</name></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>argv_testnet</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>test_args</name><operator>.</operator><name>ReadConfigString</name></name><argument_list>(<argument><expr><name>testnetconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetChainName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>ParseParameters</name></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>argv_regtest</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>test_args</name><operator>.</operator><name>ReadConfigString</name></name><argument_list>(<argument><expr><name>testnetconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_THROW</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetChainName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>runtime_error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>ParseParameters</name></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>argv_test_no_reg</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>test_args</name><operator>.</operator><name>ReadConfigString</name></name><argument_list>(<argument><expr><name>testnetconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetChainName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>ParseParameters</name></name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>argv_both</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>test_args</name><operator>.</operator><name>ReadConfigString</name></name><argument_list>(<argument><expr><name>testnetconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_THROW</name><argument_list>(<argument><expr><call><name><name>test_args</name><operator>.</operator><name>GetChainName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>runtime_error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<comment type="line">// Test different ways settings can be merged, and verify results. This test can</comment>
<comment type="line">// be used to confirm that updates to settings code don't change behavior</comment>
<comment type="line">// unintentionally.</comment>
<comment type="line">//</comment>
<comment type="line">// The test covers:</comment>
<comment type="line">//</comment>
<comment type="line">// - Combining different setting actions. Possible actions are: configuring a</comment>
<comment type="line">//   setting, negating a setting (adding "-no" prefix), and configuring/negating</comment>
<comment type="line">//   settings in a network section (adding "main." or "test." prefixes).</comment>
<comment type="line">//</comment>
<comment type="line">// - Combining settings from command line arguments and a config file.</comment>
<comment type="line">//</comment>
<comment type="line">// - Combining SoftSet and ForceSet calls.</comment>
<comment type="line">//</comment>
<comment type="line">// - Testing "main" and "test" network values to make sure settings from network</comment>
<comment type="line">//   sections are applied and to check for mainnet-specific behaviors like</comment>
<comment type="line">//   inheriting settings from the default section.</comment>
<comment type="line">//</comment>
<comment type="line">// - Testing network-specific settings like "-wallet", that may be ignored</comment>
<comment type="line">//   outside a network section, and non-network specific settings like "-server"</comment>
<comment type="line">//   that aren't sensitive to the network.</comment>
<comment type="line">//</comment>
<struct>struct <name>ArgsMergeTestingSetup</name> <super_list>: <super><specifier>public</specifier> <name>BasicTestingSetup</name></super></super_list> <block>{<public type="default">
    <comment type="line" format="doxygen">//! Max number of actions to sequence together. Can decrease this when</comment>
    <comment type="line" format="doxygen">//! debugging to make test results easier to understand.</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>constexpr</specifier> <name>int</name></type> <name>MAX_ACTIONS</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>

    <enum>enum <name>Action</name> <block>{ <decl><name>NONE</name></decl>, <decl><name>SET</name></decl>, <decl><name>NEGATE</name></decl>, <decl><name>SECTION_SET</name></decl>, <decl><name>SECTION_NEGATE</name></decl> }</block>;</enum>
    <using>using <name>ActionList</name> <init>= <type><name><name>Action</name><index>[<expr><name>MAX_ACTIONS</name></expr>]</index></name></type></init>;</using>

    <comment type="line" format="doxygen">//! Enumerate all possible test configurations.</comment>
    <function><template>template <parameter_list>&lt;<parameter><type><name>typename</name></type> <name>Fn</name></parameter>&gt;</parameter_list></template>
    <type><name>void</name></type> <name>ForEachMergeSetup</name><parameter_list>(<parameter><decl><type><name>Fn</name><modifier>&amp;&amp;</modifier></type> <name>fn</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ActionList</name></type> <name>arg_actions</name> <init>= <expr><block>{}</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ForEachNoDup</name><argument_list>(<argument><expr><name>arg_actions</name></expr></argument>, <argument><expr><name>SET</name></expr></argument>, <argument><expr><name>SECTION_NEGATE</name></expr></argument>, <argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture> <block>{<block_content>
            <decl_stmt><decl><type><name>ActionList</name> <name>conf_actions</name> = <block>{<block_content/>}</block></type></decl></decl_stmt><empty_stmt>;</empty_stmt>
            <expr_stmt><expr><call><name>ForEachNoDup</name><argument_list>(<argument><expr><name>conf_actions</name></expr></argument>, <argument><expr><name>SET</name></expr></argument>, <argument><expr><name>SECTION_NEGATE</name></expr></argument>, <argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture> <block>{<block_content>
                <for>for <control>(<init><decl><type><name>bool</name> <name>soft_set</name></type></decl></init></control></for></block_content></block></lambda></expr></argument></argument_list></call></expr></expr_stmt></block_content></block></lambda></expr></argument></argument_list></call></expr></expr_stmt></block_content></block></function> : <block>{<block_content><expr><literal type="boolean">false</literal></expr><operator>,</operator> <expr><literal type="boolean">true</literal></expr></block_content>}</block></public>)</block> <block>{<block_content>
                    <for>for <control>(<init><decl><type><name>bool</name></type> <name>force_set</name> <range>: <expr><block>{<expr><literal type="boolean">false</literal></expr>, <expr><literal type="boolean">true</literal></expr>}</block></expr></range></decl></init>)</control> <block>{<block_content>
                        <for>for <control>(<init><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>section</name> <range>: <expr><block>{<expr><name><name>CBaseChainParams</name><operator>::</operator><name>MAIN</name></name></expr>, <expr><name><name>CBaseChainParams</name><operator>::</operator><name>TESTNET</name></name></expr>}</block></expr></range></decl></init>)</control> <block>{<block_content>
                            <for>for <control>(<init><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>network</name> <range>: <expr><block>{<expr><name><name>CBaseChainParams</name><operator>::</operator><name>MAIN</name></name></expr>, <expr><name><name>CBaseChainParams</name><operator>::</operator><name>TESTNET</name></name></expr>}</block></expr></range></decl></init>)</control> <block>{<block_content>
                                <for>for <control>(<init><decl><type><name>bool</name></type> <name>net_specific</name> <range>: <expr><block>{<expr><literal type="boolean">false</literal></expr>, <expr><literal type="boolean">true</literal></expr>}</block></expr></range></decl></init>)</control> <block>{<block_content>
                                    <expr_stmt><expr><call><name>fn</name><argument_list>(<argument><expr><name>arg_actions</name></expr></argument>, <argument><expr><name>conf_actions</name></expr></argument>, <argument><expr><name>soft_set</name></expr></argument>, <argument><expr><name>force_set</name></expr></argument>, <argument><expr><name>section</name></expr></argument>, <argument><expr><name>network</name></expr></argument>, <argument><expr><name>net_specific</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></for>
                            </block_content>}</block></for>
                        </block_content>}</block></for>
                    </block_content>}</block></for>
                </block_content>}</block>
            <decl/></struct>})<empty_stmt>;</empty_stmt>
        })<empty_stmt>;</empty_stmt>
    }

    <comment type="line" format="doxygen">//! Translate actions into a list of &lt;key&gt;=&lt;value&gt; setting strings.</comment>
    std<function><type><name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>&gt;</argument_list></name></name></type> <name>GetValues</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ActionList</name><modifier>&amp;</modifier></type> <name>actions</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>section</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>name</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>value_prefix</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>&gt;</argument_list></name></type> <name>values</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>suffix</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>Action</name></type> <name>action</name> <range>: <expr><name>actions</name></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>NONE</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>prefix</name></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>SECTION_SET</name> <operator>||</operator> <name>action</name> <operator>==</operator> <name>SECTION_NEGATE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>prefix</name> <operator>=</operator> <name>section</name> <operator>+</operator> <literal type="string">"."</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>SET</name> <operator>||</operator> <name>action</name> <operator>==</operator> <name>SECTION_SET</name></expr>)</condition> <block>{<block_content>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>values</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>prefix</name> <operator>+</operator> <name>name</name> <operator>+</operator> <literal type="string">"="</literal> <operator>+</operator> <name>value_prefix</name> <operator>+</operator> <call><name><name>std</name><operator>::</operator><name>to_string</name></name><argument_list>(<argument><expr><operator>++</operator><name>suffix</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>NEGATE</name> <operator>||</operator> <name>action</name> <operator>==</operator> <name>SECTION_NEGATE</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>values</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>prefix</name> <operator>+</operator> <literal type="string">"no"</literal> <operator>+</operator> <name>name</name> <operator>+</operator> <literal type="string">"=1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <return>return <expr><name>values</name></expr>;</return>
    </block_content>}</block></function>
};

<comment type="line">// Regression test covering different ways config settings can be merged. The</comment>
<comment type="line">// test parses and merges settings, representing the results as strings that get</comment>
<comment type="line">// compared against an expected hash. To debug, the result strings can be dumped</comment>
<comment type="line">// to a file (see comments below).</comment>
<macro><name>BOOST_FIXTURE_TEST_CASE</name><argument_list>(<argument>util_ArgsMerge</argument>, <argument>ArgsMergeTestingSetup</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name>CHash256</name></type> <name>out_sha</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name><modifier>*</modifier></type> <name>out_file</name> <init>= <expr><literal type="null">nullptr</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>out_path</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"ARGS_MERGE_TEST_OUT"</literal></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>out_file</name> <operator>=</operator> <call><name><name>fsbridge</name><operator>::</operator><name>fopen</name></name><argument_list>(<argument><expr><name>out_path</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>out_file</name></expr>)</condition><block type="pseudo"><block_content> <throw>throw <expr><call><name><name>std</name><operator>::</operator><name>system_error</name></name><argument_list>(<argument><expr><name>errno</name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>generic_category</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"fopen failed"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ForEachMergeSetup</name><argument_list>(<argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ActionList</name><modifier>&amp;</modifier></type> <name>arg_actions</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ActionList</name><modifier>&amp;</modifier></type> <name>conf_actions</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>soft_set</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force_set</name></decl></parameter>,
                          <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>section</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>network</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>net_specific</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>TestArgsManager</name> <name>parser</name></type></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>parser</name><operator>.</operator><name>cs_args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name> <name>desc</name> = "net="</type></decl>;</decl_stmt>
        <expr_stmt><expr><name>desc</name> <operator>+=</operator> <name>network</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>parser</name><operator>.</operator><name>m_network</name></name> <operator>=</operator> <name>network</name></expr>;</expr_stmt>

        <decl_stmt><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier> <name>name</name> = <name>net_specific</name> <modifier/>? "wallet" : "server"</type></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <name>key</name> = "-" + <name>name</name></type></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>parser</name><operator>.</operator><name>AddArg</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>ArgsManager</name><operator>::</operator><name>ALLOW_ANY</name></name></expr></argument>, <argument><expr><name><name>OptionsCategory</name><operator>::</operator><name>OPTIONS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>net_specific</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>parser</name><operator>.</operator><name>SetNetworkOnlyArg</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>auto</name> <name>args</name> = <name>GetValues</name>(<name>arg_actions</name></type></decl>, <decl><type ref="prev"/><name>section</name></decl>, <decl><type ref="prev"/><name>name</name></decl>, "a");</decl_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>argv</name> = <block>{<block_content><expr><literal type="string">"ignored"</literal></expr></block_content>}</block></type></decl></decl_stmt><empty_stmt>;</empty_stmt>
        <for>for <control>(<init><expr><name>auto</name><operator>&amp;</operator> <name>arg</name> <operator>:</operator> <name>args</name></expr></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>arg</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>desc</name> <operator>+=</operator> <literal type="string">" "</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>desc</name> <operator>+=</operator> <name>arg</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>argv</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>arg</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name> <name>error</name></type></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>parser</name><operator>.</operator><name>ParseParameters</name></name><argument_list>(<argument><expr><call><name><name>argv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>argv</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name> <name>conf</name></type></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>auto</name><operator>&amp;</operator> <name>conf_val</name> <operator>:</operator> <call><name>GetValues</name><argument_list>(<argument><expr><name>conf_actions</name></expr></argument>, <argument><expr><name>section</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"c"</literal></expr></argument>)</argument_list></call></expr></init>)</control> <block>{<block_content>
            <expr_stmt><expr><name>desc</name> <operator>+=</operator> <literal type="string">" "</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>desc</name> <operator>+=</operator> <name>conf_val</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>conf</name> <operator>+=</operator> <name>conf_val</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>conf</name> <operator>+=</operator> <literal type="string">"\n"</literal></expr>;</expr_stmt>
        </block_content>}</block></for>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>istringstream</name></name> <name>conf_stream</name>(<name>conf</name></type></decl>);</decl_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>parser</name><operator>.</operator><name>ReadConfigStream</name></name><argument_list>(<argument><expr><name>conf_stream</name></expr></argument>, <argument><expr><literal type="string">"filepath"</literal></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>soft_set</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>desc</name> <operator>+=</operator> <literal type="string">" soft"</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>parser</name><operator>.</operator><name>SoftSetArg</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"soft1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>parser</name><operator>.</operator><name>SoftSetArg</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"soft2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>force_set</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>desc</name> <operator>+=</operator> <literal type="string">" force"</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>parser</name><operator>.</operator><name>ForceSetArg</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"force1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>parser</name><operator>.</operator><name>ForceSetArg</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"force2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>desc</name> <operator>+=</operator> <literal type="string">" || "</literal></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>parser</name><operator>.</operator><name>IsArgSet</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>desc</name> <operator>+=</operator> <literal type="string">"unset"</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>parser</name><operator>.</operator><name>IsArgNegated</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>parser</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>parser</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>empty</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>parser</name><operator>.</operator><name>IsArgNegated</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>desc</name> <operator>+=</operator> <literal type="string">"negated"</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>parser</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>parser</name><operator>.</operator><name>GetArgs</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>empty</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>desc</name> <operator>+=</operator> <call><name><name>parser</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>desc</name> <operator>+=</operator> <literal type="string">" |"</literal></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier> <name>arg</name> : <name><name>parser</name><operator>.</operator><name>GetArgs</name></name>(<name>key</name></type></decl></init>)</control><block type="pseudo"><block_content><expr_stmt><expr/></expr_stmt></block_content></block></for></block_content></block></else></if_stmt></block_content></block></lambda></expr></argument>)</argument_list></call> <block>{
                <expr><name>desc</name> <operator>+=</operator> <literal type="string">" "</literal></expr>;
                <expr><name>desc</name> <operator>+=</operator> <name>arg</name></expr>;
            }</block></expr></expr_stmt>
        </block_content>}</block>

        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>&gt;</argument_list></name></type> <name>ignored</name> <init>= <expr><call><name><name>parser</name><operator>.</operator><name>GetUnsuitableSectionOnlyArgs</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>ignored</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>desc</name> <operator>+=</operator> <literal type="string">" | ignored"</literal></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>arg</name> <range>: <expr><name>ignored</name></expr></range></decl></init>)</control> <block>{<block_content>
                <expr_stmt><expr><name>desc</name> <operator>+=</operator> <literal type="string">" "</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>desc</name> <operator>+=</operator> <name>arg</name></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>desc</name> <operator>+=</operator> <literal type="string">"\n"</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>out_sha</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><call><name><name>desc</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>desc</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>out_file</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>BOOST_REQUIRE</name><argument_list>(<argument><expr><call><name>fwrite</name><argument_list>(<argument><expr><call><name><name>desc</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>desc</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>out_file</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name><name>desc</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    })<empty_stmt>;</empty_stmt>

    <if_stmt><if>if <condition>(<expr><name>out_file</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name>out_file</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <throw>throw <expr><call><name><name>std</name><operator>::</operator><name>system_error</name></name><argument_list>(<argument><expr><name>errno</name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>generic_category</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"fclose failed"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>out_file</name> <operator>=</operator> <literal type="null">nullptr</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>out_sha_bytes</name><index>[<expr><name><name>CSHA256</name><operator>::</operator><name>OUTPUT_SIZE</name></name></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>out_sha</name><operator>.</operator><name>Finalize</name></name><argument_list>(<argument><expr><name>out_sha_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>out_sha_hex</name> <init>= <expr><call><name>HexStr</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>begin</name></name><argument_list>(<argument><expr><name>out_sha_bytes</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>end</name></name><argument_list>(<argument><expr><name>out_sha_bytes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// If check below fails, should manually dump the results with:</comment>
    <comment type="line">//</comment>
    <comment type="line">//   ARGS_MERGE_TEST_OUT=results.txt ./test_bitcoin --run_test=util_tests/util_ArgsMerge</comment>
    <comment type="line">//</comment>
    <comment type="line">// And verify diff against previous results to make sure the changes are expected.</comment>
    <comment type="line">//</comment>
    <comment type="line">// Results file is formatted like:</comment>
    <comment type="line">//</comment>
    <comment type="line">//   &lt;input&gt; || &lt;IsArgSet/IsArgNegated/GetArg output&gt; | &lt;GetArgs output&gt; | &lt;GetUnsuitable output&gt;</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>out_sha_hex</name></expr></argument>, <argument><expr><literal type="string">"b835eef5977d69114eb039a976201f8c7121f34fe2b7ea2b73cafb516e5c9dc8"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}

<comment type="line">// Similar test as above, but for ArgsManager::GetChainName function.</comment>
struct <label><name>ChainMergeTestingSetup</name> :</label> <expr_stmt><expr><specifier>public</specifier> <macro><name>BasicTestingSetup</name></macro> <block>{
    <expr><specifier>static</specifier> <specifier>constexpr</specifier> <name>int</name> <name>MAX_ACTIONS</name> <operator>=</operator> <literal type="number">2</literal></expr>;

    enum <expr><call><name>Action</name> <argument_list>{ <argument><expr><name>NONE</name></expr></argument>, <argument><expr><name>ENABLE_TEST</name></expr></argument>, <argument><expr><name>DISABLE_TEST</name></expr></argument>, <argument><expr><name>NEGATE_TEST</name></expr></argument>, <argument><expr><name>ENABLE_REG</name></expr></argument>, <argument><expr><name>DISABLE_REG</name></expr></argument>, <argument><expr><name>NEGATE_REG</name></expr></argument> }</argument_list></call></expr>;
    using <expr><name>ActionList</name> <operator>=</operator> <name><name>Action</name><index>[<expr><name>MAX_ACTIONS</name></expr>]</index></name></expr>;

    <comment type="line" format="doxygen">//! Enumerate all possible test configurations.</comment>
    <template>template <parameter_list>&lt;<parameter><type><name>typename</name></type> <name>Fn</name></parameter>&gt;</parameter_list>
    <function><type><name>void</name></type> <name>ForEachMergeSetup</name><parameter_list>(<parameter><decl><type><name>Fn</name><modifier>&amp;&amp;</modifier></type> <name>fn</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ActionList</name></type> <name>arg_actions</name> <init>= <expr><block>{}</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ForEachNoDup</name><argument_list>(<argument><expr><name>arg_actions</name></expr></argument>, <argument><expr><name>ENABLE_TEST</name></expr></argument>, <argument><expr><name>NEGATE_REG</name></expr></argument>, <argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture> <block>{<block_content>
            <decl_stmt><decl><type><name>ActionList</name> <name>conf_actions</name> = <block>{<block_content><expr_stmt/>}</block_content></block></type></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ForEachNoDup</name><argument_list>(<argument><expr><name>conf_actions</name></expr></argument>, <argument><expr><name>ENABLE_TEST</name></expr></argument>, <argument><expr><name>NEGATE_REG</name></expr></argument>, <argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture> <block>{<block_content> <expr_stmt><expr><call><name>fn</name><argument_list>(<argument><expr><name>arg_actions</name></expr></argument>, <argument><expr><name>conf_actions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt/>}</block_content></block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt/>}</block_content></block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt/></block_content></block></function></template>}</block></expr></expr_stmt>
};

<macro><name>BOOST_FIXTURE_TEST_CASE</name><argument_list>(<argument>util_ChainMerge</argument>, <argument>ChainMergeTestingSetup</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name>CHash256</name></type> <name>out_sha</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name><modifier>*</modifier></type> <name>out_file</name> <init>= <expr><literal type="null">nullptr</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>out_path</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"CHAIN_MERGE_TEST_OUT"</literal></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>out_file</name> <operator>=</operator> <call><name><name>fsbridge</name><operator>::</operator><name>fopen</name></name><argument_list>(<argument><expr><name>out_path</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>out_file</name></expr>)</condition><block type="pseudo"><block_content> <throw>throw <expr><call><name><name>std</name><operator>::</operator><name>system_error</name></name><argument_list>(<argument><expr><name>errno</name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>generic_category</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"fopen failed"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ForEachMergeSetup</name><argument_list>(<argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ActionList</name><modifier>&amp;</modifier></type> <name>arg_actions</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ActionList</name><modifier>&amp;</modifier></type> <name>conf_actions</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>TestArgsManager</name> <name>parser</name></type></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>parser</name><operator>.</operator><name>cs_args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>parser</name><operator>.</operator><name>AddArg</name></name><argument_list>(<argument><expr><literal type="string">"-regtest"</literal></expr></argument>, <argument><expr><literal type="string">"regtest"</literal></expr></argument>, <argument><expr><name><name>ArgsManager</name><operator>::</operator><name>ALLOW_ANY</name></name></expr></argument>, <argument><expr><name><name>OptionsCategory</name><operator>::</operator><name>OPTIONS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>parser</name><operator>.</operator><name>AddArg</name></name><argument_list>(<argument><expr><literal type="string">"-testnet"</literal></expr></argument>, <argument><expr><literal type="string">"testnet"</literal></expr></argument>, <argument><expr><name><name>ArgsManager</name><operator>::</operator><name>ALLOW_ANY</name></name></expr></argument>, <argument><expr><name><name>OptionsCategory</name><operator>::</operator><name>OPTIONS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>auto</name> <name>arg</name> = [](<name>Action</name> <name>action</name></type></decl>) <block>{<block_content> <return>return <expr><ternary><condition><expr><name>action</name> <operator>==</operator> <name>ENABLE_TEST</name></expr>  ?</condition><then> <expr><literal type="string">"-testnet=1"</literal></expr>   </then><else>:
                                              <expr><ternary><condition><expr><name>action</name> <operator>==</operator> <name>DISABLE_TEST</name></expr> ?</condition><then> <expr><literal type="string">"-testnet=0"</literal></expr>   </then><else>:
                                              <expr><ternary><condition><expr><name>action</name> <operator>==</operator> <name>NEGATE_TEST</name></expr>  ?</condition><then> <expr><literal type="string">"-notestnet=1"</literal></expr> </then><else>:
                                              <expr><ternary><condition><expr><name>action</name> <operator>==</operator> <name>ENABLE_REG</name></expr>   ?</condition><then> <expr><literal type="string">"-regtest=1"</literal></expr>   </then><else>:
                                              <expr><ternary><condition><expr><name>action</name> <operator>==</operator> <name>DISABLE_REG</name></expr>  ?</condition><then> <expr><literal type="string">"-regtest=0"</literal></expr>   </then><else>:
                                              <expr><ternary><condition><expr><name>action</name> <operator>==</operator> <name>NEGATE_REG</name></expr>   ?</condition><then> <expr><literal type="string">"-noregtest=1"</literal></expr> </then><else>: <expr><literal type="null">nullptr</literal></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr>;</return> </block_content>}</block></decl_stmt><empty_stmt>;</empty_stmt>

        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name> <name>desc</name></type></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>argv</name> = <block>{<block_content><expr><literal type="string">"ignored"</literal></expr></block_content>}</block></type></decl></decl_stmt><empty_stmt>;</empty_stmt>
        <for>for <control>(<init><decl><type><name>Action</name> <name>action</name> : <name>arg_actions</name></type></decl></init>)</control> <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <name>argstr</name> = <name>arg</name>(<name>action</name></type></decl>);</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>argstr</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name><name>argv</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>argstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>desc</name> <operator>+=</operator> <literal type="string">" "</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>desc</name> <operator>+=</operator> <call><name><name>argv</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name> <name>error</name></type></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>parser</name><operator>.</operator><name>ParseParameters</name></name><argument_list>(<argument><expr><call><name><name>argv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>argv</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name> <name>conf</name></type></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>Action</name> <name>action</name> : <name>conf_actions</name></type></decl></init>)</control> <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <name>argstr</name> = <name>arg</name>(<name>action</name></type></decl>);</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>argstr</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>desc</name> <operator>+=</operator> <literal type="string">" "</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>desc</name> <operator>+=</operator> <name>argstr</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>conf</name> <operator>+=</operator> <name>argstr</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>conf</name> <operator>+=</operator> <literal type="string">"\n"</literal></expr>;</expr_stmt>
        </block_content>}</block></for>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>istringstream</name></name> <name>conf_stream</name>(<name>conf</name></type></decl>);</decl_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>parser</name><operator>.</operator><name>ReadConfigStream</name></name><argument_list>(<argument><expr><name>conf_stream</name></expr></argument>, <argument><expr><literal type="string">"filepath"</literal></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>desc</name> <operator>+=</operator> <literal type="string">" || "</literal></expr>;</expr_stmt>
        <try>try <block>{<block_content>
            <expr_stmt><expr><name>desc</name> <operator>+=</operator> <call><name><name>parser</name><operator>.</operator><name>GetChainName</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>runtime_error</name></name><modifier>&amp;</modifier></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <expr_stmt><expr><name>desc</name> <operator>+=</operator> <literal type="string">"error: "</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>desc</name> <operator>+=</operator> <call><name><name>e</name><operator>.</operator><name>what</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></catch></try>
        <expr_stmt><expr><name>desc</name> <operator>+=</operator> <literal type="string">"\n"</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>out_sha</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><call><name><name>desc</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>desc</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>out_file</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>BOOST_REQUIRE</name><argument_list>(<argument><expr><call><name>fwrite</name><argument_list>(<argument><expr><call><name><name>desc</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>desc</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>out_file</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name><name>desc</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>out_file</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name>out_file</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <throw>throw <expr><call><name><name>std</name><operator>::</operator><name>system_error</name></name><argument_list>(<argument><expr><name>errno</name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>generic_category</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"fclose failed"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>out_file</name> <operator>=</operator> <literal type="null">nullptr</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>out_sha_bytes</name><index>[<expr><name><name>CSHA256</name><operator>::</operator><name>OUTPUT_SIZE</name></name></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>out_sha</name><operator>.</operator><name>Finalize</name></name><argument_list>(<argument><expr><name>out_sha_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>out_sha_hex</name> <init>= <expr><call><name>HexStr</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>begin</name></name><argument_list>(<argument><expr><name>out_sha_bytes</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>end</name></name><argument_list>(<argument><expr><name>out_sha_bytes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// If check below fails, should manually dump the results with:</comment>
    <comment type="line">//</comment>
    <comment type="line">//   CHAIN_MERGE_TEST_OUT=results.txt ./test_bitcoin --run_test=util_tests/util_ChainMerge</comment>
    <comment type="line">//</comment>
    <comment type="line">// And verify diff against previous results to make sure the changes are expected.</comment>
    <comment type="line">//</comment>
    <comment type="line">// Results file is formatted like:</comment>
    <comment type="line">//</comment>
    <comment type="line">//   &lt;input&gt; || &lt;output&gt;</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>out_sha_hex</name></expr></argument>, <argument><expr><literal type="string">"f0b3a3c29869edc765d579c928f7f1690a71fbb673b49ccf39cbc4de18156a0d"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>util_FormatMoney</argument>)</argument_list></macro>
<block>{<block_content>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatMoney</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"0.00"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatMoney</name><argument_list>(<argument><expr><operator>(</operator><name>COIN</name><operator>/</operator><literal type="number">10000</literal><operator>)</operator><operator>*</operator><literal type="number">123456789</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"12345.6789"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatMoney</name><argument_list>(<argument><expr><operator>-</operator><name>COIN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"-1.00"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatMoney</name><argument_list>(<argument><expr><name>COIN</name><operator>*</operator><literal type="number">100000000</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"100000000.00"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatMoney</name><argument_list>(<argument><expr><name>COIN</name><operator>*</operator><literal type="number">10000000</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"10000000.00"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatMoney</name><argument_list>(<argument><expr><name>COIN</name><operator>*</operator><literal type="number">1000000</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"1000000.00"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatMoney</name><argument_list>(<argument><expr><name>COIN</name><operator>*</operator><literal type="number">100000</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"100000.00"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatMoney</name><argument_list>(<argument><expr><name>COIN</name><operator>*</operator><literal type="number">10000</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"10000.00"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatMoney</name><argument_list>(<argument><expr><name>COIN</name><operator>*</operator><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"1000.00"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatMoney</name><argument_list>(<argument><expr><name>COIN</name><operator>*</operator><literal type="number">100</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"100.00"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatMoney</name><argument_list>(<argument><expr><name>COIN</name><operator>*</operator><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"10.00"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatMoney</name><argument_list>(<argument><expr><name>COIN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"1.00"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatMoney</name><argument_list>(<argument><expr><name>COIN</name><operator>/</operator><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"0.10"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatMoney</name><argument_list>(<argument><expr><name>COIN</name><operator>/</operator><literal type="number">100</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"0.01"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatMoney</name><argument_list>(<argument><expr><name>COIN</name><operator>/</operator><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"0.001"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatMoney</name><argument_list>(<argument><expr><name>COIN</name><operator>/</operator><literal type="number">10000</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"0.0001"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatMoney</name><argument_list>(<argument><expr><name>COIN</name><operator>/</operator><literal type="number">100000</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"0.00001"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatMoney</name><argument_list>(<argument><expr><name>COIN</name><operator>/</operator><literal type="number">1000000</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"0.000001"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatMoney</name><argument_list>(<argument><expr><name>COIN</name><operator>/</operator><literal type="number">10000000</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"0.0000001"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatMoney</name><argument_list>(<argument><expr><name>COIN</name><operator>/</operator><literal type="number">100000000</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"0.00000001"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>util_ParseMoney</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name>CAmount</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseMoney</name><argument_list>(<argument><expr><literal type="string">"0.0"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseMoney</name><argument_list>(<argument><expr><literal type="string">"12345.6789"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><operator>(</operator><name>COIN</name><operator>/</operator><literal type="number">10000</literal><operator>)</operator><operator>*</operator><literal type="number">123456789</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseMoney</name><argument_list>(<argument><expr><literal type="string">"100000000.00"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>COIN</name><operator>*</operator><literal type="number">100000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseMoney</name><argument_list>(<argument><expr><literal type="string">"10000000.00"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>COIN</name><operator>*</operator><literal type="number">10000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseMoney</name><argument_list>(<argument><expr><literal type="string">"1000000.00"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>COIN</name><operator>*</operator><literal type="number">1000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseMoney</name><argument_list>(<argument><expr><literal type="string">"100000.00"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>COIN</name><operator>*</operator><literal type="number">100000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseMoney</name><argument_list>(<argument><expr><literal type="string">"10000.00"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>COIN</name><operator>*</operator><literal type="number">10000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseMoney</name><argument_list>(<argument><expr><literal type="string">"1000.00"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>COIN</name><operator>*</operator><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseMoney</name><argument_list>(<argument><expr><literal type="string">"100.00"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>COIN</name><operator>*</operator><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseMoney</name><argument_list>(<argument><expr><literal type="string">"10.00"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>COIN</name><operator>*</operator><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseMoney</name><argument_list>(<argument><expr><literal type="string">"1.00"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>COIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseMoney</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>COIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseMoney</name><argument_list>(<argument><expr><literal type="string">"0.1"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>COIN</name><operator>/</operator><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseMoney</name><argument_list>(<argument><expr><literal type="string">"0.01"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>COIN</name><operator>/</operator><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseMoney</name><argument_list>(<argument><expr><literal type="string">"0.001"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>COIN</name><operator>/</operator><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseMoney</name><argument_list>(<argument><expr><literal type="string">"0.0001"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>COIN</name><operator>/</operator><literal type="number">10000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseMoney</name><argument_list>(<argument><expr><literal type="string">"0.00001"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>COIN</name><operator>/</operator><literal type="number">100000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseMoney</name><argument_list>(<argument><expr><literal type="string">"0.000001"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>COIN</name><operator>/</operator><literal type="number">1000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseMoney</name><argument_list>(<argument><expr><literal type="string">"0.0000001"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>COIN</name><operator>/</operator><literal type="number">10000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseMoney</name><argument_list>(<argument><expr><literal type="string">"0.00000001"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>COIN</name><operator>/</operator><literal type="number">100000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Attempted 63 bit overflow should fail</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseMoney</name><argument_list>(<argument><expr><literal type="string">"92233720368.54775808"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Parsing negative amounts must fail</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseMoney</name><argument_list>(<argument><expr><literal type="string">"-1"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>util_IsHex</argument>)</argument_list></macro>
<block>{<block_content>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>IsHex</name><argument_list>(<argument><expr><literal type="string">"00"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>IsHex</name><argument_list>(<argument><expr><literal type="string">"00112233445566778899aabbccddeeffAABBCCDDEEFF"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>IsHex</name><argument_list>(<argument><expr><literal type="string">"ff"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>IsHex</name><argument_list>(<argument><expr><literal type="string">"FF"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsHex</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsHex</name><argument_list>(<argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsHex</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsHex</name><argument_list>(<argument><expr><literal type="string">"eleven"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsHex</name><argument_list>(<argument><expr><literal type="string">"00xx00"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsHex</name><argument_list>(<argument><expr><literal type="string">"0x0000"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>util_IsHexNumber</argument>)</argument_list></macro>
<block>{<block_content>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>IsHexNumber</name><argument_list>(<argument><expr><literal type="string">"0x0"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>IsHexNumber</name><argument_list>(<argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>IsHexNumber</name><argument_list>(<argument><expr><literal type="string">"0x10"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>IsHexNumber</name><argument_list>(<argument><expr><literal type="string">"10"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>IsHexNumber</name><argument_list>(<argument><expr><literal type="string">"0xff"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>IsHexNumber</name><argument_list>(<argument><expr><literal type="string">"ff"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>IsHexNumber</name><argument_list>(<argument><expr><literal type="string">"0xFfa"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>IsHexNumber</name><argument_list>(<argument><expr><literal type="string">"Ffa"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>IsHexNumber</name><argument_list>(<argument><expr><literal type="string">"0x00112233445566778899aabbccddeeffAABBCCDDEEFF"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>IsHexNumber</name><argument_list>(<argument><expr><literal type="string">"00112233445566778899aabbccddeeffAABBCCDDEEFF"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsHexNumber</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="line">// empty string not allowed</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsHexNumber</name><argument_list>(<argument><expr><literal type="string">"0x"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// empty string after prefix not allowed</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsHexNumber</name><argument_list>(<argument><expr><literal type="string">"0x0 "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// no spaces at end,</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsHexNumber</name><argument_list>(<argument><expr><literal type="string">" 0x0"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// or beginning,</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsHexNumber</name><argument_list>(<argument><expr><literal type="string">"0x 0"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// or middle,</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsHexNumber</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="line">// etc.</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsHexNumber</name><argument_list>(<argument><expr><literal type="string">"0x0ga"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// invalid character</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsHexNumber</name><argument_list>(<argument><expr><literal type="string">"x0"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="line">// broken prefix</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsHexNumber</name><argument_list>(<argument><expr><literal type="string">"0x0x00"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// two prefixes not allowed</comment>

</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>util_seed_insecure_rand</argument>)</argument_list></macro>
<block>{<block_content>
    <expr_stmt><expr><call><name>SeedInsecureRand</name><argument_list>(<argument><expr><name><name>SeedRand</name><operator>::</operator><name>ZEROS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>mod</name><init>=<expr><literal type="number">2</literal></expr></init></decl>;</init><condition><expr><name>mod</name><operator>&lt;</operator><literal type="number">11</literal></expr>;</condition><incr><expr><name>mod</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>mask</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <comment type="line">// Really rough binomial confidence approximation.</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><literal type="number">30</literal><operator>*</operator><literal type="number">10000.</literal><operator>/</operator><name>mod</name><operator>*</operator><call><name>sqrt</name><argument_list>(<argument><expr><operator>(</operator><literal type="number">1.</literal><operator>/</operator><name>mod</name><operator>*</operator><operator>(</operator><literal type="number">1</literal><operator>-</operator><literal type="number">1.</literal><operator>/</operator><name>mod</name><operator>)</operator><operator>)</operator><operator>/</operator><literal type="number">10000.</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">//mask is 2^ceil(log2(mod))-1</comment>
        <while>while<condition>(<expr><name>mask</name><operator>&lt;</operator><name>mod</name><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>mask</name><operator>=</operator><operator>(</operator><name>mask</name><operator>&lt;&lt;</operator><literal type="number">1</literal><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></while>

        <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <comment type="line">//How often does it get a zero from the uniform range [0,mod)?</comment>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">10000</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>uint32_t</name></type> <name>rval</name></decl>;</decl_stmt>
            <do>do<block>{<block_content>
                <expr_stmt><expr><name>rval</name><operator>=</operator><call><name>InsecureRand32</name><argument_list>()</argument_list></call><operator>&amp;</operator><name>mask</name></expr>;</expr_stmt>
            </block_content>}</block>while<condition>(<expr><name>rval</name><operator>&gt;=</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>mod</name></expr>)</condition>;</do>
            <expr_stmt><expr><name>count</name> <operator>+=</operator> <name>rval</name><operator>==</operator><literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name>count</name><operator>&lt;=</operator><literal type="number">10000</literal><operator>/</operator><name>mod</name><operator>+</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name>count</name><operator>&gt;=</operator><literal type="number">10000</literal><operator>/</operator><name>mod</name><operator>-</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>util_TimingResistantEqual</argument>)</argument_list></macro>
<block>{<block_content>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>TimingResistantEqual</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>TimingResistantEqual</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">"abc"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>TimingResistantEqual</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">"abc"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>TimingResistantEqual</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">"aa"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>TimingResistantEqual</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">"aa"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>TimingResistantEqual</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">"abc"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">"abc"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>TimingResistantEqual</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">"abc"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">"aba"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<comment type="block">/* Test strprintf formatting directives.
 * Put a string before and after to ensure sanity of element sizes on stack. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>B</name></cpp:macro> <cpp:value>"check_prefix"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>E</name></cpp:macro> <cpp:value>"check_postfix"</cpp:value></cpp:define>
<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>strprintf_numbers</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>s64t</name> <init>= <expr><operator>-</operator><literal type="number">9223372036854775807LL</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* signed 64 bit test value */</comment>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>u64t</name> <init>= <expr><literal type="number">18446744073709551615ULL</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* unsigned 64 bit test value */</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"%s %d %s"</literal></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>s64t</name></expr></argument>, <argument><expr><name>E</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>B</name><literal type="string">" -9223372036854775807 "</literal> <name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"%s %u %s"</literal></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>u64t</name></expr></argument>, <argument><expr><name>E</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>B</name><literal type="string">" 18446744073709551615 "</literal> <name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"%s %x %s"</literal></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>u64t</name></expr></argument>, <argument><expr><name>E</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>B</name><literal type="string">" ffffffffffffffff "</literal> <name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>size_t</name></type> <name>st</name> <init>= <expr><literal type="number">12345678</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* unsigned size_t test value */</comment>
    <decl_stmt><decl><type><name>ssize_t</name></type> <name>sst</name> <init>= <expr><operator>-</operator><literal type="number">12345678</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* signed size_t test value */</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"%s %d %s"</literal></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>sst</name></expr></argument>, <argument><expr><name>E</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>B</name><literal type="string">" -12345678 "</literal> <name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"%s %u %s"</literal></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>E</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>B</name><literal type="string">" 12345678 "</literal> <name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"%s %x %s"</literal></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>E</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>B</name><literal type="string">" bc614e "</literal> <name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>pt</name> <init>= <expr><literal type="number">87654321</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* positive ptrdiff_t test value */</comment>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>spt</name> <init>= <expr><operator>-</operator><literal type="number">87654321</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* negative ptrdiff_t test value */</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"%s %d %s"</literal></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>spt</name></expr></argument>, <argument><expr><name>E</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>B</name><literal type="string">" -87654321 "</literal> <name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"%s %u %s"</literal></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>, <argument><expr><name>E</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>B</name><literal type="string">" 87654321 "</literal> <name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"%s %x %s"</literal></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>, <argument><expr><name>E</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>B</name><literal type="string">" 5397fb1 "</literal> <name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>B</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>E</name></cpp:undef>

<comment type="block">/* Check for mingw/wine issue #3494
 * Remove this test before time.ctime(0xffffffff) == 'Sun Feb  7 07:28:15 2106'
 */</comment>
<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>gettime</argument>)</argument_list></macro>
<block>{<block_content>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>(</operator><call><name>GetTime</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <operator>~</operator><literal type="number">0xFFFFFFFFLL</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>util_time_GetTime</argument>)</argument_list></macro>
<block>{<block_content>
    <expr_stmt><expr><call><name>SetMockTime</name><argument_list>(<argument><expr><literal type="number">111</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Check that mock time does not change after a sleep</comment>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>num_sleep</name> <range>: <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>MilliSleep</name><argument_list>(<argument><expr><name>num_sleep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><literal type="number">111</literal></expr></argument>, <argument><expr><call><name>GetTime</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Deprecated time getter</comment>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><literal type="number">111</literal></expr></argument>, <argument><expr><call><name><name>GetTime</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>seconds</name></name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>.</operator><call><name>count</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><literal type="number">111000</literal></expr></argument>, <argument><expr><call><name><name>GetTime</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>milliseconds</name></name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>.</operator><call><name>count</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><literal type="number">111000000</literal></expr></argument>, <argument><expr><call><name><name>GetTime</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>microseconds</name></name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>.</operator><call><name>count</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>SetMockTime</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Check that system time changes after a sleep</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>ms_0</name> <init>= <expr><call><name><name>GetTime</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>milliseconds</name></name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>us_0</name> <init>= <expr><call><name><name>GetTime</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>microseconds</name></name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>MilliSleep</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name>ms_0</name> <operator>&lt;</operator> <call><name><name>GetTime</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>milliseconds</name></name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name>us_0</name> <operator>&lt;</operator> <call><name><name>GetTime</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>microseconds</name></name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>test_IsDigit</argument>)</argument_list></macro>
<block>{<block_content>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>IsDigit</name><argument_list>(<argument><expr><literal type="char">'0'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>IsDigit</name><argument_list>(<argument><expr><literal type="char">'1'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>IsDigit</name><argument_list>(<argument><expr><literal type="char">'8'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>IsDigit</name><argument_list>(<argument><expr><literal type="char">'9'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>IsDigit</name><argument_list>(<argument><expr><literal type="char">'0'</literal> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>IsDigit</name><argument_list>(<argument><expr><literal type="char">'9'</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>IsDigit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>IsDigit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>IsDigit</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>IsDigit</name><argument_list>(<argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>test_ParseInt32</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>n</name></decl>;</decl_stmt>
    <comment type="line">// Valid values</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseInt32</name><argument_list>(<argument><expr><literal type="string">"1234"</literal></expr></argument>, <argument><expr><literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseInt32</name><argument_list>(<argument><expr><literal type="string">"0"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseInt32</name><argument_list>(<argument><expr><literal type="string">"1234"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">1234</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseInt32</name><argument_list>(<argument><expr><literal type="string">"01234"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">1234</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// no octal</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseInt32</name><argument_list>(<argument><expr><literal type="string">"2147483647"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">2147483647</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseInt32</name><argument_list>(<argument><expr><literal type="string">"-2147483648"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <operator>(</operator><operator>-</operator><literal type="number">2147483647</literal> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// (-2147483647 - 1) equals INT_MIN</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseInt32</name><argument_list>(<argument><expr><literal type="string">"-1234"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <operator>-</operator><literal type="number">1234</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Invalid values</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseInt32</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseInt32</name><argument_list>(<argument><expr><literal type="string">" 1"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// no padding inside</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseInt32</name><argument_list>(<argument><expr><literal type="string">"1 "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseInt32</name><argument_list>(<argument><expr><literal type="string">"1a"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseInt32</name><argument_list>(<argument><expr><literal type="string">"aap"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseInt32</name><argument_list>(<argument><expr><literal type="string">"0x1"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// no hex</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseInt32</name><argument_list>(<argument><expr><literal type="string">"0x1"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// no hex</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>test_bytes</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="char">'1'</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="char">'1'</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>teststr</name><argument_list>(<argument><expr><name>test_bytes</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>test_bytes</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseInt32</name><argument_list>(<argument><expr><name>teststr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// no embedded NULs</comment>
    <comment type="line">// Overflow and underflow</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseInt32</name><argument_list>(<argument><expr><literal type="string">"-2147483649"</literal></expr></argument>, <argument><expr><literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseInt32</name><argument_list>(<argument><expr><literal type="string">"2147483648"</literal></expr></argument>, <argument><expr><literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseInt32</name><argument_list>(<argument><expr><literal type="string">"-32482348723847471234"</literal></expr></argument>, <argument><expr><literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseInt32</name><argument_list>(<argument><expr><literal type="string">"32482348723847471234"</literal></expr></argument>, <argument><expr><literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>test_ParseInt64</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>n</name></decl>;</decl_stmt>
    <comment type="line">// Valid values</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseInt64</name><argument_list>(<argument><expr><literal type="string">"1234"</literal></expr></argument>, <argument><expr><literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseInt64</name><argument_list>(<argument><expr><literal type="string">"0"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">0LL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseInt64</name><argument_list>(<argument><expr><literal type="string">"1234"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">1234LL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseInt64</name><argument_list>(<argument><expr><literal type="string">"01234"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">1234LL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// no octal</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseInt64</name><argument_list>(<argument><expr><literal type="string">"2147483647"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">2147483647LL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseInt64</name><argument_list>(<argument><expr><literal type="string">"-2147483648"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <operator>-</operator><literal type="number">2147483648LL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseInt64</name><argument_list>(<argument><expr><literal type="string">"9223372036854775807"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><literal type="number">9223372036854775807</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseInt64</name><argument_list>(<argument><expr><literal type="string">"-9223372036854775808"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><operator>-</operator><literal type="number">9223372036854775807</literal><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseInt64</name><argument_list>(<argument><expr><literal type="string">"-1234"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <operator>-</operator><literal type="number">1234LL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Invalid values</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseInt64</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseInt64</name><argument_list>(<argument><expr><literal type="string">" 1"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// no padding inside</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseInt64</name><argument_list>(<argument><expr><literal type="string">"1 "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseInt64</name><argument_list>(<argument><expr><literal type="string">"1a"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseInt64</name><argument_list>(<argument><expr><literal type="string">"aap"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseInt64</name><argument_list>(<argument><expr><literal type="string">"0x1"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// no hex</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>test_bytes</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="char">'1'</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="char">'1'</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>teststr</name><argument_list>(<argument><expr><name>test_bytes</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>test_bytes</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseInt64</name><argument_list>(<argument><expr><name>teststr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// no embedded NULs</comment>
    <comment type="line">// Overflow and underflow</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseInt64</name><argument_list>(<argument><expr><literal type="string">"-9223372036854775809"</literal></expr></argument>, <argument><expr><literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseInt64</name><argument_list>(<argument><expr><literal type="string">"9223372036854775808"</literal></expr></argument>, <argument><expr><literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseInt64</name><argument_list>(<argument><expr><literal type="string">"-32482348723847471234"</literal></expr></argument>, <argument><expr><literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseInt64</name><argument_list>(<argument><expr><literal type="string">"32482348723847471234"</literal></expr></argument>, <argument><expr><literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>test_ParseUInt32</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>n</name></decl>;</decl_stmt>
    <comment type="line">// Valid values</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseUInt32</name><argument_list>(<argument><expr><literal type="string">"1234"</literal></expr></argument>, <argument><expr><literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseUInt32</name><argument_list>(<argument><expr><literal type="string">"0"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseUInt32</name><argument_list>(<argument><expr><literal type="string">"1234"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">1234</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseUInt32</name><argument_list>(<argument><expr><literal type="string">"01234"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">1234</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// no octal</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseUInt32</name><argument_list>(<argument><expr><literal type="string">"2147483647"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">2147483647</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseUInt32</name><argument_list>(<argument><expr><literal type="string">"2147483648"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><literal type="number">2147483648</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseUInt32</name><argument_list>(<argument><expr><literal type="string">"4294967295"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><literal type="number">4294967295</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Invalid values</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseUInt32</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseUInt32</name><argument_list>(<argument><expr><literal type="string">" 1"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// no padding inside</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseUInt32</name><argument_list>(<argument><expr><literal type="string">" -1"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseUInt32</name><argument_list>(<argument><expr><literal type="string">"1 "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseUInt32</name><argument_list>(<argument><expr><literal type="string">"1a"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseUInt32</name><argument_list>(<argument><expr><literal type="string">"aap"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseUInt32</name><argument_list>(<argument><expr><literal type="string">"0x1"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// no hex</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseUInt32</name><argument_list>(<argument><expr><literal type="string">"0x1"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// no hex</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>test_bytes</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="char">'1'</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="char">'1'</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>teststr</name><argument_list>(<argument><expr><name>test_bytes</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>test_bytes</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseUInt32</name><argument_list>(<argument><expr><name>teststr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// no embedded NULs</comment>
    <comment type="line">// Overflow and underflow</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseUInt32</name><argument_list>(<argument><expr><literal type="string">"-2147483648"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseUInt32</name><argument_list>(<argument><expr><literal type="string">"4294967296"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseUInt32</name><argument_list>(<argument><expr><literal type="string">"-1234"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseUInt32</name><argument_list>(<argument><expr><literal type="string">"-32482348723847471234"</literal></expr></argument>, <argument><expr><literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseUInt32</name><argument_list>(<argument><expr><literal type="string">"32482348723847471234"</literal></expr></argument>, <argument><expr><literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>test_ParseUInt64</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>n</name></decl>;</decl_stmt>
    <comment type="line">// Valid values</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseUInt64</name><argument_list>(<argument><expr><literal type="string">"1234"</literal></expr></argument>, <argument><expr><literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseUInt64</name><argument_list>(<argument><expr><literal type="string">"0"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">0LL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseUInt64</name><argument_list>(<argument><expr><literal type="string">"1234"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">1234LL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseUInt64</name><argument_list>(<argument><expr><literal type="string">"01234"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">1234LL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// no octal</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseUInt64</name><argument_list>(<argument><expr><literal type="string">"2147483647"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">2147483647LL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseUInt64</name><argument_list>(<argument><expr><literal type="string">"9223372036854775807"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">9223372036854775807ULL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseUInt64</name><argument_list>(<argument><expr><literal type="string">"9223372036854775808"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">9223372036854775808ULL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseUInt64</name><argument_list>(<argument><expr><literal type="string">"18446744073709551615"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">18446744073709551615ULL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Invalid values</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseUInt64</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseUInt64</name><argument_list>(<argument><expr><literal type="string">" 1"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// no padding inside</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseUInt64</name><argument_list>(<argument><expr><literal type="string">" -1"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseUInt64</name><argument_list>(<argument><expr><literal type="string">"1 "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseUInt64</name><argument_list>(<argument><expr><literal type="string">"1a"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseUInt64</name><argument_list>(<argument><expr><literal type="string">"aap"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseUInt64</name><argument_list>(<argument><expr><literal type="string">"0x1"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// no hex</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>test_bytes</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="char">'1'</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="char">'1'</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>teststr</name><argument_list>(<argument><expr><name>test_bytes</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>test_bytes</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseUInt64</name><argument_list>(<argument><expr><name>teststr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// no embedded NULs</comment>
    <comment type="line">// Overflow and underflow</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseUInt64</name><argument_list>(<argument><expr><literal type="string">"-9223372036854775809"</literal></expr></argument>, <argument><expr><literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseUInt64</name><argument_list>(<argument><expr><literal type="string">"18446744073709551616"</literal></expr></argument>, <argument><expr><literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseUInt64</name><argument_list>(<argument><expr><literal type="string">"-32482348723847471234"</literal></expr></argument>, <argument><expr><literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseUInt64</name><argument_list>(<argument><expr><literal type="string">"-2147483648"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseUInt64</name><argument_list>(<argument><expr><literal type="string">"-9223372036854775808"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseUInt64</name><argument_list>(<argument><expr><literal type="string">"-1234"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>test_ParseDouble</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>n</name></decl>;</decl_stmt>
    <comment type="line">// Valid values</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseDouble</name><argument_list>(<argument><expr><literal type="string">"1234"</literal></expr></argument>, <argument><expr><literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseDouble</name><argument_list>(<argument><expr><literal type="string">"0"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseDouble</name><argument_list>(<argument><expr><literal type="string">"1234"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">1234.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseDouble</name><argument_list>(<argument><expr><literal type="string">"01234"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">1234.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// no octal</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseDouble</name><argument_list>(<argument><expr><literal type="string">"2147483647"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">2147483647.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseDouble</name><argument_list>(<argument><expr><literal type="string">"-2147483648"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <operator>-</operator><literal type="number">2147483648.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseDouble</name><argument_list>(<argument><expr><literal type="string">"-1234"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <operator>-</operator><literal type="number">1234.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseDouble</name><argument_list>(<argument><expr><literal type="string">"1e6"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">1e6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseDouble</name><argument_list>(<argument><expr><literal type="string">"-1e6"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <operator>-</operator><literal type="number">1e6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Invalid values</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseDouble</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseDouble</name><argument_list>(<argument><expr><literal type="string">" 1"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// no padding inside</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseDouble</name><argument_list>(<argument><expr><literal type="string">"1 "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseDouble</name><argument_list>(<argument><expr><literal type="string">"1a"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseDouble</name><argument_list>(<argument><expr><literal type="string">"aap"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseDouble</name><argument_list>(<argument><expr><literal type="string">"0x1"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// no hex</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>test_bytes</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="char">'1'</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="char">'1'</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>teststr</name><argument_list>(<argument><expr><name>test_bytes</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>test_bytes</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseDouble</name><argument_list>(<argument><expr><name>teststr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// no embedded NULs</comment>
    <comment type="line">// Overflow and underflow</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseDouble</name><argument_list>(<argument><expr><literal type="string">"-1e10000"</literal></expr></argument>, <argument><expr><literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseDouble</name><argument_list>(<argument><expr><literal type="string">"1e10000"</literal></expr></argument>, <argument><expr><literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>test_FormatParagraph</argument>)</argument_list></macro>
<block>{<block_content>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatParagraph</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">79</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatParagraph</name><argument_list>(<argument><expr><literal type="string">"test"</literal></expr></argument>, <argument><expr><literal type="number">79</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatParagraph</name><argument_list>(<argument><expr><literal type="string">" test"</literal></expr></argument>, <argument><expr><literal type="number">79</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">" test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatParagraph</name><argument_list>(<argument><expr><literal type="string">"test test"</literal></expr></argument>, <argument><expr><literal type="number">79</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"test test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatParagraph</name><argument_list>(<argument><expr><literal type="string">"test test"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"test\ntest"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatParagraph</name><argument_list>(<argument><expr><literal type="string">"testerde test"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"testerde\ntest"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatParagraph</name><argument_list>(<argument><expr><literal type="string">"test test"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"test\n    test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Make sure we don't indent a fully-new line following a too-long line ending</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatParagraph</name><argument_list>(<argument><expr><literal type="string">"test test\nabc"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"test\n    test\nabc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatParagraph</name><argument_list>(<argument><expr><literal type="string">"This_is_a_very_long_test_string_without_any_spaces_so_it_should_just_get_returned_as_is_despite_the_length until it gets here"</literal></expr></argument>, <argument><expr><literal type="number">79</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"This_is_a_very_long_test_string_without_any_spaces_so_it_should_just_get_returned_as_is_despite_the_length\nuntil it gets here"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Test wrap length is exact</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatParagraph</name><argument_list>(<argument><expr><literal type="string">"a b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 7 8 9 a b c de f g h i j k l m n o p"</literal></expr></argument>, <argument><expr><literal type="number">79</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"a b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 7 8 9 a b c de\nf g h i j k l m n o p"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatParagraph</name><argument_list>(<argument><expr><literal type="string">"x\na b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 7 8 9 a b c de f g h i j k l m n o p"</literal></expr></argument>, <argument><expr><literal type="number">79</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"x\na b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 7 8 9 a b c de\nf g h i j k l m n o p"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Indent should be included in length of lines</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatParagraph</name><argument_list>(<argument><expr><literal type="string">"x\na b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 7 8 9 a b c de f g h i j k l m n o p q r s t u v w x y z 0 1 2 3 4 5 6 7 8 9 a b c d e fg h i j k"</literal></expr></argument>, <argument><expr><literal type="number">79</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"x\na b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 7 8 9 a b c de\n    f g h i j k l m n o p q r s t u v w x y z 0 1 2 3 4 5 6 7 8 9 a b c d e fg\n    h i j k"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatParagraph</name><argument_list>(<argument><expr><literal type="string">"This is a very long test string. This is a second sentence in the very long test string."</literal></expr></argument>, <argument><expr><literal type="number">79</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"This is a very long test string. This is a second sentence in the very long\ntest string."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatParagraph</name><argument_list>(<argument><expr><literal type="string">"This is a very long test string.\nThis is a second sentence in the very long test string. This is a third sentence in the very long test string."</literal></expr></argument>, <argument><expr><literal type="number">79</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"This is a very long test string.\nThis is a second sentence in the very long test string. This is a third\nsentence in the very long test string."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatParagraph</name><argument_list>(<argument><expr><literal type="string">"This is a very long test string.\n\nThis is a second sentence in the very long test string. This is a third sentence in the very long test string."</literal></expr></argument>, <argument><expr><literal type="number">79</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"This is a very long test string.\n\nThis is a second sentence in the very long test string. This is a third\nsentence in the very long test string."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatParagraph</name><argument_list>(<argument><expr><literal type="string">"Testing that normal newlines do not get indented.\nLike here."</literal></expr></argument>, <argument><expr><literal type="number">79</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Testing that normal newlines do not get indented.\nLike here."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>test_FormatSubVersion</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>&gt;</argument_list></name></type> <name>comments</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>comments</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">"comment1"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>&gt;</argument_list></name></type> <name>comments2</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>comments2</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">"comment1"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>comments2</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>SanitizeString</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">"Comment2; .,_?@-; !\"#$%&amp;'()*+/&lt;=&gt;[]\\^`{|}~"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SAFE_CHARS_UA_COMMENT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Semicolon is discouraged but not forbidden by BIP-0014</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatSubVersion</name><argument_list>(<argument><expr><literal type="string">"Test"</literal></expr></argument>, <argument><expr><literal type="number">99900</literal></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">"/Test:0.9.99/"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatSubVersion</name><argument_list>(<argument><expr><literal type="string">"Test"</literal></expr></argument>, <argument><expr><literal type="number">99900</literal></expr></argument>, <argument><expr><name>comments</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">"/Test:0.9.99(comment1)/"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>FormatSubVersion</name><argument_list>(<argument><expr><literal type="string">"Test"</literal></expr></argument>, <argument><expr><literal type="number">99900</literal></expr></argument>, <argument><expr><name>comments2</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><literal type="string">"/Test:0.9.99(comment1; Comment2; .,_?@-; )/"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>test_ParseFixedPoint</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>amount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"0"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>amount</name></expr></argument>, <argument><expr><literal type="number">0LL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>amount</name></expr></argument>, <argument><expr><literal type="number">100000000LL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"0.0"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>amount</name></expr></argument>, <argument><expr><literal type="number">0LL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"-0.1"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>amount</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">10000000LL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"1.1"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>amount</name></expr></argument>, <argument><expr><literal type="number">110000000LL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"1.10000000000000000"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>amount</name></expr></argument>, <argument><expr><literal type="number">110000000LL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"1.1e1"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>amount</name></expr></argument>, <argument><expr><literal type="number">1100000000LL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"1.1e-1"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>amount</name></expr></argument>, <argument><expr><literal type="number">11000000LL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"1000"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>amount</name></expr></argument>, <argument><expr><literal type="number">100000000000LL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"-1000"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>amount</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">100000000000LL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"0.00000001"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>amount</name></expr></argument>, <argument><expr><literal type="number">1LL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"0.0000000100000000"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>amount</name></expr></argument>, <argument><expr><literal type="number">1LL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"-0.00000001"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>amount</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1LL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"1000000000.00000001"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>amount</name></expr></argument>, <argument><expr><literal type="number">100000000000000001LL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"9999999999.99999999"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>amount</name></expr></argument>, <argument><expr><literal type="number">999999999999999999LL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"-9999999999.99999999"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>amount</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">999999999999999999LL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"-"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"a-1000"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"-a1000"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"-1000a"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"-01000"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"00.1"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">".1"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"--0.1"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"0.000000001"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"-0.000000001"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"0.00000001000000001"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"-10000000000.00000000"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"10000000000.00000000"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"-10000000000.00000001"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"10000000000.00000001"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"-10000000000.00000009"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"10000000000.00000009"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"-99999999999.99999999"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"99999909999.09999999"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"92233720368.54775807"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"92233720368.54775808"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"-92233720368.54775808"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"-92233720368.54775809"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"1.1e"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"1.1e-"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>ParseFixedPoint</name><argument_list>(<argument><expr><literal type="string">"1."</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<function><type><specifier>static</specifier> <name>void</name></type> <name>TestOtherThread</name><parameter_list>(<parameter><decl><type><name><name>fs</name><operator>::</operator><name>path</name></name></type> <name>dirname</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>lockname</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>LockDirectory</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>lockname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef> <comment type="line">// Cannot do this test on WIN32 due to lack of fork()</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>constexpr</specifier> <name>char</name></type> <name>LockCommand</name> <init>= <expr><literal type="char">'L'</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>constexpr</specifier> <name>char</name></type> <name>UnlockCommand</name> <init>= <expr><literal type="char">'U'</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>constexpr</specifier> <name>char</name></type> <name>ExitCommand</name> <init>= <expr><literal type="char">'X'</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>TestOtherProcess</name><parameter_list>(<parameter><decl><type><name><name>fs</name><operator>::</operator><name>path</name></name></type> <name>dirname</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>lockname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name>ch</name></decl>;</decl_stmt>
    <while>while <condition>(<expr><literal type="boolean">true</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr><call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ch</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// Wait for command</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rv</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch<condition>(<expr><name>ch</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>LockCommand</name></expr>:</case>
            <expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>LockDirectory</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>lockname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ch</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rv</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>UnlockCommand</name></expr>:</case>
            <expr_stmt><expr><call><name>ReleaseDirectoryLocks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ch</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <comment type="line">// Always succeeds</comment>
            <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ch</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rv</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>ExitCommand</name></expr>:</case>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <default>default:</default>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
    </block_content>}</block></while>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>test_LockDirectory</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>fs</name><operator>::</operator><name>path</name></name></type> <name>dirname</name> <init>= <expr><call><name>GetDataDir</name><argument_list>()</argument_list></call> <operator>/</operator> <literal type="string">"lock_dir"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name></type> <name>lockname</name> <init>= <expr><literal type="string">".lock"</literal></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
    <comment type="line">// Revert SIGCHLD to default, otherwise boost.test will catch and fail on</comment>
    <comment type="line">// it: there is BOOST_TEST_IGNORE_SIGCHLD but that only works when defined</comment>
    <comment type="line">// at build-time of the boost library</comment>
    <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>old_handler</name>)<parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list> <init>= <expr><call><name>signal</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <name>SIG_DFL</name>)</argument_list></call></expr></init>;</function_decl>

    <comment type="line">// Fork another process for testing before creating the lock, so that we</comment>
    <comment type="line">// won't fork while holding the lock (which might be undefined, and is not</comment>
    <comment type="line">// relevant as test case as that is avoided with -daemonize).</comment>
    <decl_stmt><decl><type><name>int</name></type> <name><name>fd</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>socketpair</name><argument_list>(<argument><expr><name>AF_UNIX</name></expr></argument>, <argument><expr><name>SOCK_STREAM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name> <init>= <expr><call><name>fork</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pid</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>close</name><argument_list>(<argument><expr><name><name>fd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Child: close parent end</comment>
        <expr_stmt><expr><call><name>TestOtherProcess</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>lockname</name></expr></argument>, <argument><expr><name><name>fd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>close</name><argument_list>(<argument><expr><name><name>fd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Parent: close child end</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="line">// Lock on non-existent directory should fail</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>LockDirectory</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>lockname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>fs</name><operator>::</operator><name>create_directories</name></name><argument_list>(<argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Probing lock on new directory should succeed</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>LockDirectory</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>lockname</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Persistent lock on new directory should succeed</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>LockDirectory</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>lockname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Another lock on the directory from the same thread should succeed</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>LockDirectory</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>lockname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Another lock on the directory from a different thread within the same process should succeed</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>threadresult</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>thread</name></name></type> <name>thr</name><argument_list>(<argument><expr><name>TestOtherThread</name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>lockname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>threadresult</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>thr</name><operator>.</operator><name>join</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>threadresult</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
    <comment type="line">// Try to acquire lock in child process while we're holding it, this should fail.</comment>
    <decl_stmt><decl><type><name>char</name></type> <name>ch</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>write</name><argument_list>(<argument><expr><name><name>fd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>LockCommand</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>read</name><argument_list>(<argument><expr><name><name>fd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ch</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><operator>(</operator><name>bool</name><operator>)</operator><name>ch</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Give up our lock</comment>
    <expr_stmt><expr><call><name>ReleaseDirectoryLocks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Probing lock from our side now should succeed, but not hold on to the lock.</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>LockDirectory</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>lockname</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Try to acquire the lock in the child process, this should be successful.</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>write</name><argument_list>(<argument><expr><name><name>fd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>LockCommand</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>read</name><argument_list>(<argument><expr><name><name>fd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ch</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><operator>(</operator><name>bool</name><operator>)</operator><name>ch</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// When we try to probe the lock now, it should fail.</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>LockDirectory</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>lockname</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Unlock the lock in the child process</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>write</name><argument_list>(<argument><expr><name><name>fd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>UnlockCommand</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>read</name><argument_list>(<argument><expr><name><name>fd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ch</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><operator>(</operator><name>bool</name><operator>)</operator><name>ch</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// When we try to probe the lock now, it should succeed.</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>LockDirectory</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>lockname</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Re-lock the lock in the child process, then wait for it to exit, check</comment>
    <comment type="line">// successful return. After that, we check that exiting the process</comment>
    <comment type="line">// has released the lock as we would expect by probing it.</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>processstatus</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>write</name><argument_list>(<argument><expr><name><name>fd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>LockCommand</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>write</name><argument_list>(<argument><expr><name><name>fd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ExitCommand</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>waitpid</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>processstatus</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>processstatus</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>LockDirectory</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>lockname</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Restore SIGCHLD</comment>
    <expr_stmt><expr><call><name>signal</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>old_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>close</name><argument_list>(<argument><expr><name><name>fd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Close our side of the socketpair</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="line">// Clean up</comment>
    <expr_stmt><expr><call><name>ReleaseDirectoryLocks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>fs</name><operator>::</operator><name>remove_all</name></name><argument_list>(<argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>test_DirIsWritable</argument>)</argument_list></macro>
<block>{<block_content>
    <comment type="line">// Should be able to write to the data dir.</comment>
    <decl_stmt><decl><type><name><name>fs</name><operator>::</operator><name>path</name></name></type> <name>tmpdirname</name> <init>= <expr><call><name>GetDataDir</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>DirIsWritable</name><argument_list>(<argument><expr><name>tmpdirname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Should not be able to write to a non-existent dir.</comment>
    <expr_stmt><expr><name>tmpdirname</name> <operator>=</operator> <name>tmpdirname</name> <operator>/</operator> <call><name><name>fs</name><operator>::</operator><name>unique_path</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>DirIsWritable</name><argument_list>(<argument><expr><name>tmpdirname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>fs</name><operator>::</operator><name>create_directory</name></name><argument_list>(<argument><expr><name>tmpdirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Should be able to write to it now.</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>DirIsWritable</name><argument_list>(<argument><expr><name>tmpdirname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>fs</name><operator>::</operator><name>remove</name></name><argument_list>(<argument><expr><name>tmpdirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>test_ToLower</argument>)</argument_list></macro>
<block>{<block_content>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>ToLower</name><argument_list>(<argument><expr><literal type="char">'@'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'@'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>ToLower</name><argument_list>(<argument><expr><literal type="char">'A'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'a'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>ToLower</name><argument_list>(<argument><expr><literal type="char">'Z'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'z'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>ToLower</name><argument_list>(<argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>ToLower</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>ToLower</name><argument_list>(<argument><expr><literal type="char">'\xff'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'\xff'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>ToLower</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>ToLower</name><argument_list>(<argument><expr><literal type="string">"#HODL"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"#hodl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>ToLower</name><argument_list>(<argument><expr><literal type="string">"\x00\xfe\xff"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"\x00\xfe\xff"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>test_ToUpper</argument>)</argument_list></macro>
<block>{<block_content>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>ToUpper</name><argument_list>(<argument><expr><literal type="char">'`'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'`'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>ToUpper</name><argument_list>(<argument><expr><literal type="char">'a'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'A'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>ToUpper</name><argument_list>(<argument><expr><literal type="char">'z'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'Z'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>ToUpper</name><argument_list>(<argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>ToUpper</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>ToUpper</name><argument_list>(<argument><expr><literal type="char">'\xff'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'\xff'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>ToUpper</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>ToUpper</name><argument_list>(<argument><expr><literal type="string">"#hodl"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"#HODL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>ToUpper</name><argument_list>(<argument><expr><literal type="string">"\x00\xfe\xff"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"\x00\xfe\xff"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>test_Capitalize</argument>)</argument_list></macro>
<block>{<block_content>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>Capitalize</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>Capitalize</name><argument_list>(<argument><expr><literal type="string">"bitcoin"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Bitcoin"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>Capitalize</name><argument_list>(<argument><expr><literal type="string">"\x00\xfe\xff"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"\x00\xfe\xff"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<function><type><specifier>static</specifier> <name><name>std</name><operator>::</operator><name>string</name></name></type> <name>SpanToStr</name><parameter_list>(<parameter><decl><type><name><name>Span</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>char</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>span</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><call><name><name>span</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>span</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>test_spanparsing</argument>)</argument_list></macro>
<block>{<block_content>
    <using>using <namespace>namespace <name>spanparsing</name>;</namespace></using>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>input</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Span</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>sp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>success</name></decl>;</decl_stmt>

    <comment type="line">// Const(...): parse a constant, update span to skip it if successful</comment>
    <expr_stmt><expr><name>input</name> <operator>=</operator> <literal type="string">"MilkToastHoney"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>MakeSpan</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>Const</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// empty</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name>success</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>SpanToStr</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"MilkToastHoney"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>Const</name><argument_list>(<argument><expr><literal type="string">"Milk"</literal></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name>success</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>SpanToStr</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"ToastHoney"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>Const</name><argument_list>(<argument><expr><literal type="string">"Bread"</literal></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><name>success</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>Const</name><argument_list>(<argument><expr><literal type="string">"Toast"</literal></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name>success</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>SpanToStr</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Honey"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>Const</name><argument_list>(<argument><expr><literal type="string">"Honeybadger"</literal></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><name>success</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>Const</name><argument_list>(<argument><expr><literal type="string">"Honey"</literal></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name>success</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>SpanToStr</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Func(...): parse a function call, update span to argument if successful</comment>
    <expr_stmt><expr><name>input</name> <operator>=</operator> <literal type="string">"Foo(Bar(xy,z()))"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>MakeSpan</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>Func</name><argument_list>(<argument><expr><literal type="string">"FooBar"</literal></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><name>success</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>Func</name><argument_list>(<argument><expr><literal type="string">"Foo("</literal></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><name>success</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>Func</name><argument_list>(<argument><expr><literal type="string">"Foo"</literal></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name>success</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>SpanToStr</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Bar(xy,z())"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>Func</name><argument_list>(<argument><expr><literal type="string">"Bar"</literal></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name>success</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>SpanToStr</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"xy,z()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>Func</name><argument_list>(<argument><expr><literal type="string">"xy"</literal></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><name>success</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Expr(...): return expression that span begins with, update span to skip it</comment>
    <decl_stmt><decl><type><name><name>Span</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>input</name> <operator>=</operator> <literal type="string">"(n*(n-1))/2"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>MakeSpan</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>SpanToStr</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"(n*(n-1))/2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>SpanToStr</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>input</name> <operator>=</operator> <literal type="string">"foo,bar"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>MakeSpan</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>SpanToStr</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"foo"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>SpanToStr</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">",bar"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>input</name> <operator>=</operator> <literal type="string">"(aaaaa,bbbbb()),c"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>MakeSpan</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>SpanToStr</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"(aaaaa,bbbbb())"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>SpanToStr</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">",c"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>input</name> <operator>=</operator> <literal type="string">"xyz)foo"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>MakeSpan</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>SpanToStr</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"xyz"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>SpanToStr</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">")foo"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>input</name> <operator>=</operator> <literal type="string">"((a),(b),(c)),xxx"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>MakeSpan</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>SpanToStr</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"((a),(b),(c))"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>SpanToStr</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">",xxx"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Split(...): split a string on every instance of sep, return vector</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>Span</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>char</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>results</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>input</name> <operator>=</operator> <literal type="string">"xxx"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>results</name> <operator>=</operator> <call><name>Split</name><argument_list>(<argument><expr><call><name>MakeSpan</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'x'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>results</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>SpanToStr</name><argument_list>(<argument><expr><name><name>results</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>SpanToStr</name><argument_list>(<argument><expr><name><name>results</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>SpanToStr</name><argument_list>(<argument><expr><name><name>results</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>SpanToStr</name><argument_list>(<argument><expr><name><name>results</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>input</name> <operator>=</operator> <literal type="string">"one#two#three"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>results</name> <operator>=</operator> <call><name>Split</name><argument_list>(<argument><expr><call><name>MakeSpan</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>results</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>SpanToStr</name><argument_list>(<argument><expr><name><name>results</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"one#two#three"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>input</name> <operator>=</operator> <literal type="string">"one#two#three"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>results</name> <operator>=</operator> <call><name>Split</name><argument_list>(<argument><expr><call><name>MakeSpan</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'#'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>results</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>SpanToStr</name><argument_list>(<argument><expr><name><name>results</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"one"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>SpanToStr</name><argument_list>(<argument><expr><name><name>results</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"two"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>SpanToStr</name><argument_list>(<argument><expr><name><name>results</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"three"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>input</name> <operator>=</operator> <literal type="string">"*foo*bar*"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>results</name> <operator>=</operator> <call><name>Split</name><argument_list>(<argument><expr><call><name>MakeSpan</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>results</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>SpanToStr</name><argument_list>(<argument><expr><name><name>results</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>SpanToStr</name><argument_list>(<argument><expr><name><name>results</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"foo"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>SpanToStr</name><argument_list>(<argument><expr><name><name>results</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"bar"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name>SpanToStr</name><argument_list>(<argument><expr><name><name>results</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>test_LogEscapeMessage</argument>)</argument_list></macro>
<block>{<block_content>
    <comment type="line">// ASCII and UTF-8 must pass through unaltered.</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>BCLog</name><operator>::</operator><name>LogEscapeMessage</name></name><argument_list>(<argument><expr><literal type="string">"Valid log messageè²"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Valid log messageè²"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Newlines must pass through unaltered.</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>BCLog</name><operator>::</operator><name>LogEscapeMessage</name></name><argument_list>(<argument><expr><literal type="string">"Message\n with newlines\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Message\n with newlines\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Other control characters are escaped in C syntax.</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>BCLog</name><operator>::</operator><name>LogEscapeMessage</name></name><argument_list>(<argument><expr><literal type="string">"\x01\x7f Corrupted log message\x0d"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">R"(\x01\x7f Corrupted log message\x0d)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Embedded NULL characters are escaped too.</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name></type> <name>NUL</name><argument_list>(<argument><expr><literal type="string">"O\x00O"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>BCLog</name><operator>::</operator><name>LogEscapeMessage</name></name><argument_list>(<argument><expr><name>NUL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">R"(O\x00O)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<namespace>namespace <block>{

<struct>struct <name>Tracker</name>
<block>{<public type="default">
    <comment type="line" format="doxygen">//! Points to the original object (possibly itself) we moved/copied from</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Tracker</name><modifier>*</modifier></type> <name>origin</name></decl>;</decl_stmt>
    <comment type="line" format="doxygen">//! How many copies where involved between the original object and this one (moves are not counted)</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>copies</name></decl>;</decl_stmt>

    <constructor><name>Tracker</name><parameter_list>()</parameter_list> <noexcept>noexcept</noexcept></constructor> : <macro><name>origin</name><argument_list>(<argument>this</argument>)</argument_list></macro><operator>,</operator> <macro><name>copies</name><argument_list>(<argument><literal type="number">0</literal></argument>)</argument_list></macro> <block>{<block_content/>}</block>
    <constructor><name>Tracker</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Tracker</name><modifier>&amp;</modifier></type> <name>t</name></decl></parameter>)</parameter_list> <noexcept>noexcept</noexcept></constructor> : <macro><name>origin</name><argument_list>(<argument>t.origin</argument>)</argument_list></macro><operator>,</operator> <macro><name>copies</name><argument_list>(<argument>t.copies + <literal type="number">1</literal></argument>)</argument_list></macro> <block>{<block_content/>}</block>
    <constructor><name>Tracker</name><parameter_list>(<parameter><decl><type><name>Tracker</name><modifier>&amp;&amp;</modifier></type> <name>t</name></decl></parameter>)</parameter_list> <noexcept>noexcept</noexcept></constructor> : <macro><name>origin</name><argument_list>(<argument>t.origin</argument>)</argument_list></macro><operator>,</operator> <macro><name>copies</name><argument_list>(<argument>t.copies</argument>)</argument_list></macro> <block>{<block_content/>}</block>
    <function type="operator"><type><name>Tracker</name><modifier>&amp;</modifier></type> <name>operator<name>=</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Tracker</name><modifier>&amp;</modifier></type> <name>t</name></decl></parameter>)</parameter_list> <noexcept>noexcept</noexcept>
    <block>{<block_content>
        <expr_stmt><expr><name>origin</name> <operator>=</operator> <name><name>t</name><operator>.</operator><name>origin</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>copies</name> <operator>=</operator> <name><name>t</name><operator>.</operator><name>copies</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><operator>*</operator><name>this</name></expr>;</return>
    </block_content>}</block></function>
    <function type="operator"><type><name>Tracker</name><modifier>&amp;</modifier></type> <name>operator<name>=</name></name><parameter_list>(<parameter><decl><type><name>Tracker</name><modifier>&amp;&amp;</modifier></type> <name>t</name></decl></parameter>)</parameter_list> <noexcept>noexcept</noexcept>
    <block>{<block_content>
        <expr_stmt><expr><name>origin</name> <operator>=</operator> <name><name>t</name><operator>.</operator><name>origin</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>copies</name> <operator>=</operator> <name><name>t</name><operator>.</operator><name>copies</name></name></expr>;</expr_stmt>
        <return>return <expr><operator>*</operator><name>this</name></expr>;</return>
    </block_content>}</block></function>
</public>}</block>;</struct>

}</block></namespace>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>test_tracked_vector</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name>Tracker</name></type> <name>t1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Tracker</name></type> <name>t2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Tracker</name></type> <name>t3</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>t1</name><operator>.</operator><name>origin</name></name> <operator>==</operator> <operator>&amp;</operator><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>t2</name><operator>.</operator><name>origin</name></name> <operator>==</operator> <operator>&amp;</operator><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>t3</name><operator>.</operator><name>origin</name></name> <operator>==</operator> <operator>&amp;</operator><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>v1</name> <init>= <expr><call><name>Vector</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>v1</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>v1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>origin</name> <operator>==</operator> <operator>&amp;</operator><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name><name>v1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>copies</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>v2</name> <init>= <expr><call><name>Vector</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>v2</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>v2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>origin</name> <operator>==</operator> <operator>&amp;</operator><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name><name>v2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>copies</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>v3</name> <init>= <expr><call><name>Vector</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>v3</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>v3</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>origin</name> <operator>==</operator> <operator>&amp;</operator><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>v3</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>origin</name> <operator>==</operator> <operator>&amp;</operator><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name><name>v3</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>copies</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name><name>v3</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>copies</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>v4</name> <init>= <expr><call><name>Vector</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name><name>v3</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>v3</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>v4</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>v4</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>origin</name> <operator>==</operator> <operator>&amp;</operator><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>v4</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>origin</name> <operator>==</operator> <operator>&amp;</operator><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>v4</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>origin</name> <operator>==</operator> <operator>&amp;</operator><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name><name>v4</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>copies</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name><name>v4</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>copies</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name><name>v4</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>copies</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>v5</name> <init>= <expr><call><name>Cat</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v4</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>v5</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>v5</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>origin</name> <operator>==</operator> <operator>&amp;</operator><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>v5</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>origin</name> <operator>==</operator> <operator>&amp;</operator><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>v5</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>origin</name> <operator>==</operator> <operator>&amp;</operator><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>v5</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>origin</name> <operator>==</operator> <operator>&amp;</operator><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name><name>v5</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>copies</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name><name>v5</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>copies</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name><name>v5</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>copies</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name><name>v5</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>copies</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>v6</name> <init>= <expr><call><name>Cat</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>v3</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>v6</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>v6</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>origin</name> <operator>==</operator> <operator>&amp;</operator><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>v6</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>origin</name> <operator>==</operator> <operator>&amp;</operator><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>v6</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>origin</name> <operator>==</operator> <operator>&amp;</operator><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name><name>v6</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>copies</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name><name>v6</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>copies</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name><name>v6</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>copies</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>v7</name> <init>= <expr><call><name>Cat</name><argument_list>(<argument><expr><name>v2</name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>v4</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>v7</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>v7</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>origin</name> <operator>==</operator> <operator>&amp;</operator><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>v7</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>origin</name> <operator>==</operator> <operator>&amp;</operator><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>v7</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>origin</name> <operator>==</operator> <operator>&amp;</operator><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>v7</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>origin</name> <operator>==</operator> <operator>&amp;</operator><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name><name>v7</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>copies</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name><name>v7</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>copies</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name><name>v7</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>copies</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name><name>v7</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>copies</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>v8</name> <init>= <expr><call><name>Cat</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>v3</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>v8</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>v8</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>origin</name> <operator>==</operator> <operator>&amp;</operator><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>v8</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>origin</name> <operator>==</operator> <operator>&amp;</operator><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name><name>v8</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>origin</name> <operator>==</operator> <operator>&amp;</operator><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name><name>v8</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>copies</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name><name>v8</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>copies</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name><name>v8</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>copies</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_SUITE_END</name><argument_list>()</argument_list></macro>
</unit>
