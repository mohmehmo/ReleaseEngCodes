<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/mmm/Projects/bitcoin/src/addrman.h"><comment type="line">// Copyright (c) 2012 Pieter Wuille</comment>
<comment type="line">// Copyright (c) 2012-2018 The Bitcoin Core developers</comment>
<comment type="line">// Distributed under the MIT software license, see the accompanying</comment>
<comment type="line">// file COPYING or http://www.opensource.org/licenses/mit-license.php.</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>BITCOIN_ADDRMAN_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITCOIN_ADDRMAN_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netaddress.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;protocol.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;random.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sync.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;timedata.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/system.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;map&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;set&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>

<comment type="block" format="doxygen">/**
 * Extended statistics about a CAddress
 */</comment>
<decl_stmt><decl><type><name>class</name></type> <name>CAddrInfo</name> <range>: <expr><name>public</name> <name>CAddress</name>
<block>{
<expr><name>public</name><operator>:</operator>
    <comment type="line" format="doxygen">//! last try whatsoever by us (memory only)</comment>
    <name>int64_t</name> <name>nLastTry</name><block>{<expr><literal type="number">0</literal></expr>}</block></expr>;

    <comment type="line" format="doxygen">//! last counted attempt (memory only)</comment>
    <expr><name>int64_t</name> <name>nLastCountAttempt</name><block>{<expr><literal type="number">0</literal></expr>}</block></expr>;

<expr><name>private</name><operator>:</operator>
    <comment type="line" format="doxygen">//! where knowledge about this address first came from</comment>
    <name>CNetAddr</name> <name>source</name></expr>;

    <comment type="line" format="doxygen">//! last successful connection by us</comment>
    <expr><name>int64_t</name> <name>nLastSuccess</name><block>{<expr><literal type="number">0</literal></expr>}</block></expr>;

    <comment type="line" format="doxygen">//! connection attempts since last successful attempt</comment>
    <expr><name>int</name> <name>nAttempts</name><block>{<expr><literal type="number">0</literal></expr>}</block></expr>;

    <comment type="line" format="doxygen">//! reference count in new sets (memory only)</comment>
    <expr><name>int</name> <name>nRefCount</name><block>{<expr><literal type="number">0</literal></expr>}</block></expr>;

    <comment type="line" format="doxygen">//! in tried set? (memory only)</comment>
    <expr><name>bool</name> <name>fInTried</name><block>{<expr><name>false</name></expr>}</block></expr>;

    <comment type="line" format="doxygen">//! position in vRandom</comment>
    <expr><name>int</name> <name>nRandomPos</name><block>{<expr><operator>-</operator><literal type="number">1</literal></expr>}</block></expr>;

    <expr><name>friend</name> <name>class</name> <name>CAddrMan</name></expr>;

<expr><name>public</name><operator>:</operator>

    <name>ADD_SERIALIZE_METHODS</name></expr>;

    <expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Stream</name></expr></argument>, <argument><expr><name>typename</name> <name>Operation</name></expr></argument>&gt;</argument_list></name>
    <specifier>inline</specifier> <name>void</name> <macro><name>SerializationOp</name><argument_list>(<argument>Stream&amp; s</argument>, <argument>Operation ser_action</argument>)</argument_list></macro> <block>{
        <expr><call><name>READWRITEAS</name><argument_list>(<argument><expr><name>CAddress</name></expr></argument>, <argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;
        <expr><call><name>READWRITE</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;
        <expr><call><name>READWRITE</name><argument_list>(<argument><expr><name>nLastSuccess</name></expr></argument>)</argument_list></call></expr>;
        <expr><call><name>READWRITE</name><argument_list>(<argument><expr><name>nAttempts</name></expr></argument>)</argument_list></call></expr>;
    }</block>

    <call><name>CAddrInfo</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CAddress</name> <operator>&amp;</operator><name>addrIn</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CNetAddr</name> <operator>&amp;</operator><name>addrSource</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>CAddress</name><argument_list>(<argument><expr><name>addrIn</name></expr></argument>)</argument_list></call></expr>, <macro><name>source</name><argument_list>(<argument>addrSource</argument>)</argument_list></macro>
    <expr><block>{
    }</block>

    <call><name>CAddrInfo</name><argument_list>()</argument_list></call> <operator>:</operator> <call><name>CAddress</name><argument_list>()</argument_list></call></expr>, <macro><name>source</name><argument_list>()</argument_list></macro>
    <expr><block>{
    }</block>

    <comment type="line" format="doxygen">//! Calculate in which "tried" bucket this entry belongs</comment>
    <name>int</name> <macro><name>GetTriedBucket</name><argument_list>(<argument>const uint256 &amp;nKey</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

    <comment type="line" format="doxygen">//! Calculate in which "new" bucket this entry belongs, given a certain source</comment>
    <expr><name>int</name> <macro><name>GetNewBucket</name><argument_list>(<argument>const uint256 &amp;nKey</argument>, <argument>const CNetAddr&amp; src</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

    <comment type="line" format="doxygen">//! Calculate in which "new" bucket this entry belongs, using its default source</comment>
    <expr><name>int</name> <macro><name>GetNewBucket</name><argument_list>(<argument>const uint256 &amp;nKey</argument>)</argument_list></macro> <specifier>const</specifier>
    <block>{
        <return>return <expr><call><name>GetNewBucket</name><argument_list>(<argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block>

    <comment type="line" format="doxygen">//! Calculate in which position of a bucket to store this entry.</comment>
    <name>int</name> <macro><name>GetBucketPosition</name><argument_list>(<argument>const uint256 &amp;nKey</argument>, <argument>bool fNew</argument>, <argument>int nBucket</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

    <comment type="line" format="doxygen">//! Determine whether the statistics about this entry are bad enough so that it can just be deleted</comment>
    <expr><name>bool</name> <macro><name>IsTerrible</name><argument_list>(<argument>int64_t nNow = GetAdjustedTime()</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

    <comment type="line" format="doxygen">//! Calculate the relative chance this entry should be given when selecting nodes to connect to</comment>
    <expr><name>double</name> <macro><name>GetChance</name><argument_list>(<argument>int64_t nNow = GetAdjustedTime()</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
}</block></expr></range></decl>;</decl_stmt>

<comment type="block" format="doxygen">/** Stochastic address manager
 *
 * Design goals:
 *  * Keep the address tables in-memory, and asynchronously dump the entire table to peers.dat.
 *  * Make sure no (localized) attacker can fill the entire table with his nodes/addresses.
 *
 * To that end:
 *  * Addresses are organized into buckets.
 *    * Addresses that have not yet been tried go into 1024 "new" buckets.
 *      * Based on the address range (/16 for IPv4) of the source of information, 64 buckets are selected at random.
 *      * The actual bucket is chosen from one of these, based on the range in which the address itself is located.
 *      * One single address can occur in up to 8 different buckets to increase selection chances for addresses that
 *        are seen frequently. The chance for increasing this multiplicity decreases exponentially.
 *      * When adding a new address to a full bucket, a randomly chosen entry (with a bias favoring less recently seen
 *        ones) is removed from it first.
 *    * Addresses of nodes that are known to be accessible go into 256 "tried" buckets.
 *      * Each address range selects at random 8 of these buckets.
 *      * The actual bucket is chosen from one of these, based on the full address.
 *      * When adding a new good address to a full bucket, a randomly chosen entry (with a bias favoring less recently
 *        tried ones) is evicted from it, back to the "new" buckets.
 *    * Bucket selection is based on cryptographic hashing, using a randomly-generated 256-bit key, which should not
 *      be observable by adversaries.
 *    * Several indexes are kept for high performance. Defining DEBUG_ADDRMAN will introduce frequent (and expensive)
 *      consistency checks for the entire data structure.
 */</comment>

<comment type="line" format="doxygen">//! total number of buckets for tried addresses</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDRMAN_TRIED_BUCKET_COUNT_LOG2</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>

<comment type="line" format="doxygen">//! total number of buckets for new addresses</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDRMAN_NEW_BUCKET_COUNT_LOG2</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<comment type="line" format="doxygen">//! maximum allowed number of entries in buckets for new and tried addresses</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDRMAN_BUCKET_SIZE_LOG2</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>

<comment type="line" format="doxygen">//! over how many buckets entries with tried addresses from a single group (/16 for IPv4) are spread</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDRMAN_TRIED_BUCKETS_PER_GROUP</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>

<comment type="line" format="doxygen">//! over how many buckets entries with new addresses originating from a single group are spread</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>

<comment type="line" format="doxygen">//! in how many buckets for entries with new addresses a single address may occur</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDRMAN_NEW_BUCKETS_PER_ADDRESS</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>

<comment type="line" format="doxygen">//! how old addresses can maximally be</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDRMAN_HORIZON_DAYS</name></cpp:macro> <cpp:value>30</cpp:value></cpp:define>

<comment type="line" format="doxygen">//! after how many failed attempts we give up on a new node</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDRMAN_RETRIES</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<comment type="line" format="doxygen">//! how many successive failures are allowed ...</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDRMAN_MAX_FAILURES</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<comment type="line" format="doxygen">//! ... in at least this many days</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDRMAN_MIN_FAIL_DAYS</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>

<comment type="line" format="doxygen">//! how recent a successful connection should be before we allow an address to be evicted from tried</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDRMAN_REPLACEMENT_HOURS</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<comment type="line" format="doxygen">//! the maximum percentage of nodes to return in a getaddr call</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDRMAN_GETADDR_MAX_PCT</name></cpp:macro> <cpp:value>23</cpp:value></cpp:define>

<comment type="line" format="doxygen">//! the maximum number of nodes to return in a getaddr call</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDRMAN_GETADDR_MAX</name></cpp:macro> <cpp:value>2500</cpp:value></cpp:define>

<comment type="line" format="doxygen">//! Convenience</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDRMAN_TRIED_BUCKET_COUNT</name></cpp:macro> <cpp:value>(1 &lt;&lt; ADDRMAN_TRIED_BUCKET_COUNT_LOG2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDRMAN_NEW_BUCKET_COUNT</name></cpp:macro> <cpp:value>(1 &lt;&lt; ADDRMAN_NEW_BUCKET_COUNT_LOG2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDRMAN_BUCKET_SIZE</name></cpp:macro> <cpp:value>(1 &lt;&lt; ADDRMAN_BUCKET_SIZE_LOG2)</cpp:value></cpp:define>

<comment type="line" format="doxygen">//! the maximum number of tried addr collisions to store</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDRMAN_SET_TRIED_COLLISION_SIZE</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<comment type="line" format="doxygen">//! the maximum time we'll spend trying to resolve a tried table collision, in seconds</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int64_t</name></type> <name>ADDRMAN_TEST_WINDOW</name> <init>= <expr><literal type="number">40</literal><operator>*</operator><literal type="number">60</literal></expr></init></decl>;</decl_stmt> <comment type="line">// 40 minutes</comment>

<comment type="block" format="doxygen">/**
 * Stochastical (IP) address manager
 */</comment>
<decl_stmt><decl><type><name>class</name></type> <name>CAddrMan</name>
<block>{<block_content>
<label><name>protected</name>:</label>
    <comment type="line" format="doxygen">//! critical section to protect the inner data structures</comment>
    <decl_stmt><decl><type><name>mutable</name> <name>CCriticalSection</name></type> <name>cs</name></decl>;</decl_stmt>

<label><name>private</name>:</label>
    <comment type="line" format="doxygen">//! last used nId</comment>
    <function_decl><type><name>int</name> <name>nIdCount</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs</name></type></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="line" format="doxygen">//! table with information about all nIds</comment>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>map</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>, <argument><expr><name>CAddrInfo</name></expr></argument>&gt;</argument_list></name> <name>mapInfo</name> <call><name>GUARDED_BY</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line" format="doxygen">//! find an nId based on its network address</comment>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>map</name><argument_list type="generic">&lt;<argument><expr><name>CNetAddr</name></expr></argument>, <argument><expr><name>int</name></expr></argument>&gt;</argument_list></name> <name>mapAddr</name> <call><name>GUARDED_BY</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line" format="doxygen">//! randomly-ordered vector of all nIds</comment>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name> <name>vRandom</name> <call><name>GUARDED_BY</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// number of "tried" entries</comment>
    <function_decl><type><name>int</name> <name>nTried</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs</name></type></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="line" format="doxygen">//! list of "tried" buckets</comment>
    <function_decl><type><name>int</name> <name><name>vvTried</name><index>[<expr><name>ADDRMAN_TRIED_BUCKET_COUNT</name></expr>]</index><index>[<expr><name>ADDRMAN_BUCKET_SIZE</name></expr>]</index></name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs</name></type></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="line" format="doxygen">//! number of (unique) "new" entries</comment>
    <function_decl><type><name>int</name> <name>nNew</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs</name></type></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="line" format="doxygen">//! list of "new" buckets</comment>
    <function_decl><type><name>int</name> <name><name>vvNew</name><index>[<expr><name>ADDRMAN_NEW_BUCKET_COUNT</name></expr>]</index><index>[<expr><name>ADDRMAN_BUCKET_SIZE</name></expr>]</index></name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs</name></type></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="line" format="doxygen">//! last time Good was called (memory only)</comment>
    <function_decl><type><name>int64_t</name> <name>nLastGood</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs</name></type></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="line" format="doxygen">//! Holds addrs inserted into tried table that collide with existing entries. Test-before-evict discipline used to resolve these collisions.</comment>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>set</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name> <name>m_tried_collisions</name></expr>;</expr_stmt>

<label><name>protected</name>:</label>
    <comment type="line" format="doxygen">//! secret key to randomize bucket select with</comment>
    <decl_stmt><decl><type><name>uint256</name></type> <name>nKey</name></decl>;</decl_stmt>

    <comment type="line" format="doxygen">//! Source of random numbers for randomization in inner loops</comment>
    <decl_stmt><decl><type><name>FastRandomContext</name></type> <name>insecure_rand</name></decl>;</decl_stmt>

    <comment type="line" format="doxygen">//! Find an entry.</comment>
    <function_decl><type><name>CAddrInfo</name><modifier>*</modifier></type> <name>Find</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CNetAddr</name><modifier>&amp;</modifier></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnId</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list> EXCLUSIVE_LOCKS_REQUIRED<parameter_list>(<parameter><decl><type><name>cs</name></type></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="line" format="doxygen">//! find an entry, creating it if necessary.</comment>
    <comment type="line" format="doxygen">//! nTime and nServices of the found node are updated, if necessary.</comment>
    <function_decl><type><name>CAddrInfo</name><modifier>*</modifier></type> <name>Create</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CAddress</name> <modifier>&amp;</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CNetAddr</name> <modifier>&amp;</modifier></type><name>addrSource</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnId</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list> EXCLUSIVE_LOCKS_REQUIRED<parameter_list>(<parameter><decl><type><name>cs</name></type></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="line" format="doxygen">//! Swap two elements in vRandom.</comment>
    <function_decl><type><name>void</name></type> <name>SwapRandom</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nRandomPos1</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nRandomPos2</name></decl></parameter>)</parameter_list> EXCLUSIVE_LOCKS_REQUIRED<parameter_list>(<parameter><decl><type><name>cs</name></type></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="line" format="doxygen">//! Move an entry from the "new" table(s) to the "tried" table</comment>
    <function_decl><type><name>void</name></type> <name>MakeTried</name><parameter_list>(<parameter><decl><type><name>CAddrInfo</name><modifier>&amp;</modifier></type> <name>info</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nId</name></decl></parameter>)</parameter_list> EXCLUSIVE_LOCKS_REQUIRED<parameter_list>(<parameter><decl><type><name>cs</name></type></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="line" format="doxygen">//! Delete an entry. It must not be in tried, and have refcount 0.</comment>
    <function_decl><type><name>void</name></type> <name>Delete</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nId</name></decl></parameter>)</parameter_list> EXCLUSIVE_LOCKS_REQUIRED<parameter_list>(<parameter><decl><type><name>cs</name></type></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="line" format="doxygen">//! Clear a position in a "new" table. This is the only place where entries are actually deleted.</comment>
    <function_decl><type><name>void</name></type> <name>ClearNew</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nUBucket</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nUBucketPos</name></decl></parameter>)</parameter_list> EXCLUSIVE_LOCKS_REQUIRED<parameter_list>(<parameter><decl><type><name>cs</name></type></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="line" format="doxygen">//! Mark an entry "good", possibly moving it from "new" to "tried".</comment>
    <function_decl><type><name>void</name></type> <name>Good_</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CService</name> <modifier>&amp;</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>test_before_evict</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>time</name></decl></parameter>)</parameter_list> EXCLUSIVE_LOCKS_REQUIRED<parameter_list>(<parameter><decl><type><name>cs</name></type></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="line" format="doxygen">//! Add an entry to the "new" table.</comment>
    <function_decl><type><name>bool</name></type> <name>Add_</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CAddress</name> <modifier>&amp;</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CNetAddr</name><modifier>&amp;</modifier></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>nTimePenalty</name></decl></parameter>)</parameter_list> EXCLUSIVE_LOCKS_REQUIRED<parameter_list>(<parameter><decl><type><name>cs</name></type></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="line" format="doxygen">//! Mark an entry as attempted to connect.</comment>
    <function_decl><type><name>void</name></type> <name>Attempt_</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CService</name> <modifier>&amp;</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fCountFailure</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>nTime</name></decl></parameter>)</parameter_list> EXCLUSIVE_LOCKS_REQUIRED<parameter_list>(<parameter><decl><type><name>cs</name></type></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="line" format="doxygen">//! Select an address to connect to, if newOnly is set to true, only the new table is selected from.</comment>
    <function_decl><type><name>CAddrInfo</name></type> <name>Select_</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>newOnly</name></decl></parameter>)</parameter_list> EXCLUSIVE_LOCKS_REQUIRED<parameter_list>(<parameter><decl><type><name>cs</name></type></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="line" format="doxygen">//! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.</comment>
    <function_decl><type><name>void</name></type> <name>ResolveCollisions_</name><parameter_list>()</parameter_list> EXCLUSIVE_LOCKS_REQUIRED<parameter_list>(<parameter><decl><type><name>cs</name></type></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="line" format="doxygen">//! Return a random to-be-evicted tried table address.</comment>
    <function_decl><type><name>CAddrInfo</name></type> <name>SelectTriedCollision_</name><parameter_list>()</parameter_list> EXCLUSIVE_LOCKS_REQUIRED<parameter_list>(<parameter><decl><type><name>cs</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_ADDRMAN</name></cpp:ifdef>
    <comment type="line" format="doxygen">//! Perform consistency check. Returns an error code or zero.</comment>
    <function_decl><type><name>int</name></type> <name>Check_</name><parameter_list>()</parameter_list> EXCLUSIVE_LOCKS_REQUIRED<parameter_list>(<parameter><decl><type><name>cs</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line" format="doxygen">//! Select several addresses at once.</comment>
    <decl_stmt><decl><type><name>void</name></type> <name>GetAddr_</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CAddress</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>vAddr</name></expr></argument>)</argument_list> <name>EXCLUSIVE_LOCKS_REQUIRED</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></decl>;</decl_stmt>

    <comment type="line" format="doxygen">//! Mark an entry as currently-connected-to.</comment>
    <function_decl><type><name>void</name></type> <name>Connected_</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CService</name> <modifier>&amp;</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>nTime</name></decl></parameter>)</parameter_list> EXCLUSIVE_LOCKS_REQUIRED<parameter_list>(<parameter><decl><type><name>cs</name></type></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="line" format="doxygen">//! Update an entry's service bits.</comment>
    <function_decl><type><name>void</name></type> <name>SetServices_</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CService</name> <modifier>&amp;</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>ServiceFlags</name></type> <name>nServices</name></decl></parameter>)</parameter_list> EXCLUSIVE_LOCKS_REQUIRED<parameter_list>(<parameter><decl><type><name>cs</name></type></decl></parameter>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>
    <comment type="block" format="doxygen">/**
     * serialized format:
     * * version byte (currently 1)
     * * 0x20 + nKey (serialized as if it were a vector, for backward compatibility)
     * * nNew
     * * nTried
     * * number of "new" buckets XOR 2**30
     * * all nNew addrinfos in vvNew
     * * all nTried addrinfos in vvTried
     * * for each bucket:
     *   * number of elements
     *   * for each element: index
     *
     * 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it
     * as incompatible. This is necessary because it did not check the version number on
     * deserialization.
     *
     * Notice that vvTried, mapAddr and vVector are never encoded explicitly;
     * they are instead reconstructed from the other information.
     *
     * vvNew is serialized, but only used if ADDRMAN_UNKNOWN_BUCKET_COUNT didn't change,
     * otherwise it is reconstructed as well.
     *
     * This format is more complex, but significantly smaller (at most 1.5 MiB), and supports
     * changes to the ADDRMAN_ parameters without breaking the on-disk structure.
     *
     * We don't use ADD_SERIALIZE_METHODS since the serialization and deserialization code has
     * very little in common.
     */</comment>
    <decl_stmt><decl><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Stream</name></expr></argument>&gt;</argument_list></name>
    <name>void</name></type> <name>Serialize</name><argument_list>(<argument><expr><name>Stream</name> <operator>&amp;</operator><name>s</name></expr></argument>)</argument_list> const
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>nVersion</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>s</name> <operator>&lt;&lt;</operator> <name>nVersion</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>s</name> <operator>&lt;&lt;</operator> <operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><literal type="number">32</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>s</name> <operator>&lt;&lt;</operator> <name>nKey</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>s</name> <operator>&lt;&lt;</operator> <name>nNew</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>s</name> <operator>&lt;&lt;</operator> <name>nTried</name></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>nUBuckets</name> <init>= <expr><name>ADDRMAN_NEW_BUCKET_COUNT</name> <operator>^</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">30</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>s</name> <operator>&lt;&lt;</operator> <name>nUBuckets</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>std</name><operator>::</operator><name><name>map</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>, <argument><expr><name>int</name></expr></argument>&gt;</argument_list></name> <name>mapUnkIds</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nIds</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>entry</name> <range>: <expr><name>mapInfo</name></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><name><name>mapUnkIds</name><index>[<expr><name><name>entry</name><operator>.</operator><name>first</name></name></expr>]</index></name> <operator>=</operator> <name>nIds</name></expr>;</expr_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>CAddrInfo</name> <modifier>&amp;</modifier></type><name>info</name> <init>= <expr><name><name>entry</name><operator>.</operator><name>second</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>info</name><operator>.</operator><name>nRefCount</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nIds</name> <operator>!=</operator> <name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// this means nNew was wrong, oh ow</comment>
                <expr_stmt><expr><name>s</name> <operator>&lt;&lt;</operator> <name>info</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>nIds</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>nIds</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>entry</name> <range>: <expr><name>mapInfo</name></expr></range></decl></init>)</control> <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>CAddrInfo</name> <modifier>&amp;</modifier></type><name>info</name> <init>= <expr><name><name>entry</name><operator>.</operator><name>second</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>info</name><operator>.</operator><name>fInTried</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nIds</name> <operator>!=</operator> <name>nTried</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// this means nTried was wrong, oh ow</comment>
                <expr_stmt><expr><name>s</name> <operator>&lt;&lt;</operator> <name>info</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>nIds</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>bucket</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>bucket</name> <operator>&lt;</operator> <name>ADDRMAN_NEW_BUCKET_COUNT</name></expr>;</condition> <incr><expr><name>bucket</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>nSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ADDRMAN_BUCKET_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>vvNew</name><index>[<expr><name>bucket</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>nSize</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><name>s</name> <operator>&lt;&lt;</operator> <name>nSize</name></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ADDRMAN_BUCKET_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>vvNew</name><index>[<expr><name>bucket</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type> <name>nIndex</name> <init>= <expr><name><name>mapUnkIds</name><index>[<expr><name><name>vvNew</name><index>[<expr><name>bucket</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>s</name> <operator>&lt;&lt;</operator> <name>nIndex</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></for>
    </block_content>}</block></decl></decl_stmt>

    <function><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Stream</name></expr></argument>&gt;</argument_list></name>
    <name>void</name></type> <name>Unserialize</name><parameter_list>(<parameter><decl><type><name>Stream</name><modifier>&amp;</modifier></type> <name>s</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>nVersion</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>s</name> <operator>&gt;&gt;</operator> <name>nVersion</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>nKeySize</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>s</name> <operator>&gt;&gt;</operator> <name>nKeySize</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nKeySize</name> <operator>!=</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>throw</name> <name>std</name><operator>::</operator><name>ios_base</name><operator>::</operator><call><name>failure</name><argument_list>(<argument><expr><literal type="string">"Incorrect keysize in addrman deserialization"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>s</name> <operator>&gt;&gt;</operator> <name>nKey</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>s</name> <operator>&gt;&gt;</operator> <name>nNew</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>s</name> <operator>&gt;&gt;</operator> <name>nTried</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nUBuckets</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>s</name> <operator>&gt;&gt;</operator> <name>nUBuckets</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nVersion</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>nUBuckets</name> <operator>^=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">30</literal><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>nNew</name> <operator>&gt;</operator> <name>ADDRMAN_NEW_BUCKET_COUNT</name> <operator>*</operator> <name>ADDRMAN_BUCKET_SIZE</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>throw</name> <name>std</name><operator>::</operator><name>ios_base</name><operator>::</operator><call><name>failure</name><argument_list>(<argument><expr><literal type="string">"Corrupt CAddrMan serialization, nNew exceeds limit."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>nTried</name> <operator>&gt;</operator> <name>ADDRMAN_TRIED_BUCKET_COUNT</name> <operator>*</operator> <name>ADDRMAN_BUCKET_SIZE</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>throw</name> <name>std</name><operator>::</operator><name>ios_base</name><operator>::</operator><call><name>failure</name><argument_list>(<argument><expr><literal type="string">"Corrupt CAddrMan serialization, nTried exceeds limit."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Deserialize entries from the new table.</comment>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>nNew</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>CAddrInfo</name> <modifier>&amp;</modifier></type><name>info</name> <init>= <expr><name><name>mapInfo</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>s</name> <operator>&gt;&gt;</operator> <name>info</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mapAddr</name><index>[<expr><name>info</name></expr>]</index></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>info</name><operator>.</operator><name>nRandomPos</name></name> <operator>=</operator> <call><name><name>vRandom</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>vRandom</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>nVersion</name> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <name>nUBuckets</name> <operator>!=</operator> <name>ADDRMAN_NEW_BUCKET_COUNT</name></expr>)</condition> <block>{<block_content>
                <comment type="line">// In case the new table data cannot be used (nVersion unknown, or bucket count wrong),</comment>
                <comment type="line">// immediately try to give them a reference based on their primary source address.</comment>
                <decl_stmt><decl><type><name>int</name></type> <name>nUBucket</name> <init>= <expr><call><name><name>info</name><operator>.</operator><name>GetNewBucket</name></name><argument_list>(<argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>nUBucketPos</name> <init>= <expr><call><name><name>info</name><operator>.</operator><name>GetBucketPosition</name></name><argument_list>(<argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>nUBucket</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>vvNew</name><index>[<expr><name>nUBucket</name></expr>]</index><index>[<expr><name>nUBucketPos</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>vvNew</name><index>[<expr><name>nUBucket</name></expr>]</index><index>[<expr><name>nUBucketPos</name></expr>]</index></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>info</name><operator>.</operator><name>nRefCount</name></name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>nIdCount</name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt>

        <comment type="line">// Deserialize entries from the tried table.</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>nLost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>nTried</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>CAddrInfo</name></type> <name>info</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>s</name> <operator>&gt;&gt;</operator> <name>info</name></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>nKBucket</name> <init>= <expr><call><name><name>info</name><operator>.</operator><name>GetTriedBucket</name></name><argument_list>(<argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>nKBucketPos</name> <init>= <expr><call><name><name>info</name><operator>.</operator><name>GetBucketPosition</name></name><argument_list>(<argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>nKBucket</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>vvTried</name><index>[<expr><name>nKBucket</name></expr>]</index><index>[<expr><name>nKBucketPos</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>info</name><operator>.</operator><name>nRandomPos</name></name> <operator>=</operator> <call><name><name>vRandom</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>info</name><operator>.</operator><name>fInTried</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>vRandom</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>nIdCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mapInfo</name><index>[<expr><name>nIdCount</name></expr>]</index></name> <operator>=</operator> <name>info</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mapAddr</name><index>[<expr><name>info</name></expr>]</index></name> <operator>=</operator> <name>nIdCount</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>vvTried</name><index>[<expr><name>nKBucket</name></expr>]</index><index>[<expr><name>nKBucketPos</name></expr>]</index></name> <operator>=</operator> <name>nIdCount</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>nIdCount</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>nLost</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>nTried</name> <operator>-=</operator> <name>nLost</name></expr>;</expr_stmt>

        <comment type="line">// Deserialize positions in the new table (if possible).</comment>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>bucket</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>bucket</name> <operator>&lt;</operator> <name>nUBuckets</name></expr>;</condition> <incr><expr><name>bucket</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>nSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>s</name> <operator>&gt;&gt;</operator> <name>nSize</name></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>nSize</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>nIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>s</name> <operator>&gt;&gt;</operator> <name>nIndex</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>nIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nIndex</name> <operator>&lt;</operator> <name>nNew</name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>CAddrInfo</name> <modifier>&amp;</modifier></type><name>info</name> <init>= <expr><name><name>mapInfo</name><index>[<expr><name>nIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>nUBucketPos</name> <init>= <expr><call><name><name>info</name><operator>.</operator><name>GetBucketPosition</name></name><argument_list>(<argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>nVersion</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>nUBuckets</name> <operator>==</operator> <name>ADDRMAN_NEW_BUCKET_COUNT</name> <operator>&amp;&amp;</operator> <name><name>vvNew</name><index>[<expr><name>bucket</name></expr>]</index><index>[<expr><name>nUBucketPos</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>info</name><operator>.</operator><name>nRefCount</name></name> <operator>&lt;</operator> <name>ADDRMAN_NEW_BUCKETS_PER_ADDRESS</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name><name>info</name><operator>.</operator><name>nRefCount</name></name><operator>++</operator></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>vvNew</name><index>[<expr><name>bucket</name></expr>]</index><index>[<expr><name>nUBucketPos</name></expr>]</index></name> <operator>=</operator> <name>nIndex</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></for>

        <comment type="line">// Prune new entries with refcount 0 (as a result of collisions).</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>nLostUnk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>std</name><operator>::</operator><name><name>map</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>, <argument><expr><name>CAddrInfo</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>const_iterator</name> <name>it</name> <operator>=</operator> <call><name><name>mapInfo</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</init> <condition><expr><name>it</name> <operator>!=</operator> <call><name><name>mapInfo</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr/>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>fInTried</name></name> <operator>==</operator> <name>false</name> <operator>&amp;&amp;</operator> <name><name>it</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>nRefCount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>std</name><operator>::</operator><name><name>map</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>, <argument><expr><name>CAddrInfo</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>const_iterator</name> <name>itCopy</name> <operator>=</operator> <name>it</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Delete</name><argument_list>(<argument><expr><name><name>itCopy</name><operator>-&gt;</operator><name>first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>nLostUnk</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>it</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>nLost</name> <operator>+</operator> <name>nLostUnk</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name>BCLog</name><operator>::</operator><name>ADDRMAN</name></expr></argument>, <argument><expr><literal type="string">"addrman lost %i new and %i tried addresses due to collisions\n"</literal></expr></argument>, <argument><expr><name>nLostUnk</name></expr></argument>, <argument><expr><name>nLost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>Check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type> <name>Clear</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>std</name><operator>::</operator><call><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>.</operator><call><name>swap</name><argument_list>(<argument><expr><name>vRandom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nKey</name> <operator>=</operator> <call><name><name>insecure_rand</name><operator>.</operator><name>rand256</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>size_t</name></type> <name>bucket</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>bucket</name> <operator>&lt;</operator> <name>ADDRMAN_NEW_BUCKET_COUNT</name></expr>;</condition> <incr><expr><name>bucket</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <for>for <control>(<init><decl><type><name>size_t</name></type> <name>entry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>entry</name> <operator>&lt;</operator> <name>ADDRMAN_BUCKET_SIZE</name></expr>;</condition> <incr><expr><name>entry</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <expr_stmt><expr><name><name>vvNew</name><index>[<expr><name>bucket</name></expr>]</index><index>[<expr><name>entry</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></for>
        <for>for <control>(<init><decl><type><name>size_t</name></type> <name>bucket</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>bucket</name> <operator>&lt;</operator> <name>ADDRMAN_TRIED_BUCKET_COUNT</name></expr>;</condition> <incr><expr><name>bucket</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <for>for <control>(<init><decl><type><name>size_t</name></type> <name>entry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>entry</name> <operator>&lt;</operator> <name>ADDRMAN_BUCKET_SIZE</name></expr>;</condition> <incr><expr><name>entry</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <expr_stmt><expr><name><name>vvTried</name><index>[<expr><name>bucket</name></expr>]</index><index>[<expr><name>entry</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></for>

        <expr_stmt><expr><name>nIdCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>nTried</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>nNew</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>nLastGood</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="line">//Initially at 1 so that "never" is strictly worse.</comment>
        <expr_stmt><expr><call><name><name>mapInfo</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mapAddr</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <macro><name>CAddrMan</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><operator>~</operator><macro><name>CAddrMan</name><argument_list>()</argument_list></macro>
    <block>{
        <expr><call><name><name>nKey</name><operator>.</operator><name>SetNull</name></name><argument_list>()</argument_list></call></expr>;
    }</block>

    <comment type="line" format="doxygen">//! Return the number of (unique) addresses in all tables.</comment>
    <name>size_t</name> <macro><name>size</name><argument_list>()</argument_list></macro> <specifier>const</specifier>
    <block>{
        <expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>; <comment type="line">// TODO: Cache this in an atomic to avoid this overhead</comment>
        <return>return <expr><call><name><name>vRandom</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></expr></expr_stmt>

    <comment type="line" format="doxygen">//! Consistency check</comment>
    <function><type><name>void</name></type> <name>Check</name><parameter_list>()</parameter_list>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_ADDRMAN</name></cpp:ifdef>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name><operator>=</operator><call><name>Check_</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\n"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></function>

    <comment type="line" format="doxygen">//! Add a single address.</comment>
    <function><type><name>bool</name></type> <name>Add</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CAddress</name> <modifier>&amp;</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CNetAddr</name><modifier>&amp;</modifier></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>nTimePenalty</name> <init>= <expr><literal type="number">0</literal></expr></init></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>fRet</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>Check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>fRet</name> <operator>|=</operator> <call><name>Add_</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>nTimePenalty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>fRet</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name>BCLog</name><operator>::</operator><name>ADDRMAN</name></expr></argument>, <argument><expr><literal type="string">"Added %s from %s: %i tried, %i new\n"</literal></expr></argument>, <argument><expr><call><name><name>addr</name><operator>.</operator><name>ToStringIPPort</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>source</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nTried</name></expr></argument>, <argument><expr><name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>fRet</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="line" format="doxygen">//! Add multiple addresses.</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>Add</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CAddress</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>vAddr</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CNetAddr</name><operator>&amp;</operator> <name>source</name></expr></argument>, <argument><expr><name>int64_t</name> <name>nTimePenalty</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>)</argument_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nAdd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>Check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CAddress</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>const_iterator</name> <name>it</name> <operator>=</operator> <call><name><name>vAddr</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</init> <condition><expr><name>it</name> <operator>!=</operator> <call><name><name>vAddr</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>it</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name>nAdd</name> <operator>+=</operator> <ternary><condition><expr><call><name>Add_</name><argument_list>(<argument><expr><operator>*</operator><name>it</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>nTimePenalty</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><call><name>Check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nAdd</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name>BCLog</name><operator>::</operator><name>ADDRMAN</name></expr></argument>, <argument><expr><literal type="string">"Added %i addresses from %s: %i tried, %i new\n"</literal></expr></argument>, <argument><expr><name>nAdd</name></expr></argument>, <argument><expr><call><name><name>source</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nTried</name></expr></argument>, <argument><expr><name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>nAdd</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
    </block_content>}</block></decl></decl_stmt>

    <comment type="line" format="doxygen">//! Mark an entry as accessible.</comment>
    <function><type><name>void</name></type> <name>Good</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CService</name> <modifier>&amp;</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>test_before_evict</name> <init>= <expr><name>true</name></expr></init></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>nTime</name> <init>= <expr><call><name>GetAdjustedTime</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Good_</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>test_before_evict</name></expr></argument>, <argument><expr><name>nTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="line" format="doxygen">//! Mark an entry as connection attempted to.</comment>
    <function><type><name>void</name></type> <name>Attempt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CService</name> <modifier>&amp;</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fCountFailure</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>nTime</name> <init>= <expr><call><name>GetAdjustedTime</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Attempt_</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>fCountFailure</name></expr></argument>, <argument><expr><name>nTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="line" format="doxygen">//! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.</comment>
    <function><type><name>void</name></type> <name>ResolveCollisions</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ResolveCollisions_</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="line" format="doxygen">//! Randomly select an address in tried that another address is attempting to evict.</comment>
    <function><type><name>CAddrInfo</name></type> <name>SelectTriedCollision</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CAddrInfo</name></type> <name>ret</name></decl>;</decl_stmt>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>SelectTriedCollision_</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <return>return <expr><name>ret</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="doxygen">/**
     * Choose an address to connect to.
     */</comment>
    <function><type><name>CAddrInfo</name></type> <name>Select</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>newOnly</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CAddrInfo</name></type> <name>addrRet</name></decl>;</decl_stmt>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>addrRet</name> <operator>=</operator> <call><name>Select_</name><argument_list>(<argument><expr><name>newOnly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <return>return <expr><name>addrRet</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="line" format="doxygen">//! Return a bunch of addresses, selected at random.</comment>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CAddress</name></expr></argument>&gt;</argument_list></name> <macro><name>GetAddr</name><argument_list>()</argument_list></macro>
    <block>{
        <expr><call><name>Check</name><argument_list>()</argument_list></call></expr>;
        <expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CAddress</name></expr></argument>&gt;</argument_list></name> <name>vAddr</name></expr>;
        <expr><block>{
            <expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;
            <expr><call><name>GetAddr_</name><argument_list>(<argument><expr><name>vAddr</name></expr></argument>)</argument_list></call></expr>;
        }</block>
        <call><name>Check</name><argument_list>()</argument_list></call></expr>;
        <return>return <expr><name>vAddr</name></expr>;</return>
    }</block></expr></expr_stmt>

    <comment type="line" format="doxygen">//! Mark an entry as currently-connected-to.</comment>
    <function><type><name>void</name></type> <name>Connected</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CService</name> <modifier>&amp;</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>nTime</name> <init>= <expr><call><name>GetAdjustedTime</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Connected_</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>nTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type> <name>SetServices</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CService</name> <modifier>&amp;</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>ServiceFlags</name></type> <name>nServices</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SetServices_</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>nServices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// BITCOIN_ADDRMAN_H</comment>
</unit>
