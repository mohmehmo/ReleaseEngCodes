<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C++" filename="/home/mmm/Projects/bitcoin/src/netaddress.cpp"><comment type="line">// Copyright (c) 2009-2010 Satoshi Nakamoto</comment>
<comment type="line">// Copyright (c) 2009-2018 The Bitcoin Core developers</comment>
<comment type="line">// Distributed under the MIT software license, see the accompanying</comment>
<comment type="line">// file COPYING or http://www.opensource.org/licenses/mit-license.php.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netaddress.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;hash.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/strencodings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;tinyformat.h&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>pchIPv4</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0xff</literal></expr>, <expr><literal type="number">0xff</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>pchOnionCat</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">0xFD</literal></expr>,<expr><literal type="number">0x87</literal></expr>,<expr><literal type="number">0xD8</literal></expr>,<expr><literal type="number">0x7E</literal></expr>,<expr><literal type="number">0xEB</literal></expr>,<expr><literal type="number">0x43</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<comment type="line">// 0xFD + sha256("bitcoin")[0:5]</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>g_internal_prefix</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">0xFD</literal></expr>, <expr><literal type="number">0x6B</literal></expr>, <expr><literal type="number">0x88</literal></expr>, <expr><literal type="number">0xC0</literal></expr>, <expr><literal type="number">0x87</literal></expr>, <expr><literal type="number">0x24</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<comment type="block" format="doxygen">/**
 * Construct an unspecified IPv6 network address (::/128).
 *
 * @note This address is considered invalid by CNetAddr::IsValid()
 */</comment>
<constructor><name><name>CNetAddr</name><operator>::</operator><name>CNetAddr</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></constructor>

<function><type><name>void</name></type> <name><name>CNetAddr</name><operator>::</operator><name>SetIP</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CNetAddr</name><modifier>&amp;</modifier></type> <name>ipIn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name><name>ipIn</name><operator>.</operator><name>ip</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CNetAddr</name><operator>::</operator><name>SetRaw</name></name><parameter_list>(<parameter><decl><type><name>Network</name></type> <name>network</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>ip_in</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch<condition>(<expr><name>network</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>NET_IPV4</name></expr>:</case>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>pchIPv4</name></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">12</literal></expr></argument>, <argument><expr><name>ip_in</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>NET_IPV6</name></expr>:</case>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>ip_in</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><literal type="string">"invalid network"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Try to make this a dummy address that maps the specified name into IPv6 like
 * so: (0xFD + %sha256("bitcoin")[0:5]) + %sha256(name)[0:10]. Such dummy
 * addresses have a prefix of fd6b:88c0:8724::/48 and are guaranteed to not be
 * publicly routable as it falls under RFC4193's fc00::/7 subnet allocated to
 * unique-local addresses.
 *
 * CAddrMan uses these fake addresses to keep track of which DNS seeds were
 * used.
 *
 * @returns Whether or not the operation was successful.
 *
 * @see CNetAddr::IsInternal(), CNetAddr::IsRFC4193()
 */</comment>
<function><type><name>bool</name></type> <name><name>CNetAddr</name><operator>::</operator><name>SetInternal</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name><name>name</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>hash</name><index>[<expr><literal type="number">32</literal></expr>]</index></name> <init>= <expr><block>{}</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>CSHA256</name><argument_list>()</argument_list></call><operator>.</operator><call><name>Write</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><call><name><name>name</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>name</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>Finalize</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>g_internal_prefix</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>g_internal_prefix</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ip</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>g_internal_prefix</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>g_internal_prefix</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Try to make this a dummy address that maps the specified onion address into
 * IPv6 using OnionCat's range and encoding. Such dummy addresses have a prefix
 * of fd87:d87e:eb43::/48 and are guaranteed to not be publicly routable as they
 * fall under RFC4193's fc00::/7 subnet allocated to unique-local addresses.
 *
 * @returns Whether or not the operation was successful.
 *
 * @see CNetAddr::IsTor(), CNetAddr::IsRFC4193()
 */</comment>
<function><type><name>bool</name></type> <name><name>CNetAddr</name><operator>::</operator><name>SetSpecial</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>strName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name><name>strName</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call><operator>&gt;</operator><literal type="number">6</literal> <operator>&amp;&amp;</operator> <call><name><name>strName</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><call><name><name>strName</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">".onion"</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>vchAddr</name> <init>= <expr><call><name>DecodeBase32</name><argument_list>(<argument><expr><call><name><name>strName</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>strName</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">6</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>c_str</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>vchAddr</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">16</literal><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr><name>pchOnionCat</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>pchOnionCat</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pchOnionCat</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">16</literal><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr><name>pchOnionCat</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>ip</name><index>[<expr><name>i</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pchOnionCat</name></expr></argument>)</argument_list></sizeof></expr>]</index></name> <operator>=</operator> <name><name>vchAddr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
</block_content>}</block></function>

<constructor><name><name>CNetAddr</name><operator>::</operator><name>CNetAddr</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>in_addr</name></name><modifier>&amp;</modifier></type> <name>ipv4Addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>SetRaw</name><argument_list>(<argument><expr><name>NET_IPV4</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>uint8_t</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ipv4Addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></constructor>

<constructor><name><name>CNetAddr</name><operator>::</operator><name>CNetAddr</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>in6_addr</name></name><modifier>&amp;</modifier></type> <name>ipv6Addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>scope</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>SetRaw</name><argument_list>(<argument><expr><name>NET_IPV6</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>uint8_t</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ipv6Addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scopeId</name> <operator>=</operator> <name>scope</name></expr>;</expr_stmt>
</block_content>}</block></constructor>

<function><type><name>unsigned</name> <name>int</name></type> <name><name>CNetAddr</name><operator>::</operator><name>GetByte</name></name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <return>return <expr><name><name>ip</name><index>[<expr><literal type="number">15</literal><operator>-</operator><name>n</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CNetAddr</name><operator>::</operator><name>IsBindAny</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>cmplen</name> <init>= <expr><ternary><condition><expr><call><name>IsIPv4</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="number">4</literal></expr> </then><else>: <expr><literal type="number">16</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cmplen</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>GetByte</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CNetAddr</name><operator>::</operator><name>IsIPv4</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <return>return <expr><operator>(</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>pchIPv4</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pchIPv4</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CNetAddr</name><operator>::</operator><name>IsIPv6</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <return>return <expr><operator>(</operator><operator>!</operator><call><name>IsIPv4</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsTor</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsInternal</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CNetAddr</name><operator>::</operator><name>IsRFC1918</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <return>return <expr><call><name>IsIPv4</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator>
        <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">10</literal> <operator>||</operator>
        <operator>(</operator><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">192</literal> <operator>&amp;&amp;</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">168</literal><operator>)</operator> <operator>||</operator>
        <operator>(</operator><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">172</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">16</literal> <operator>&amp;&amp;</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">31</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CNetAddr</name><operator>::</operator><name>IsRFC2544</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <return>return <expr><call><name>IsIPv4</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">198</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">18</literal> <operator>||</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">19</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CNetAddr</name><operator>::</operator><name>IsRFC3927</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <return>return <expr><call><name>IsIPv4</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">169</literal> <operator>&amp;&amp;</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">254</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CNetAddr</name><operator>::</operator><name>IsRFC6598</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <return>return <expr><call><name>IsIPv4</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">100</literal> <operator>&amp;&amp;</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">64</literal> <operator>&amp;&amp;</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">127</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CNetAddr</name><operator>::</operator><name>IsRFC5737</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <return>return <expr><call><name>IsIPv4</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">192</literal> <operator>&amp;&amp;</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal><operator>)</operator> <operator>||</operator>
        <operator>(</operator><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">198</literal> <operator>&amp;&amp;</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">51</literal> <operator>&amp;&amp;</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">100</literal><operator>)</operator> <operator>||</operator>
        <operator>(</operator><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">203</literal> <operator>&amp;&amp;</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">113</literal><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CNetAddr</name><operator>::</operator><name>IsRFC3849</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <return>return <expr><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0x20</literal> <operator>&amp;&amp;</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0x01</literal> <operator>&amp;&amp;</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0x0D</literal> <operator>&amp;&amp;</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0xB8</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CNetAddr</name><operator>::</operator><name>IsRFC3964</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <return>return <expr><operator>(</operator><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0x20</literal> <operator>&amp;&amp;</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0x02</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CNetAddr</name><operator>::</operator><name>IsRFC6052</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>pchRFC6052</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0x64</literal></expr>,<expr><literal type="number">0xFF</literal></expr>,<expr><literal type="number">0x9B</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <return>return <expr><operator>(</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>pchRFC6052</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pchRFC6052</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CNetAddr</name><operator>::</operator><name>IsRFC4380</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <return>return <expr><operator>(</operator><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0x20</literal> <operator>&amp;&amp;</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0x01</literal> <operator>&amp;&amp;</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CNetAddr</name><operator>::</operator><name>IsRFC4862</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>pchRFC4862</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">0xFE</literal></expr>,<expr><literal type="number">0x80</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <return>return <expr><operator>(</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>pchRFC4862</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pchRFC4862</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CNetAddr</name><operator>::</operator><name>IsRFC4193</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <return>return <expr><operator>(</operator><operator>(</operator><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0xFE</literal><operator>)</operator> <operator>==</operator> <literal type="number">0xFC</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CNetAddr</name><operator>::</operator><name>IsRFC6145</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>pchRFC6145</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0xFF</literal></expr>,<expr><literal type="number">0xFF</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <return>return <expr><operator>(</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>pchRFC6145</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pchRFC6145</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CNetAddr</name><operator>::</operator><name>IsRFC4843</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <return>return <expr><operator>(</operator><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0x20</literal> <operator>&amp;&amp;</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0x01</literal> <operator>&amp;&amp;</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0x00</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0xF0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x10</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CNetAddr</name><operator>::</operator><name>IsRFC7343</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <return>return <expr><operator>(</operator><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0x20</literal> <operator>&amp;&amp;</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0x01</literal> <operator>&amp;&amp;</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0x00</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0xF0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x20</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * @returns Whether or not this is a dummy address that maps an onion address
 *          into IPv6.
 *
 * @see CNetAddr::SetSpecial(const std::string &amp;)
 */</comment>
<function><type><name>bool</name></type> <name><name>CNetAddr</name><operator>::</operator><name>IsTor</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <return>return <expr><operator>(</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>pchOnionCat</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pchOnionCat</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CNetAddr</name><operator>::</operator><name>IsLocal</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <comment type="line">// IPv4 loopback (127.0.0.0/8 or 0.0.0.0/8)</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsIPv4</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">127</literal> <operator>||</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// IPv6 loopback (::1/128)</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>pchLocal</name><index>[<expr><literal type="number">16</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">1</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>pchLocal</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * @returns Whether or not this network address is a valid address that @a could
 *          be used to refer to an actual host.
 *
 * @note A valid address may or may not be publicly routable on the global
 *       internet. As in, the set of valid addresses is a superset of the set of
 *       publicly routable addresses.
 *
 * @see CNetAddr::IsRoutable()
 */</comment>
<function><type><name>bool</name></type> <name><name>CNetAddr</name><operator>::</operator><name>IsValid</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <comment type="line">// Cleanup 3-byte shifted addresses caused by garbage in size field</comment>
    <comment type="line">// of addr messages from versions before 0.2.9 checksum.</comment>
    <comment type="line">// Two consecutive addr messages look like this:</comment>
    <comment type="line">// header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...</comment>
    <comment type="line">// so if the first length field is garbled, it reads the second batch</comment>
    <comment type="line">// of addr misaligned by 3 bytes.</comment>
    <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>pchIPv4</name><operator>+</operator><literal type="number">3</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pchIPv4</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// unspecified IPv6 address (::/128)</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>ipNone6</name><index>[<expr><literal type="number">16</literal></expr>]</index></name> <init>= <expr><block>{}</block></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>ipNone6</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// documentation IPv6 address</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsRFC3849</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsInternal</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsIPv4</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// INADDR_NONE</comment>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>ipNone</name> <init>= <expr><name>INADDR_NONE</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">12</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ipNone</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

        <comment type="line">// 0</comment>
        <expr_stmt><expr><name>ipNone</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>ip</name><operator>+</operator><literal type="number">12</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ipNone</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * @returns Whether or not this network address is publicly routable on the
 *          global internet.
 *
 * @note A routable address is always valid. As in, the set of routable addresses
 *       is a subset of the set of valid addresses.
 *
 * @see CNetAddr::IsValid()
 */</comment>
<function><type><name>bool</name></type> <name><name>CNetAddr</name><operator>::</operator><name>IsRoutable</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <return>return <expr><call><name>IsValid</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><call><name>IsRFC1918</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsRFC2544</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsRFC3927</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsRFC4862</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsRFC6598</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsRFC5737</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>(</operator><call><name>IsRFC4193</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsTor</name><argument_list>()</argument_list></call><operator>)</operator> <operator>||</operator> <call><name>IsRFC4843</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsRFC7343</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsLocal</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsInternal</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * @returns Whether or not this is a dummy address that maps a name into IPv6.
 *
 * @see CNetAddr::SetInternal(const std::string &amp;)
 */</comment>
<function><type><name>bool</name></type> <name><name>CNetAddr</name><operator>::</operator><name>IsInternal</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
   <return>return <expr><call><name>memcmp</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>g_internal_prefix</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>g_internal_prefix</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>enum</name> <name>Network</name></name></type> <name><name>CNetAddr</name><operator>::</operator><name>GetNetwork</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>IsInternal</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NET_INTERNAL</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsRoutable</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NET_UNROUTABLE</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsIPv4</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NET_IPV4</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsTor</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NET_ONION</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>NET_IPV6</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name><name>CNetAddr</name><operator>::</operator><name>ToStringIP</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>IsTor</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>EncodeBase32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ip</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="string">".onion"</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsInternal</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>EncodeBase32</name><argument_list>(<argument><expr><name>ip</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>g_internal_prefix</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>g_internal_prefix</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="string">".internal"</literal></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>CService</name></type> <name>serv</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_storage</name></name></type> <name>sockaddr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>socklen_t</name></type> <name>socklen</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>sockaddr</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>serv</name><operator>.</operator><name>GetSockAddr</name></name><argument_list>(<argument><expr><operator>(</operator>struct <name>sockaddr</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>sockaddr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>socklen</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><literal type="number">1025</literal></expr>]</index></name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getnameinfo</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> struct <name>sockaddr</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>sockaddr</name></expr></argument>, <argument><expr><name>socklen</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="null">nullptr</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NI_NUMERICHOST</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsIPv4</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"%u.%u.%u.%u"</literal></expr></argument>, <argument><expr><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"%x:%x:%x:%x:%x:%x:%x:%x"</literal></expr></argument>,
                         <argument><expr><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">8</literal> <operator>|</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">8</literal> <operator>|</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">8</literal> <operator>|</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">8</literal> <operator>|</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">8</literal> <operator>|</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">8</literal> <operator>|</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">8</literal> <operator>|</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">8</literal> <operator>|</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name><name>CNetAddr</name><operator>::</operator><name>ToString</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <return>return <expr><call><name>ToStringIP</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function type="operator"><type><name>bool</name></type> <name>operator<name>==</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CNetAddr</name><modifier>&amp;</modifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CNetAddr</name><modifier>&amp;</modifier></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>a</name><operator>.</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>.</operator><name>ip</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function type="operator"><type><name>bool</name></type> <name>operator<name>&lt;</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CNetAddr</name><modifier>&amp;</modifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CNetAddr</name><modifier>&amp;</modifier></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>a</name><operator>.</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>.</operator><name>ip</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Try to get our IPv4 address.
 *
 * @param[out] pipv4Addr The in_addr struct to which to copy.
 *
 * @returns Whether or not the operation was successful, in particular, whether
 *          or not our address was an IPv4 address.
 *
 * @see CNetAddr::IsIPv4()
 */</comment>
<function><type><name>bool</name></type> <name><name>CNetAddr</name><operator>::</operator><name>GetInAddr</name></name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>in_addr</name></name><modifier>*</modifier></type> <name>pipv4Addr</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsIPv4</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pipv4Addr</name></expr></argument>, <argument><expr><name>ip</name><operator>+</operator><literal type="number">12</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Try to get our IPv6 address.
 *
 * @param[out] pipv6Addr The in6_addr struct to which to copy.
 *
 * @returns Whether or not the operation was successful, in particular, whether
 *          or not our address was an IPv6 address.
 *
 * @see CNetAddr::IsIPv6()
 */</comment>
<function><type><name>bool</name></type> <name><name>CNetAddr</name><operator>::</operator><name>GetIn6Addr</name></name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>in6_addr</name></name><modifier>*</modifier></type> <name>pipv6Addr</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsIPv6</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pipv6Addr</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Get the canonical identifier of our network group
 *
 * The groups are assigned in a way where it should be costly for an attacker to
 * obtain addresses with many different group identifiers, even if it is cheap
 * to obtain addresses with the same identifier.
 *
 * @note No two connections will be attempted to addresses with the same network
 *       group.
 */</comment>
<function><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name><name>CNetAddr</name><operator>::</operator><name>GetGroup</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>vchRet</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nClass</name> <init>= <expr><name>NET_IPV6</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nStartByte</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nBits</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>;</decl_stmt>

    <comment type="line">// all local addresses belong to the same group</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsLocal</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>nClass</name> <operator>=</operator> <literal type="number">255</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>nBits</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="line">// all internal-usage addresses get their own group</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsInternal</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>nClass</name> <operator>=</operator> <name>NET_INTERNAL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nStartByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>g_internal_prefix</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name>nBits</name> <operator>=</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>g_internal_prefix</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>*</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="line">// all other unroutable addresses belong to the same group</comment>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>IsRoutable</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>nClass</name> <operator>=</operator> <name>NET_UNROUTABLE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nBits</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="line">// for IPv4 addresses, '1' + the 16 higher-order bits of the IP</comment>
    <comment type="line">// includes mapped IPv4, SIIT translated IPv4, and the well-known prefix</comment>
    <if type="elseif">else if <condition>(<expr><call><name>IsIPv4</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsRFC6145</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsRFC6052</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>nClass</name> <operator>=</operator> <name>NET_IPV4</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nStartByte</name> <operator>=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="line">// for 6to4 tunnelled addresses, use the encapsulated IPv4 address</comment>
    <if type="elseif">else if <condition>(<expr><call><name>IsRFC3964</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>nClass</name> <operator>=</operator> <name>NET_IPV4</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nStartByte</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="line">// for Teredo-tunnelled IPv6 addresses, use the encapsulated IPv4 address</comment>
    <if type="elseif">else if <condition>(<expr><call><name>IsRFC4380</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>vchRet</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>NET_IPV4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>vchRet</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>^</operator> <literal type="number">0xFF</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>vchRet</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>^</operator> <literal type="number">0xFF</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>vchRet</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsTor</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>nClass</name> <operator>=</operator> <name>NET_ONION</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nStartByte</name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>nBits</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="line">// for he.net, use /36 groups</comment>
    <if type="elseif">else if <condition>(<expr><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0x20</literal> <operator>&amp;&amp;</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0x01</literal> <operator>&amp;&amp;</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0x04</literal> <operator>&amp;&amp;</operator> <call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0x70</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>nBits</name> <operator>=</operator> <literal type="number">36</literal></expr>;</expr_stmt></block_content></block></if>
    <comment type="line">// for the rest of the IPv6 network, use /32 groups</comment>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>nBits</name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name><name>vchRet</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>nClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// push our ip onto vchRet byte by byte...</comment>
    <while>while <condition>(<expr><name>nBits</name> <operator>&gt;=</operator> <literal type="number">8</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>vchRet</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">15</literal> <operator>-</operator> <name>nStartByte</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nStartByte</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>nBits</name> <operator>-=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
    <comment type="line">// ...for the last byte, push nBits and for the rest of the byte push 1's</comment>
    <if_stmt><if>if <condition>(<expr><name>nBits</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name><name>vchRet</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>GetByte</name><argument_list>(<argument><expr><literal type="number">15</literal> <operator>-</operator> <name>nStartByte</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">8</literal> <operator>-</operator> <name>nBits</name><operator>)</operator><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>vchRet</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint64_t</name></type> <name><name>CNetAddr</name><operator>::</operator><name>GetHash</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint256</name></type> <name>hash</name> <init>= <expr><call><name>Hash</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ip</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>nRet</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nRet</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hash</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nRet</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>nRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// private extensions to enum Network, only returned by GetExtNetwork,</comment>
<comment type="line">// and only used in GetReachabilityFrom</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>NET_UNKNOWN</name> <init>= <expr><name>NET_MAX</name> <operator>+</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>NET_TEREDO</name>  <init>= <expr><name>NET_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<function><type><name>int</name> <specifier>static</specifier></type> <name>GetExtNetwork</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CNetAddr</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <literal type="null">nullptr</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NET_UNKNOWN</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>addr</name><operator>-&gt;</operator><name>IsRFC4380</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NET_TEREDO</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name><name>addr</name><operator>-&gt;</operator><name>GetNetwork</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** Calculates a metric for how reachable (*this) is from a given partner */</comment>
<function><type><name>int</name></type> <name><name>CNetAddr</name><operator>::</operator><name>GetReachabilityFrom</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CNetAddr</name> <modifier>*</modifier></type><name>paddrPartner</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <enum>enum <name>Reachability</name> <block>{
        <decl><name>REACH_UNREACHABLE</name></decl>,
        <decl><name>REACH_DEFAULT</name></decl>,
        <decl><name>REACH_TEREDO</name></decl>,
        <decl><name>REACH_IPV6_WEAK</name></decl>,
        <decl><name>REACH_IPV4</name></decl>,
        <decl><name>REACH_IPV6_STRONG</name></decl>,
        <decl><name>REACH_PRIVATE</name></decl>
    }</block>;</enum>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsRoutable</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsInternal</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>REACH_UNREACHABLE</name></expr>;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>ourNet</name> <init>= <expr><call><name>GetExtNetwork</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>theirNet</name> <init>= <expr><call><name>GetExtNetwork</name><argument_list>(<argument><expr><name>paddrPartner</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>fTunnel</name> <init>= <expr><call><name>IsRFC3964</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsRFC6052</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsRFC6145</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <switch>switch<condition>(<expr><name>theirNet</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>NET_IPV4</name></expr>:</case>
        <switch>switch<condition>(<expr><name>ourNet</name></expr>)</condition> <block>{<block_content>
        <default>default:</default>       <return>return <expr><name>REACH_DEFAULT</name></expr>;</return>
        <case>case <expr><name>NET_IPV4</name></expr>:</case> <return>return <expr><name>REACH_IPV4</name></expr>;</return>
        </block_content>}</block></switch>
    <case>case <expr><name>NET_IPV6</name></expr>:</case>
        <switch>switch<condition>(<expr><name>ourNet</name></expr>)</condition> <block>{<block_content>
        <default>default:</default>         <return>return <expr><name>REACH_DEFAULT</name></expr>;</return>
        <case>case <expr><name>NET_TEREDO</name></expr>:</case> <return>return <expr><name>REACH_TEREDO</name></expr>;</return>
        <case>case <expr><name>NET_IPV4</name></expr>:</case>   <return>return <expr><name>REACH_IPV4</name></expr>;</return>
        <case>case <expr><name>NET_IPV6</name></expr>:</case>   <return>return <expr><ternary><condition><expr><name>fTunnel</name></expr> ?</condition><then> <expr><name>REACH_IPV6_WEAK</name></expr> </then><else>: <expr><name>REACH_IPV6_STRONG</name></expr></else></ternary></expr>;</return> <comment type="line">// only prefer giving our IPv6 address if it's not tunnelled</comment>
        </block_content>}</block></switch>
    <case>case <expr><name>NET_ONION</name></expr>:</case>
        <switch>switch<condition>(<expr><name>ourNet</name></expr>)</condition> <block>{<block_content>
        <default>default:</default>         <return>return <expr><name>REACH_DEFAULT</name></expr>;</return>
        <case>case <expr><name>NET_IPV4</name></expr>:</case>   <return>return <expr><name>REACH_IPV4</name></expr>;</return> <comment type="line">// Tor users can connect to IPv4 as well</comment>
        <case>case <expr><name>NET_ONION</name></expr>:</case>    <return>return <expr><name>REACH_PRIVATE</name></expr>;</return>
        </block_content>}</block></switch>
    <case>case <expr><name>NET_TEREDO</name></expr>:</case>
        <switch>switch<condition>(<expr><name>ourNet</name></expr>)</condition> <block>{<block_content>
        <default>default:</default>          <return>return <expr><name>REACH_DEFAULT</name></expr>;</return>
        <case>case <expr><name>NET_TEREDO</name></expr>:</case>  <return>return <expr><name>REACH_TEREDO</name></expr>;</return>
        <case>case <expr><name>NET_IPV6</name></expr>:</case>    <return>return <expr><name>REACH_IPV6_WEAK</name></expr>;</return>
        <case>case <expr><name>NET_IPV4</name></expr>:</case>    <return>return <expr><name>REACH_IPV4</name></expr>;</return>
        </block_content>}</block></switch>
    <case>case <expr><name>NET_UNKNOWN</name></expr>:</case>
    <case>case <expr><name>NET_UNROUTABLE</name></expr>:</case>
    <default>default:</default>
        <switch>switch<condition>(<expr><name>ourNet</name></expr>)</condition> <block>{<block_content>
        <default>default:</default>          <return>return <expr><name>REACH_DEFAULT</name></expr>;</return>
        <case>case <expr><name>NET_TEREDO</name></expr>:</case>  <return>return <expr><name>REACH_TEREDO</name></expr>;</return>
        <case>case <expr><name>NET_IPV6</name></expr>:</case>    <return>return <expr><name>REACH_IPV6_WEAK</name></expr>;</return>
        <case>case <expr><name>NET_IPV4</name></expr>:</case>    <return>return <expr><name>REACH_IPV4</name></expr>;</return>
        <case>case <expr><name>NET_ONION</name></expr>:</case>     <return>return <expr><name>REACH_PRIVATE</name></expr>;</return> <comment type="line">// either from Tor, or don't care about our address</comment>
        </block_content>}</block></switch>
    </block_content>}</block></switch>
</block_content>}</block></function>

<constructor><name><name>CService</name><operator>::</operator><name>CService</name></name><parameter_list>()</parameter_list> <member_init_list>: <call><name>port</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call>
</member_init_list><block>{<block_content>
</block_content>}</block></constructor>

<constructor><name><name>CService</name><operator>::</operator><name>CService</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CNetAddr</name><modifier>&amp;</modifier></type> <name>cip</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>short</name></type> <name>portIn</name></decl></parameter>)</parameter_list> <member_init_list>: <call><name>CNetAddr</name><argument_list>(<argument><expr><name>cip</name></expr></argument>)</argument_list></call>, <call><name>port</name><argument_list>(<argument><expr><name>portIn</name></expr></argument>)</argument_list></call>
</member_init_list><block>{<block_content>
</block_content>}</block></constructor>

<constructor><name><name>CService</name><operator>::</operator><name>CService</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>in_addr</name></name><modifier>&amp;</modifier></type> <name>ipv4Addr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>short</name></type> <name>portIn</name></decl></parameter>)</parameter_list> <member_init_list>: <call><name>CNetAddr</name><argument_list>(<argument><expr><name>ipv4Addr</name></expr></argument>)</argument_list></call>, <call><name>port</name><argument_list>(<argument><expr><name>portIn</name></expr></argument>)</argument_list></call>
</member_init_list><block>{<block_content>
</block_content>}</block></constructor>

<constructor><name><name>CService</name><operator>::</operator><name>CService</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>in6_addr</name></name><modifier>&amp;</modifier></type> <name>ipv6Addr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>short</name></type> <name>portIn</name></decl></parameter>)</parameter_list> <member_init_list>: <call><name>CNetAddr</name><argument_list>(<argument><expr><name>ipv6Addr</name></expr></argument>)</argument_list></call>, <call><name>port</name><argument_list>(<argument><expr><name>portIn</name></expr></argument>)</argument_list></call>
</member_init_list><block>{<block_content>
</block_content>}</block></constructor>

<constructor><name><name>CService</name><operator>::</operator><name>CService</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>sockaddr_in</name></name><modifier>&amp;</modifier></type> <name>addr</name></decl></parameter>)</parameter_list> <member_init_list>: <call><name>CNetAddr</name><argument_list>(<argument><expr><name><name>addr</name><operator>.</operator><name>sin_addr</name></name></expr></argument>)</argument_list></call>, <call><name>port</name><argument_list>(<argument><expr><call><name>ntohs</name><argument_list>(<argument><expr><name><name>addr</name><operator>.</operator><name>sin_port</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
</member_init_list><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>addr</name><operator>.</operator><name>sin_family</name></name> <operator>==</operator> <name>AF_INET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></constructor>

<constructor><name><name>CService</name><operator>::</operator><name>CService</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>sockaddr_in6</name></name> <modifier>&amp;</modifier></type><name>addr</name></decl></parameter>)</parameter_list> <member_init_list>: <call><name>CNetAddr</name><argument_list>(<argument><expr><name><name>addr</name><operator>.</operator><name>sin6_addr</name></name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>sin6_scope_id</name></name></expr></argument>)</argument_list></call>, <call><name>port</name><argument_list>(<argument><expr><call><name>ntohs</name><argument_list>(<argument><expr><name><name>addr</name><operator>.</operator><name>sin6_port</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
</member_init_list><block>{<block_content>
   <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>addr</name><operator>.</operator><name>sin6_family</name></name> <operator>==</operator> <name>AF_INET6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></constructor>

<function><type><name>bool</name></type> <name><name>CService</name><operator>::</operator><name>SetSockAddr</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>sockaddr</name></name> <modifier>*</modifier></type><name>paddr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><name><name>paddr</name><operator>-&gt;</operator><name>sa_family</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>AF_INET</name></expr>:</case>
        <expr_stmt><expr><operator>*</operator><name>this</name> <operator>=</operator> <call><name>CService</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> struct <name>sockaddr_in</name><operator>*</operator><operator>)</operator><name>paddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    <case>case <expr><name>AF_INET6</name></expr>:</case>
        <expr_stmt><expr><operator>*</operator><name>this</name> <operator>=</operator> <call><name>CService</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> struct <name>sockaddr_in6</name><operator>*</operator><operator>)</operator><name>paddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    <default>default:</default>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>short</name></type> <name><name>CService</name><operator>::</operator><name>GetPort</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <return>return <expr><name>port</name></expr>;</return>
</block_content>}</block></function>

<function type="operator"><type><name>bool</name></type> <name>operator<name>==</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CService</name><modifier>&amp;</modifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CService</name><modifier>&amp;</modifier></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>CNetAddr</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></cast> <operator>==</operator> <cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>CNetAddr</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></cast> <operator>&amp;&amp;</operator> <name><name>a</name><operator>.</operator><name>port</name></name> <operator>==</operator> <name><name>b</name><operator>.</operator><name>port</name></name></expr>;</return>
</block_content>}</block></function>

<function type="operator"><type><name>bool</name></type> <name>operator<name>&lt;</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CService</name><modifier>&amp;</modifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CService</name><modifier>&amp;</modifier></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>CNetAddr</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></cast> <operator>&lt;</operator> <cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>CNetAddr</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></cast> <operator>||</operator> <operator>(</operator><cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>CNetAddr</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></cast> <operator>==</operator> <cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>CNetAddr</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></cast> <operator>&amp;&amp;</operator> <name><name>a</name><operator>.</operator><name>port</name></name> <operator>&lt;</operator> <name><name>b</name><operator>.</operator><name>port</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Obtain the IPv4/6 socket address this represents.
 *
 * @param[out] paddr The obtained socket address.
 * @param[in,out] addrlen The size, in bytes, of the address structure pointed
 *                        to by paddr. The value that's pointed to by this
 *                        parameter might change after calling this function if
 *                        the size of the corresponding address structure
 *                        changed.
 *
 * @returns Whether or not the operation was successful.
 */</comment>
<function><type><name>bool</name></type> <name><name>CService</name><operator>::</operator><name>GetSockAddr</name></name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sockaddr</name></name><modifier>*</modifier></type> <name>paddr</name></decl></parameter>, <parameter><decl><type><name>socklen_t</name> <modifier>*</modifier></type><name>addrlen</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>IsIPv4</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>addrlen</name> <operator>&lt;</operator> <operator>(</operator><name>socklen_t</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr>struct <name>sockaddr_in</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>addrlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>sockaddr_in</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_in</name></name> <modifier>*</modifier></type><name>paddrin</name> <init>= <expr><operator>(</operator>struct <name>sockaddr_in</name><operator>*</operator><operator>)</operator><name>paddr</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>paddrin</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>*</operator><name>addrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetInAddr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>paddrin</name><operator>-&gt;</operator><name>sin_addr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>paddrin</name><operator>-&gt;</operator><name>sin_family</name></name> <operator>=</operator> <name>AF_INET</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>paddrin</name><operator>-&gt;</operator><name>sin_port</name></name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsIPv6</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>addrlen</name> <operator>&lt;</operator> <operator>(</operator><name>socklen_t</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr>struct <name>sockaddr_in6</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>addrlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>sockaddr_in6</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_in6</name></name> <modifier>*</modifier></type><name>paddrin6</name> <init>= <expr><operator>(</operator>struct <name>sockaddr_in6</name><operator>*</operator><operator>)</operator><name>paddr</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>paddrin6</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>*</operator><name>addrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetIn6Addr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>paddrin6</name><operator>-&gt;</operator><name>sin6_addr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>paddrin6</name><operator>-&gt;</operator><name>sin6_scope_id</name></name> <operator>=</operator> <name>scopeId</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>paddrin6</name><operator>-&gt;</operator><name>sin6_family</name></name> <operator>=</operator> <name>AF_INET6</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>paddrin6</name><operator>-&gt;</operator><name>sin6_port</name></name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * @returns An identifier unique to this service's address and port number.
 */</comment>
<function><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name><name>CService</name><operator>::</operator><name>GetKey</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
     <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>vKey</name></decl>;</decl_stmt>
     <expr_stmt><expr><call><name><name>vKey</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><literal type="number">18</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name><name>vKey</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><name><name>vKey</name><index>[<expr><literal type="number">16</literal></expr>]</index></name> <operator>=</operator> <name>port</name> <operator>/</operator> <literal type="number">0x100</literal></expr>;</expr_stmt> <comment type="line">// most significant byte of our port</comment>
     <expr_stmt><expr><name><name>vKey</name><index>[<expr><literal type="number">17</literal></expr>]</index></name> <operator>=</operator> <name>port</name> <operator>&amp;</operator> <literal type="number">0x0FF</literal></expr>;</expr_stmt> <comment type="line">// least significant byte of our port</comment>
     <return>return <expr><name>vKey</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name><name>CService</name><operator>::</operator><name>ToStringPort</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <return>return <expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name><name>CService</name><operator>::</operator><name>ToStringIPPort</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>IsIPv4</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsTor</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsInternal</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>ToStringIP</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="string">":"</literal> <operator>+</operator> <call><name>ToStringPort</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><literal type="string">"["</literal> <operator>+</operator> <call><name>ToStringIP</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="string">"]:"</literal> <operator>+</operator> <call><name>ToStringPort</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name><name>CService</name><operator>::</operator><name>ToString</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <return>return <expr><call><name>ToStringIPPort</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<constructor><name><name>CSubNet</name><operator>::</operator><name>CSubNet</name></name><parameter_list>()</parameter_list><member_init_list>:
    <call><name>valid</name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call>
</member_init_list><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>netmask</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>netmask</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></constructor>

<constructor><name><name>CSubNet</name><operator>::</operator><name>CSubNet</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CNetAddr</name> <modifier>&amp;</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>mask</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>valid</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>network</name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
    <comment type="line">// Default to /32 (IPv4) or /128 (IPv6), i.e. match single address</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>netmask</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>netmask</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// IPv4 addresses start at offset 12, and first 12 bytes must match, so just offset n</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>astartofs</name> <init>= <expr><ternary><condition><expr><call><name><name>network</name><operator>.</operator><name>IsIPv4</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="number">12</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int32_t</name></type> <name>n</name> <init>= <expr><name>mask</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>(<expr><name>n</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>n</name> <operator>&lt;=</operator> <operator>(</operator><literal type="number">128</literal> <operator>-</operator> <name>astartofs</name><operator>*</operator><literal type="number">8</literal><operator>)</operator></expr>)</condition> <comment type="line">// Only valid if in range of bits of address</comment>
    <block>{<block_content>
        <expr_stmt><expr><name>n</name> <operator>+=</operator> <name>astartofs</name><operator>*</operator><literal type="number">8</literal></expr>;</expr_stmt>
        <comment type="line">// Clear bits [n..127]</comment>
        <for>for <control>(<init>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <literal type="number">128</literal></expr>;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>netmask</name><index>[<expr><name>n</name><operator>&gt;&gt;</operator><literal type="number">3</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><literal type="number">7</literal><operator>-</operator><operator>(</operator><name>n</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if> <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>valid</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="line">// Normalize network according to netmask</comment>
    <for>for<control>(<init><decl><type><name>int</name></type> <name>x</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>x</name><operator>&lt;</operator><literal type="number">16</literal></expr>;</condition> <incr><expr><operator>++</operator><name>x</name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>network</name><operator>.</operator><name>ip</name><index>[<expr><name>x</name></expr>]</index></name> <operator>&amp;=</operator> <name><name>netmask</name><index>[<expr><name>x</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></constructor>

<constructor><name><name>CSubNet</name><operator>::</operator><name>CSubNet</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CNetAddr</name> <modifier>&amp;</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CNetAddr</name> <modifier>&amp;</modifier></type><name>mask</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>valid</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>network</name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
    <comment type="line">// Default to /32 (IPv4) or /128 (IPv6), i.e. match single address</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>netmask</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>netmask</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// IPv4 addresses start at offset 12, and first 12 bytes must match, so just offset n</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>astartofs</name> <init>= <expr><ternary><condition><expr><call><name><name>network</name><operator>.</operator><name>IsIPv4</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="number">12</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <for>for<control>(<init><decl><type><name>int</name></type> <name>x</name><init>=<expr><name>astartofs</name></expr></init></decl>;</init> <condition><expr><name>x</name><operator>&lt;</operator><literal type="number">16</literal></expr>;</condition> <incr><expr><operator>++</operator><name>x</name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>netmask</name><index>[<expr><name>x</name></expr>]</index></name> <operator>=</operator> <name><name>mask</name><operator>.</operator><name>ip</name><index>[<expr><name>x</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

    <comment type="line">// Normalize network according to netmask</comment>
    <for>for<control>(<init><decl><type><name>int</name></type> <name>x</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>x</name><operator>&lt;</operator><literal type="number">16</literal></expr>;</condition> <incr><expr><operator>++</operator><name>x</name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>network</name><operator>.</operator><name>ip</name><index>[<expr><name>x</name></expr>]</index></name> <operator>&amp;=</operator> <name><name>netmask</name><index>[<expr><name>x</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></constructor>

<constructor><name><name>CSubNet</name><operator>::</operator><name>CSubNet</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CNetAddr</name> <modifier>&amp;</modifier></type><name>addr</name></decl></parameter>)</parameter_list><member_init_list>:
    <call><name>valid</name><argument_list>(<argument><expr><call><name><name>addr</name><operator>.</operator><name>IsValid</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
</member_init_list><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>netmask</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>netmask</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>network</name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
</block_content>}</block></constructor>

<comment type="block" format="doxygen">/**
 * @returns True if this subnet is valid, the specified address is valid, and
 *          the specified address belongs in this subnet.
 */</comment>
<function><type><name>bool</name></type> <name><name>CSubNet</name><operator>::</operator><name>Match</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CNetAddr</name> <modifier>&amp;</modifier></type><name>addr</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>valid</name> <operator>||</operator> <operator>!</operator><call><name><name>addr</name><operator>.</operator><name>IsValid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
    <for>for<control>(<init><decl><type><name>int</name></type> <name>x</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>x</name><operator>&lt;</operator><literal type="number">16</literal></expr>;</condition> <incr><expr><operator>++</operator><name>x</name></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>addr</name><operator>.</operator><name>ip</name><index>[<expr><name>x</name></expr>]</index></name> <operator>&amp;</operator> <name><name>netmask</name><index>[<expr><name>x</name></expr>]</index></name><operator>)</operator> <operator>!=</operator> <name><name>network</name><operator>.</operator><name>ip</name><index>[<expr><name>x</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * @returns The number of 1-bits in the prefix of the specified subnet mask. If
 *          the specified subnet mask is not a valid one, -1.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>NetmaskBits</name><parameter_list>(<parameter><decl><type><name>uint8_t</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch<condition>(<expr><name>x</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><literal type="number">0x00</literal></expr>:</case> <return>return <expr><literal type="number">0</literal></expr>;</return>
    <case>case <expr><literal type="number">0x80</literal></expr>:</case> <return>return <expr><literal type="number">1</literal></expr>;</return>
    <case>case <expr><literal type="number">0xc0</literal></expr>:</case> <return>return <expr><literal type="number">2</literal></expr>;</return>
    <case>case <expr><literal type="number">0xe0</literal></expr>:</case> <return>return <expr><literal type="number">3</literal></expr>;</return>
    <case>case <expr><literal type="number">0xf0</literal></expr>:</case> <return>return <expr><literal type="number">4</literal></expr>;</return>
    <case>case <expr><literal type="number">0xf8</literal></expr>:</case> <return>return <expr><literal type="number">5</literal></expr>;</return>
    <case>case <expr><literal type="number">0xfc</literal></expr>:</case> <return>return <expr><literal type="number">6</literal></expr>;</return>
    <case>case <expr><literal type="number">0xfe</literal></expr>:</case> <return>return <expr><literal type="number">7</literal></expr>;</return>
    <case>case <expr><literal type="number">0xff</literal></expr>:</case> <return>return <expr><literal type="number">8</literal></expr>;</return>
    <default>default:</default> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name><name>CSubNet</name><operator>::</operator><name>ToString</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <comment type="block">/* Parse binary 1{n}0{N-n} to see if mask can be represented as /n */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>cidr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>valid_cidr</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><ternary><condition><expr><call><name><name>network</name><operator>.</operator><name>IsIPv4</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="number">12</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <literal type="number">16</literal> <operator>&amp;&amp;</operator> <name><name>netmask</name><index>[<expr><name>n</name></expr>]</index></name> <operator>==</operator> <literal type="number">0xff</literal></expr>;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>cidr</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></for>
    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>bits</name> <init>= <expr><call><name>NetmaskBits</name><argument_list>(<argument><expr><name><name>netmask</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>bits</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>valid_cidr</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>cidr</name> <operator>+=</operator> <name>bits</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><operator>++</operator><name>n</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <literal type="number">16</literal> <operator>&amp;&amp;</operator> <name>valid_cidr</name></expr>;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name><name>netmask</name><index>[<expr><name>n</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0x00</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>valid_cidr</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

    <comment type="block">/* Format output */</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>strNetmask</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>valid_cidr</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>strNetmask</name> <operator>=</operator> <call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name>cidr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>network</name><operator>.</operator><name>IsIPv4</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>strNetmask</name> <operator>=</operator> <call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"%u.%u.%u.%u"</literal></expr></argument>, <argument><expr><name><name>netmask</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>netmask</name><index>[<expr><literal type="number">13</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>netmask</name><index>[<expr><literal type="number">14</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>netmask</name><index>[<expr><literal type="number">15</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>strNetmask</name> <operator>=</operator> <call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"%x:%x:%x:%x:%x:%x:%x:%x"</literal></expr></argument>,
                             <argument><expr><name><name>netmask</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal> <operator>|</operator> <name><name>netmask</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>netmask</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal> <operator>|</operator> <name><name>netmask</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,
                             <argument><expr><name><name>netmask</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal> <operator>|</operator> <name><name>netmask</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>netmask</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal> <operator>|</operator> <name><name>netmask</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>,
                             <argument><expr><name><name>netmask</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal> <operator>|</operator> <name><name>netmask</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>netmask</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal> <operator>|</operator> <name><name>netmask</name><index>[<expr><literal type="number">11</literal></expr>]</index></name></expr></argument>,
                             <argument><expr><name><name>netmask</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal> <operator>|</operator> <name><name>netmask</name><index>[<expr><literal type="number">13</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>netmask</name><index>[<expr><literal type="number">14</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal> <operator>|</operator> <name><name>netmask</name><index>[<expr><literal type="number">15</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><call><name><name>network</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="string">"/"</literal> <operator>+</operator> <name>strNetmask</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CSubNet</name><operator>::</operator><name>IsValid</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <return>return <expr><name>valid</name></expr>;</return>
</block_content>}</block></function>

<function type="operator"><type><name>bool</name></type> <name>operator<name>==</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CSubNet</name><modifier>&amp;</modifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CSubNet</name><modifier>&amp;</modifier></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>a</name><operator>.</operator><name>valid</name></name> <operator>==</operator> <name><name>b</name><operator>.</operator><name>valid</name></name> <operator>&amp;&amp;</operator> <name><name>a</name><operator>.</operator><name>network</name></name> <operator>==</operator> <name><name>b</name><operator>.</operator><name>network</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>a</name><operator>.</operator><name>netmask</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>.</operator><name>netmask</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function type="operator"><type><name>bool</name></type> <name>operator<name>&lt;</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CSubNet</name><modifier>&amp;</modifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CSubNet</name><modifier>&amp;</modifier></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><name><name>a</name><operator>.</operator><name>network</name></name> <operator>&lt;</operator> <name><name>b</name><operator>.</operator><name>network</name></name> <operator>||</operator> <operator>(</operator><name><name>a</name><operator>.</operator><name>network</name></name> <operator>==</operator> <name><name>b</name><operator>.</operator><name>network</name></name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>a</name><operator>.</operator><name>netmask</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>.</operator><name>netmask</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>
</unit>
