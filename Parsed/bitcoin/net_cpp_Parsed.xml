<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C++" filename="/home/mmm/Projects/bitcoin/src/net.cpp"><comment type="line">// Copyright (c) 2009-2010 Satoshi Nakamoto</comment>
<comment type="line">// Copyright (c) 2009-2019 The Bitcoin Core developers</comment>
<comment type="line">// Distributed under the MIT software license, see the accompanying</comment>
<comment type="line">// file COPYING or http://www.opensource.org/licenses/mit-license.php.</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CONFIG_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;config/bitcoin-config.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;net.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;banman.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;chainparams.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;clientversion.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;consensus/consensus.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;crypto/sha256.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netbase.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;net_permissions.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;random.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;scheduler.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ui_interface.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/strencodings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/translation.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_POLL</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;poll.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_UPNP</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miniupnpc/miniupnpc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miniupnpc/upnpcommands.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miniupnpc/upnperrors.h&gt;</cpp:file></cpp:include>
<comment type="line">// The minimum supported miniUPnPc API version is set to 10. This keeps compatibility</comment>
<comment type="line">// with Ubuntu 16.04 LTS and Debian 8 libminiupnpc-dev packages.</comment>
<assert type="static">static_assert<argument_list>(<argument><expr><name>MINIUPNPC_API_VERSION</name> <operator>&gt;=</operator> <literal type="number">10</literal></expr></argument>, <argument><expr><literal type="string">"miniUPnPc API version &gt;= 10 assumed"</literal></expr></argument>)</argument_list>;</assert>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unordered_map&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<comment type="line">// Dump addresses to peers.dat every 15 minutes (900s)</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>constexpr</specifier> <name>int</name></type> <name>DUMP_PEERS_INTERVAL</name> <init>= <expr><literal type="number">15</literal> <operator>*</operator> <literal type="number">60</literal></expr></init></decl>;</decl_stmt>

<comment type="block" format="doxygen">/** Number of DNS seeds to query when the number of connections is low. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>constexpr</specifier> <name>int</name></type> <name>DNSSEEDS_TO_QUERY_AT_ONCE</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>

<comment type="line">// We add a random period time (0 to 1 seconds) to feeler connections to prevent synchronization.</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FEELER_SLEEP_WINDOW</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<comment type="line">// MSG_NOSIGNAL is not available on some platforms, if it doesn't exist define it as 0</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MSG_NOSIGNAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSG_NOSIGNAL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">// MSG_DONTWAIT is not available on some platforms, if it doesn't exist define it as 0</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MSG_DONTWAIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSG_DONTWAIT</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/** Used to pass flags to the Bind() function */</comment>
<enum>enum <name>BindFlags</name> <block>{
    <decl><name>BF_NONE</name>         <init>= <expr><literal type="number">0</literal></expr></init></decl>,
    <decl><name>BF_EXPLICIT</name>     <init>= <expr><operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>,
    <decl><name>BF_REPORT_ERROR</name> <init>= <expr><operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>,
}</block>;</enum>

<comment type="line">// The set of sockets cannot be modified while waiting</comment>
<comment type="line">// The sleep time needs to be small to avoid new sockets stalling</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint64_t</name></type> <name>SELECT_TIMEOUT_MILLISECONDS</name> <init>= <expr><literal type="number">50</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name></type> <name>NET_MESSAGE_COMMAND_OTHER</name> <init>= <expr><literal type="string">"*other*"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint64_t</name></type> <name>RANDOMIZER_ID_NETGROUP</name> <init>= <expr><literal type="number">0x6c0edd8036ef4036ULL</literal></expr></init></decl>;</decl_stmt> <comment type="line">// SHA256("netgroup")[0:8]</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint64_t</name></type> <name>RANDOMIZER_ID_LOCALHOSTNONCE</name> <init>= <expr><literal type="number">0xd93e69e2bbfa5735ULL</literal></expr></init></decl>;</decl_stmt> <comment type="line">// SHA256("localhostnonce")[0:8]</comment>
<comment type="line">//</comment>
<comment type="line">// Global state variables</comment>
<comment type="line">//</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>fDiscover</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>fListen</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>g_relay_txes</name> <init>= <expr><operator>!</operator><name>DEFAULT_BLOCKSONLY</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CCriticalSection</name></type> <name>cs_mapLocalHost</name></decl>;</decl_stmt>
<function_decl><type><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>CNetAddr</name></expr></argument>, <argument><expr><name>LocalServiceInfo</name></expr></argument>&gt;</argument_list></name> <name>mapLocalHost</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_mapLocalHost</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name> <name><name>vfLimited</name><index>[<expr><name>NET_MAX</name></expr>]</index></name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_mapLocalHost</name></type></decl></parameter>)</parameter_list> <init>= <expr><block>{}</block></expr></init>;</function_decl>
<decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>strSubVersion</name></decl>;</decl_stmt>

<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>AddOneShot</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>strDest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vOneShots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>vOneShots</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>strDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>short</name></type> <name>GetListenPort</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator><operator>(</operator><call><name><name>gArgs</name><operator>.</operator><name>GetArg</name></name><argument_list>(<argument><expr><literal type="string">"-port"</literal></expr></argument>, <argument><expr><call><name>Params</name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetDefaultPort</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="line">// find 'best' local address for a particular peer</comment>
<function><type><name>bool</name></type> <name>GetLocal</name><parameter_list>(<parameter><decl><type><name>CService</name><modifier>&amp;</modifier></type> <name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CNetAddr</name> <modifier>*</modifier></type><name>paddrPeer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fListen</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>nBestScore</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nBestReachability</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_mapLocalHost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>entry</name> <range>: <expr><name>mapLocalHost</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>nScore</name> <init>= <expr><name><name>entry</name><operator>.</operator><name>second</name><operator>.</operator><name>nScore</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>nReachability</name> <init>= <expr><call><name><name>entry</name><operator>.</operator><name>first</name><operator>.</operator><name>GetReachabilityFrom</name></name><argument_list>(<argument><expr><name>paddrPeer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>nReachability</name> <operator>&gt;</operator> <name>nBestReachability</name> <operator>||</operator> <operator>(</operator><name>nReachability</name> <operator>==</operator> <name>nBestReachability</name> <operator>&amp;&amp;</operator> <name>nScore</name> <operator>&gt;</operator> <name>nBestScore</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>CService</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>first</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>second</name><operator>.</operator><name>nPort</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>nBestReachability</name> <operator>=</operator> <name>nReachability</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>nBestScore</name> <operator>=</operator> <name>nScore</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
    <return>return <expr><name>nBestScore</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="line" format="doxygen">//! Convert the pnSeed6 array into usable address objects.</comment>
<function><type><specifier>static</specifier> <name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CAddress</name></expr></argument>&gt;</argument_list></name></type> <name>convertSeed6</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>SeedSpec6</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>vSeedsIn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">// It'll only connect to one or two seed nodes because once it connects,</comment>
    <comment type="line">// it'll get a pile of addresses with newer timestamps.</comment>
    <comment type="line">// Seed nodes are given a random 'last seen time' of between one and two</comment>
    <comment type="line">// weeks ago.</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>nOneWeek</name> <init>= <expr><literal type="number">7</literal><operator>*</operator><literal type="number">24</literal><operator>*</operator><literal type="number">60</literal><operator>*</operator><literal type="number">60</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CAddress</name></expr></argument>&gt;</argument_list></name></type> <name>vSeedsOut</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>vSeedsOut</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>vSeedsIn</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>FastRandomContext</name></type> <name>rng</name></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>seed_in</name> <range>: <expr><name>vSeedsIn</name></expr></range></decl></init>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>in6_addr</name></name></type> <name>ip</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ip</name></expr></argument>, <argument><expr><name><name>seed_in</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>CAddress</name></type> <name>addr</name><argument_list>(<argument><expr><call><name>CService</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name><name>seed_in</name><operator>.</operator><name>port</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetDesirableServiceFlags</name><argument_list>(<argument><expr><name>NODE_NONE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>addr</name><operator>.</operator><name>nTime</name></name> <operator>=</operator> <call><name>GetTime</name><argument_list>()</argument_list></call> <operator>-</operator> <call><name><name>rng</name><operator>.</operator><name>randrange</name></name><argument_list>(<argument><expr><name>nOneWeek</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>nOneWeek</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>vSeedsOut</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>vSeedsOut</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// get best local address for a particular peer as a CAddress</comment>
<comment type="line">// Otherwise, return the unroutable 0.0.0.0 but filled in with</comment>
<comment type="line">// the normal parameters, since the IP may be changed to a useful</comment>
<comment type="line">// one by discovery.</comment>
<function><type><name>CAddress</name></type> <name>GetLocalAddress</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CNetAddr</name> <modifier>*</modifier></type><name>paddrPeer</name></decl></parameter>, <parameter><decl><type><name>ServiceFlags</name></type> <name>nLocalServices</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CAddress</name></type> <name>ret</name><argument_list>(<argument><expr><call><name>CService</name><argument_list>(<argument><expr><call><name>CNetAddr</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><call><name>GetListenPort</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nLocalServices</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CService</name></type> <name>addr</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>GetLocal</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>paddrPeer</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>CAddress</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>nLocalServices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>ret</name><operator>.</operator><name>nTime</name></name> <operator>=</operator> <call><name>GetAdjustedTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>GetnScore</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CService</name><modifier>&amp;</modifier></type> <name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_mapLocalHost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>mapLocalHost</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name><name>mapLocalHost</name><index>[<expr><name>addr</name></expr>]</index></name><operator>.</operator><name>nScore</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Is our peer's addrLocal potentially useful as an external IP source?</comment>
<function><type><name>bool</name></type> <name>IsPeerAddrLocalGood</name><parameter_list>(<parameter><decl><type><name>CNode</name> <modifier>*</modifier></type><name>pnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CService</name></type> <name>addrLocal</name> <init>= <expr><call><name><name>pnode</name><operator>-&gt;</operator><name>GetAddrLocal</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>fDiscover</name> <operator>&amp;&amp;</operator> <call><name><name>pnode</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>IsRoutable</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>addrLocal</name><operator>.</operator><name>IsRoutable</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
           <call><name>IsReachable</name><argument_list>(<argument><expr><call><name><name>addrLocal</name><operator>.</operator><name>GetNetwork</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// pushes our own address to a peer</comment>
<function><type><name>void</name></type> <name>AdvertiseLocal</name><parameter_list>(<parameter><decl><type><name>CNode</name> <modifier>*</modifier></type><name>pnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>fListen</name> <operator>&amp;&amp;</operator> <name><name>pnode</name><operator>-&gt;</operator><name>fSuccessfullyConnected</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CAddress</name></type> <name>addrLocal</name> <init>= <expr><call><name>GetLocalAddress</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pnode</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>GetLocalServices</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>gArgs</name><operator>.</operator><name>GetBoolArg</name></name><argument_list>(<argument><expr><literal type="string">"-addrmantest"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="line">// use IPv4 loopback during addrmantest</comment>
            <expr_stmt><expr><name>addrLocal</name> <operator>=</operator> <call><name>CAddress</name><argument_list>(<argument><expr><call><name>CService</name><argument_list>(<argument><expr><call><name>LookupNumeric</name><argument_list>(<argument><expr><literal type="string">"127.0.0.1"</literal></expr></argument>, <argument><expr><call><name>GetListenPort</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>GetLocalServices</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="line">// If discovery is enabled, sometimes give our peer the address it</comment>
        <comment type="line">// tells us that it sees us as in case it has a better idea of our</comment>
        <comment type="line">// address than we do.</comment>
        <decl_stmt><decl><type><name>FastRandomContext</name></type> <name>rng</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>IsPeerAddrLocalGood</name><argument_list>(<argument><expr><name>pnode</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name><name>addrLocal</name><operator>.</operator><name>IsRoutable</name></name><argument_list>()</argument_list></call> <operator>||</operator>
             <call><name><name>rng</name><operator>.</operator><name>randbits</name></name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><call><name>GetnScore</name><argument_list>(<argument><expr><name>addrLocal</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>LOCAL_MANUAL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>addrLocal</name><operator>.</operator><name>SetIP</name></name><argument_list>(<argument><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>GetAddrLocal</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>addrLocal</name><operator>.</operator><name>IsRoutable</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>gArgs</name><operator>.</operator><name>GetBoolArg</name></name><argument_list>(<argument><expr><literal type="string">"-addrmantest"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"AdvertiseLocal: advertising address %s\n"</literal></expr></argument>, <argument><expr><call><name><name>addrLocal</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>PushAddress</name></name><argument_list>(<argument><expr><name>addrLocal</name></expr></argument>, <argument><expr><name>rng</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="line">// learn a new local address</comment>
<function><type><name>bool</name></type> <name>AddLocal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CService</name><modifier>&amp;</modifier></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nScore</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>addr</name><operator>.</operator><name>IsRoutable</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fDiscover</name> <operator>&amp;&amp;</operator> <name>nScore</name> <operator>&lt;</operator> <name>LOCAL_MANUAL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsReachable</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"AddLocal(%s,%i)\n"</literal></expr></argument>, <argument><expr><call><name><name>addr</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nScore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_mapLocalHost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>fAlready</name> <init>= <expr><call><name><name>mapLocalHost</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LocalServiceInfo</name> <modifier>&amp;</modifier></type><name>info</name> <init>= <expr><name><name>mapLocalHost</name><index>[<expr><name>addr</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fAlready</name> <operator>||</operator> <name>nScore</name> <operator>&gt;=</operator> <name><name>info</name><operator>.</operator><name>nScore</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>info</name><operator>.</operator><name>nScore</name></name> <operator>=</operator> <name>nScore</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>fAlready</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>info</name><operator>.</operator><name>nPort</name></name> <operator>=</operator> <call><name><name>addr</name><operator>.</operator><name>GetPort</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>AddLocal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CNetAddr</name> <modifier>&amp;</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nScore</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>AddLocal</name><argument_list>(<argument><expr><call><name>CService</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><call><name>GetListenPort</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nScore</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>RemoveLocal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CService</name><modifier>&amp;</modifier></type> <name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_mapLocalHost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"RemoveLocal(%s)\n"</literal></expr></argument>, <argument><expr><call><name><name>addr</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mapLocalHost</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>SetReachable</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>Network</name></name></type> <name>net</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>reachable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>net</name> <operator>==</operator> <name>NET_UNROUTABLE</name> <operator>||</operator> <name>net</name> <operator>==</operator> <name>NET_INTERNAL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_mapLocalHost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vfLimited</name><index>[<expr><name>net</name></expr>]</index></name> <operator>=</operator> <operator>!</operator><name>reachable</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>IsReachable</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>Network</name></name></type> <name>net</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_mapLocalHost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>!</operator><name><name>vfLimited</name><index>[<expr><name>net</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>IsReachable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CNetAddr</name> <modifier>&amp;</modifier></type><name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>IsReachable</name><argument_list>(<argument><expr><call><name><name>addr</name><operator>.</operator><name>GetNetwork</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** vote for a local address */</comment>
<function><type><name>bool</name></type> <name>SeenLocal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CService</name><modifier>&amp;</modifier></type> <name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_mapLocalHost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>mapLocalHost</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>mapLocalHost</name><index>[<expr><name>addr</name></expr>]</index></name><operator>.</operator><name>nScore</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/** check whether a given address is potentially local */</comment>
<function><type><name>bool</name></type> <name>IsLocal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CService</name><modifier>&amp;</modifier></type> <name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_mapLocalHost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name><name>mapLocalHost</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>CNode</name><modifier>*</modifier></type> <name><name>CConnman</name><operator>::</operator><name>FindNode</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CNetAddr</name><modifier>&amp;</modifier></type> <name>ip</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <range>: <expr><name>vNodes</name></expr></range></decl></init>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>CNetAddr</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></cast> <operator>==</operator> <name>ip</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>pnode</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><literal type="null">nullptr</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>CNode</name><modifier>*</modifier></type> <name><name>CConnman</name><operator>::</operator><name>FindNode</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CSubNet</name><modifier>&amp;</modifier></type> <name>subNet</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <range>: <expr><name>vNodes</name></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>subNet</name><operator>.</operator><name>Match</name></name><argument_list>(<argument><expr><cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>CNetAddr</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></cast></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>pnode</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><literal type="null">nullptr</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>CNode</name><modifier>*</modifier></type> <name><name>CConnman</name><operator>::</operator><name>FindNode</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>addrName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <range>: <expr><name>vNodes</name></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>pnode</name><operator>-&gt;</operator><name>GetAddrName</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>addrName</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>pnode</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><literal type="null">nullptr</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>CNode</name><modifier>*</modifier></type> <name><name>CConnman</name><operator>::</operator><name>FindNode</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CService</name><modifier>&amp;</modifier></type> <name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <range>: <expr><name>vNodes</name></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>CService</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></cast> <operator>==</operator> <name>addr</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>pnode</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><literal type="null">nullptr</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CConnman</name><operator>::</operator><name>CheckIncomingNonce</name></name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>nonce</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <range>: <expr><name>vNodes</name></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pnode</name><operator>-&gt;</operator><name>fSuccessfullyConnected</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pnode</name><operator>-&gt;</operator><name>fInbound</name></name> <operator>&amp;&amp;</operator> <call><name><name>pnode</name><operator>-&gt;</operator><name>GetLocalNonce</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>nonce</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** Get the bind address for a socket as CAddress */</comment>
<function><type><specifier>static</specifier> <name>CAddress</name></type> <name>GetBindAddress</name><parameter_list>(<parameter><decl><type><name>SOCKET</name></type> <name>sock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CAddress</name></type> <name>addr_bind</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_storage</name></name></type> <name>sockaddr_bind</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>socklen_t</name></type> <name>sockaddr_bind_len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>sockaddr_bind</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>sock</name> <operator>!=</operator> <name>INVALID_SOCKET</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getsockname</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>sockaddr_bind</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sockaddr_bind_len</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>addr_bind</name><operator>.</operator><name>SetSockAddr</name></name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> struct <name>sockaddr</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>sockaddr_bind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"Warning: getsockname failed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>addr_bind</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>CNode</name><modifier>*</modifier></type> <name><name>CConnman</name><operator>::</operator><name>ConnectNode</name></name><parameter_list>(<parameter><decl><type><name>CAddress</name></type> <name>addrConnect</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pszDest</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fCountFailure</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>manual_connection</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>block_relay_only</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>pszDest</name> <operator>==</operator> <literal type="null">nullptr</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>IsLocal</name><argument_list>(<argument><expr><name>addrConnect</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="null">nullptr</literal></expr>;</return></block_content></block></if></if_stmt>

        <comment type="line">// Look for an existing connection</comment>
        <decl_stmt><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <init>= <expr><call><name>FindNode</name><argument_list>(<argument><expr><cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>CService</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name>addrConnect</name></expr></argument>)</argument_list></cast></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>pnode</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"Failed to open new connection, already connected\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="null">nullptr</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line" format="doxygen">/// debug print</comment>
    <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"trying connection %s lastseen=%.1fhrs\n"</literal></expr></argument>,
        <argument><expr><ternary><condition><expr><name>pszDest</name></expr> ?</condition><then> <expr><name>pszDest</name></expr> </then><else>: <expr><call><name><name>addrConnect</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr></argument>,
        <argument><expr><ternary><condition><expr><name>pszDest</name></expr> ?</condition><then> <expr><literal type="number">0.0</literal></expr> </then><else>: <expr><operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><call><name>GetAdjustedTime</name><argument_list>()</argument_list></call> <operator>-</operator> <name><name>addrConnect</name><operator>.</operator><name>nTime</name></name><operator>)</operator><operator>/</operator><literal type="number">3600.0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Resolve</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>default_port</name> <init>= <expr><call><name>Params</name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetDefaultPort</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>pszDest</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CService</name></expr></argument>&gt;</argument_list></name></type> <name>resolved</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>Lookup</name><argument_list>(<argument><expr><name>pszDest</name></expr></argument>, <argument><expr><name>resolved</name></expr></argument>,  <argument><expr><name>default_port</name></expr></argument>, <argument><expr><name>fNameLookup</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>HaveNameProxy</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">256</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>resolved</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>addrConnect</name> <operator>=</operator> <call><name>CAddress</name><argument_list>(<argument><expr><name><name>resolved</name><index>[<expr><call><name>GetRand</name><argument_list>(<argument><expr><call><name><name>resolved</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><name>NODE_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>addrConnect</name><operator>.</operator><name>IsValid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"Resolver returned invalid address %s for %s\n"</literal></expr></argument>, <argument><expr><call><name><name>addrConnect</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pszDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><literal type="null">nullptr</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <comment type="line">// It is possible that we already have a connection to the IP/port pszDest resolved to.</comment>
            <comment type="line">// In that case, drop the connection that was just created, and return the existing CNode instead.</comment>
            <comment type="line">// Also store the name we used to connect in that CNode, so that future FindNode() calls to that</comment>
            <comment type="line">// name catch this early.</comment>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <init>= <expr><call><name>FindNode</name><argument_list>(<argument><expr><cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>CService</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name>addrConnect</name></expr></argument>)</argument_list></cast></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>pnode</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>MaybeSetAddrName</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><name>pszDest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"Failed to open new connection, already connected\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><literal type="null">nullptr</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Connect</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>connected</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SOCKET</name></type> <name>hSocket</name> <init>= <expr><name>INVALID_SOCKET</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>proxyType</name></type> <name>proxy</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>addrConnect</name><operator>.</operator><name>IsValid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type> <name>proxyConnectionFailed</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>GetProxy</name><argument_list>(<argument><expr><call><name><name>addrConnect</name><operator>.</operator><name>GetNetwork</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>proxy</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>hSocket</name> <operator>=</operator> <call><name>CreateSocket</name><argument_list>(<argument><expr><name><name>proxy</name><operator>.</operator><name>proxy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>hSocket</name> <operator>==</operator> <name>INVALID_SOCKET</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><literal type="null">nullptr</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>connected</name> <operator>=</operator> <call><name>ConnectThroughProxy</name><argument_list>(<argument><expr><name>proxy</name></expr></argument>, <argument><expr><call><name><name>addrConnect</name><operator>.</operator><name>ToStringIP</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>addrConnect</name><operator>.</operator><name>GetPort</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>hSocket</name></expr></argument>, <argument><expr><name>nConnectTimeout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>proxyConnectionFailed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="line">// no proxy needed (none set for target network)</comment>
            <expr_stmt><expr><name>hSocket</name> <operator>=</operator> <call><name>CreateSocket</name><argument_list>(<argument><expr><name>addrConnect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>hSocket</name> <operator>==</operator> <name>INVALID_SOCKET</name></expr>)</condition> <block>{<block_content>
                <return>return <expr><literal type="null">nullptr</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>connected</name> <operator>=</operator> <call><name>ConnectSocketDirectly</name><argument_list>(<argument><expr><name>addrConnect</name></expr></argument>, <argument><expr><name>hSocket</name></expr></argument>, <argument><expr><name>nConnectTimeout</name></expr></argument>, <argument><expr><name>manual_connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>proxyConnectionFailed</name></expr>)</condition> <block>{<block_content>
            <comment type="line">// If a connection to the node was attempted, and failure (if any) is not caused by a problem connecting to</comment>
            <comment type="line">// the proxy, mark this as an attempt.</comment>
            <expr_stmt><expr><call><name><name>addrman</name><operator>.</operator><name>Attempt</name></name><argument_list>(<argument><expr><name>addrConnect</name></expr></argument>, <argument><expr><name>fCountFailure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>pszDest</name> <operator>&amp;&amp;</operator> <call><name>GetNameProxy</name><argument_list>(<argument><expr><name>proxy</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>hSocket</name> <operator>=</operator> <call><name>CreateSocket</name><argument_list>(<argument><expr><name><name>proxy</name><operator>.</operator><name>proxy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>hSocket</name> <operator>==</operator> <name>INVALID_SOCKET</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="null">nullptr</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>host</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>port</name> <init>= <expr><name>default_port</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>SplitHostPort</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><name>pszDest</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>connected</name> <operator>=</operator> <call><name>ConnectThroughProxy</name><argument_list>(<argument><expr><name>proxy</name></expr></argument>, <argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>hSocket</name></expr></argument>, <argument><expr><name>nConnectTimeout</name></expr></argument>, <argument><expr><literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>connected</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>CloseSocket</name><argument_list>(<argument><expr><name>hSocket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="null">nullptr</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Add node</comment>
    <decl_stmt><decl><type><name>NodeId</name></type> <name>id</name> <init>= <expr><call><name>GetNewNodeId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>nonce</name> <init>= <expr><call><name>GetDeterministicRandomizer</name><argument_list>(<argument><expr><name>RANDOMIZER_ID_LOCALHOSTNONCE</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>Write</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>Finalize</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CAddress</name></type> <name>addr_bind</name> <init>= <expr><call><name>GetBindAddress</name><argument_list>(<argument><expr><name>hSocket</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <init>= <expr><operator>new</operator> <call><name>CNode</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>nLocalServices</name></expr></argument>, <argument><expr><call><name>GetBestHeight</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>hSocket</name></expr></argument>, <argument><expr><name>addrConnect</name></expr></argument>, <argument><expr><call><name>CalculateKeyedNetGroup</name><argument_list>(<argument><expr><name>addrConnect</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nonce</name></expr></argument>, <argument><expr><name>addr_bind</name></expr></argument>, <argument><expr><ternary><condition><expr><name>pszDest</name></expr> ?</condition><then> <expr><name>pszDest</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name>block_relay_only</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>AddRef</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// We're making a new connection, harvest entropy from the time (and our peer count)</comment>
    <expr_stmt><expr><call><name>RandAddEvent</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>pnode</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CNode</name><operator>::</operator><name>CloseSocketDisconnect</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>fDisconnect</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_hSocket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>hSocket</name> <operator>!=</operator> <name>INVALID_SOCKET</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"disconnecting peer=%d\n"</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CloseSocket</name><argument_list>(<argument><expr><name>hSocket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>AddWhitelistPermissionFlags</name></name><parameter_list>(<parameter><decl><type><name>NetPermissionFlags</name><modifier>&amp;</modifier></type> <name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CNetAddr</name> <modifier>&amp;</modifier></type><name>addr</name></decl></parameter>)</parameter_list> <specifier>const</specifier> <block>{<block_content>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>subnet</name> <range>: <expr><name>vWhitelistedRange</name></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>subnet</name><operator>.</operator><name>m_subnet</name><operator>.</operator><name>Match</name></name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>NetPermissions</name><operator>::</operator><name>AddFlag</name></name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name><name>subnet</name><operator>.</operator><name>m_flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name><name>CNode</name><operator>::</operator><name>GetAddrName</name></name><parameter_list>()</parameter_list> <specifier>const</specifier> <block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_addrName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>addrName</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CNode</name><operator>::</operator><name>MaybeSetAddrName</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>addrNameIn</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_addrName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>addrName</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>addrName</name> <operator>=</operator> <name>addrNameIn</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>CService</name></type> <name><name>CNode</name><operator>::</operator><name>GetAddrLocal</name></name><parameter_list>()</parameter_list> <specifier>const</specifier> <block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_addrLocal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>addrLocal</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CNode</name><operator>::</operator><name>SetAddrLocal</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CService</name><modifier>&amp;</modifier></type> <name>addrLocalIn</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_addrLocal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>addrLocal</name><operator>.</operator><name>IsValid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"Addr local already set for node: %i. Refusing to change from %s to %s"</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><call><name><name>addrLocal</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>addrLocalIn</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>addrLocal</name> <operator>=</operator> <name>addrLocalIn</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>X</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>X</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>stats.name = name</cpp:value></cpp:define>
<function><type><name>void</name></type> <name><name>CNode</name><operator>::</operator><name>copyStats</name></name><parameter_list>(<parameter><decl><type><name>CNodeStats</name> <modifier>&amp;</modifier></type><name>stats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>stats</name><operator>.</operator><name>nodeid</name></name> <operator>=</operator> <call><name><name>this</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>X</name><argument_list>(<argument><expr><name>nServices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>X</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>X</name><argument_list>(<argument><expr><name>addrBind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>m_tx_relay</name> <operator>!=</operator> <literal type="null">nullptr</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>m_tx_relay</name><operator>-&gt;</operator><name>cs_filter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stats</name><operator>.</operator><name>fRelayTxes</name></name> <operator>=</operator> <name><name>m_tx_relay</name><operator>-&gt;</operator><name>fRelayTxes</name></name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>stats</name><operator>.</operator><name>fRelayTxes</name></name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>X</name><argument_list>(<argument><expr><name>nLastSend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>X</name><argument_list>(<argument><expr><name>nLastRecv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>X</name><argument_list>(<argument><expr><name>nTimeConnected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>X</name><argument_list>(<argument><expr><name>nTimeOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stats</name><operator>.</operator><name>addrName</name></name> <operator>=</operator> <call><name>GetAddrName</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>X</name><argument_list>(<argument><expr><name>nVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_SubVer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>X</name><argument_list>(<argument><expr><name>cleanSubVer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>X</name><argument_list>(<argument><expr><name>fInbound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>X</name><argument_list>(<argument><expr><name>m_manual_connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>X</name><argument_list>(<argument><expr><name>nStartingHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vSend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>X</name><argument_list>(<argument><expr><name>mapSendBytesPerMsgCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>X</name><argument_list>(<argument><expr><name>nSendBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vRecv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>X</name><argument_list>(<argument><expr><name>mapRecvBytesPerMsgCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>X</name><argument_list>(<argument><expr><name>nRecvBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>X</name><argument_list>(<argument><expr><name>m_legacyWhitelisted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>X</name><argument_list>(<argument><expr><name>m_permissionFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>m_tx_relay</name> <operator>!=</operator> <literal type="null">nullptr</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>m_tx_relay</name><operator>-&gt;</operator><name>cs_feeFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stats</name><operator>.</operator><name>minFeeFilter</name></name> <operator>=</operator> <name><name>m_tx_relay</name><operator>-&gt;</operator><name>minFeeFilter</name></name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>stats</name><operator>.</operator><name>minFeeFilter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// It is common for nodes with good ping times to suddenly become lagged,</comment>
    <comment type="line">// due to a new block arriving or other large transfer.</comment>
    <comment type="line">// Merely reporting pingtime might fool the caller into thinking the node was still responsive,</comment>
    <comment type="line">// since pingtime does not update until the ping is complete, which might take a while.</comment>
    <comment type="line">// So, if a ping is taking an unusually long time in flight,</comment>
    <comment type="line">// the caller can immediately detect that this is happening.</comment>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>nPingUsecWait</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0</literal> <operator>!=</operator> <name>nPingNonceSent</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><literal type="number">0</literal> <operator>!=</operator> <name>nPingUsecStart</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>nPingUsecWait</name> <operator>=</operator> <call><name>GetTimeMicros</name><argument_list>()</argument_list></call> <operator>-</operator> <name>nPingUsecStart</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Raw ping time is in microseconds, but show it to user as whole seconds (Bitcoin users should be well used to small numbers with many decimal places by now :)</comment>
    <expr_stmt><expr><name><name>stats</name><operator>.</operator><name>dPingTime</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name>nPingUsecTime</name><operator>)</operator> <operator>/</operator> <literal type="number">1e6</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stats</name><operator>.</operator><name>dMinPing</name></name>  <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name>nMinPingUsecTime</name><operator>)</operator> <operator>/</operator> <literal type="number">1e6</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stats</name><operator>.</operator><name>dPingWait</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name>nPingUsecWait</name><operator>)</operator> <operator>/</operator> <literal type="number">1e6</literal><operator>)</operator></expr>;</expr_stmt>

    <comment type="line">// Leave string empty if addrLocal invalid (not filled in yet)</comment>
    <decl_stmt><decl><type><name>CService</name></type> <name>addrLocalUnlocked</name> <init>= <expr><call><name>GetAddrLocal</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>stats</name><operator>.</operator><name>addrLocal</name></name> <operator>=</operator> <ternary><condition><expr><call><name><name>addrLocalUnlocked</name><operator>.</operator><name>IsValid</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name><name>addrLocalUnlocked</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>X</name></cpp:undef>

<function><type><name>bool</name></type> <name><name>CNode</name><operator>::</operator><name>ReceiveMsgBytes</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pch</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nBytes</name></decl></parameter>, <parameter><decl><type><name>bool</name><modifier>&amp;</modifier></type> <name>complete</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>complete</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>nTimeMicros</name> <init>= <expr><call><name>GetTimeMicros</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vRecv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nLastRecv</name> <operator>=</operator> <name>nTimeMicros</name> <operator>/</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>nRecvBytes</name> <operator>+=</operator> <name>nBytes</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>nBytes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// absorb network data</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>handled</name> <init>= <expr><call><name><name>m_deserializer</name><operator>-&gt;</operator><name>Read</name></name><argument_list>(<argument><expr><name>pch</name></expr></argument>, <argument><expr><name>nBytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>handled</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>pch</name> <operator>+=</operator> <name>handled</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nBytes</name> <operator>-=</operator> <name>handled</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>m_deserializer</name><operator>-&gt;</operator><name>Complete</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="line">// decompose a transport agnostic CNetMessage from the deserializer</comment>
            <decl_stmt><decl><type><name>CNetMessage</name></type> <name>msg</name> <init>= <expr><call><name><name>m_deserializer</name><operator>-&gt;</operator><name>GetMessage</name></name><argument_list>(<argument><expr><call><name>Params</name><argument_list>()</argument_list></call><operator>.</operator><call><name>MessageStart</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nTimeMicros</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">//store received bytes per message command</comment>
            <comment type="line">//to prevent a memory DOS, only allow valid commands</comment>
            <decl_stmt><decl><type><name><name>mapMsgCmdSize</name><operator>::</operator><name>iterator</name></name></type> <name>i</name> <init>= <expr><call><name><name>mapRecvBytesPerMsgCmd</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name><name>msg</name><operator>.</operator><name>m_command</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <call><name><name>mapRecvBytesPerMsgCmd</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name><name>mapRecvBytesPerMsgCmd</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>NET_MESSAGE_COMMAND_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>!=</operator> <call><name><name>mapRecvBytesPerMsgCmd</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>i</name><operator>-&gt;</operator><name>second</name></name> <operator>+=</operator> <name><name>msg</name><operator>.</operator><name>m_raw_message_size</name></name></expr>;</expr_stmt>

            <comment type="line">// push the message to the process queue,</comment>
            <expr_stmt><expr><call><name><name>vRecvMsg</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>complete</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CNode</name><operator>::</operator><name>SetSendVersion</name></name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nVersionIn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">// Send version may only be changed in the version message, and</comment>
    <comment type="line">// only one version message is allowed per session. We can therefore</comment>
    <comment type="line">// treat this value as const and even atomic as long as it's only used</comment>
    <comment type="line">// once a version message has been successfully processed. Any attempt to</comment>
    <comment type="line">// set this twice is an error.</comment>
    <if_stmt><if>if <condition>(<expr><name>nSendVersion</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"Send version already set for node: %i. Refusing to change from %i to %i"</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>nSendVersion</name></expr></argument>, <argument><expr><name>nVersionIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>nSendVersion</name> <operator>=</operator> <name>nVersionIn</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name><name>CNode</name><operator>::</operator><name>GetSendVersion</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <comment type="line">// The send version should always be explicitly set to</comment>
    <comment type="line">// INIT_PROTO_VERSION rather than using this value until SetSendVersion</comment>
    <comment type="line">// has been called.</comment>
    <if_stmt><if>if <condition>(<expr><name>nSendVersion</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"Requesting unset send version for node: %i. Using %i"</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>INIT_PROTO_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>INIT_PROTO_VERSION</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>nSendVersion</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name><name>V1TransportDeserializer</name><operator>::</operator><name>readHeader</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pch</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nBytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">// copy data to temporary parsing buffer</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nRemaining</name> <init>= <expr><literal type="number">24</literal> <operator>-</operator> <name>nHdrPos</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nCopy</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>min</name></name><argument_list>(<argument><expr><name>nRemaining</name></expr></argument>, <argument><expr><name>nBytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hdrbuf</name><index>[<expr><name>nHdrPos</name></expr>]</index></name></expr></argument>, <argument><expr><name>pch</name></expr></argument>, <argument><expr><name>nCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nHdrPos</name> <operator>+=</operator> <name>nCopy</name></expr>;</expr_stmt>

    <comment type="line">// if header incomplete, exit</comment>
    <if_stmt><if>if <condition>(<expr><name>nHdrPos</name> <operator>&lt;</operator> <literal type="number">24</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>nCopy</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// deserialize to CMessageHeader</comment>
    <try>try <block>{<block_content>
        <expr_stmt><expr><name>hdrbuf</name> <operator>&gt;&gt;</operator> <name>hdr</name></expr>;</expr_stmt>
    </block_content>}</block>
    <catch>catch <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>exception</name></name><modifier>&amp;</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></catch></try>

    <comment type="line">// reject messages larger than MAX_SIZE or MAX_PROTOCOL_MESSAGE_LENGTH</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>.</operator><name>nMessageSize</name></name> <operator>&gt;</operator> <name>MAX_SIZE</name> <operator>||</operator> <name><name>hdr</name><operator>.</operator><name>nMessageSize</name></name> <operator>&gt;</operator> <name>MAX_PROTOCOL_MESSAGE_LENGTH</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// switch state to reading message data</comment>
    <expr_stmt><expr><name>in_data</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>

    <return>return <expr><name>nCopy</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name><name>V1TransportDeserializer</name><operator>::</operator><name>readData</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pch</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nBytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nRemaining</name> <init>= <expr><name><name>hdr</name><operator>.</operator><name>nMessageSize</name></name> <operator>-</operator> <name>nDataPos</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nCopy</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>min</name></name><argument_list>(<argument><expr><name>nRemaining</name></expr></argument>, <argument><expr><name>nBytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name><name>vRecv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>nDataPos</name> <operator>+</operator> <name>nCopy</name></expr>)</condition> <block>{<block_content>
        <comment type="line">// Allocate up to 256 KiB ahead, but never more than the total message size.</comment>
        <expr_stmt><expr><call><name><name>vRecv</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>min</name></name><argument_list>(<argument><expr><name><name>hdr</name><operator>.</operator><name>nMessageSize</name></name></expr></argument>, <argument><expr><name>nDataPos</name> <operator>+</operator> <name>nCopy</name> <operator>+</operator> <literal type="number">256</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name><name>hasher</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>pch</name></expr></argument>, <argument><expr><name>nCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vRecv</name><index>[<expr><name>nDataPos</name></expr>]</index></name></expr></argument>, <argument><expr><name>pch</name></expr></argument>, <argument><expr><name>nCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nDataPos</name> <operator>+=</operator> <name>nCopy</name></expr>;</expr_stmt>

    <return>return <expr><name>nCopy</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>uint256</name><modifier>&amp;</modifier></type> <name><name>V1TransportDeserializer</name><operator>::</operator><name>GetMessageHash</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>Complete</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>data_hash</name><operator>.</operator><name>IsNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name><name>hasher</name><operator>.</operator><name>Finalize</name></name><argument_list>(<argument><expr><call><name><name>data_hash</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>data_hash</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>CNetMessage</name></type> <name><name>V1TransportDeserializer</name><operator>::</operator><name>GetMessage</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>CMessageHeader</name><operator>::</operator><name>MessageStartChars</name></name><modifier>&amp;</modifier></type> <name>message_start</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>time</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="line">// decompose a single CNetMessage from the TransportDeserializer</comment>
    <decl_stmt><decl><type><name>CNetMessage</name></type> <name>msg</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>vRecv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

    <comment type="line">// store state about valid header, netmagic and checksum</comment>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_valid_header</name></name> <operator>=</operator> <call><name><name>hdr</name><operator>.</operator><name>IsValid</name></name><argument_list>(<argument><expr><name>message_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_valid_netmagic</name></name> <operator>=</operator> <operator>(</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>hdr</name><operator>.</operator><name>pchMessageStart</name></name></expr></argument>, <argument><expr><name>message_start</name></expr></argument>, <argument><expr><name><name>CMessageHeader</name><operator>::</operator><name>MESSAGE_START_SIZE</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>uint256</name></type> <name>hash</name> <init>= <expr><call><name>GetMessageHash</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// store command string, payload size</comment>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_command</name></name> <operator>=</operator> <call><name><name>hdr</name><operator>.</operator><name>GetCommand</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_message_size</name></name> <operator>=</operator> <name><name>hdr</name><operator>.</operator><name>nMessageSize</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_raw_message_size</name></name> <operator>=</operator> <name><name>hdr</name><operator>.</operator><name>nMessageSize</name></name> <operator>+</operator> <name><name>CMessageHeader</name><operator>::</operator><name>HEADER_SIZE</name></name></expr>;</expr_stmt>

    <comment type="line">// We just received a message off the wire, harvest entropy from the time (and the message checksum)</comment>
    <expr_stmt><expr><call><name>RandAddEvent</name><argument_list>(<argument><expr><call><name>ReadLE32</name><argument_list>(<argument><expr><call><name><name>hash</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_valid_checksum</name></name> <operator>=</operator> <operator>(</operator><call><name>memcmp</name><argument_list>(<argument><expr><call><name><name>hash</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>hdr</name><operator>.</operator><name>pchChecksum</name></name></expr></argument>, <argument><expr><name><name>CMessageHeader</name><operator>::</operator><name>CHECKSUM_SIZE</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>msg</name><operator>.</operator><name>m_valid_checksum</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"CHECKSUM ERROR (%s, %u bytes), expected %s was %s\n"</literal></expr></argument>,
                 <argument><expr><call><name>SanitizeString</name><argument_list>(<argument><expr><name><name>msg</name><operator>.</operator><name>m_command</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>msg</name><operator>.</operator><name>m_message_size</name></name></expr></argument>,
                 <argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><call><name><name>hash</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>hash</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call><operator>+</operator><name><name>CMessageHeader</name><operator>::</operator><name>CHECKSUM_SIZE</name></name></expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><name><name>hdr</name><operator>.</operator><name>pchChecksum</name></name></expr></argument>, <argument><expr><name><name>hdr</name><operator>.</operator><name>pchChecksum</name></name><operator>+</operator><name><name>CMessageHeader</name><operator>::</operator><name>CHECKSUM_SIZE</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// store receive time</comment>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>m_time</name></name> <operator>=</operator> <name>time</name></expr>;</expr_stmt>

    <comment type="line">// reset the network deserializer (prepare for the next message)</comment>
    <expr_stmt><expr><call><name>Reset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>msg</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>size_t</name></type> <name><name>CConnman</name><operator>::</operator><name>SocketSendData</name></name><argument_list>(<argument><expr><name>CNode</name> <operator>*</operator><name>pnode</name></expr></argument>)</argument_list> const <name>EXCLUSIVE_LOCKS_REQUIRED</name><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>cs_vSend</name></name></expr></argument>)</argument_list>
<argument_list>{
    <argument><expr><name>auto</name> <name>it</name> <operator>=</operator> <call><name><name>pnode</name><operator>-&gt;</operator><name>vSendMsg</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>;
    <argument><expr><name>size_t</name> <name>nSentSize</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>;

    while <argument><expr><operator>(</operator><name>it</name> <operator>!=</operator> <call><name><name>pnode</name><operator>-&gt;</operator><name>vSendMsg</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call><operator>)</operator> <block>{
        <expr><specifier>const</specifier> <name>auto</name> <operator>&amp;</operator><name>data</name> <operator>=</operator> <operator>*</operator><name>it</name></expr>;
        <expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>data</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name><name>pnode</name><operator>-&gt;</operator><name>nSendOffset</name></name></expr></argument>)</argument_list></call></expr>;
        <expr><name>int</name> <name>nBytes</name> <operator>=</operator> <literal type="number">0</literal></expr>;
        <expr><block>{
            <expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>cs_hSocket</name></name></expr></argument>)</argument_list></call></expr>;
            <if_stmt><if>if <condition>(<expr><name><name>pnode</name><operator>-&gt;</operator><name>hSocket</name></name> <operator>==</operator> <name>INVALID_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
            <name>nBytes</name> <operator>=</operator> <call><name>send</name><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>hSocket</name></name></expr></argument>, <argument><expr><cast type="reinterpret">reinterpret_cast<argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><call><name><name>data</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></cast> <operator>+</operator> <name><name>pnode</name><operator>-&gt;</operator><name>nSendOffset</name></name></expr></argument>, <argument><expr><call><name><name>data</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name><name>pnode</name><operator>-&gt;</operator><name>nSendOffset</name></name></expr></argument>, <argument><expr><name>MSG_NOSIGNAL</name> <operator>|</operator> <name>MSG_DONTWAIT</name></expr></argument>)</argument_list></call></block></expr>;
        }</block></expr></argument>
        <if_stmt><if>if <condition>(<expr><name>nBytes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <expr_stmt><expr><block>{
            <expr><name><name>pnode</name><operator>-&gt;</operator><name>nLastSend</name></name> <operator>=</operator> <call><name>GetSystemTimeInSeconds</name><argument_list>()</argument_list></call></expr>;
            <name><name>pnode</name><operator>-&gt;</operator><name>nSendBytes</name></name> <operator>+=</operator> <name>nBytes</name></block></expr>;</expr_stmt></if></if_stmt></argument_list></decl></decl_stmt>
            <expr_stmt><expr><name><name>pnode</name><operator>-&gt;</operator><name>nSendOffset</name></name> <operator>+=</operator> <name>nBytes</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>nSentSize</name> <operator>+=</operator> <name>nBytes</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>pnode</name><operator>-&gt;</operator><name>nSendOffset</name></name> <operator>==</operator> <call><name><name>data</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>pnode</name><operator>-&gt;</operator><name>nSendOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pnode</name><operator>-&gt;</operator><name>nSendSize</name></name> <operator>-=</operator> <call><name><name>data</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pnode</name><operator>-&gt;</operator><name>fPauseSend</name></name> <operator>=</operator> <name><name>pnode</name><operator>-&gt;</operator><name>nSendSize</name></name> <operator>&gt;</operator> <name>nSendBufferMaxSize</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>it</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <comment type="line">// could not send full message; stop sending more</comment>
                <break>break;</break>
            </block_content>}</block></else></if_stmt>
        } else <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>nBytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <comment type="line">// error</comment>
                <decl_stmt><decl><type><name>int</name></type> <name>nErr</name> <init>= <expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>nErr</name> <operator>!=</operator> <name>WSAEWOULDBLOCK</name> <operator>&amp;&amp;</operator> <name>nErr</name> <operator>!=</operator> <name>WSAEMSGSIZE</name> <operator>&amp;&amp;</operator> <name>nErr</name> <operator>!=</operator> <name>WSAEINTR</name> <operator>&amp;&amp;</operator> <name>nErr</name> <operator>!=</operator> <name>WSAEINPROGRESS</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"socket send error %s\n"</literal></expr></argument>, <argument><expr><call><name>NetworkErrorString</name><argument_list>(<argument><expr><name>nErr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>CloseSocketDisconnect</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="line">// couldn't send anything at all</comment>
            <break>break;</break>
        </block_content>}</block>
    }

    if <expr_stmt><expr><operator>(</operator><name>it</name> <operator>==</operator> <call><name><name>pnode</name><operator>-&gt;</operator><name>vSendMsg</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call><operator>)</operator> <block>{
        <expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>nSendOffset</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;
        <expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>nSendSize</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;
    }</block>
    <call><name><name>pnode</name><operator>-&gt;</operator><name>vSendMsg</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>vSendMsg</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>nSentSize</name></expr>;</return>
}

struct <macro><name>NodeEvictionCandidate</name></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name>NodeId</name></type> <name>id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>nTimeConnected</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>nMinPingUsecTime</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>nLastBlockTime</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>nLastTXTime</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>fRelevantServices</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>fRelayTxes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>fBloomFilter</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CAddress</name></type> <name>addr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>nKeyedNetGroup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>prefer_evict</name></decl>;</decl_stmt>
</block_content>}</block><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>ReverseCompareNodeMinPingTime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NodeEvictionCandidate</name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NodeEvictionCandidate</name> <modifier>&amp;</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>a</name><operator>.</operator><name>nMinPingUsecTime</name></name> <operator>&gt;</operator> <name><name>b</name><operator>.</operator><name>nMinPingUsecTime</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>ReverseCompareNodeTimeConnected</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NodeEvictionCandidate</name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NodeEvictionCandidate</name> <modifier>&amp;</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>a</name><operator>.</operator><name>nTimeConnected</name></name> <operator>&gt;</operator> <name><name>b</name><operator>.</operator><name>nTimeConnected</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>CompareNetGroupKeyed</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NodeEvictionCandidate</name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NodeEvictionCandidate</name> <modifier>&amp;</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><name><name>a</name><operator>.</operator><name>nKeyedNetGroup</name></name> <operator>&lt;</operator> <name><name>b</name><operator>.</operator><name>nKeyedNetGroup</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>CompareNodeBlockTime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NodeEvictionCandidate</name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NodeEvictionCandidate</name> <modifier>&amp;</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">// There is a fall-through here because it is common for a node to have many peers which have not yet relayed a block.</comment>
    <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>.</operator><name>nLastBlockTime</name></name> <operator>!=</operator> <name><name>b</name><operator>.</operator><name>nLastBlockTime</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name><name>a</name><operator>.</operator><name>nLastBlockTime</name></name> <operator>&lt;</operator> <name><name>b</name><operator>.</operator><name>nLastBlockTime</name></name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>.</operator><name>fRelevantServices</name></name> <operator>!=</operator> <name><name>b</name><operator>.</operator><name>fRelevantServices</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name><name>b</name><operator>.</operator><name>fRelevantServices</name></name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name><name>a</name><operator>.</operator><name>nTimeConnected</name></name> <operator>&gt;</operator> <name><name>b</name><operator>.</operator><name>nTimeConnected</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>CompareNodeTXTime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NodeEvictionCandidate</name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NodeEvictionCandidate</name> <modifier>&amp;</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">// There is a fall-through here because it is common for a node to have more than a few peers that have not yet relayed txn.</comment>
    <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>.</operator><name>nLastTXTime</name></name> <operator>!=</operator> <name><name>b</name><operator>.</operator><name>nLastTXTime</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name><name>a</name><operator>.</operator><name>nLastTXTime</name></name> <operator>&lt;</operator> <name><name>b</name><operator>.</operator><name>nLastTXTime</name></name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>.</operator><name>fRelayTxes</name></name> <operator>!=</operator> <name><name>b</name><operator>.</operator><name>fRelayTxes</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name><name>b</name><operator>.</operator><name>fRelayTxes</name></name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>.</operator><name>fBloomFilter</name></name> <operator>!=</operator> <name><name>b</name><operator>.</operator><name>fBloomFilter</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name><name>a</name><operator>.</operator><name>fBloomFilter</name></name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name><name>a</name><operator>.</operator><name>nTimeConnected</name></name> <operator>&gt;</operator> <name><name>b</name><operator>.</operator><name>nTimeConnected</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="line" format="doxygen">//! Sort an array by the specified comparator, then erase the last K elements.</comment>
<function><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>, <parameter><type><name>typename</name></type> <name>Comparator</name></parameter>&gt;</parameter_list></template>
<type><specifier>static</specifier> <name>void</name></type> <name>EraseLastKElements</name><parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>elements</name></decl></parameter>, <parameter><decl><type><name>Comparator</name></type> <name>comparator</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name><name>std</name><operator>::</operator><name>sort</name></name><argument_list>(<argument><expr><call><name><name>elements</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>elements</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>eraseSize</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>min</name></name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><call><name><name>elements</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>elements</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><call><name><name>elements</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>eraseSize</name></expr></argument>, <argument><expr><call><name><name>elements</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** Try to find a connection to evict when the node is full.
 *  Extreme care must be taken to avoid opening the node to attacker
 *   triggered network partitioning.
 *  The strategy used here is to protect a small number of peers
 *   for each of several distinct characteristics which are difficult
 *   to forge.  In order to partition a node the attacker must be
 *   simultaneously better at all of them than honest peers.
 */</comment>
<function><type><name>bool</name></type> <name><name>CConnman</name><operator>::</operator><name>AttemptToEvictConnection</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>NodeEvictionCandidate</name></expr></argument>&gt;</argument_list></name></type> <name>vEvictionCandidates</name></decl>;</decl_stmt>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CNode</name><modifier>*</modifier></type> <name>node</name> <range>: <expr><name>vNodes</name></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>node</name><operator>-&gt;</operator><name>HasPermission</name></name><argument_list>(<argument><expr><name>PF_NOBAN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>fInbound</name></name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>fDisconnect</name></name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>peer_relay_txes</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>peer_filter_not_null</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>m_tx_relay</name></name> <operator>!=</operator> <literal type="null">nullptr</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>cs_filter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>peer_relay_txes</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>fRelayTxes</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>peer_filter_not_null</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>m_tx_relay</name><operator>-&gt;</operator><name>pfilter</name></name> <operator>!=</operator> <literal type="null">nullptr</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>NodeEvictionCandidate</name></type> <name>candidate</name> <init>= <expr><block>{<expr><call><name><name>node</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr>, <expr><name><name>node</name><operator>-&gt;</operator><name>nTimeConnected</name></name></expr>, <expr><name><name>node</name><operator>-&gt;</operator><name>nMinPingUsecTime</name></name></expr>,
                                               <expr><name><name>node</name><operator>-&gt;</operator><name>nLastBlockTime</name></name></expr>, <expr><name><name>node</name><operator>-&gt;</operator><name>nLastTXTime</name></name></expr>,
                                               <expr><call><name>HasAllDesirableServiceFlags</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nServices</name></name></expr></argument>)</argument_list></call></expr>,
                                               <expr><name>peer_relay_txes</name></expr>, <expr><name>peer_filter_not_null</name></expr>, <expr><name><name>node</name><operator>-&gt;</operator><name>addr</name></name></expr>, <expr><name><name>node</name><operator>-&gt;</operator><name>nKeyedNetGroup</name></name></expr>,
                                               <expr><name><name>node</name><operator>-&gt;</operator><name>m_prefer_evict</name></name></expr>}</block></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>vEvictionCandidates</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block>

    <comment type="line">// Protect connections with certain characteristics</comment>

    <comment type="line">// Deterministically select 4 peers to protect by netgroup.</comment>
    <comment type="line">// An attacker cannot predict which netgroups will be protected</comment>
    <expr_stmt><expr><call><name>EraseLastKElements</name><argument_list>(<argument><expr><name>vEvictionCandidates</name></expr></argument>, <argument><expr><name>CompareNetGroupKeyed</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Protect the 8 nodes with the lowest minimum ping time.</comment>
    <comment type="line">// An attacker cannot manipulate this metric without physically moving nodes closer to the target.</comment>
    <expr_stmt><expr><call><name>EraseLastKElements</name><argument_list>(<argument><expr><name>vEvictionCandidates</name></expr></argument>, <argument><expr><name>ReverseCompareNodeMinPingTime</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Protect 4 nodes that most recently sent us transactions.</comment>
    <comment type="line">// An attacker cannot manipulate this metric without performing useful work.</comment>
    <expr_stmt><expr><call><name>EraseLastKElements</name><argument_list>(<argument><expr><name>vEvictionCandidates</name></expr></argument>, <argument><expr><name>CompareNodeTXTime</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Protect 4 nodes that most recently sent us blocks.</comment>
    <comment type="line">// An attacker cannot manipulate this metric without performing useful work.</comment>
    <expr_stmt><expr><call><name>EraseLastKElements</name><argument_list>(<argument><expr><name>vEvictionCandidates</name></expr></argument>, <argument><expr><name>CompareNodeBlockTime</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Protect the half of the remaining nodes which have been connected the longest.</comment>
    <comment type="line">// This replicates the non-eviction implicit behavior, and precludes attacks that start later.</comment>
    <expr_stmt><expr><call><name>EraseLastKElements</name><argument_list>(<argument><expr><name>vEvictionCandidates</name></expr></argument>, <argument><expr><name>ReverseCompareNodeTimeConnected</name></expr></argument>, <argument><expr><call><name><name>vEvictionCandidates</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name><name>vEvictionCandidates</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// If any remaining peers are preferred for eviction consider only them.</comment>
    <comment type="line">// This happens after the other preferences since if a peer is really the best by other criteria (esp relaying blocks)</comment>
    <comment type="line">//  then we probably don't want to evict it no matter what.</comment>
    <if_stmt><if>if <condition>(<expr><call><name><name>std</name><operator>::</operator><name>any_of</name></name><argument_list>(<argument><expr><call><name><name>vEvictionCandidates</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><call><name><name>vEvictionCandidates</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><lambda><capture>[]</capture><parameter_list>(<parameter><decl/></parameter></parameter_list>NodeEvictionCandidate <specifier>const</specifier> <ref_qualifier>&amp;</ref_qualifier><name>n</name></lambda></expr></argument>)</argument_list></call></expr></condition><block>{<block_content><return>return <expr><name><name>n</name><operator>.</operator><name>prefer_evict</name></name></expr>;</return></block_content>}</block></if></if_stmt>)</block_content></block></function>) <block>{<block_content>
        <expr_stmt><expr><call><name><name>vEvictionCandidates</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>remove_if</name></name><argument_list>(<argument><expr><call><name><name>vEvictionCandidates</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><call><name><name>vEvictionCandidates</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>,
                                  <argument><expr><lambda><capture>[]</capture><parameter_list>(<parameter><decl><type><name>NodeEvictionCandidate</name> <specifier>const</specifier> <modifier>&amp;</modifier></type><name>n</name></decl></parameter>)</parameter_list><block>{<block_content><return>return <expr><operator>!</operator><name><name>n</name><operator>.</operator><name>prefer_evict</name></name></expr>;</return></block_content>}</block></lambda></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name><name>vEvictionCandidates</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="line">// Identify the network group with the most connections and youngest member.</comment>
    <comment type="line">// (vEvictionCandidates is already sorted by reverse connect time)</comment>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>naMostConnections</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nMostConnections</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>nMostConnectionsTime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>uint64_t</name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>NodeEvictionCandidate</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type> <name>mapNetGroupNodes</name></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <name>NodeEvictionCandidate</name> <modifier>&amp;</modifier></type><name>node</name> <range>: <expr><name>vEvictionCandidates</name></expr></range></decl></init>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>NodeEvictionCandidate</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>group</name> <init>= <expr><name><name>mapNetGroupNodes</name><index>[<expr><name><name>node</name><operator>.</operator><name>nKeyedNetGroup</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>group</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>grouptime</name> <init>= <expr><name><name>group</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>nTimeConnected</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>group</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>nMostConnections</name> <operator>||</operator> <operator>(</operator><call><name><name>group</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>nMostConnections</name> <operator>&amp;&amp;</operator> <name>grouptime</name> <operator>&gt;</operator> <name>nMostConnectionsTime</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>nMostConnections</name> <operator>=</operator> <call><name><name>group</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>nMostConnectionsTime</name> <operator>=</operator> <name>grouptime</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>naMostConnections</name> <operator>=</operator> <name><name>node</name><operator>.</operator><name>nKeyedNetGroup</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="line">// Reduce to the network group with the most connections</comment>
    <expr_stmt><expr><name>vEvictionCandidates</name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name><name>mapNetGroupNodes</name><index>[<expr><name>naMostConnections</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Disconnect from the network group with the most connections</comment>
    <decl_stmt><decl><type><name>NodeId</name></type> <name>evicted</name> <init>= <expr><call><name><name>vEvictionCandidates</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call><operator>.</operator><name>id</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <range>: <expr><name>vNodes</name></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>pnode</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>evicted</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>pnode</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
}

void <macro><name>CConnman</name></macro><expr_stmt><expr><name><operator>::</operator><name>AcceptConnection</name></name><operator>(</operator><specifier>const</specifier> <name>ListenSocket</name><operator>&amp;</operator> <name>hListenSocket</name><operator>)</operator> <block>{
    struct <expr><name>sockaddr_storage</name> <name>sockaddr</name></expr>;
    <expr><name>socklen_t</name> <name>len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sockaddr</name></expr></argument>)</argument_list></sizeof></expr>;
    <expr><name>SOCKET</name> <name>hSocket</name> <operator>=</operator> <call><name>accept</name><argument_list>(<argument><expr><name><name>hListenSocket</name><operator>.</operator><name>socket</name></name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>sockaddr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>CAddress</name> <name>addr</name></expr>;
    <expr><name>int</name> <name>nInbound</name> <operator>=</operator> <literal type="number">0</literal></expr>;
    <expr><name>int</name> <name>nMaxInbound</name> <operator>=</operator> <name>nMaxConnections</name> <operator>-</operator> <name>m_max_outbound</name></expr>;

    <if_stmt><if>if <condition>(<expr><name>hSocket</name> <operator>!=</operator> <name>INVALID_SOCKET</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>addr</name><operator>.</operator><name>SetSockAddr</name></name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> struct <name>sockaddr</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>sockaddr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"Warning: Unknown socket family\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt/></block_content></block></if></if_stmt></block_content></block></if></if_stmt>}</block></expr></expr_stmt>
    }

    NetPermissionFlags <expr_stmt><expr><name>permissionFlags</name> <operator>=</operator> <name><name>NetPermissionFlags</name><operator>::</operator><name>PF_NONE</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>hListenSocket</name><operator>.</operator><name>AddSocketPermissionFlags</name></name><argument_list>(<argument><expr><name>permissionFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AddWhitelistPermissionFlags</name><argument_list>(<argument><expr><name>permissionFlags</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>legacyWhitelisted</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>NetPermissions</name><operator>::</operator><name>HasFlag</name></name><argument_list>(<argument><expr><name>permissionFlags</name></expr></argument>, <argument><expr><name><name>NetPermissionFlags</name><operator>::</operator><name>PF_ISIMPLICIT</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>NetPermissions</name><operator>::</operator><name>ClearFlag</name></name><argument_list>(<argument><expr><name>permissionFlags</name></expr></argument>, <argument><expr><name>PF_ISIMPLICIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>gArgs</name><operator>.</operator><name>GetBoolArg</name></name><argument_list>(<argument><expr><literal type="string">"-whitelistforcerelay"</literal></expr></argument>, <argument><expr><name>DEFAULT_WHITELISTFORCERELAY</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>NetPermissions</name><operator>::</operator><name>AddFlag</name></name><argument_list>(<argument><expr><name>permissionFlags</name></expr></argument>, <argument><expr><name>PF_FORCERELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>gArgs</name><operator>.</operator><name>GetBoolArg</name></name><argument_list>(<argument><expr><literal type="string">"-whitelistrelay"</literal></expr></argument>, <argument><expr><name>DEFAULT_WHITELISTRELAY</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>NetPermissions</name><operator>::</operator><name>AddFlag</name></name><argument_list>(<argument><expr><name>permissionFlags</name></expr></argument>, <argument><expr><name>PF_RELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name><name>NetPermissions</name><operator>::</operator><name>AddFlag</name></name><argument_list>(<argument><expr><name>permissionFlags</name></expr></argument>, <argument><expr><name>PF_MEMPOOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>NetPermissions</name><operator>::</operator><name>AddFlag</name></name><argument_list>(<argument><expr><name>permissionFlags</name></expr></argument>, <argument><expr><name>PF_NOBAN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>legacyWhitelisted</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <range>: <expr><name>vNodes</name></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>pnode</name><operator>-&gt;</operator><name>fInbound</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nInbound</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block>

    <if_stmt><if>if <condition>(<expr><name>hSocket</name> <operator>==</operator> <name>INVALID_SOCKET</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nErr</name> <init>= <expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>nErr</name> <operator>!=</operator> <name>WSAEWOULDBLOCK</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"socket error accept failed: %s\n"</literal></expr></argument>, <argument><expr><call><name>NetworkErrorString</name><argument_list>(<argument><expr><name>nErr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fNetworkActive</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"connection from %s dropped: not accepting new connections\n"</literal></expr></argument>, <argument><expr><call><name><name>addr</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CloseSocket</name><argument_list>(<argument><expr><name>hSocket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsSelectableSocket</name><argument_list>(<argument><expr><name>hSocket</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"connection from %s dropped: non-selectable socket\n"</literal></expr></argument>, <argument><expr><call><name><name>addr</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CloseSocket</name><argument_list>(<argument><expr><name>hSocket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// According to the internet TCP_NODELAY is not carried into accepted sockets</comment>
    <comment type="line">// on all platforms.  Set it again here just to be sure.</comment>
    <expr_stmt><expr><call><name>SetSocketNoDelay</name><argument_list>(<argument><expr><name>hSocket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>bannedlevel</name> <init>= <expr><ternary><condition><expr><name>m_banman</name></expr> ?</condition><then> <expr><call><name><name>m_banman</name><operator>-&gt;</operator><name>IsBannedLevel</name></name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <comment type="line">// Don't accept connections from banned peers, but if our inbound slots aren't almost full, accept</comment>
    <comment type="line">// if the only banning reason was an automatic misbehavior ban.</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>NetPermissions</name><operator>::</operator><name>HasFlag</name></name><argument_list>(<argument><expr><name>permissionFlags</name></expr></argument>, <argument><expr><name><name>NetPermissionFlags</name><operator>::</operator><name>PF_NOBAN</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>bannedlevel</name> <operator>&gt;</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>nInbound</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>nMaxInbound</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"connection from %s dropped (banned)\n"</literal></expr></argument>, <argument><expr><call><name><name>addr</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CloseSocket</name><argument_list>(<argument><expr><name>hSocket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>nInbound</name> <operator>&gt;=</operator> <name>nMaxInbound</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttemptToEvictConnection</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="line">// No connection to evict, disconnect the new connection</comment>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"failed to find an eviction candidate - connection dropped (full)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CloseSocket</name><argument_list>(<argument><expr><name>hSocket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>NodeId</name></type> <name>id</name> <init>= <expr><call><name>GetNewNodeId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>nonce</name> <init>= <expr><call><name>GetDeterministicRandomizer</name><argument_list>(<argument><expr><name>RANDOMIZER_ID_LOCALHOSTNONCE</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>Write</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>Finalize</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CAddress</name></type> <name>addr_bind</name> <init>= <expr><call><name>GetBindAddress</name><argument_list>(<argument><expr><name>hSocket</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>ServiceFlags</name></type> <name>nodeServices</name> <init>= <expr><name>nLocalServices</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>NetPermissions</name><operator>::</operator><name>HasFlag</name></name><argument_list>(<argument><expr><name>permissionFlags</name></expr></argument>, <argument><expr><name>PF_BLOOMFILTER</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>nodeServices</name> <operator>=</operator> <cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>ServiceFlags</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name>nodeServices</name> <operator>|</operator> <name>NODE_BLOOM</name></expr></argument>)</argument_list></cast></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <init>= <expr><operator>new</operator> <call><name>CNode</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>nodeServices</name></expr></argument>, <argument><expr><call><name>GetBestHeight</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>hSocket</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><call><name>CalculateKeyedNetGroup</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nonce</name></expr></argument>, <argument><expr><name>addr_bind</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>AddRef</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pnode</name><operator>-&gt;</operator><name>m_permissionFlags</name></name> <operator>=</operator> <name>permissionFlags</name></expr>;</expr_stmt>
    <comment type="line">// If this flag is present, the user probably expect that RPC and QT report it as whitelisted (backward compatibility)</comment>
    <expr_stmt><expr><name><name>pnode</name><operator>-&gt;</operator><name>m_legacyWhitelisted</name></name> <operator>=</operator> <name>legacyWhitelisted</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pnode</name><operator>-&gt;</operator><name>m_prefer_evict</name></name> <operator>=</operator> <name>bannedlevel</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>m_msgproc</name><operator>-&gt;</operator><name>InitializeNode</name></name><argument_list>(<argument><expr><name>pnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"connection from %s accepted\n"</literal></expr></argument>, <argument><expr><call><name><name>addr</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>vNodes</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>pnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="line">// We received a new connection, harvest entropy from the time (and our peer count)</comment>
    <expr_stmt><expr><call><name>RandAddEvent</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}

void <macro><name>CConnman</name></macro><expr_stmt><expr><name><operator>::</operator><name>DisconnectNodes</name></name><operator>(</operator><operator>)</operator>
<block>{
    <expr><block>{
        <expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fNetworkActive</name></expr>)</condition> <block>{<block_content>
            <comment type="line">// Disconnect any connected nodes</comment>
            <for>for <control>(<init><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <range>: <expr><name>vNodes</name></expr></range></decl></init>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pnode</name><operator>-&gt;</operator><name>fDisconnect</name></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"Network not active, dropping peer=%d\n"</literal></expr></argument>, <argument><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>pnode</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt/></block_content></block></if></if_stmt></block_content></block></for></block_content></block></if></if_stmt>}</block></expr>
            }</block></expr></expr_stmt>
        }

        <comment type="line">// Disconnect unused nodes</comment>
        std<decl_stmt><decl><type><name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CNode</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name></name></type> <name>vNodesCopy</name> <init>= <expr><name>vNodes</name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <range>: <expr><name>vNodesCopy</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>pnode</name><operator>-&gt;</operator><name>fDisconnect</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// remove from vNodes</comment>
                <expr_stmt><expr><call><name><name>vNodes</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><call><name>remove</name><argument_list>(<argument><expr><call><name><name>vNodes</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>vNodes</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pnode</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>vNodes</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// release outbound grant (if any)</comment>
                <expr_stmt><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>grantOutbound</name><operator>.</operator><name>Release</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// close socket and cleanup</comment>
                <expr_stmt><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>CloseSocketDisconnect</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// hold in disconnected pool until all refs are released</comment>
                <expr_stmt><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>Release</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>vNodesDisconnected</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>pnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    }
    {
        <comment type="line">// Delete disconnected nodes</comment>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>list</name><argument_list type="generic">&lt;<argument><expr><name>CNode</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>vNodesDisconnectedCopy</name> <init>= <expr><name>vNodesDisconnected</name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <range>: <expr><name>vNodesDisconnectedCopy</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <comment type="line">// wait until threads are done using it</comment>
            <if_stmt><if>if <condition>(<expr><call><name><name>pnode</name><operator>-&gt;</operator><name>GetRefCount</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>bool</name></type> <name>fDelete</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>TRY_LOCK</name><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>cs_inventory</name></name></expr></argument>, <argument><expr><name>lockInv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>lockInv</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>TRY_LOCK</name><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>cs_vSend</name></name></expr></argument>, <argument><expr><name>lockSend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>lockSend</name></expr>)</condition> <block>{<block_content>
                            <expr_stmt><expr><name>fDelete</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block>
                <if_stmt><if>if <condition>(<expr><name>fDelete</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>vNodesDisconnected</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>pnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>DeleteNode</name><argument_list>(<argument><expr><name>pnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    }
}

<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>NotifyNumConnectionsChanged</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>vNodesSize</name></decl>;</decl_stmt>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vNodesSize</name> <operator>=</operator> <call><name><name>vNodes</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <if_stmt><if>if<condition>(<expr><name>vNodesSize</name> <operator>!=</operator> <name>nPrevNodeCount</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>nPrevNodeCount</name> <operator>=</operator> <name>vNodesSize</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name>clientInterface</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>clientInterface</name><operator>-&gt;</operator><name>NotifyNumConnectionsChanged</name></name><argument_list>(<argument><expr><name>vNodesSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>InactivityCheck</name></name><parameter_list>(<parameter><decl><type><name>CNode</name> <modifier>*</modifier></type><name>pnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>nTime</name> <init>= <expr><call><name>GetSystemTimeInSeconds</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>nTime</name> <operator>-</operator> <name><name>pnode</name><operator>-&gt;</operator><name>nTimeConnected</name></name> <operator>&gt;</operator> <name>m_peer_connect_timeout</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>pnode</name><operator>-&gt;</operator><name>nLastRecv</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>pnode</name><operator>-&gt;</operator><name>nLastSend</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"socket no message in first %i seconds, %d %d from %d\n"</literal></expr></argument>, <argument><expr><name>m_peer_connect_timeout</name></expr></argument>, <argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>nLastRecv</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>nLastSend</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pnode</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>nTime</name> <operator>-</operator> <name><name>pnode</name><operator>-&gt;</operator><name>nLastSend</name></name> <operator>&gt;</operator> <name>TIMEOUT_INTERVAL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"socket sending timeout: %is\n"</literal></expr></argument>, <argument><expr><name>nTime</name> <operator>-</operator> <name><name>pnode</name><operator>-&gt;</operator><name>nLastSend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pnode</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>nTime</name> <operator>-</operator> <name><name>pnode</name><operator>-&gt;</operator><name>nLastRecv</name></name> <operator>&gt;</operator> <operator>(</operator><ternary><condition><expr><name><name>pnode</name><operator>-&gt;</operator><name>nVersion</name></name> <operator>&gt;</operator> <name>BIP0031_VERSION</name></expr> ?</condition><then> <expr><name>TIMEOUT_INTERVAL</name></expr> </then><else>: <expr><literal type="number">90</literal><operator>*</operator><literal type="number">60</literal></expr></else></ternary><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"socket receive timeout: %is\n"</literal></expr></argument>, <argument><expr><name>nTime</name> <operator>-</operator> <name><name>pnode</name><operator>-&gt;</operator><name>nLastRecv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pnode</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>pnode</name><operator>-&gt;</operator><name>nPingNonceSent</name></name> <operator>&amp;&amp;</operator> <name><name>pnode</name><operator>-&gt;</operator><name>nPingUsecStart</name></name> <operator>+</operator> <name>TIMEOUT_INTERVAL</name> <operator>*</operator> <literal type="number">1000000</literal> <operator>&lt;</operator> <call><name>GetTimeMicros</name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"ping timeout: %fs\n"</literal></expr></argument>, <argument><expr><literal type="number">0.000001</literal> <operator>*</operator> <operator>(</operator><call><name>GetTimeMicros</name><argument_list>()</argument_list></call> <operator>-</operator> <name><name>pnode</name><operator>-&gt;</operator><name>nPingUsecStart</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pnode</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>pnode</name><operator>-&gt;</operator><name>fSuccessfullyConnected</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"version handshake timeout from %d\n"</literal></expr></argument>, <argument><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pnode</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CConnman</name><operator>::</operator><name>GenerateSelectSet</name></name><parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>SOCKET</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>recv_set</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>SOCKET</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>send_set</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>SOCKET</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>error_set</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <name>ListenSocket</name><modifier>&amp;</modifier></type> <name>hListenSocket</name> <range>: <expr><name>vhListenSocket</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>recv_set</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name><name>hListenSocket</name><operator>.</operator><name>socket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <range>: <expr><name>vNodes</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <comment type="line">// Implement the following logic:</comment>
            <comment type="line">// * If there is data to send, select() for sending data. As this only</comment>
            <comment type="line">//   happens when optimistic write failed, we choose to first drain the</comment>
            <comment type="line">//   write buffer in this case before receiving more. This avoids</comment>
            <comment type="line">//   needlessly queueing received data, if the remote peer is not themselves</comment>
            <comment type="line">//   receiving data. This means properly utilizing TCP flow control signalling.</comment>
            <comment type="line">// * Otherwise, if there is space left in the receive buffer, select() for</comment>
            <comment type="line">//   receiving data.</comment>
            <comment type="line">// * Hand off all complete messages to the processor, to be handled without</comment>
            <comment type="line">//   blocking here.</comment>

            <decl_stmt><decl><type><name>bool</name></type> <name>select_recv</name> <init>= <expr><operator>!</operator><name><name>pnode</name><operator>-&gt;</operator><name>fPauseRecv</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>select_send</name></decl>;</decl_stmt>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>cs_vSend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>select_send</name> <operator>=</operator> <operator>!</operator><call><name><name>pnode</name><operator>-&gt;</operator><name>vSendMsg</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>

            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>cs_hSocket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>pnode</name><operator>-&gt;</operator><name>hSocket</name></name> <operator>==</operator> <name>INVALID_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name><name>error_set</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>hSocket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>select_send</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>send_set</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>hSocket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>select_recv</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>recv_set</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>hSocket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block>

    <return>return <expr><operator>!</operator><call><name><name>recv_set</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name><name>send_set</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name><name>error_set</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_POLL</name></cpp:ifdef>
<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>SocketEvents</name></name><parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>SOCKET</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>recv_set</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>SOCKET</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>send_set</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>SOCKET</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>error_set</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>SOCKET</name></expr></argument>&gt;</argument_list></name></type> <name>recv_select_set</name></decl>, <decl><type ref="prev"/><name>send_select_set</name></decl>, <decl><type ref="prev"/><name>error_select_set</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GenerateSelectSet</name><argument_list>(<argument><expr><name>recv_select_set</name></expr></argument>, <argument><expr><name>send_select_set</name></expr></argument>, <argument><expr><name>error_select_set</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>interruptNet</name><operator>.</operator><name>sleep_for</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>milliseconds</name></name><argument_list>(<argument><expr><name>SELECT_TIMEOUT_MILLISECONDS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>unordered_map</name><argument_list type="generic">&lt;<argument><expr><name>SOCKET</name></expr></argument>, <argument><expr>struct <name>pollfd</name></expr></argument>&gt;</argument_list></name></type> <name>pollfds</name></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>SOCKET</name></type> <name>socket_id</name> <range>: <expr><name>recv_select_set</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>pollfds</name><index>[<expr><name>socket_id</name></expr>]</index></name><operator>.</operator><name>fd</name> <operator>=</operator> <name>socket_id</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pollfds</name><index>[<expr><name>socket_id</name></expr>]</index></name><operator>.</operator><name>events</name> <operator>|=</operator> <name>POLLIN</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <for>for <control>(<init><decl><type><name>SOCKET</name></type> <name>socket_id</name> <range>: <expr><name>send_select_set</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>pollfds</name><index>[<expr><name>socket_id</name></expr>]</index></name><operator>.</operator><name>fd</name> <operator>=</operator> <name>socket_id</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pollfds</name><index>[<expr><name>socket_id</name></expr>]</index></name><operator>.</operator><name>events</name> <operator>|=</operator> <name>POLLOUT</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <for>for <control>(<init><decl><type><name>SOCKET</name></type> <name>socket_id</name> <range>: <expr><name>error_select_set</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>pollfds</name><index>[<expr><name>socket_id</name></expr>]</index></name><operator>.</operator><name>fd</name> <operator>=</operator> <name>socket_id</name></expr>;</expr_stmt>
        <comment type="line">// These flags are ignored, but we set them for clarity</comment>
        <expr_stmt><expr><name><name>pollfds</name><index>[<expr><name>socket_id</name></expr>]</index></name><operator>.</operator><name>events</name> <operator>|=</operator> <name>POLLERR</name><operator>|</operator><name>POLLHUP</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr>struct <name>pollfd</name></expr></argument>&gt;</argument_list></name></type> <name>vpollfds</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>vpollfds</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>pollfds</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>it</name> <range>: <expr><name>pollfds</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>vpollfds</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name><name>it</name><operator>.</operator><name>second</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><call><name>poll</name><argument_list>(<argument><expr><call><name><name>vpollfds</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>vpollfds</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SELECT_TIMEOUT_MILLISECONDS</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>interruptNet</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <for>for <control>(<init><decl><type><name><name>struct</name> <name>pollfd</name></name></type> <name>pollfd_entry</name> <range>: <expr><name>vpollfds</name></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>pollfd_entry</name><operator>.</operator><name>revents</name></name> <operator>&amp;</operator> <name>POLLIN</name></expr>)</condition><block type="pseudo"><block_content>            <expr_stmt><expr><call><name><name>recv_set</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name><name>pollfd_entry</name><operator>.</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>pollfd_entry</name><operator>.</operator><name>revents</name></name> <operator>&amp;</operator> <name>POLLOUT</name></expr>)</condition><block type="pseudo"><block_content>           <expr_stmt><expr><call><name><name>send_set</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name><name>pollfd_entry</name><operator>.</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>pollfd_entry</name><operator>.</operator><name>revents</name></name> <operator>&amp;</operator> <operator>(</operator><name>POLLERR</name><operator>|</operator><name>POLLHUP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>error_set</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name><name>pollfd_entry</name><operator>.</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>SocketEvents</name></name><parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>SOCKET</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>recv_set</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>SOCKET</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>send_set</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>SOCKET</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>error_set</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>SOCKET</name></expr></argument>&gt;</argument_list></name></type> <name>recv_select_set</name></decl>, <decl><type ref="prev"/><name>send_select_set</name></decl>, <decl><type ref="prev"/><name>error_select_set</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GenerateSelectSet</name><argument_list>(<argument><expr><name>recv_select_set</name></expr></argument>, <argument><expr><name>send_select_set</name></expr></argument>, <argument><expr><name>error_select_set</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>interruptNet</name><operator>.</operator><name>sleep_for</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>milliseconds</name></name><argument_list>(<argument><expr><name>SELECT_TIMEOUT_MILLISECONDS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//</comment>
    <comment type="line">// Find which sockets have data to receive</comment>
    <comment type="line">//</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>timeout</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_sec</name></name>  <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <name>SELECT_TIMEOUT_MILLISECONDS</name> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt> <comment type="line">// frequency to poll pnode-&gt;vSend</comment>

    <decl_stmt><decl><type><name>fd_set</name></type> <name>fdsetRecv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>fd_set</name></type> <name>fdsetSend</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>fd_set</name></type> <name>fdsetError</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fdsetRecv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fdsetSend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fdsetError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>SOCKET</name></type> <name>hSocketMax</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><decl><type><name>SOCKET</name></type> <name>hSocket</name> <range>: <expr><name>recv_select_set</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>hSocket</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fdsetRecv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>hSocketMax</name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>max</name></name><argument_list>(<argument><expr><name>hSocketMax</name></expr></argument>, <argument><expr><name>hSocket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <for>for <control>(<init><decl><type><name>SOCKET</name></type> <name>hSocket</name> <range>: <expr><name>send_select_set</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>hSocket</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fdsetSend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>hSocketMax</name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>max</name></name><argument_list>(<argument><expr><name>hSocketMax</name></expr></argument>, <argument><expr><name>hSocket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <for>for <control>(<init><decl><type><name>SOCKET</name></type> <name>hSocket</name> <range>: <expr><name>error_select_set</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>hSocket</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fdsetError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>hSocketMax</name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>max</name></name><argument_list>(<argument><expr><name>hSocketMax</name></expr></argument>, <argument><expr><name>hSocket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <decl_stmt><decl><type><name>int</name></type> <name>nSelect</name> <init>= <expr><call><name>select</name><argument_list>(<argument><expr><name>hSocketMax</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>fdsetRecv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fdsetSend</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fdsetError</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>interruptNet</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>nSelect</name> <operator>==</operator> <name>SOCKET_ERROR</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nErr</name> <init>= <expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"socket select error %s\n"</literal></expr></argument>, <argument><expr><call><name>NetworkErrorString</name><argument_list>(<argument><expr><name>nErr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>hSocketMax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fdsetRecv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fdsetSend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fdsetError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>interruptNet</name><operator>.</operator><name>sleep_for</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>milliseconds</name></name><argument_list>(<argument><expr><name>SELECT_TIMEOUT_MILLISECONDS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><decl><type><name>SOCKET</name></type> <name>hSocket</name> <range>: <expr><name>recv_select_set</name></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>FD_ISSET</name><argument_list>(<argument><expr><name>hSocket</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fdsetRecv</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>recv_set</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>hSocket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <for>for <control>(<init><decl><type><name>SOCKET</name></type> <name>hSocket</name> <range>: <expr><name>send_select_set</name></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>FD_ISSET</name><argument_list>(<argument><expr><name>hSocket</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fdsetSend</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>send_set</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>hSocket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <for>for <control>(<init><decl><type><name>SOCKET</name></type> <name>hSocket</name> <range>: <expr><name>error_select_set</name></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>FD_ISSET</name><argument_list>(<argument><expr><name>hSocket</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fdsetError</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>error_set</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>hSocket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>SocketHandler</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>SOCKET</name></expr></argument>&gt;</argument_list></name></type> <name>recv_set</name></decl>, <decl><type ref="prev"/><name>send_set</name></decl>, <decl><type ref="prev"/><name>error_set</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>SocketEvents</name><argument_list>(<argument><expr><name>recv_set</name></expr></argument>, <argument><expr><name>send_set</name></expr></argument>, <argument><expr><name>error_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>interruptNet</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="line">//</comment>
    <comment type="line">// Accept new connections</comment>
    <comment type="line">//</comment>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <name>ListenSocket</name><modifier>&amp;</modifier></type> <name>hListenSocket</name> <range>: <expr><name>vhListenSocket</name></expr></range></decl></init>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>hListenSocket</name><operator>.</operator><name>socket</name></name> <operator>!=</operator> <name>INVALID_SOCKET</name> <operator>&amp;&amp;</operator> <call><name><name>recv_set</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name><name>hListenSocket</name><operator>.</operator><name>socket</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>AcceptConnection</name><argument_list>(<argument><expr><name>hListenSocket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="line">//</comment>
    <comment type="line">// Service each socket</comment>
    <comment type="line">//</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CNode</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>vNodesCopy</name></decl>;</decl_stmt>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vNodesCopy</name> <operator>=</operator> <name>vNodes</name></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <range>: <expr><name>vNodesCopy</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>AddRef</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block>
    <for>for <control>(<init><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <range>: <expr><name>vNodesCopy</name></expr></range></decl></init>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>interruptNet</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <comment type="line">//</comment>
        <comment type="line">// Receive</comment>
        <comment type="line">//</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>recvSet</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>sendSet</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>errorSet</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>cs_hSocket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>pnode</name><operator>-&gt;</operator><name>hSocket</name></name> <operator>==</operator> <name>INVALID_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>recvSet</name> <operator>=</operator> <call><name><name>recv_set</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>hSocket</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>sendSet</name> <operator>=</operator> <call><name><name>send_set</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>hSocket</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>errorSet</name> <operator>=</operator> <call><name><name>error_set</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>hSocket</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block>
        <if_stmt><if>if <condition>(<expr><name>recvSet</name> <operator>||</operator> <name>errorSet</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// typical socket buffer is 8K-64K</comment>
            <decl_stmt><decl><type><name>char</name></type> <name><name>pchBuf</name><index>[<expr><literal type="number">0x10000</literal></expr>]</index></name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>nBytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>cs_hSocket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>pnode</name><operator>-&gt;</operator><name>hSocket</name></name> <operator>==</operator> <name>INVALID_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>nBytes</name> <operator>=</operator> <call><name>recv</name><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>hSocket</name></name></expr></argument>, <argument><expr><name>pchBuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pchBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>MSG_DONTWAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <if_stmt><if>if <condition>(<expr><name>nBytes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>bool</name></type> <name>notify</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pnode</name><operator>-&gt;</operator><name>ReceiveMsgBytes</name></name><argument_list>(<argument><expr><name>pchBuf</name></expr></argument>, <argument><expr><name>nBytes</name></expr></argument>, <argument><expr><name>notify</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>CloseSocketDisconnect</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>RecordBytesRecv</name><argument_list>(<argument><expr><name>nBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>notify</name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>size_t</name></type> <name>nSizeAdded</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>auto</name></type> <name>it</name><argument_list>(<argument><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>vRecvMsg</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
                    <for>for <control>(<init>;</init> <condition><expr><name>it</name> <operator>!=</operator> <call><name><name>pnode</name><operator>-&gt;</operator><name>vRecvMsg</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>it</name></expr></incr>)</control> <block>{<block_content>
                        <comment type="line">// vRecvMsg contains only completed CNetMessage</comment>
                        <comment type="line">// the single possible partially deserialized message are held by TransportDeserializer</comment>
                        <expr_stmt><expr><name>nSizeAdded</name> <operator>+=</operator> <name><name>it</name><operator>-&gt;</operator><name>m_raw_message_size</name></name></expr>;</expr_stmt>
                    </block_content>}</block></for>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>cs_vProcessMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>vProcessMsg</name><operator>.</operator><name>splice</name></name><argument_list>(<argument><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>vProcessMsg</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>vRecvMsg</name></name></expr></argument>, <argument><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>vRecvMsg</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>pnode</name><operator>-&gt;</operator><name>nProcessQueueSize</name></name> <operator>+=</operator> <name>nSizeAdded</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>pnode</name><operator>-&gt;</operator><name>fPauseRecv</name></name> <operator>=</operator> <name><name>pnode</name><operator>-&gt;</operator><name>nProcessQueueSize</name></name> <operator>&gt;</operator> <name>nReceiveFloodSize</name></expr>;</expr_stmt>
                    </block_content>}</block>
                    <expr_stmt><expr><call><name>WakeMessageHandler</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>nBytes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// socket closed gracefully</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pnode</name><operator>-&gt;</operator><name>fDisconnect</name></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"socket closed for peer=%d\n"</literal></expr></argument>, <argument><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>CloseSocketDisconnect</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>nBytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// error</comment>
                <decl_stmt><decl><type><name>int</name></type> <name>nErr</name> <init>= <expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>nErr</name> <operator>!=</operator> <name>WSAEWOULDBLOCK</name> <operator>&amp;&amp;</operator> <name>nErr</name> <operator>!=</operator> <name>WSAEMSGSIZE</name> <operator>&amp;&amp;</operator> <name>nErr</name> <operator>!=</operator> <name>WSAEINTR</name> <operator>&amp;&amp;</operator> <name>nErr</name> <operator>!=</operator> <name>WSAEINPROGRESS</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pnode</name><operator>-&gt;</operator><name>fDisconnect</name></name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"socket recv error for peer=%d: %s\n"</literal></expr></argument>, <argument><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>NetworkErrorString</name><argument_list>(<argument><expr><name>nErr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>CloseSocketDisconnect</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">//</comment>
        <comment type="line">// Send</comment>
        <comment type="line">//</comment>
        <if_stmt><if>if <condition>(<expr><name>sendSet</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>cs_vSend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>size_t</name></type> <name>nBytes</name> <init>= <expr><call><name>SocketSendData</name><argument_list>(<argument><expr><name>pnode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>nBytes</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>RecordBytesSent</name><argument_list>(<argument><expr><name>nBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>InactivityCheck</name><argument_list>(<argument><expr><name>pnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <range>: <expr><name>vNodesCopy</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>Release</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>ThreadSocketHandler</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <while>while <condition>(<expr><operator>!</operator><name>interruptNet</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>DisconnectNodes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NotifyNumConnectionsChanged</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SocketHandler</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>WakeMessageHandler</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>lock_guard</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>mutex</name></name></expr></argument>&gt;</argument_list></name></type> <name>lock</name><argument_list>(<argument><expr><name>mutexMsgProc</name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <expr_stmt><expr><name>fMsgProcWake</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name><name>condMsgProc</name><operator>.</operator><name>notify_one</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_UPNP</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>CThreadInterrupt</name></type> <name>g_upnp_interrupt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>std</name><operator>::</operator><name>thread</name></name></type> <name>g_upnp_thread</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ThreadMapPort</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>port</name> <init>= <expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><call><name>GetListenPort</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>multicastif</name> <init>= <expr><literal type="null">nullptr</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>minissdpdpath</name> <init>= <expr><literal type="null">nullptr</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>UPNPDev</name></name> <modifier>*</modifier></type> <name>devlist</name> <init>= <expr><literal type="null">nullptr</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>lanaddr</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>error</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MINIUPNPC_API_VERSION</name> <operator>&lt;</operator> <literal type="number">14</literal></expr></cpp:if>
    <expr_stmt><expr><name>devlist</name> <operator>=</operator> <call><name>upnpDiscover</name><argument_list>(<argument><expr><literal type="number">2000</literal></expr></argument>, <argument><expr><name>multicastif</name></expr></argument>, <argument><expr><name>minissdpdpath</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>devlist</name> <operator>=</operator> <call><name>upnpDiscover</name><argument_list>(<argument><expr><literal type="number">2000</literal></expr></argument>, <argument><expr><name>multicastif</name></expr></argument>, <argument><expr><name>minissdpdpath</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><name><name>struct</name> <name>UPNPUrls</name></name></type> <name>urls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>IGDdatas</name></name></type> <name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>UPNP_GetValidIGD</name><argument_list>(<argument><expr><name>devlist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>urls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>lanaddr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lanaddr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>fDiscover</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>char</name></type> <name><name>externalIPAddress</name><index>[<expr><literal type="number">40</literal></expr>]</index></name></decl>;</decl_stmt>
            <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>UPNP_GetExternalIPAddress</name><argument_list>(<argument><expr><name><name>urls</name><operator>.</operator><name>controlURL</name></name></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>first</name><operator>.</operator><name>servicetype</name></name></expr></argument>, <argument><expr><name>externalIPAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>UPNPCOMMAND_SUCCESS</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"UPnP: GetExternalIPAddress() returned %d\n"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>externalIPAddress</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>CNetAddr</name></type> <name>resolved</name></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>LookupHost</name><argument_list>(<argument><expr><name>externalIPAddress</name></expr></argument>, <argument><expr><name>resolved</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"UPnP: ExternalIPAddress = %s\n"</literal></expr></argument>, <argument><expr><call><name><name>resolved</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>AddLocal</name><argument_list>(<argument><expr><name>resolved</name></expr></argument>, <argument><expr><name>LOCAL_UPNP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"UPnP: GetExternalIPAddress failed.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>strDesc</name> <init>= <expr><name>PACKAGE_NAME</name> <literal type="string">" "</literal> <operator>+</operator> <call><name>FormatFullVersion</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <do>do <block>{<block_content>
            <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>UPNP_AddPortMapping</name><argument_list>(<argument><expr><name><name>urls</name><operator>.</operator><name>controlURL</name></name></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>first</name><operator>.</operator><name>servicetype</name></name></expr></argument>, <argument><expr><call><name><name>port</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>port</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>lanaddr</name></expr></argument>, <argument><expr><call><name><name>strDesc</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"TCP"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>UPNPCOMMAND_SUCCESS</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"AddPortMapping(%s, %s, %s) failed with code %d (%s)\n"</literal></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>lanaddr</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>strupnperror</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"UPnP Port Mapping successful.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block> while <condition>(<expr><call><name><name>g_upnp_interrupt</name><operator>.</operator><name>sleep_for</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>minutes</name></name><argument_list>(<argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>

        <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>UPNP_DeletePortMapping</name><argument_list>(<argument><expr><name><name>urls</name><operator>.</operator><name>controlURL</name></name></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>first</name><operator>.</operator><name>servicetype</name></name></expr></argument>, <argument><expr><call><name><name>port</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"TCP"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"UPNP_DeletePortMapping() returned: %d\n"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>freeUPNPDevlist</name><argument_list>(<argument><expr><name>devlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>devlist</name> <operator>=</operator> <literal type="null">nullptr</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FreeUPNPUrls</name><argument_list>(<argument><expr><operator>&amp;</operator><name>urls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"No valid UPnP IGDs found\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>freeUPNPDevlist</name><argument_list>(<argument><expr><name>devlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>devlist</name> <operator>=</operator> <literal type="null">nullptr</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>FreeUPNPUrls</name><argument_list>(<argument><expr><operator>&amp;</operator><name>urls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>StartMapPort</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>g_upnp_thread</name><operator>.</operator><name>joinable</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>g_upnp_interrupt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>g_upnp_thread</name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>thread</name></name><argument_list>(<argument><expr><operator>(</operator><call><name><name>std</name><operator>::</operator><name>bind</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>TraceThread</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>(</operator><operator>*</operator><operator>)</operator><operator>(</operator><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><literal type="string">"upnp"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ThreadMapPort</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>InterruptMapPort</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>(<expr><call><name><name>g_upnp_thread</name><operator>.</operator><name>joinable</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>g_upnp_interrupt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>StopMapPort</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>(<expr><call><name><name>g_upnp_thread</name><operator>.</operator><name>joinable</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>g_upnp_thread</name><operator>.</operator><name>join</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>g_upnp_interrupt</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><name>void</name></type> <name>StartMapPort</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <comment type="line">// Intentionally left blank.</comment>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>InterruptMapPort</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <comment type="line">// Intentionally left blank.</comment>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>StopMapPort</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <comment type="line">// Intentionally left blank.</comment>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>






<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>ThreadDNSAddressSeed</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FastRandomContext</name></type> <name>rng</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>&gt;</argument_list></name></type> <name>seeds</name> <init>= <expr><call><name>Params</name><argument_list>()</argument_list></call><operator>.</operator><call><name>DNSSeeds</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>Shuffle</name><argument_list>(<argument><expr><call><name><name>seeds</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>seeds</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>rng</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>seeds_right_now</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="line">// Number of seeds left before testing if we have enough connections</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name><name>gArgs</name><operator>.</operator><name>GetBoolArg</name></name><argument_list>(<argument><expr><literal type="string">"-forcednsseed"</literal></expr></argument>, <argument><expr><name>DEFAULT_FORCEDNSSEED</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="line">// When -forcednsseed is provided, query all.</comment>
        <expr_stmt><expr><name>seeds_right_now</name> <operator>=</operator> <call><name><name>seeds</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>seed</name> <range>: <expr><name>seeds</name></expr></range></decl></init>)</control> <block>{<block_content>
        <comment type="line">// goal: only query DNS seed if address need is acute</comment>
        <comment type="line">// Avoiding DNS seeds when we don't need them improves user privacy by</comment>
        <comment type="line">// creating fewer identifying DNS requests, reduces trust by giving seeds</comment>
        <comment type="line">// less influence on the network topology, and reduces traffic to the seeds.</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>addrman</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>seeds_right_now</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>interruptNet</name><operator>.</operator><name>sleep_for</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>seconds</name></name><argument_list>(<argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>nRelevant</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <range>: <expr><name>vNodes</name></expr></range></decl></init>)</control> <block>{<block_content>
                <expr_stmt><expr><name>nRelevant</name> <operator>+=</operator> <name><name>pnode</name><operator>-&gt;</operator><name>fSuccessfullyConnected</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pnode</name><operator>-&gt;</operator><name>fFeeler</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pnode</name><operator>-&gt;</operator><name>fOneShot</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pnode</name><operator>-&gt;</operator><name>m_manual_connection</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pnode</name><operator>-&gt;</operator><name>fInbound</name></name></expr>;</expr_stmt>
            </block_content>}</block></for>
            <if_stmt><if>if <condition>(<expr><name>nRelevant</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"P2P peers available. Skipped DNS seeding.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>seeds_right_now</name> <operator>+=</operator> <name>DNSSEEDS_TO_QUERY_AT_ONCE</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>interruptNet</name></expr>)</condition> <block>{<block_content>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"Loading addresses from DNS seed %s\n"</literal></expr></argument>, <argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>HaveNameProxy</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>AddOneShot</name><argument_list>(<argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CNetAddr</name></expr></argument>&gt;</argument_list></name></type> <name>vIPs</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CAddress</name></expr></argument>&gt;</argument_list></name></type> <name>vAdd</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ServiceFlags</name></type> <name>requiredServiceBits</name> <init>= <expr><call><name>GetDesirableServiceFlags</name><argument_list>(<argument><expr><name>NODE_NONE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>host</name> <init>= <expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"x%x.%s"</literal></expr></argument>, <argument><expr><name>requiredServiceBits</name></expr></argument>, <argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>CNetAddr</name></type> <name>resolveSource</name></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>resolveSource</name><operator>.</operator><name>SetInternal</name></name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nMaxIPs</name> <init>= <expr><literal type="number">256</literal></expr></init></decl>;</decl_stmt> <comment type="line">// Limits number of IPs learned from a DNS seed</comment>
            <if_stmt><if>if <condition>(<expr><call><name>LookupHost</name><argument_list>(<argument><expr><call><name><name>host</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>vIPs</name></expr></argument>, <argument><expr><name>nMaxIPs</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CNetAddr</name><modifier>&amp;</modifier></type> <name>ip</name> <range>: <expr><name>vIPs</name></expr></range></decl></init>)</control> <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type> <name>nOneDay</name> <init>= <expr><literal type="number">24</literal><operator>*</operator><literal type="number">3600</literal></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>CAddress</name></type> <name>addr</name> <init>= <expr><call><name>CAddress</name><argument_list>(<argument><expr><call><name>CService</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><call><name>Params</name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetDefaultPort</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>requiredServiceBits</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name><name>addr</name><operator>.</operator><name>nTime</name></name> <operator>=</operator> <call><name>GetTime</name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">3</literal><operator>*</operator><name>nOneDay</name> <operator>-</operator> <call><name><name>rng</name><operator>.</operator><name>randrange</name></name><argument_list>(<argument><expr><literal type="number">4</literal><operator>*</operator><name>nOneDay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// use a random age between 3 and 7 days old</comment>
                    <expr_stmt><expr><call><name><name>vAdd</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>found</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><call><name><name>addrman</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>vAdd</name></expr></argument>, <argument><expr><name>resolveSource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <comment type="line">// We now avoid directly using results from DNS Seeds which do not support service bit filtering,</comment>
                <comment type="line">// instead using them as a oneshot to get nodes with our desired service bits.</comment>
                <expr_stmt><expr><call><name>AddOneShot</name><argument_list>(<argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><operator>--</operator><name>seeds_right_now</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"%d addresses found from DNS seeds\n"</literal></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>












<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>DumpAddresses</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>nStart</name> <init>= <expr><call><name>GetTimeMillis</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>CAddrDB</name></type> <name>adb</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>adb</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><name>addrman</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"Flushed %d addresses to peers.dat  %dms\n"</literal></expr></argument>,
           <argument><expr><call><name><name>addrman</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>GetTimeMillis</name><argument_list>()</argument_list></call> <operator>-</operator> <name>nStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>ProcessOneShot</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>strDest</name></decl>;</decl_stmt>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vOneShots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>vOneShots</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>strDest</name> <operator>=</operator> <call><name><name>vOneShots</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>vOneShots</name><operator>.</operator><name>pop_front</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <decl_stmt><decl><type><name>CAddress</name></type> <name>addr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CSemaphoreGrant</name></type> <name>grant</name><argument_list>(<argument><expr><operator>*</operator><name>semOutbound</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>grant</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>OpenNetworkConnection</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>grant</name></expr></argument>, <argument><expr><call><name><name>strDest</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CConnman</name><operator>::</operator><name>GetTryNewOutboundPeer</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <return>return <expr><name>m_try_another_outbound_peer</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>SetTryNewOutboundPeer</name></name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>flag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>m_try_another_outbound_peer</name> <operator>=</operator> <name>flag</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"net: setting try another outbound peer=%s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>flag</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Return the number of peers we have over our outbound connection limit</comment>
<comment type="line">// Exclude peers that are marked for disconnect, or are going to be</comment>
<comment type="line">// disconnected soon (eg one-shots and feelers)</comment>
<comment type="line">// Also exclude peers that haven't finished initial connection handshake yet</comment>
<comment type="line">// (so that we don't decide we're over our desired connection limit, and then</comment>
<comment type="line">// evict some peer that has finished the handshake)</comment>
<function><type><name>int</name></type> <name><name>CConnman</name><operator>::</operator><name>GetExtraOutboundCount</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nOutbound</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <range>: <expr><name>vNodes</name></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pnode</name><operator>-&gt;</operator><name>fInbound</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pnode</name><operator>-&gt;</operator><name>m_manual_connection</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pnode</name><operator>-&gt;</operator><name>fFeeler</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pnode</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pnode</name><operator>-&gt;</operator><name>fOneShot</name></name> <operator>&amp;&amp;</operator> <name><name>pnode</name><operator>-&gt;</operator><name>fSuccessfullyConnected</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>++</operator><name>nOutbound</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
    <return>return <expr><call><name><name>std</name><operator>::</operator><name>max</name></name><argument_list>(<argument><expr><name>nOutbound</name> <operator>-</operator> <name>m_max_outbound_full_relay</name> <operator>-</operator> <name>m_max_outbound_block_relay</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>ThreadOpenConnections</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>&gt;</argument_list></name></type> <name>connect</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">// Connect to specific addresses</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>connect</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>nLoop</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init><condition>;</condition> <incr><expr><name>nLoop</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ProcessOneShot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>strAddr</name> <range>: <expr><name>connect</name></expr></range></decl></init>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>CAddress</name></type> <name>addr</name><argument_list>(<argument><expr><call><name>CService</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NODE_NONE</name></expr></argument>)</argument_list></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>OpenNetworkConnection</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="null">nullptr</literal></expr></argument>, <argument><expr><call><name><name>strAddr</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">10</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>nLoop</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>interruptNet</name><operator>.</operator><name>sleep_for</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>milliseconds</name></name><argument_list>(<argument><expr><literal type="number">500</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return;</return></block_content></block></if></if_stmt>
                </block_content>}</block></for>
            </block_content>}</block></for>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>interruptNet</name><operator>.</operator><name>sleep_for</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>milliseconds</name></name><argument_list>(<argument><expr><literal type="number">500</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return;</return></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Initiate network connections</comment>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>nStart</name> <init>= <expr><call><name>GetTime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Minimum time before next feeler connection (in microseconds).</comment>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>nNextFeeler</name> <init>= <expr><call><name>PoissonNextSend</name><argument_list>(<argument><expr><name>nStart</name><operator>*</operator><literal type="number">1000</literal><operator>*</operator><literal type="number">1000</literal></expr></argument>, <argument><expr><name>FEELER_INTERVAL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><operator>!</operator><name>interruptNet</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ProcessOneShot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>interruptNet</name><operator>.</operator><name>sleep_for</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>milliseconds</name></name><argument_list>(<argument><expr><literal type="number">500</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>CSemaphoreGrant</name></type> <name>grant</name><argument_list>(<argument><expr><operator>*</operator><name>semOutbound</name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>interruptNet</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <comment type="line">// Add seed nodes if DNS seeds are all down (an infrastructure attack?).</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>addrman</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>GetTime</name><argument_list>()</argument_list></call> <operator>-</operator> <name>nStart</name> <operator>&gt;</operator> <literal type="number">60</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>done</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>done</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"Adding fixed seed nodes as DNS doesn't seem to be available.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>CNetAddr</name></type> <name>local</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>local</name><operator>.</operator><name>SetInternal</name></name><argument_list>(<argument><expr><literal type="string">"fixedseeds"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>addrman</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><call><name>convertSeed6</name><argument_list>(<argument><expr><call><name>Params</name><argument_list>()</argument_list></call><operator>.</operator><call><name>FixedSeeds</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>local</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>done</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">//</comment>
        <comment type="line">// Choose an address to connect to based on most recently seen</comment>
        <comment type="line">//</comment>
        <decl_stmt><decl><type><name>CAddress</name></type> <name>addrConnect</name></decl>;</decl_stmt>

        <comment type="line">// Only connect out to one peer per network group (/16 for IPv4).</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>nOutboundFullRelay</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nOutboundBlockRelay</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type> <name>setConnected</name></decl>;</decl_stmt>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <range>: <expr><name>vNodes</name></expr></range></decl></init>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pnode</name><operator>-&gt;</operator><name>fInbound</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pnode</name><operator>-&gt;</operator><name>m_manual_connection</name></name></expr>)</condition> <block>{<block_content>
                    <comment type="line">// Netgroups for inbound and addnode peers are not excluded because our goal here</comment>
                    <comment type="line">// is to not use multiple of our limited outbound slots on a single netgroup</comment>
                    <comment type="line">// but inbound and addnode peers do not use our outbound slots.  Inbound peers</comment>
                    <comment type="line">// also have the added issue that they're attacker controlled and could be used</comment>
                    <comment type="line">// to prevent us from connecting to particular hosts if we used them here.</comment>
                    <expr_stmt><expr><call><name><name>setConnected</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>GetGroup</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>pnode</name><operator>-&gt;</operator><name>m_tx_relay</name></name> <operator>==</operator> <literal type="null">nullptr</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>nOutboundBlockRelay</name><operator>++</operator></expr>;</expr_stmt>
                    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>pnode</name><operator>-&gt;</operator><name>fFeeler</name></name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>nOutboundFullRelay</name><operator>++</operator></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block>

        <comment type="line">// Feeler Connections</comment>
        <comment type="line">//</comment>
        <comment type="line">// Design goals:</comment>
        <comment type="line">//  * Increase the number of connectable addresses in the tried table.</comment>
        <comment type="line">//</comment>
        <comment type="line">// Method:</comment>
        <comment type="line">//  * Choose a random address from new and attempt to connect to it if we can connect</comment>
        <comment type="line">//    successfully it is added to tried.</comment>
        <comment type="line">//  * Start attempting feeler connections only after node finishes making outbound</comment>
        <comment type="line">//    connections.</comment>
        <comment type="line">//  * Only make a feeler connection once every few minutes.</comment>
        <comment type="line">//</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>fFeeler</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>nOutboundFullRelay</name> <operator>&gt;=</operator> <name>m_max_outbound_full_relay</name> <operator>&amp;&amp;</operator> <name>nOutboundBlockRelay</name> <operator>&gt;=</operator> <name>m_max_outbound_block_relay</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>GetTryNewOutboundPeer</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>nTime</name> <init>= <expr><call><name>GetTimeMicros</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// The current time right now (in microseconds).</comment>
            <if_stmt><if>if <condition>(<expr><name>nTime</name> <operator>&gt;</operator> <name>nNextFeeler</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>nNextFeeler</name> <operator>=</operator> <call><name>PoissonNextSend</name><argument_list>(<argument><expr><name>nTime</name></expr></argument>, <argument><expr><name>FEELER_INTERVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>fFeeler</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <continue>continue;</continue>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name><name>addrman</name><operator>.</operator><name>ResolveCollisions</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>int64_t</name></type> <name>nANow</name> <init>= <expr><call><name>GetAdjustedTime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nTries</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><operator>!</operator><name>interruptNet</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>CAddrInfo</name></type> <name>addr</name> <init>= <expr><call><name><name>addrman</name><operator>.</operator><name>SelectTriedCollision</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// SelectTriedCollision returns an invalid address if it is empty.</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fFeeler</name> <operator>||</operator> <operator>!</operator><call><name><name>addr</name><operator>.</operator><name>IsValid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name><name>addrman</name><operator>.</operator><name>Select</name></name><argument_list>(<argument><expr><name>fFeeler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Require outbound connections, other than feelers, to be to distinct network groups</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fFeeler</name> <operator>&amp;&amp;</operator> <call><name><name>setConnected</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><call><name><name>addr</name><operator>.</operator><name>GetGroup</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// if we selected an invalid or local address, restart</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>addr</name><operator>.</operator><name>IsValid</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsLocal</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// If we didn't find an appropriate destination after trying 100 addresses fetched from addrman,</comment>
            <comment type="line">// stop this loop, and let the outer loop run again (which sleeps, adds seed nodes, recalculates</comment>
            <comment type="line">// already-connected network ranges, ...) before trying new addrman addresses.</comment>
            <expr_stmt><expr><name>nTries</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>nTries</name> <operator>&gt;</operator> <literal type="number">100</literal></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsReachable</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="line">// only consider very recently tried nodes after 30 failed attempts</comment>
            <if_stmt><if>if <condition>(<expr><name>nANow</name> <operator>-</operator> <name><name>addr</name><operator>.</operator><name>nLastTry</name></name> <operator>&lt;</operator> <literal type="number">600</literal> <operator>&amp;&amp;</operator> <name>nTries</name> <operator>&lt;</operator> <literal type="number">30</literal></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="line">// for non-feelers, require all the services we'll want,</comment>
            <comment type="line">// for feelers, only require they be a full node (only because most</comment>
            <comment type="line">// SPV clients don't have a good address DB available)</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fFeeler</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>HasAllDesirableServiceFlags</name><argument_list>(<argument><expr><name><name>addr</name><operator>.</operator><name>nServices</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <continue>continue;</continue>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>fFeeler</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>MayHaveUsefulAddressDB</name><argument_list>(<argument><expr><name><name>addr</name><operator>.</operator><name>nServices</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// do not allow non-default ports, unless after 50 invalid addresses selected already</comment>
            <if_stmt><if>if <condition>(<expr><call><name><name>addr</name><operator>.</operator><name>GetPort</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name>Params</name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetDefaultPort</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>nTries</name> <operator>&lt;</operator> <literal type="number">50</literal></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>addrConnect</name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></while>

        <if_stmt><if>if <condition>(<expr><call><name><name>addrConnect</name><operator>.</operator><name>IsValid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

            <if_stmt><if>if <condition>(<expr><name>fFeeler</name></expr>)</condition> <block>{<block_content>
                <comment type="line">// Add small amount of random noise before connection to avoid synchronization.</comment>
                <decl_stmt><decl><type><name>int</name></type> <name>randsleep</name> <init>= <expr><call><name>GetRandInt</name><argument_list>(<argument><expr><name>FEELER_SLEEP_WINDOW</name> <operator>*</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>interruptNet</name><operator>.</operator><name>sleep_for</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>milliseconds</name></name><argument_list>(<argument><expr><name>randsleep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return;</return></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"Making feeler connection to %s\n"</literal></expr></argument>, <argument><expr><call><name><name>addrConnect</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Open this connection as block-relay-only if we're already at our</comment>
            <comment type="line">// full-relay capacity, but not yet at our block-relay peer limit.</comment>
            <comment type="line">// (It should not be possible for fFeeler to be set if we're not</comment>
            <comment type="line">// also at our block-relay peer limit, but check against that as</comment>
            <comment type="line">// well for sanity.)</comment>
            <decl_stmt><decl><type><name>bool</name></type> <name>block_relay_only</name> <init>= <expr><name>nOutboundBlockRelay</name> <operator>&lt;</operator> <name>m_max_outbound_block_relay</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>fFeeler</name> <operator>&amp;&amp;</operator> <name>nOutboundFullRelay</name> <operator>&gt;=</operator> <name>m_max_outbound_full_relay</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>OpenNetworkConnection</name><argument_list>(<argument><expr><name>addrConnect</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name><name>setConnected</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <call><name><name>std</name><operator>::</operator><name>min</name></name><argument_list>(<argument><expr><name>nMaxConnections</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>grant</name></expr></argument>, <argument><expr><literal type="null">nullptr</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name>fFeeler</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name>block_relay_only</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>AddedNodeInfo</name></expr></argument>&gt;</argument_list></name></type> <name><name>CConnman</name><operator>::</operator><name>GetAddedNodeInfo</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>AddedNodeInfo</name></expr></argument>&gt;</argument_list></name></type> <name>ret</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>list</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>&gt;</argument_list></name></type> <name>lAddresses</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vAddedNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>ret</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>vAddedNodes</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>std</name><operator>::</operator><name>copy</name></name><argument_list>(<argument><expr><call><name><name>vAddedNodes</name><operator>.</operator><name>cbegin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>vAddedNodes</name><operator>.</operator><name>cend</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>back_inserter</name></name><argument_list>(<argument><expr><name>lAddresses</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>


    <comment type="line">// Build a map of all already connected addresses (by IP:port and by name) to inbound/outbound and resolved CService</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>CService</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name></type> <name>mapConnected</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>, <argument><expr><name>CService</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>mapConnectedByName</name></decl>;</decl_stmt>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <range>: <expr><name>vNodes</name></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>pnode</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>IsValid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>mapConnected</name><index>[<expr><name><name>pnode</name><operator>-&gt;</operator><name>addr</name></name></expr>]</index></name> <operator>=</operator> <name><name>pnode</name><operator>-&gt;</operator><name>fInbound</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>addrName</name> <init>= <expr><call><name><name>pnode</name><operator>-&gt;</operator><name>GetAddrName</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>addrName</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>mapConnectedByName</name><index>[<expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>addrName</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>fInbound</name></name></expr></argument>, <argument><expr><cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CService</name><operator>&amp;</operator></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></cast></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block>

    <for>for <control>(<init><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>strAddNode</name> <range>: <expr><name>lAddresses</name></expr></range></decl></init>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>CService</name></type> <name>service</name><argument_list>(<argument><expr><call><name>LookupNumeric</name><argument_list>(<argument><expr><call><name><name>strAddNode</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>Params</name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetDefaultPort</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AddedNodeInfo</name></type> <name>addedNode</name><argument_list>{<argument><expr><name>strAddNode</name></expr></argument>, <argument><expr><call><name>CService</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>}</argument_list></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>service</name><operator>.</operator><name>IsValid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="line">// strAddNode is an IP:port</comment>
            <decl_stmt><decl><type><name>auto</name></type> <name>it</name> <init>= <expr><call><name><name>mapConnected</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>service</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>it</name> <operator>!=</operator> <call><name><name>mapConnected</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>addedNode</name><operator>.</operator><name>resolvedAddress</name></name> <operator>=</operator> <name>service</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>addedNode</name><operator>.</operator><name>fConnected</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>addedNode</name><operator>.</operator><name>fInbound</name></name> <operator>=</operator> <name><name>it</name><operator>-&gt;</operator><name>second</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="line">// strAddNode is a name</comment>
            <decl_stmt><decl><type><name>auto</name></type> <name>it</name> <init>= <expr><call><name><name>mapConnectedByName</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>strAddNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>it</name> <operator>!=</operator> <call><name><name>mapConnectedByName</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>addedNode</name><operator>.</operator><name>resolvedAddress</name></name> <operator>=</operator> <name><name>it</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>second</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>addedNode</name><operator>.</operator><name>fConnected</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>addedNode</name><operator>.</operator><name>fInbound</name></name> <operator>=</operator> <name><name>it</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>first</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name><name>ret</name><operator>.</operator><name>emplace_back</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>addedNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>ThreadOpenAddedConnections</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <while>while <condition>(<expr><literal type="boolean">true</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CSemaphoreGrant</name></type> <name>grant</name><argument_list>(<argument><expr><operator>*</operator><name>semAddnode</name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>AddedNodeInfo</name></expr></argument>&gt;</argument_list></name></type> <name>vInfo</name> <init>= <expr><call><name>GetAddedNodeInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>tried</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>const</specifier> <name>AddedNodeInfo</name><modifier>&amp;</modifier></type> <name>info</name> <range>: <expr><name>vInfo</name></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>info</name><operator>.</operator><name>fConnected</name></name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>grant</name><operator>.</operator><name>TryAcquire</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <comment type="line">// If we've used up our semaphore and need a new one, let's not wait here since while we are waiting</comment>
                    <comment type="line">// the addednodeinfo state might change.</comment>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>tried</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>CAddress</name></type> <name>addr</name><argument_list>(<argument><expr><call><name>CService</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NODE_NONE</name></expr></argument>)</argument_list></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>OpenNetworkConnection</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>grant</name></expr></argument>, <argument><expr><call><name><name>info</name><operator>.</operator><name>strAddedNode</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>interruptNet</name><operator>.</operator><name>sleep_for</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>milliseconds</name></name><argument_list>(<argument><expr><literal type="number">500</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return;</return></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <comment type="line">// Retry every 60 seconds if a connection was attempted, otherwise two seconds</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>interruptNet</name><operator>.</operator><name>sleep_for</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>seconds</name></name><argument_list>(<argument><expr><ternary><condition><expr><name>tried</name></expr> ?</condition><then> <expr><literal type="number">60</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="line">// if successful, this moves the passed grant to the constructed node</comment>
<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>OpenNetworkConnection</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CAddress</name><modifier>&amp;</modifier></type> <name>addrConnect</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fCountFailure</name></decl></parameter>, <parameter><decl><type><name>CSemaphoreGrant</name> <modifier>*</modifier></type><name>grantOutbound</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pszDest</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fOneShot</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fFeeler</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>manual_connection</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>block_relay_only</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">//</comment>
    <comment type="line">// Initiate outbound network connection</comment>
    <comment type="line">//</comment>
    <if_stmt><if>if <condition>(<expr><name>interruptNet</name></expr>)</condition> <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fNetworkActive</name></expr>)</condition> <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pszDest</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>IsLocal</name><argument_list>(<argument><expr><name>addrConnect</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <call><name>FindNode</name><argument_list>(<argument><expr><cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>CNetAddr</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name>addrConnect</name></expr></argument>)</argument_list></cast></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>m_banman</name> <operator>&amp;&amp;</operator> <call><name><name>m_banman</name><operator>-&gt;</operator><name>IsBanned</name></name><argument_list>(<argument><expr><name>addrConnect</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
            <call><name>FindNode</name><argument_list>(<argument><expr><call><name><name>addrConnect</name><operator>.</operator><name>ToStringIPPort</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>FindNode</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>string</name></name><argument_list>(<argument><expr><name>pszDest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <init>= <expr><call><name>ConnectNode</name><argument_list>(<argument><expr><name>addrConnect</name></expr></argument>, <argument><expr><name>pszDest</name></expr></argument>, <argument><expr><name>fCountFailure</name></expr></argument>, <argument><expr><name>manual_connection</name></expr></argument>, <argument><expr><name>block_relay_only</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pnode</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>grantOutbound</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name><name>grantOutbound</name><operator>-&gt;</operator><name>MoveTo</name></name><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>grantOutbound</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>fOneShot</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>pnode</name><operator>-&gt;</operator><name>fOneShot</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>fFeeler</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>pnode</name><operator>-&gt;</operator><name>fFeeler</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>manual_connection</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>pnode</name><operator>-&gt;</operator><name>m_manual_connection</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name><name>m_msgproc</name><operator>-&gt;</operator><name>InitializeNode</name></name><argument_list>(<argument><expr><name>pnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>vNodes</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>pnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>ThreadMessageHandler</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <while>while <condition>(<expr><operator>!</operator><name>flagInterruptMsgProc</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CNode</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>vNodesCopy</name></decl>;</decl_stmt>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>vNodesCopy</name> <operator>=</operator> <name>vNodes</name></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <range>: <expr><name>vNodesCopy</name></expr></range></decl></init>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>AddRef</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block>

        <decl_stmt><decl><type><name>bool</name></type> <name>fMoreWork</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <range>: <expr><name>vNodesCopy</name></expr></range></decl></init>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>pnode</name><operator>-&gt;</operator><name>fDisconnect</name></name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="line">// Receive messages</comment>
            <decl_stmt><decl><type><name>bool</name></type> <name>fMoreNodeWork</name> <init>= <expr><call><name><name>m_msgproc</name><operator>-&gt;</operator><name>ProcessMessages</name></name><argument_list>(<argument><expr><name>pnode</name></expr></argument>, <argument><expr><name>flagInterruptMsgProc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>fMoreWork</name> <operator>|=</operator> <operator>(</operator><name>fMoreNodeWork</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pnode</name><operator>-&gt;</operator><name>fPauseSend</name></name><operator>)</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>flagInterruptMsgProc</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return;</return></block_content></block></if></if_stmt>
            <comment type="line">// Send messages</comment>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>cs_sendProcessing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>m_msgproc</name><operator>-&gt;</operator><name>SendMessages</name></name><argument_list>(<argument><expr><name>pnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>

            <if_stmt><if>if <condition>(<expr><name>flagInterruptMsgProc</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return;</return></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <range>: <expr><name>vNodesCopy</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>Release</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block>

        <expr_stmt><expr><call><name>WAIT_LOCK</name><argument_list>(<argument><expr><name>mutexMsgProc</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fMoreWork</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>condMsgProc</name><operator>.</operator><name>wait_until</name></name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>steady_clock</name><operator>::</operator><name>now</name></name><argument_list>()</argument_list></call> <operator>+</operator> <call><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>milliseconds</name></name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><lambda><capture>[<argument><name>this</name></argument>]</capture> <block>{<block_content> <return>return <expr><name>fMsgProcWake</name></expr>;</return> </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>fMsgProcWake</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>






<function><type><name>bool</name></type> <name><name>CConnman</name><operator>::</operator><name>BindListenPort</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CService</name><modifier>&amp;</modifier></type> <name>addrBind</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>strError</name></decl></parameter>, <parameter><decl><type><name>NetPermissionFlags</name></type> <name>permissions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>strError</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nOne</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="line">// Create socket for listening for incoming connections</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_storage</name></name></type> <name>sockaddr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>socklen_t</name></type> <name>len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>sockaddr</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>addrBind</name><operator>.</operator><name>GetSockAddr</name></name><argument_list>(<argument><expr><operator>(</operator>struct <name>sockaddr</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>sockaddr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>strError</name> <operator>=</operator> <call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"Error: Bind address family for %s not supported"</literal></expr></argument>, <argument><expr><call><name><name>addrBind</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>strError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>SOCKET</name></type> <name>hListenSocket</name> <init>= <expr><call><name>CreateSocket</name><argument_list>(<argument><expr><name>addrBind</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>hListenSocket</name> <operator>==</operator> <name>INVALID_SOCKET</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>strError</name> <operator>=</operator> <call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"Error: Couldn't open socket for incoming connections (socket returned error %s)"</literal></expr></argument>, <argument><expr><call><name>NetworkErrorString</name><argument_list>(<argument><expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>strError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Allow binding if the port is still in TIME_WAIT state after</comment>
    <comment type="line">// the program was closed and restarted.</comment>
    <expr_stmt><expr><call><name>setsockopt</name><argument_list>(<argument><expr><name>hListenSocket</name></expr></argument>, <argument><expr><name>SOL_SOCKET</name></expr></argument>, <argument><expr><name>SO_REUSEADDR</name></expr></argument>, <argument><expr><operator>(</operator><name>sockopt_arg_type</name><operator>)</operator><operator>&amp;</operator><name>nOne</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// some systems don't have IPV6_V6ONLY but are always v6only; others do have the option</comment>
    <comment type="line">// and enable it by default or not. Try to enable it, if possible.</comment>
    <if_stmt><if>if <condition>(<expr><call><name><name>addrBind</name><operator>.</operator><name>IsIPv6</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IPV6_V6ONLY</name></cpp:ifdef>
        <expr_stmt><expr><call><name>setsockopt</name><argument_list>(<argument><expr><name>hListenSocket</name></expr></argument>, <argument><expr><name>IPPROTO_IPV6</name></expr></argument>, <argument><expr><name>IPV6_V6ONLY</name></expr></argument>, <argument><expr><operator>(</operator><name>sockopt_arg_type</name><operator>)</operator><operator>&amp;</operator><name>nOne</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
        <decl_stmt><decl><type><name>int</name></type> <name>nProtLevel</name> <init>= <expr><name>PROTECTION_LEVEL_UNRESTRICTED</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>setsockopt</name><argument_list>(<argument><expr><name>hListenSocket</name></expr></argument>, <argument><expr><name>IPPROTO_IPV6</name></expr></argument>, <argument><expr><name>IPV6_PROTECTION_LEVEL</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>nProtLevel</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name><operator>::</operator><name>bind</name></name><argument_list>(<argument><expr><name>hListenSocket</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>sockaddr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SOCKET_ERROR</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nErr</name> <init>= <expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>nErr</name> <operator>==</operator> <name>WSAEADDRINUSE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>strError</name> <operator>=</operator> <call><name>strprintf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Unable to bind to %s on this computer. %s is probably already running."</literal></expr></argument>)</argument_list></call><operator>.</operator><name>translated</name></expr></argument>, <argument><expr><call><name><name>addrBind</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PACKAGE_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>strError</name> <operator>=</operator> <call><name>strprintf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Unable to bind to %s on this computer (bind returned error %s)"</literal></expr></argument>)</argument_list></call><operator>.</operator><name>translated</name></expr></argument>, <argument><expr><call><name><name>addrBind</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>NetworkErrorString</name><argument_list>(<argument><expr><name>nErr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>strError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CloseSocket</name><argument_list>(<argument><expr><name>hListenSocket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"Bound to %s\n"</literal></expr></argument>, <argument><expr><call><name><name>addrBind</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Listen for incoming connections</comment>
    <if_stmt><if>if <condition>(<expr><call><name>listen</name><argument_list>(<argument><expr><name>hListenSocket</name></expr></argument>, <argument><expr><name>SOMAXCONN</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SOCKET_ERROR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>strError</name> <operator>=</operator> <call><name>strprintf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Error: Listening for incoming connections failed (listen returned error %s)"</literal></expr></argument>)</argument_list></call><operator>.</operator><name>translated</name></expr></argument>, <argument><expr><call><name>NetworkErrorString</name><argument_list>(<argument><expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>strError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CloseSocket</name><argument_list>(<argument><expr><name>hListenSocket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name><name>vhListenSocket</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>ListenSocket</name><argument_list>(<argument><expr><name>hListenSocket</name></expr></argument>, <argument><expr><name>permissions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name><name>addrBind</name><operator>.</operator><name>IsRoutable</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>fDiscover</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>permissions</name> <operator>&amp;</operator> <name>PF_NOBAN</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>AddLocal</name><argument_list>(<argument><expr><name>addrBind</name></expr></argument>, <argument><expr><name>LOCAL_BIND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>Discover</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fDiscover</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <comment type="line">// Get local host IP</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>pszHostName</name><index>[<expr><literal type="number">256</literal></expr>]</index></name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>gethostname</name><argument_list>(<argument><expr><name>pszHostName</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pszHostName</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SOCKET_ERROR</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CNetAddr</name></expr></argument>&gt;</argument_list></name></type> <name>vaddr</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>LookupHost</name><argument_list>(<argument><expr><name>pszHostName</name></expr></argument>, <argument><expr><name>vaddr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CNetAddr</name> <modifier>&amp;</modifier></type><name>addr</name> <range>: <expr><name>vaddr</name></expr></range></decl></init>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>AddLocal</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>LOCAL_IF</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"%s: %s - %s\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><name>pszHostName</name></expr></argument>, <argument><expr><call><name><name>addr</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><name>HAVE_DECL_GETIFADDRS</name> <operator>&amp;&amp;</operator> <name>HAVE_DECL_FREEIFADDRS</name><operator>)</operator></expr></cpp:elif>
    <comment type="line">// Get local host ip</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>ifaddrs</name></name><modifier>*</modifier></type> <name>myaddrs</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>getifaddrs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myaddrs</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><decl><type><name><name>struct</name> <name>ifaddrs</name></name><modifier>*</modifier> <name>ifa</name></type> <init>= <expr><name>myaddrs</name></expr></init></decl>;</init> <condition><expr><name>ifa</name> <operator>!=</operator> <literal type="null">nullptr</literal></expr>;</condition> <incr><expr><name>ifa</name> <operator>=</operator> <name><name>ifa</name><operator>-&gt;</operator><name>ifa_next</name></name></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>ifa</name><operator>-&gt;</operator><name>ifa_addr</name></name> <operator>==</operator> <literal type="null">nullptr</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ifa</name><operator>-&gt;</operator><name>ifa_flags</name></name> <operator>&amp;</operator> <name>IFF_UP</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>ifa</name><operator>-&gt;</operator><name>ifa_name</name></name></expr></argument>, <argument><expr><literal type="string">"lo"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>ifa</name><operator>-&gt;</operator><name>ifa_name</name></name></expr></argument>, <argument><expr><literal type="string">"lo0"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>ifa</name><operator>-&gt;</operator><name>ifa_addr</name><operator>-&gt;</operator><name>sa_family</name></name> <operator>==</operator> <name>AF_INET</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_in</name></name><modifier>*</modifier></type> <name>s4</name> <init>= <expr><operator>(</operator>struct <name>sockaddr_in</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>ifa</name><operator>-&gt;</operator><name>ifa_addr</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>CNetAddr</name></type> <name>addr</name><argument_list>(<argument><expr><name><name>s4</name><operator>-&gt;</operator><name>sin_addr</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>AddLocal</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>LOCAL_IF</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"%s: IPv4 %s: %s\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><name><name>ifa</name><operator>-&gt;</operator><name>ifa_name</name></name></expr></argument>, <argument><expr><call><name><name>addr</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>ifa</name><operator>-&gt;</operator><name>ifa_addr</name><operator>-&gt;</operator><name>sa_family</name></name> <operator>==</operator> <name>AF_INET6</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_in6</name></name><modifier>*</modifier></type> <name>s6</name> <init>= <expr><operator>(</operator>struct <name>sockaddr_in6</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>ifa</name><operator>-&gt;</operator><name>ifa_addr</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>CNetAddr</name></type> <name>addr</name><argument_list>(<argument><expr><name><name>s6</name><operator>-&gt;</operator><name>sin6_addr</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>AddLocal</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>LOCAL_IF</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"%s: IPv6 %s: %s\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><name><name>ifa</name><operator>-&gt;</operator><name>ifa_name</name></name></expr></argument>, <argument><expr><call><name><name>addr</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>freeifaddrs</name><argument_list>(<argument><expr><name>myaddrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>SetNetworkActive</name></name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>active</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"SetNetworkActive: %s\n"</literal></expr></argument>, <argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>fNetworkActive</name> <operator>==</operator> <name>active</name></expr>)</condition> <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>fNetworkActive</name> <operator>=</operator> <name>active</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>uiInterface</name><operator>.</operator><name>NotifyNetworkActiveChanged</name></name><argument_list>(<argument><expr><name>fNetworkActive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<constructor><name><name>CConnman</name><operator>::</operator><name>CConnman</name></name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>nSeed0In</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>nSeed1In</name></decl></parameter>)</parameter_list> <member_init_list>: <call><name>nSeed0</name><argument_list>(<argument><expr><name>nSeed0In</name></expr></argument>)</argument_list></call>, <call><name>nSeed1</name><argument_list>(<argument><expr><name>nSeed1In</name></expr></argument>)</argument_list></call>
</member_init_list><block>{<block_content>
    <expr_stmt><expr><call><name>SetTryNewOutboundPeer</name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>Options</name></type> <name>connOptions</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>Init</name><argument_list>(<argument><expr><name>connOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></constructor>

<function><type><name>NodeId</name></type> <name><name>CConnman</name><operator>::</operator><name>GetNewNodeId</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name><name>nLastNodeId</name><operator>.</operator><name>fetch_add</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>memory_order_relaxed</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>bool</name></type> <name><name>CConnman</name><operator>::</operator><name>Bind</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CService</name> <modifier>&amp;</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>NetPermissionFlags</name></type> <name>permissions</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BF_EXPLICIT</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsReachable</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>strError</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BindListenPort</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>strError</name></expr></argument>, <argument><expr><name>permissions</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BF_REPORT_ERROR</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>clientInterface</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>clientInterface</name><operator>-&gt;</operator><name>ThreadSafeMessageBox</name></name><argument_list>(<argument><expr><name>strError</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>CClientUIInterface</name><operator>::</operator><name>MSG_ERROR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CConnman</name><operator>::</operator><name>InitBinds</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CService</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>binds</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>NetWhitebindPermissions</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>whiteBinds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>fBound</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>addrBind</name> <range>: <expr><name>binds</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><name>fBound</name> <operator>|=</operator> <call><name>Bind</name><argument_list>(<argument><expr><name>addrBind</name></expr></argument>, <argument><expr><operator>(</operator><name>BF_EXPLICIT</name> <operator>|</operator> <name>BF_REPORT_ERROR</name><operator>)</operator></expr></argument>, <argument><expr><name><name>NetPermissionFlags</name><operator>::</operator><name>PF_NONE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>addrBind</name> <range>: <expr><name>whiteBinds</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><name>fBound</name> <operator>|=</operator> <call><name>Bind</name><argument_list>(<argument><expr><name><name>addrBind</name><operator>.</operator><name>m_service</name></name></expr></argument>, <argument><expr><operator>(</operator><name>BF_EXPLICIT</name> <operator>|</operator> <name>BF_REPORT_ERROR</name><operator>)</operator></expr></argument>, <argument><expr><name><name>addrBind</name><operator>.</operator><name>m_flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><call><name><name>binds</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>whiteBinds</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>in_addr</name></name></type> <name>inaddr_any</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>inaddr_any</name><operator>.</operator><name>s_addr</name></name> <operator>=</operator> <name>INADDR_ANY</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>in6_addr</name></name></type> <name>inaddr6_any</name> <init>= <expr><name>IN6ADDR_ANY_INIT</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>fBound</name> <operator>|=</operator> <call><name>Bind</name><argument_list>(<argument><expr><call><name>CService</name><argument_list>(<argument><expr><name>inaddr6_any</name></expr></argument>, <argument><expr><call><name>GetListenPort</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BF_NONE</name></expr></argument>, <argument><expr><name><name>NetPermissionFlags</name><operator>::</operator><name>PF_NONE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>fBound</name> <operator>|=</operator> <call><name>Bind</name><argument_list>(<argument><expr><call><name>CService</name><argument_list>(<argument><expr><name>inaddr_any</name></expr></argument>, <argument><expr><call><name>GetListenPort</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><operator>!</operator><name>fBound</name></expr> ?</condition><then> <expr><name>BF_REPORT_ERROR</name></expr> </then><else>: <expr><name>BF_NONE</name></expr></else></ternary></expr></argument>, <argument><expr><name><name>NetPermissionFlags</name><operator>::</operator><name>PF_NONE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>fBound</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CConnman</name><operator>::</operator><name>Start</name></name><parameter_list>(<parameter><decl><type><name>CScheduler</name><modifier>&amp;</modifier></type> <name>scheduler</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Options</name><modifier>&amp;</modifier></type> <name>connOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Init</name><argument_list>(<argument><expr><name>connOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_totalBytesRecv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nTotalBytesRecv</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_totalBytesSent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nTotalBytesSent</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>nMaxOutboundTotalBytesSentInCycle</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>nMaxOutboundCycleStartTime</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block>

    <if_stmt><if>if <condition>(<expr><name>fListen</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>InitBinds</name><argument_list>(<argument><expr><name><name>connOptions</name><operator>.</operator><name>vBinds</name></name></expr></argument>, <argument><expr><name><name>connOptions</name><operator>.</operator><name>vWhiteBinds</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>clientInterface</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>clientInterface</name><operator>-&gt;</operator><name>ThreadSafeMessageBox</name></name><argument_list>(
                <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Failed to listen on any port. Use -listen=0 if you want this."</literal></expr></argument>)</argument_list></call><operator>.</operator><name>translated</name></expr></argument>,
                <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>CClientUIInterface</name><operator>::</operator><name>MSG_ERROR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>strDest</name> <range>: <expr><name><name>connOptions</name><operator>.</operator><name>vSeedNodes</name></name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>AddOneShot</name><argument_list>(<argument><expr><name>strDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>clientInterface</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>clientInterface</name><operator>-&gt;</operator><name>InitMessage</name></name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Loading P2P addresses..."</literal></expr></argument>)</argument_list></call><operator>.</operator><name>translated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="line">// Load addresses from peers.dat</comment>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>nStart</name> <init>= <expr><call><name>GetTimeMillis</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CAddrDB</name></type> <name>adb</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>adb</name><operator>.</operator><name>Read</name></name><argument_list>(<argument><expr><name>addrman</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"Loaded %i addresses from peers.dat  %dms\n"</literal></expr></argument>, <argument><expr><call><name><name>addrman</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>GetTimeMillis</name><argument_list>()</argument_list></call> <operator>-</operator> <name>nStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else <block>{<block_content>
            <expr_stmt><expr><call><name><name>addrman</name><operator>.</operator><name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// Addrman can be in an inconsistent state after failure, reset it</comment>
            <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"Invalid or missing peers.dat; recreating\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DumpAddresses</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name><name>uiInterface</name><operator>.</operator><name>InitMessage</name></name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Starting network threads..."</literal></expr></argument>)</argument_list></call><operator>.</operator><name>translated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>fAddressesInitialized</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>semOutbound</name> <operator>==</operator> <literal type="null">nullptr</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// initialize semaphore</comment>
        <expr_stmt><expr><name>semOutbound</name> <operator>=</operator> <call><name><name>MakeUnique</name><argument_list type="generic">&lt;<argument><expr><name>CSemaphore</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>min</name></name><argument_list>(<argument><expr><name>m_max_outbound</name></expr></argument>, <argument><expr><name>nMaxConnections</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>semAddnode</name> <operator>==</operator> <literal type="null">nullptr</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// initialize semaphore</comment>
        <expr_stmt><expr><name>semAddnode</name> <operator>=</operator> <call><name><name>MakeUnique</name><argument_list type="generic">&lt;<argument><expr><name>CSemaphore</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>nMaxAddnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//</comment>
    <comment type="line">// Start threads</comment>
    <comment type="line">//</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>m_msgproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>InterruptSocks5</name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>interruptNet</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>flagInterruptMsgProc</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>

    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>mutexMsgProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>fMsgProcWake</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="line">// Send and receive from sockets, accept connections</comment>
    <expr_stmt><expr><name>threadSocketHandler</name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>thread</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>TraceThread</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>function</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></expr></argument>, <argument><expr><literal type="string">"net"</literal></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>function</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><operator>)</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>bind</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CConnman</name><operator>::</operator><name>ThreadSocketHandler</name></name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>gArgs</name><operator>.</operator><name>GetBoolArg</name></name><argument_list>(<argument><expr><literal type="string">"-dnsseed"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"DNS seeding disabled\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>threadDNSAddressSeed</name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>thread</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>TraceThread</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>function</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></expr></argument>, <argument><expr><literal type="string">"dnsseed"</literal></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>function</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><operator>)</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>bind</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CConnman</name><operator>::</operator><name>ThreadDNSAddressSeed</name></name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="line">// Initiate outbound connections from -addnode</comment>
    <expr_stmt><expr><name>threadOpenAddedConnections</name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>thread</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>TraceThread</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>function</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></expr></argument>, <argument><expr><literal type="string">"addcon"</literal></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>function</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><operator>)</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>bind</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CConnman</name><operator>::</operator><name>ThreadOpenAddedConnections</name></name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>connOptions</name><operator>.</operator><name>m_use_addrman_outgoing</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>connOptions</name><operator>.</operator><name>m_specified_outgoing</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>clientInterface</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>clientInterface</name><operator>-&gt;</operator><name>ThreadSafeMessageBox</name></name><argument_list>(
                <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Cannot provide specific connections and have addrman find outgoing connections at the same."</literal></expr></argument>)</argument_list></call><operator>.</operator><name>translated</name></expr></argument>,
                <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>CClientUIInterface</name><operator>::</operator><name>MSG_ERROR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>connOptions</name><operator>.</operator><name>m_use_addrman_outgoing</name></name> <operator>||</operator> <operator>!</operator><call><name><name>connOptions</name><operator>.</operator><name>m_specified_outgoing</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>threadOpenConnections</name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>thread</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>TraceThread</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>function</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></expr></argument>, <argument><expr><literal type="string">"opencon"</literal></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>function</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><operator>)</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>bind</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CConnman</name><operator>::</operator><name>ThreadOpenConnections</name></name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>connOptions</name><operator>.</operator><name>m_specified_outgoing</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">// Process messages</comment>
    <expr_stmt><expr><name>threadMessageHandler</name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>thread</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>TraceThread</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>function</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></expr></argument>, <argument><expr><literal type="string">"msghand"</literal></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>function</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><operator>)</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>bind</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CConnman</name><operator>::</operator><name>ThreadMessageHandler</name></name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Dump network addresses</comment>
    <expr_stmt><expr><call><name><name>scheduler</name><operator>.</operator><name>scheduleEvery</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>bind</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CConnman</name><operator>::</operator><name>DumpAddresses</name></name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>DUMP_PEERS_INTERVAL</name> <operator>*</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<class>class <name>CNetCleanup</name>
<block>{<private type="default">
</private><public>public:
    <constructor><name>CNetCleanup</name><parameter_list>()</parameter_list> <block>{<block_content/>}</block></constructor>

    <destructor><name>~CNetCleanup</name><parameter_list>()</parameter_list>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
        <comment type="line">// Shutdown Windows Sockets</comment>
        <expr_stmt><expr><call><name>WSACleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></destructor>
</public>}</block>;</class>
<decl_stmt><decl><type><specifier>static</specifier> <name>CNetCleanup</name></type> <name>instance_of_cnetcleanup</name></decl>;</decl_stmt>

<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>Interrupt</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>lock_guard</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>mutex</name></name></expr></argument>&gt;</argument_list></name></type> <name>lock</name><argument_list>(<argument><expr><name>mutexMsgProc</name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <expr_stmt><expr><name>flagInterruptMsgProc</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name><name>condMsgProc</name><operator>.</operator><name>notify_all</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>interruptNet</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>InterruptSocks5</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>semOutbound</name></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>m_max_outbound</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>semOutbound</name><operator>-&gt;</operator><name>post</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>semAddnode</name></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nMaxAddnode</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>semAddnode</name><operator>-&gt;</operator><name>post</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>Stop</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name><name>threadMessageHandler</name><operator>.</operator><name>joinable</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name><name>threadMessageHandler</name><operator>.</operator><name>join</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>threadOpenConnections</name><operator>.</operator><name>joinable</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name><name>threadOpenConnections</name><operator>.</operator><name>join</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>threadOpenAddedConnections</name><operator>.</operator><name>joinable</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name><name>threadOpenAddedConnections</name><operator>.</operator><name>join</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>threadDNSAddressSeed</name><operator>.</operator><name>joinable</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name><name>threadDNSAddressSeed</name><operator>.</operator><name>join</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>threadSocketHandler</name><operator>.</operator><name>joinable</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name><name>threadSocketHandler</name><operator>.</operator><name>join</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>fAddressesInitialized</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>DumpAddresses</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>fAddressesInitialized</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Close sockets</comment>
    <for>for <control>(<init><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <range>: <expr><name>vNodes</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>CloseSocketDisconnect</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <for>for <control>(<init><decl><type><name>ListenSocket</name><modifier>&amp;</modifier></type> <name>hListenSocket</name> <range>: <expr><name>vhListenSocket</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name><name>hListenSocket</name><operator>.</operator><name>socket</name></name> <operator>!=</operator> <name>INVALID_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CloseSocket</name><argument_list>(<argument><expr><name><name>hListenSocket</name><operator>.</operator><name>socket</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"CloseSocket(hListenSocket) failed with error %s\n"</literal></expr></argument>, <argument><expr><call><name>NetworkErrorString</name><argument_list>(<argument><expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></for>

    <comment type="line">// clean up some globals (to help leak detection)</comment>
    <for>for <control>(<init><decl><type><name>CNode</name> <modifier>*</modifier></type><name>pnode</name> <range>: <expr><name>vNodes</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>DeleteNode</name><argument_list>(<argument><expr><name>pnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <for>for <control>(<init><decl><type><name>CNode</name> <modifier>*</modifier></type><name>pnode</name> <range>: <expr><name>vNodesDisconnected</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>DeleteNode</name><argument_list>(<argument><expr><name>pnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name><name>vNodes</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>vNodesDisconnected</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>vhListenSocket</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>semOutbound</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>semAddnode</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>DeleteNode</name></name><parameter_list>(<parameter><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>fUpdateConnectionTime</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>m_msgproc</name><operator>-&gt;</operator><name>FinalizeNode</name></name><argument_list>(<argument><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>fUpdateConnectionTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>fUpdateConnectionTime</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>addrman</name><operator>.</operator><name>Connected</name></name><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>delete</operator> <name>pnode</name></expr>;</expr_stmt>
</block_content>}</block></function>

<destructor><name><name>CConnman</name><operator>::</operator><name>~CConnman</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Interrupt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Stop</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></destructor>

<function><type><name>size_t</name></type> <name><name>CConnman</name><operator>::</operator><name>GetAddressCount</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <return>return <expr><call><name><name>addrman</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>SetServices</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CService</name> <modifier>&amp;</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>ServiceFlags</name></type> <name>nServices</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name><name>addrman</name><operator>.</operator><name>SetServices</name></name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>nServices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>MarkAddressGood</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CAddress</name><modifier>&amp;</modifier></type> <name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name><name>addrman</name><operator>.</operator><name>Good</name></name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>AddNewAddresses</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CAddress</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>vAddr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CAddress</name><modifier>&amp;</modifier></type> <name>addrFrom</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>nTimePenalty</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name><name>addrman</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>vAddr</name></expr></argument>, <argument><expr><name>addrFrom</name></expr></argument>, <argument><expr><name>nTimePenalty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CAddress</name></expr></argument>&gt;</argument_list></name></type> <name><name>CConnman</name><operator>::</operator><name>GetAddresses</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name><name>addrman</name><operator>.</operator><name>GetAddr</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CConnman</name><operator>::</operator><name>AddNode</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>strNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vAddedNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>it</name> <range>: <expr><name>vAddedNodes</name></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>strNode</name> <operator>==</operator> <name>it</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name><name>vAddedNodes</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>strNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CConnman</name><operator>::</operator><name>RemoveAddedNode</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>strNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vAddedNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>&gt;</argument_list><operator>::</operator><name>iterator</name></name></type> <name>it</name> <init>= <expr><call><name><name>vAddedNodes</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>it</name> <operator>!=</operator> <call><name><name>vAddedNodes</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>it</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>strNode</name> <operator>==</operator> <operator>*</operator><name>it</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>vAddedNodes</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name><name>CConnman</name><operator>::</operator><name>GetNodeCount</name></name><parameter_list>(<parameter><decl><type><name>NumConnections</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>==</operator> <name><name>CConnman</name><operator>::</operator><name>CONNECTIONS_ALL</name></name></expr>)</condition><block type="pseudo"><block_content> <comment type="line">// Shortcut if we want total</comment>
        <return>return <expr><call><name><name>vNodes</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>nNum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>pnode</name> <range>: <expr><name>vNodes</name></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <operator>(</operator><ternary><condition><expr><name><name>pnode</name><operator>-&gt;</operator><name>fInbound</name></name></expr> ?</condition><then> <expr><name>CONNECTIONS_IN</name></expr> </then><else>: <expr><name>CONNECTIONS_OUT</name></expr></else></ternary><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>nNum</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>nNum</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>GetNodeStats</name></name><parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CNodeStats</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>vstats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name><name>vstats</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>vstats</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>vNodes</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <range>: <expr><name>vNodes</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>vstats</name><operator>.</operator><name>emplace_back</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>copyStats</name></name><argument_list>(<argument><expr><call><name><name>vstats</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CConnman</name><operator>::</operator><name>DisconnectNode</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>strNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <init>= <expr><call><name>FindNode</name><argument_list>(<argument><expr><name>strNode</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>pnode</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CConnman</name><operator>::</operator><name>DisconnectNode</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CSubNet</name><modifier>&amp;</modifier></type> <name>subnet</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>disconnected</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <range>: <expr><name>vNodes</name></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>subnet</name><operator>.</operator><name>Match</name></name><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>pnode</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>disconnected</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>disconnected</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CConnman</name><operator>::</operator><name>DisconnectNode</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CNetAddr</name><modifier>&amp;</modifier></type> <name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>DisconnectNode</name><argument_list>(<argument><expr><call><name>CSubNet</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CConnman</name><operator>::</operator><name>DisconnectNode</name></name><parameter_list>(<parameter><decl><type><name>NodeId</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name> <range>: <expr><name>vNodes</name></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <call><name><name>pnode</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>pnode</name><operator>-&gt;</operator><name>fDisconnect</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>RecordBytesRecv</name></name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>bytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_totalBytesRecv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nTotalBytesRecv</name> <operator>+=</operator> <name>bytes</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>RecordBytesSent</name></name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>bytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_totalBytesSent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nTotalBytesSent</name> <operator>+=</operator> <name>bytes</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>uint64_t</name></type> <name>now</name> <init>= <expr><call><name>GetTime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>nMaxOutboundCycleStartTime</name> <operator>+</operator> <name>nMaxOutboundTimeframe</name> <operator>&lt;</operator> <name>now</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// timeframe expired, reset cycle</comment>
        <expr_stmt><expr><name>nMaxOutboundCycleStartTime</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nMaxOutboundTotalBytesSentInCycle</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// TODO, exclude whitebind peers</comment>
    <expr_stmt><expr><name>nMaxOutboundTotalBytesSentInCycle</name> <operator>+=</operator> <name>bytes</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>SetMaxOutboundTarget</name></name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>limit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_totalBytesSent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nMaxOutboundLimit</name> <operator>=</operator> <name>limit</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>uint64_t</name></type> <name><name>CConnman</name><operator>::</operator><name>GetMaxOutboundTarget</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_totalBytesSent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>nMaxOutboundLimit</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint64_t</name></type> <name><name>CConnman</name><operator>::</operator><name>GetMaxOutboundTimeframe</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_totalBytesSent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>nMaxOutboundTimeframe</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint64_t</name></type> <name><name>CConnman</name><operator>::</operator><name>GetMaxOutboundTimeLeftInCycle</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_totalBytesSent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nMaxOutboundLimit</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>nMaxOutboundCycleStartTime</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>nMaxOutboundTimeframe</name></expr>;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>uint64_t</name></type> <name>cycleEndTime</name> <init>= <expr><name>nMaxOutboundCycleStartTime</name> <operator>+</operator> <name>nMaxOutboundTimeframe</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>now</name> <init>= <expr><call><name>GetTime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><ternary><condition><expr><operator>(</operator><name>cycleEndTime</name> <operator>&lt;</operator> <name>now</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>cycleEndTime</name> <operator>-</operator> <call><name>GetTime</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>SetMaxOutboundTimeframe</name></name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>timeframe</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_totalBytesSent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nMaxOutboundTimeframe</name> <operator>!=</operator> <name>timeframe</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// reset measure-cycle in case of changing</comment>
        <comment type="line">// the timeframe</comment>
        <expr_stmt><expr><name>nMaxOutboundCycleStartTime</name> <operator>=</operator> <call><name>GetTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nMaxOutboundTimeframe</name> <operator>=</operator> <name>timeframe</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CConnman</name><operator>::</operator><name>OutboundTargetReached</name></name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>historicalBlockServingLimit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_totalBytesSent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nMaxOutboundLimit</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>historicalBlockServingLimit</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// keep a large enough buffer to at least relay each block once</comment>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>timeLeftInCycle</name> <init>= <expr><call><name>GetMaxOutboundTimeLeftInCycle</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>buffer</name> <init>= <expr><name>timeLeftInCycle</name> <operator>/</operator> <literal type="number">600</literal> <operator>*</operator> <name>MAX_BLOCK_SERIALIZED_SIZE</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>&gt;=</operator> <name>nMaxOutboundLimit</name> <operator>||</operator> <name>nMaxOutboundTotalBytesSentInCycle</name> <operator>&gt;=</operator> <name>nMaxOutboundLimit</name> <operator>-</operator> <name>buffer</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>nMaxOutboundTotalBytesSentInCycle</name> <operator>&gt;=</operator> <name>nMaxOutboundLimit</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint64_t</name></type> <name><name>CConnman</name><operator>::</operator><name>GetOutboundTargetBytesLeft</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_totalBytesSent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nMaxOutboundLimit</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><ternary><condition><expr><operator>(</operator><name>nMaxOutboundTotalBytesSentInCycle</name> <operator>&gt;=</operator> <name>nMaxOutboundLimit</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>nMaxOutboundLimit</name> <operator>-</operator> <name>nMaxOutboundTotalBytesSentInCycle</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint64_t</name></type> <name><name>CConnman</name><operator>::</operator><name>GetTotalBytesRecv</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_totalBytesRecv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>nTotalBytesRecv</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint64_t</name></type> <name><name>CConnman</name><operator>::</operator><name>GetTotalBytesSent</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_totalBytesSent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>nTotalBytesSent</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ServiceFlags</name></type> <name><name>CConnman</name><operator>::</operator><name>GetLocalServices</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <return>return <expr><name>nLocalServices</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>SetBestHeight</name></name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name><name>nBestHeight</name><operator>.</operator><name>store</name></name><argument_list>(<argument><expr><name>height</name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>memory_order_release</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name><name>CConnman</name><operator>::</operator><name>GetBestHeight</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <return>return <expr><call><name><name>nBestHeight</name><operator>.</operator><name>load</name></name><argument_list>(<argument><expr><name><name>std</name><operator>::</operator><name>memory_order_acquire</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>int</name></type> <name><name>CConnman</name><operator>::</operator><name>GetReceiveFloodSize</name></name><parameter_list>()</parameter_list> <specifier>const</specifier> <block>{<block_content> <return>return <expr><name>nReceiveFloodSize</name></expr>;</return> </block_content>}</block></function>

<constructor><name><name>CNode</name><operator>::</operator><name>CNode</name></name><parameter_list>(<parameter><decl><type><name>NodeId</name></type> <name>idIn</name></decl></parameter>, <parameter><decl><type><name>ServiceFlags</name></type> <name>nLocalServicesIn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nMyStartingHeightIn</name></decl></parameter>, <parameter><decl><type><name>SOCKET</name></type> <name>hSocketIn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CAddress</name><modifier>&amp;</modifier></type> <name>addrIn</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>nKeyedNetGroupIn</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>nLocalHostNonceIn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CAddress</name><modifier>&amp;</modifier></type> <name>addrBindIn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>addrNameIn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fInboundIn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>block_relay_only</name></decl></parameter>)</parameter_list>
    <member_init_list>: <call><name>nTimeConnected</name><argument_list>(<argument><expr><call><name>GetSystemTimeInSeconds</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>,
    <call><name>addr</name><argument_list>(<argument><expr><name>addrIn</name></expr></argument>)</argument_list></call>,
    <call><name>addrBind</name><argument_list>(<argument><expr><name>addrBindIn</name></expr></argument>)</argument_list></call>,
    <call><name>fInbound</name><argument_list>(<argument><expr><name>fInboundIn</name></expr></argument>)</argument_list></call>,
    <call><name>nKeyedNetGroup</name><argument_list>(<argument><expr><name>nKeyedNetGroupIn</name></expr></argument>)</argument_list></call>,
    <comment type="line">// Don't relay addr messages to peers that we connect to as block-relay-only</comment>
    <comment type="line">// peers (to prevent adversaries from inferring these links from addr</comment>
    <comment type="line">// traffic).</comment>
    <call><name>m_addr_known</name><argument_list>{<argument><expr><ternary><condition><expr><name>block_relay_only</name></expr> ?</condition><then> <expr><literal type="null">nullptr</literal></expr> </then><else>: <macro><name>MakeUnique</name></macro><expr><operator>&lt;</operator><name>CRollingBloomFilter</name><operator>&gt;</operator><operator>(</operator><literal type="number">5000</literal><operator>,</operator> <literal type="number">0.001</literal><operator>)</operator></expr></else></ternary></expr></argument>}</argument_list></call>,
    <call><name>id</name><argument_list>(<argument><expr><name>idIn</name></expr></argument>)</argument_list></call>,
    <call><name>nLocalHostNonce</name><argument_list>(<argument><expr><name>nLocalHostNonceIn</name></expr></argument>)</argument_list></call>,
    <call><name>nLocalServices</name><argument_list>(<argument><expr><name>nLocalServicesIn</name></expr></argument>)</argument_list></call>,
    <call><name>nMyStartingHeight</name><argument_list>(<argument><expr><name>nMyStartingHeightIn</name></expr></argument>)</argument_list></call>
</member_init_list><block>{<block_content>
    <expr_stmt><expr><name>hSocket</name> <operator>=</operator> <name>hSocketIn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrName</name> <operator>=</operator> <ternary><condition><expr><name>addrNameIn</name> <operator>==</operator> <literal type="string">""</literal></expr> ?</condition><then> <expr><call><name><name>addr</name><operator>.</operator><name>ToStringIPPort</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><name>addrNameIn</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>hashContinue</name> <operator>=</operator> <call><name>uint256</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>block_relay_only</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>m_tx_relay</name> <operator>=</operator> <call><name><name>MakeUnique</name><argument_list type="generic">&lt;<argument><expr><name>TxRelay</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>msg</name> <range>: <expr><call><name>getAllNetMessageTypes</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>mapRecvBytesPerMsgCmd</name><index>[<expr><name>msg</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name><name>mapRecvBytesPerMsgCmd</name><index>[<expr><name>NET_MESSAGE_COMMAND_OTHER</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>fLogIPs</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"Added connection to %s peer=%d\n"</literal></expr></argument>, <argument><expr><name>addrName</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"Added connection peer=%d\n"</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>m_deserializer</name> <operator>=</operator> <call><name><name>MakeUnique</name><argument_list type="generic">&lt;<argument><expr><name>V1TransportDeserializer</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>V1TransportDeserializer</name><argument_list>(<argument><expr><call><name>Params</name><argument_list>()</argument_list></call><operator>.</operator><call><name>MessageStart</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SER_NETWORK</name></expr></argument>, <argument><expr><name>INIT_PROTO_VERSION</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></constructor>

<destructor><name><name>CNode</name><operator>::</operator><name>~CNode</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>CloseSocket</name><argument_list>(<argument><expr><name>hSocket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></destructor>

<function><type><name>bool</name></type> <name><name>CConnman</name><operator>::</operator><name>NodeFullyConnected</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CNode</name><modifier>*</modifier></type> <name>pnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>pnode</name> <operator>&amp;&amp;</operator> <name><name>pnode</name><operator>-&gt;</operator><name>fSuccessfullyConnected</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pnode</name><operator>-&gt;</operator><name>fDisconnect</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CConnman</name><operator>::</operator><name>PushMessage</name></name><parameter_list>(<parameter><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name></decl></parameter>, <parameter><decl><type><name>CSerializedNetMsg</name><modifier>&amp;&amp;</modifier></type> <name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>nMessageSize</name> <init>= <expr><call><name><name>msg</name><operator>.</operator><name>data</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>nTotalSize</name> <init>= <expr><name>nMessageSize</name> <operator>+</operator> <name><name>CMessageHeader</name><operator>::</operator><name>HEADER_SIZE</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>NET</name></name></expr></argument>, <argument><expr><literal type="string">"sending %s (%d bytes) peer=%d\n"</literal></expr></argument>,  <argument><expr><call><name>SanitizeString</name><argument_list>(<argument><expr><name><name>msg</name><operator>.</operator><name>command</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nMessageSize</name></expr></argument>, <argument><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>serializedHeader</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>serializedHeader</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><name><name>CMessageHeader</name><operator>::</operator><name>HEADER_SIZE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>uint256</name></type> <name>hash</name> <init>= <expr><call><name>Hash</name><argument_list>(<argument><expr><call><name><name>msg</name><operator>.</operator><name>data</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>msg</name><operator>.</operator><name>data</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>nMessageSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CMessageHeader</name></type> <name>hdr</name><argument_list>(<argument><expr><call><name>Params</name><argument_list>()</argument_list></call><operator>.</operator><call><name>MessageStart</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>msg</name><operator>.</operator><name>command</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nMessageSize</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>hdr</name><operator>.</operator><name>pchChecksum</name></name></expr></argument>, <argument><expr><call><name><name>hash</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>CMessageHeader</name><operator>::</operator><name>CHECKSUM_SIZE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>CVectorWriter</name><argument_list>{<argument><expr><name>SER_NETWORK</name></expr></argument>, <argument><expr><name>INIT_PROTO_VERSION</name></expr></argument>, <argument><expr><name>serializedHeader</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>hdr</name></expr></argument>}</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>size_t</name></type> <name>nBytesSent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pnode</name><operator>-&gt;</operator><name>cs_vSend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>optimisticSend</name><argument_list>(<argument><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>vSendMsg</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

        <comment type="line">//log total amount of bytes per command</comment>
        <expr_stmt><expr><name><name>pnode</name><operator>-&gt;</operator><name>mapSendBytesPerMsgCmd</name><index>[<expr><name><name>msg</name><operator>.</operator><name>command</name></name></expr>]</index></name> <operator>+=</operator> <name>nTotalSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pnode</name><operator>-&gt;</operator><name>nSendSize</name></name> <operator>+=</operator> <name>nTotalSize</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pnode</name><operator>-&gt;</operator><name>nSendSize</name></name> <operator>&gt;</operator> <name>nSendBufferMaxSize</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>pnode</name><operator>-&gt;</operator><name>fPauseSend</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>vSendMsg</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>serializedHeader</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nMessageSize</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>pnode</name><operator>-&gt;</operator><name>vSendMsg</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name><name>msg</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// If write queue empty, attempt "optimistic write"</comment>
        <if_stmt><if>if <condition>(<expr><name>optimisticSend</name> <operator>==</operator> <literal type="boolean">true</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>nBytesSent</name> <operator>=</operator> <call><name>SocketSendData</name><argument_list>(<argument><expr><name>pnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>
    <if_stmt><if>if <condition>(<expr><name>nBytesSent</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>RecordBytesSent</name><argument_list>(<argument><expr><name>nBytesSent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CConnman</name><operator>::</operator><name>ForNode</name></name><parameter_list>(<parameter><decl><type><name>NodeId</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>function</name><argument_list type="generic">&lt;<argument><expr><name>bool</name><operator>(</operator><name>CNode</name><modifier>*</modifier> <name>pnode</name><operator>)</operator></expr></argument>&gt;</argument_list></name></type> <name>func</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CNode</name><modifier>*</modifier></type> <name>found</name> <init>= <expr><literal type="null">nullptr</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>auto</name><operator>&amp;&amp;</operator> <name>pnode</name> <operator>:</operator> <name>vNodes</name></expr></init>)</control> <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><call><name><name>pnode</name><operator>-&gt;</operator><name>GetId</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>id</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>found</name> <operator>=</operator> <name>pnode</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>found</name> <operator>!=</operator> <literal type="null">nullptr</literal> <operator>&amp;&amp;</operator> <call><name>NodeFullyConnected</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>func</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int64_t</name></type> <name><name>CConnman</name><operator>::</operator><name>PoissonNextSendInbound</name></name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>now</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>average_interval_seconds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>m_next_send_inv_to_incoming</name> <operator>&lt;</operator> <name>now</name></expr>)</condition> <block>{<block_content>
        <comment type="line">// If this function were called from multiple threads simultaneously</comment>
        <comment type="line">// it would possible that both update the next send variable, and return a different result to their caller.</comment>
        <comment type="line">// This is not possible in practice as only the net processing thread invokes this function.</comment>
        <expr_stmt><expr><name>m_next_send_inv_to_incoming</name> <operator>=</operator> <call><name>PoissonNextSend</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><name>average_interval_seconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>m_next_send_inv_to_incoming</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int64_t</name></type> <name>PoissonNextSend</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>now</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>average_interval_seconds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>now</name> <operator>+</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><operator>(</operator><call><name>log1p</name><argument_list>(<argument><expr><call><name>GetRand</name><argument_list>(<argument><expr><literal type="number">1ULL</literal> <operator>&lt;&lt;</operator> <literal type="number">48</literal></expr></argument>)</argument_list></call> <operator>*</operator> <operator>-</operator><literal type="number">0.0000000000000035527136788</literal></expr></argument> <comment type="block">/* -1/2^48 */</comment>)</argument_list></call> <operator>*</operator> <name>average_interval_seconds</name> <operator>*</operator> <operator>-</operator><literal type="number">1000000.0</literal> <operator>+</operator> <literal type="number">0.5</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>CSipHasher</name></type> <name><name>CConnman</name><operator>::</operator><name>GetDeterministicRandomizer</name></name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>id</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <return>return <expr><call><name>CSipHasher</name><argument_list>(<argument><expr><name>nSeed0</name></expr></argument>, <argument><expr><name>nSeed1</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>Write</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint64_t</name></type> <name><name>CConnman</name><operator>::</operator><name>CalculateKeyedNetGroup</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CAddress</name><modifier>&amp;</modifier></type> <name>ad</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>vchNetGroup</name><argument_list>(<argument><expr><call><name><name>ad</name><operator>.</operator><name>GetGroup</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

    <return>return <expr><call><name>GetDeterministicRandomizer</name><argument_list>(<argument><expr><name>RANDOMIZER_ID_NETGROUP</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>Write</name><argument_list>(<argument><expr><call><name><name>vchNetGroup</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>vchNetGroup</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>Finalize</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
