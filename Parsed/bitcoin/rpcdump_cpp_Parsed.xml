<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C++" filename="/home/mmm/Projects/bitcoin/src/wallet/rpcdump.cpp"><comment type="line">// Copyright (c) 2009-2019 The Bitcoin Core developers</comment>
<comment type="line">// Distributed under the MIT software license, see the accompanying</comment>
<comment type="line">// file COPYING or http://www.opensource.org/licenses/mit-license.php.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;chain.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;core_io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;interfaces/chain.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;key_io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;merkleblock.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;rpc/util.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;script/descriptor.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;script/script.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;script/standard.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sync.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/bip32.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/system.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/translation.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;wallet/rpcwallet.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;wallet/wallet.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;tuple&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;boost/algorithm/string.hpp&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;univalue.h&gt;</cpp:file></cpp:include>



<function><type><name><name>std</name><operator>::</operator><name>string</name></name> <specifier>static</specifier></type> <name>EncodeDumpString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>stringstream</name></name></type> <name>ret</name></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name>c</name> <range>: <expr><name>str</name></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;=</operator> <literal type="number">32</literal> <operator>||</operator> <name>c</name> <operator>&gt;=</operator> <literal type="number">128</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'%'</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>ret</name> <operator>&lt;&lt;</operator> <literal type="char">'%'</literal> <operator>&lt;&lt;</operator> <call><name>HexStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>ret</name> <operator>&lt;&lt;</operator> <name>c</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><call><name><name>ret</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>std</name><operator>::</operator><name>string</name></name></type> <name>DecodeDumpString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>stringstream</name></name></type> <name>ret</name></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>pos</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name> <init>= <expr><name><name>str</name><index>[<expr><name>pos</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'%'</literal> <operator>&amp;&amp;</operator> <name>pos</name><operator>+</operator><literal type="number">2</literal> <operator>&lt;</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name><name>str</name><index>[<expr><name>pos</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>&gt;&gt;</operator><literal type="number">6</literal><operator>)</operator><operator>*</operator><literal type="number">9</literal><operator>+</operator><operator>(</operator><operator>(</operator><name><name>str</name><index>[<expr><name>pos</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>-</operator><literal type="char">'0'</literal><operator>)</operator><operator>&amp;</operator><literal type="number">15</literal><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>|</operator>
                <operator>(</operator><operator>(</operator><name><name>str</name><index>[<expr><name>pos</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name><operator>&gt;&gt;</operator><literal type="number">6</literal><operator>)</operator><operator>*</operator><literal type="number">9</literal><operator>+</operator><operator>(</operator><operator>(</operator><name><name>str</name><index>[<expr><name>pos</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name><operator>-</operator><literal type="char">'0'</literal><operator>)</operator><operator>&amp;</operator><literal type="number">15</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>pos</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>ret</name> <operator>&lt;&lt;</operator> <name>c</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><call><name><name>ret</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>GetWalletAddressesForKey</name><argument_list>(<argument><expr><name>LegacyScriptPubKeyMan</name><operator>*</operator> <name>spk_man</name></expr></argument>, <argument><expr><name>CWallet</name><operator>*</operator> <specifier>const</specifier> <name>pwallet</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CKeyID</name><operator>&amp;</operator> <name>keyid</name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>string</name></name><operator>&amp;</operator> <name>strAddr</name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>string</name></name><operator>&amp;</operator> <name>strLabel</name></expr></argument>)</argument_list> <name>EXCLUSIVE_LOCKS_REQUIRED</name><argument_list>(<argument><expr><name><name>pwallet</name><operator>-&gt;</operator><name>cs_wallet</name></name></expr></argument>)</argument_list>
<argument_list>{
    <argument><expr><name>bool</name> <name>fLabelFound</name> <operator>=</operator> <literal type="boolean">false</literal></expr></argument>;
    <argument><expr><name>CKey</name> <name>key</name></expr></argument>;
    <argument><expr><call><name><name>spk_man</name><operator>-&gt;</operator><name>GetKey</name></name><argument_list>(<argument><expr><name>keyid</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>;
    for <argument><expr><operator>(</operator><specifier>const</specifier> <name>auto</name><operator>&amp;</operator> <name>dest</name> <operator>:</operator> <call><name>GetAllDestinationsForKey</name><argument_list>(<argument><expr><call><name><name>key</name><operator>.</operator><name>GetPubKey</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <block>{
        <if_stmt><if>if <condition>(<expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>mapAddressBook</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>)</condition> <expr_stmt><expr><block>{
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>strAddr</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <expr_stmt><expr><block>{
                <expr><name>strAddr</name> <operator>+=</operator> <literal type="string">","</literal></expr>;
            }</block>
            <name>strAddr</name> <operator>+=</operator> <call><name>EncodeDestination</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></if></if_stmt>
            <name>strLabel</name> <operator>=</operator> <call><name>EncodeDumpString</name><argument_list>(<argument><expr><name><name>pwallet</name><operator>-&gt;</operator><name>mapAddressBook</name><index>[<expr><name>dest</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt></if></if_stmt>
            <name>fLabelFound</name> <operator>=</operator> <literal type="boolean">true</literal></block></expr></argument>;
        }</argument_list></decl></decl_stmt>
    }
    if <expr_stmt><expr><operator>(</operator><operator>!</operator><name>fLabelFound</name><operator>)</operator> <block>{
        <expr><name>strAddr</name> <operator>=</operator> <call><name>EncodeDestination</name><argument_list>(<argument><expr><call><name>GetDestinationForKey</name><argument_list>(<argument><expr><call><name><name>key</name><operator>.</operator><name>GetPubKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>pwallet</name><operator>-&gt;</operator><name>m_default_address_type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    }</block></expr></expr_stmt>
    <return>return <expr><name>fLabelFound</name></expr>;</return>
}

static <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>TIMESTAMP_MIN</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>RescanWallet</name><parameter_list>(<parameter><decl><type><name>CWallet</name><modifier>&amp;</modifier></type> <name>wallet</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>WalletRescanReserver</name><modifier>&amp;</modifier></type> <name>reserver</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>time_begin</name> <init>= <expr><name>TIMESTAMP_MIN</name></expr></init></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>update</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>scanned_time</name> <init>= <expr><call><name><name>wallet</name><operator>.</operator><name>RescanFromTime</name></name><argument_list>(<argument><expr><name>time_begin</name></expr></argument>, <argument><expr><name>reserver</name></expr></argument>, <argument><expr><name>update</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>wallet</name><operator>.</operator><name>IsAbortingRescan</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_MISC_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Rescan aborted by user."</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>scanned_time</name> <operator>&gt;</operator> <name>time_begin</name></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_WALLET_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Rescan was unable to fully rescan the blockchain. Some transactions may be missing."</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>UniValue</name></type> <name>importprivkey</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>JSONRPCRequest</name><modifier>&amp;</modifier></type> <name>request</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CWallet</name></expr></argument>&gt;</argument_list></name> <specifier>const</specifier></type> <name>wallet</name> <init>= <expr><call><name>GetWalletForJSONRPCRequest</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CWallet</name><modifier>*</modifier> <specifier>const</specifier></type> <name>pwallet</name> <init>= <expr><call><name><name>wallet</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EnsureWalletIsAvailable</name><argument_list>(<argument><expr><name>pwallet</name></expr></argument>, <argument><expr><name><name>request</name><operator>.</operator><name>fHelp</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>NullUniValue</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>RPCHelpMan</name><argument_list>{<argument><expr><literal type="string">"importprivkey"</literal></expr></argument>,
                <argument><expr><literal type="string">"\nAdds a private key (as returned by dumpprivkey) to your wallet. Requires a new wallet backup.\n"</literal>
                <literal type="string">"Hint: use importmulti to import more than one private key.\n"</literal>
            <literal type="string">"\nNote: This call can take over an hour to complete if rescan is true, during that time, other rpc calls\n"</literal>
            <literal type="string">"may report that the imported key exists but related transactions are still missing, leading to temporarily incorrect/bogus balances and unspent outputs until rescan completes.\n"</literal>
            <literal type="string">"Note: Use \"getwalletinfo\" to query the scanning progress.\n"</literal></expr></argument>,
                <block>{<block_content>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"privkey"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"The private key (see dumpprivkey)"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"label"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR</name></name></expr><operator>,</operator> <comment type="block">/* default */</comment> <expr><literal type="string">"current label if address exists, otherwise \"\""</literal></expr><operator>,</operator> <expr><literal type="string">"An optional label"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"rescan"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>BOOL</name></name></expr><operator>,</operator> <comment type="block">/* default */</comment> <expr><literal type="string">"true"</literal></expr><operator>,</operator> <expr><literal type="string">"Rescan the wallet for transactions"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                <expr_stmt/>}</block_content></block>,
                <argument><expr><call><name>RPCResults</name><argument_list>{}</argument_list></call></expr></argument>,
                <argument><expr><call><name>RPCExamples</name><argument_list>{
            <argument><expr><literal type="string">"\nDump a private key\n"</literal>
            <operator>+</operator> <call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"dumpprivkey"</literal></expr></argument>, <argument><expr><literal type="string">"\"myaddress\""</literal></expr></argument>)</argument_list></call> <operator>+</operator>
            <literal type="string">"\nImport the private key with rescan\n"</literal>
            <operator>+</operator> <call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"importprivkey"</literal></expr></argument>, <argument><expr><literal type="string">"\"mykey\""</literal></expr></argument>)</argument_list></call> <operator>+</operator>
            <literal type="string">"\nImport using a label and without rescan\n"</literal>
            <operator>+</operator> <call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"importprivkey"</literal></expr></argument>, <argument><expr><literal type="string">"\"mykey\" \"testing\" false"</literal></expr></argument>)</argument_list></call> <operator>+</operator>
            <literal type="string">"\nImport using default blank label and without rescan\n"</literal>
            <operator>+</operator> <call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"importprivkey"</literal></expr></argument>, <argument><expr><literal type="string">"\"mykey\" \"\" false"</literal></expr></argument>)</argument_list></call> <operator>+</operator>
            <literal type="string">"\nAs a JSON-RPC call\n"</literal>
            <operator>+</operator> <macro><name>HelpExampleRpc</name><argument_list>(<argument><literal type="string">"importprivkey"</literal></argument>, <argument><literal type="string">"\"mykey\", \"testing\", false"</literal></argument>)</argument_list></macro></expr></argument>
                }</argument_list></call></expr></argument>,
            }</argument_list></call><operator>.</operator><call><name>Check</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>IsWalletFlagSet</name></name><argument_list>(<argument><expr><name>WALLET_FLAG_DISABLE_PRIVATE_KEYS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_WALLET_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Cannot import private keys to a wallet with private keys disabled"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>EnsureLegacyScriptPubKeyMan</name><argument_list>(<argument><expr><operator>*</operator><name>wallet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>WalletRescanReserver</name></type> <name>reserver</name><argument_list>(<argument><expr><name>pwallet</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>fRescan</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>
    <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>locked_chain</name> <init>= <expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>chain</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pwallet</name><operator>-&gt;</operator><name>cs_wallet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>EnsureWalletIsUnlocked</name><argument_list>(<argument><expr><name>pwallet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>strSecret</name> <init>= <expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>strLabel</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>strLabel</name> <operator>=</operator> <name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Whether to perform rescan after import</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>fRescan</name> <operator>=</operator> <name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><call><name>get_bool</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>fRescan</name> <operator>&amp;&amp;</operator> <call><name><name>pwallet</name><operator>-&gt;</operator><name>chain</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>havePruned</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="line">// Exit early and print an error.</comment>
            <comment type="line">// If a block is pruned after this check, we will import the key(s),</comment>
            <comment type="line">// but fail the rescan with a generic error.</comment>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_WALLET_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Rescan is disabled when blocks are pruned"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>fRescan</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>reserver</name><operator>.</operator><name>reserve</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_WALLET_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Wallet is currently rescanning. Abort existing rescan or wait."</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>CKey</name></type> <name>key</name> <init>= <expr><call><name>DecodeSecret</name><argument_list>(<argument><expr><name>strSecret</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>key</name><operator>.</operator><name>IsValid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><literal type="string">"Invalid private key encoding"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>CPubKey</name></type> <name>pubkey</name> <init>= <expr><call><name><name>key</name><operator>.</operator><name>GetPubKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>CHECK_NONFATAL</name><argument_list>(<argument><expr><call><name><name>key</name><operator>.</operator><name>VerifyPubKey</name></name><argument_list>(<argument><expr><name>pubkey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>CKeyID</name></type> <name>vchAddress</name> <init>= <expr><call><name><name>pubkey</name><operator>.</operator><name>GetID</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <block>{<block_content>
            <expr_stmt><expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>MarkDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// We don't know which corresponding address will be used;</comment>
            <comment type="line">// label all new addresses, and label existing addresses if a</comment>
            <comment type="line">// label was passed.</comment>
            <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>dest</name> <range>: <expr><call><name>GetAllDestinationsForKey</name><argument_list>(<argument><expr><name>pubkey</name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>pwallet</name><operator>-&gt;</operator><name>mapAddressBook</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>SetAddressBook</name></name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>strLabel</name></expr></argument>, <argument><expr><literal type="string">"receive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <comment type="line">// Use timestamp of 1 to scan the whole chain</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pwallet</name><operator>-&gt;</operator><name>ImportPrivKeys</name></name><argument_list>(<argument><expr><block>{</block></expr></argument></argument_list></call></expr></condition><block>{<block_content><expr><name>vchAddress</name></expr><operator>,</operator> <expr><name>key</name></expr></block_content>}</block></if></if_stmt></block_content>}</block><operator>,</operator> <expr_stmt><expr><literal type="number">1</literal></expr></expr_stmt>)</block_content></block>)</block_content> <block>{<block_content>
                <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_WALLET_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error adding key to wallet"</literal></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block>

            <comment type="line">// Add the wpkh script for this key if possible</comment>
            if (pubkey.IsCompressed(</block></function>)) <block>{<block_content>
                <expr_stmt><expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>ImportScripts</name></name><argument_list>(<argument><expr><block>{<macro><name>GetScriptForDestination</name><argument_list>(<argument>WitnessV0KeyHash(vchAddress)</argument>)</argument_list></macro>}</block></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* timestamp */</comment>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        }
    }
    <if_stmt><if>if <condition>(<expr><name>fRescan</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>RescanWallet</name><argument_list>(<argument><expr><operator>*</operator><name>pwallet</name></expr></argument>, <argument><expr><name>reserver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>NullUniValue</name></expr>;</return>
}

UniValue <macro><name>abortrescan</name><argument_list>(<argument>const JSONRPCRequest&amp; request</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CWallet</name></expr></argument>&gt;</argument_list></name> <specifier>const</specifier></type> <name>wallet</name> <init>= <expr><call><name>GetWalletForJSONRPCRequest</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CWallet</name><modifier>*</modifier> <specifier>const</specifier></type> <name>pwallet</name> <init>= <expr><call><name><name>wallet</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EnsureWalletIsAvailable</name><argument_list>(<argument><expr><name>pwallet</name></expr></argument>, <argument><expr><name><name>request</name><operator>.</operator><name>fHelp</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>NullUniValue</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>RPCHelpMan</name><argument_list>{<argument><expr><literal type="string">"abortrescan"</literal></expr></argument>,
                <argument><expr><literal type="string">"\nStops current wallet rescan triggered by an RPC call, e.g. by an importprivkey call.\n"</literal>
                <literal type="string">"Note: Use \"getwalletinfo\" to query the scanning progress.\n"</literal></expr></argument>,
                <block>{<block_content><expr_stmt/>}</block_content></block>,
                <argument><expr><call><name>RPCResults</name><argument_list>{}</argument_list></call></expr></argument>,
                <argument><expr><call><name>RPCExamples</name><argument_list>{
            <argument><expr><literal type="string">"\nImport a private key\n"</literal>
            <operator>+</operator> <call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"importprivkey"</literal></expr></argument>, <argument><expr><literal type="string">"\"mykey\""</literal></expr></argument>)</argument_list></call> <operator>+</operator>
            <literal type="string">"\nAbort the running wallet rescan\n"</literal>
            <operator>+</operator> <call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"abortrescan"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>+</operator>
            <literal type="string">"\nAs a JSON-RPC call\n"</literal>
            <operator>+</operator> <macro><name>HelpExampleRpc</name><argument_list>(<argument><literal type="string">"abortrescan"</literal></argument>, <argument><literal type="string">""</literal></argument>)</argument_list></macro></expr></argument>
                }</argument_list></call></expr></argument>,
            }</argument_list></call><operator>.</operator><call><name>Check</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pwallet</name><operator>-&gt;</operator><name>IsScanning</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>pwallet</name><operator>-&gt;</operator><name>IsAbortingRescan</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>AbortRescan</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block>

<function><type><name>UniValue</name></type> <name>importaddress</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>JSONRPCRequest</name><modifier>&amp;</modifier></type> <name>request</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CWallet</name></expr></argument>&gt;</argument_list></name> <specifier>const</specifier></type> <name>wallet</name> <init>= <expr><call><name>GetWalletForJSONRPCRequest</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CWallet</name><modifier>*</modifier> <specifier>const</specifier></type> <name>pwallet</name> <init>= <expr><call><name><name>wallet</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EnsureWalletIsAvailable</name><argument_list>(<argument><expr><name>pwallet</name></expr></argument>, <argument><expr><name><name>request</name><operator>.</operator><name>fHelp</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>NullUniValue</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>RPCHelpMan</name><argument_list>{<argument><expr><literal type="string">"importaddress"</literal></expr></argument>,
                <argument><expr><literal type="string">"\nAdds an address or script (in hex) that can be watched as if it were in your wallet but cannot be used to spend. Requires a new wallet backup.\n"</literal>
            <literal type="string">"\nNote: This call can take over an hour to complete if rescan is true, during that time, other rpc calls\n"</literal>
            <literal type="string">"may report that the imported address exists but related transactions are still missing, leading to temporarily incorrect/bogus balances and unspent outputs until rescan completes.\n"</literal>
            <literal type="string">"If you have the full public key, you should call importpubkey instead of this.\n"</literal>
            <literal type="string">"Hint: use importmulti to import more than one address.\n"</literal>
            <literal type="string">"\nNote: If you import a non-standard raw script in hex form, outputs sending to it will be treated\n"</literal>
            <literal type="string">"as change, and not show up in many RPCs.\n"</literal>
            <literal type="string">"Note: Use \"getwalletinfo\" to query the scanning progress.\n"</literal></expr></argument>,
                <block>{<block_content>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"address"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"The Bitcoin address (or hex-encoded script)"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"label"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR</name></name></expr><operator>,</operator> <comment type="block">/* default */</comment> <expr><literal type="string">"\"\""</literal></expr><operator>,</operator> <expr><literal type="string">"An optional label"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"rescan"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>BOOL</name></name></expr><operator>,</operator> <comment type="block">/* default */</comment> <expr><literal type="string">"true"</literal></expr><operator>,</operator> <expr><literal type="string">"Rescan the wallet for transactions"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"p2sh"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>BOOL</name></name></expr><operator>,</operator> <comment type="block">/* default */</comment> <expr><literal type="string">"false"</literal></expr><operator>,</operator> <expr><literal type="string">"Add the P2SH version of the script as well"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                <expr_stmt/>}</block_content></block>,
                <argument><expr><call><name>RPCResults</name><argument_list>{}</argument_list></call></expr></argument>,
                <argument><expr><call><name>RPCExamples</name><argument_list>{
            <argument><expr><literal type="string">"\nImport an address with rescan\n"</literal>
            <operator>+</operator> <call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"importaddress"</literal></expr></argument>, <argument><expr><literal type="string">"\"myaddress\""</literal></expr></argument>)</argument_list></call> <operator>+</operator>
            <literal type="string">"\nImport using a label without rescan\n"</literal>
            <operator>+</operator> <call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"importaddress"</literal></expr></argument>, <argument><expr><literal type="string">"\"myaddress\" \"testing\" false"</literal></expr></argument>)</argument_list></call> <operator>+</operator>
            <literal type="string">"\nAs a JSON-RPC call\n"</literal>
            <operator>+</operator> <macro><name>HelpExampleRpc</name><argument_list>(<argument><literal type="string">"importaddress"</literal></argument>, <argument><literal type="string">"\"myaddress\", \"testing\", false"</literal></argument>)</argument_list></macro></expr></argument>
                }</argument_list></call></expr></argument>,
            }</argument_list></call><operator>.</operator><call><name>Check</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>EnsureLegacyScriptPubKeyMan</name><argument_list>(<argument><expr><operator>*</operator><name>pwallet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>strLabel</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>strLabel</name> <operator>=</operator> <name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">// Whether to perform rescan after import</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>fRescan</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>fRescan</name> <operator>=</operator> <name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><call><name>get_bool</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>fRescan</name> <operator>&amp;&amp;</operator> <call><name><name>pwallet</name><operator>-&gt;</operator><name>chain</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>havePruned</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="line">// Exit early and print an error.</comment>
        <comment type="line">// If a block is pruned after this check, we will import the key(s),</comment>
        <comment type="line">// but fail the rescan with a generic error.</comment>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_WALLET_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Rescan is disabled when blocks are pruned"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>WalletRescanReserver</name></type> <name>reserver</name><argument_list>(<argument><expr><name>pwallet</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>fRescan</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>reserver</name><operator>.</operator><name>reserve</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_WALLET_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Wallet is currently rescanning. Abort existing rescan or wait."</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Whether to import a p2sh version, too</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>fP2SH</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>fP2SH</name> <operator>=</operator> <name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><call><name>get_bool</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>locked_chain</name> <init>= <expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>chain</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pwallet</name><operator>-&gt;</operator><name>cs_wallet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>CTxDestination</name></type> <name>dest</name> <init>= <expr><call><name>DecodeDestination</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>IsValidDestination</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>fP2SH</name></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><literal type="string">"Cannot use the p2sh flag with an address - use a script instead"</literal></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>MarkDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>ImportScriptPubKeys</name></name><argument_list>(<argument><expr><name>strLabel</name></expr></argument>, <block>{<block_content><macro><name>GetScriptForDestination</name><argument_list>(<argument>dest</argument>)</argument_list></macro></block_content>}</block></argument_list></call></expr></expr_stmt><operator>,</operator> <expr_stmt><expr><literal type="boolean">false</literal></expr> <comment type="block">/* have_solving_data */</comment><operator>,</operator> <expr><literal type="boolean">true</literal></expr> <comment type="block">/* apply_label */</comment><operator>,</operator> <expr><literal type="number">1</literal></expr></expr_stmt> <comment type="block">/* timestamp */</comment>)</block_content></block><empty_stmt>;</empty_stmt></if></if_stmt>
        </block_content>}</block> <if_stmt><if type="elseif">else if <condition>(<expr><call><name>IsHex</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>data</name><argument_list>(<argument><expr><call><name>ParseHex</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>CScript</name></type> <name>redeem_script</name><argument_list>(<argument><expr><call><name><name>data</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>data</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>CScript</name></expr></argument>&gt;</argument_list></name></type> <name>scripts</name> <init>= <expr><block>{<expr><name>redeem_script</name></expr>}</block></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>ImportScripts</name></name><argument_list>(<argument><expr><name>scripts</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* timestamp */</comment>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>fP2SH</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>scripts</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name>GetScriptForDestination</name><argument_list>(<argument><expr><call><name>ScriptHash</name><argument_list>(<argument><expr><call><name>CScriptID</name><argument_list>(<argument><expr><name>redeem_script</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>ImportScriptPubKeys</name></name><argument_list>(<argument><expr><name>strLabel</name></expr></argument>, <argument><expr><name>scripts</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument> <comment type="block">/* have_solving_data */</comment>, <argument><expr><literal type="boolean">true</literal></expr></argument> <comment type="block">/* apply_label */</comment>, <argument><expr><literal type="number">1</literal></expr></argument> <comment type="block">/* timestamp */</comment>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><literal type="string">"Invalid Bitcoin address or script"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></function>
    <if_stmt><if>if <condition>(<expr><name>fRescan</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>RescanWallet</name><argument_list>(<argument><expr><operator>*</operator><name>pwallet</name></expr></argument>, <argument><expr><name>reserver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <block>{<block_content>
            <decl_stmt><decl><type><name>auto</name></type> <name>locked_chain</name> <init>= <expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>chain</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pwallet</name><operator>-&gt;</operator><name>cs_wallet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>ReacceptWalletTransactions</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>NullUniValue</name></expr>;</return>
}

UniValue <macro><name>importprunedfunds</name><argument_list>(<argument>const JSONRPCRequest&amp; request</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CWallet</name></expr></argument>&gt;</argument_list></name> <specifier>const</specifier></type> <name>wallet</name> <init>= <expr><call><name>GetWalletForJSONRPCRequest</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CWallet</name><modifier>*</modifier> <specifier>const</specifier></type> <name>pwallet</name> <init>= <expr><call><name><name>wallet</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EnsureWalletIsAvailable</name><argument_list>(<argument><expr><name>pwallet</name></expr></argument>, <argument><expr><name><name>request</name><operator>.</operator><name>fHelp</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>NullUniValue</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>RPCHelpMan</name><argument_list>{<argument><expr><literal type="string">"importprunedfunds"</literal></expr></argument>,
                <argument><expr><literal type="string">"\nImports funds without rescan. Corresponding address or script must previously be included in wallet. Aimed towards pruned wallets. The end-user is responsible to import additional transactions that subsequently spend the imported outputs or rescan after the point in the blockchain the transaction is included.\n"</literal></expr></argument>,
                <block>{<block_content>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"rawtransaction"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR_HEX</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"A raw transaction in hex funding an already-existing address in wallet"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"txoutproof"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR_HEX</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"The hex output from gettxoutproof that contains the transaction"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                <expr_stmt/>}</block_content></block>,
                <argument><expr><call><name>RPCResults</name><argument_list>{}</argument_list></call></expr></argument>,
                <argument><expr><call><name>RPCExamples</name><argument_list>{<argument><expr><literal type="string">""</literal></expr></argument>}</argument_list></call></expr></argument>,
            }</argument_list></call><operator>.</operator><call><name>Check</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>CMutableTransaction</name></type> <name>tx</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DecodeHexTx</name><argument_list>(<argument><expr><name>tx</name></expr></argument>, <argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_DESERIALIZATION_ERROR</name></expr></argument>, <argument><expr><literal type="string">"TX decode failed"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>uint256</name></type> <name>hashTx</name> <init>= <expr><call><name><name>tx</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CWalletTx</name></type> <name>wtx</name><argument_list>(<argument><expr><name>pwallet</name></expr></argument>, <argument><expr><call><name>MakeTransactionRef</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>CDataStream</name></type> <name>ssMB</name><argument_list>(<argument><expr><call><name>ParseHexV</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"proof"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SER_NETWORK</name></expr></argument>, <argument><expr><name>PROTOCOL_VERSION</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CMerkleBlock</name></type> <name>merkleBlock</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>ssMB</name> <operator>&gt;&gt;</operator> <name>merkleBlock</name></expr>;</expr_stmt>

    <comment type="line">//Search partial merkle tree in proof for our transaction and index in valid block</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>&gt;</argument_list></name></type> <name>vMatch</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>int</name></expr></argument>&gt;</argument_list></name></type> <name>vIndex</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>merkleBlock</name><operator>.</operator><name>txn</name><operator>.</operator><name>ExtractMatches</name></name><argument_list>(<argument><expr><name>vMatch</name></expr></argument>, <argument><expr><name>vIndex</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>merkleBlock</name><operator>.</operator><name>header</name><operator>.</operator><name>hashMerkleRoot</name></name></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><literal type="string">"Something wrong with merkleblock"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>locked_chain</name> <init>= <expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>chain</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type> <name>height</name> <init>= <expr><call><name><name>locked_chain</name><operator>-&gt;</operator><name>getBlockHeight</name></name><argument_list>(<argument><expr><call><name><name>merkleBlock</name><operator>.</operator><name>header</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>height</name> <operator>==</operator> <name>nullopt</name></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><literal type="string">"Block not found in chain"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>&gt;</argument_list><operator>::</operator><name>const_iterator</name></name></type> <name>it</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>it</name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>find</name></name><argument_list>(<argument><expr><call><name><name>vMatch</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>vMatch</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>hashTx</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <call><name><name>vMatch</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><literal type="string">"Transaction given doesn't exist in proof"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>txnIndex</name> <init>= <expr><name><name>vIndex</name><index>[<expr><name>it</name> <operator>-</operator> <call><name><name>vMatch</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>CWalletTx</name><operator>::</operator><name>Confirmation</name></name></type> <name>confirm</name><argument_list>(<argument><expr><name><name>CWalletTx</name><operator>::</operator><name>Status</name><operator>::</operator><name>CONFIRMED</name></name></expr></argument>, <argument><expr><operator>*</operator><name>height</name></expr></argument>, <argument><expr><call><name><name>merkleBlock</name><operator>.</operator><name>header</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>txnIndex</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>wtx</name><operator>.</operator><name>m_confirm</name></name> <operator>=</operator> <name>confirm</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pwallet</name><operator>-&gt;</operator><name>cs_wallet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>IsMine</name></name><argument_list>(<argument><expr><operator>*</operator><name><name>wtx</name><operator>.</operator><name>tx</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>AddToWallet</name></name><argument_list>(<argument><expr><name>wtx</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NullUniValue</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><literal type="string">"No addresses in wallet correspond to included transaction"</literal></expr></argument>)</argument_list></call></expr>;</throw>
</block_content>}</block>

<function><type><name>UniValue</name></type> <name>removeprunedfunds</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>JSONRPCRequest</name><modifier>&amp;</modifier></type> <name>request</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CWallet</name></expr></argument>&gt;</argument_list></name> <specifier>const</specifier></type> <name>wallet</name> <init>= <expr><call><name>GetWalletForJSONRPCRequest</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CWallet</name><modifier>*</modifier> <specifier>const</specifier></type> <name>pwallet</name> <init>= <expr><call><name><name>wallet</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EnsureWalletIsAvailable</name><argument_list>(<argument><expr><name>pwallet</name></expr></argument>, <argument><expr><name><name>request</name><operator>.</operator><name>fHelp</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>NullUniValue</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>RPCHelpMan</name><argument_list>{<argument><expr><literal type="string">"removeprunedfunds"</literal></expr></argument>,
                <argument><expr><literal type="string">"\nDeletes the specified transaction from the wallet. Meant for use with pruned wallets and as a companion to importprunedfunds. This will affect wallet balances.\n"</literal></expr></argument>,
                <block>{<block_content>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"txid"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR_HEX</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"The hex-encoded id of the transaction you are deleting"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                <expr_stmt/>}</block_content></block>,
                <argument><expr><call><name>RPCResults</name><argument_list>{}</argument_list></call></expr></argument>,
                <argument><expr><call><name>RPCExamples</name><argument_list>{
                    <argument><expr><call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"removeprunedfunds"</literal></expr></argument>, <argument><expr><literal type="string">"\"a8d0c0184dde994a09ec054286f1ce581bebf46446a512166eae7628734ea0a5\""</literal></expr></argument>)</argument_list></call> <operator>+</operator>
            <literal type="string">"\nAs a JSON-RPC call\n"</literal>
            <operator>+</operator> <macro><name>HelpExampleRpc</name><argument_list>(<argument><literal type="string">"removeprunedfunds"</literal></argument>, <argument><literal type="string">"\"a8d0c0184dde994a09ec054286f1ce581bebf46446a512166eae7628734ea0a5\""</literal></argument>)</argument_list></macro></expr></argument>
                }</argument_list></call></expr></argument>,
            }</argument_list></call><operator>.</operator><call><name>Check</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>locked_chain</name> <init>= <expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>chain</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pwallet</name><operator>-&gt;</operator><name>cs_wallet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>uint256</name></type> <name>hash</name><argument_list>(<argument><expr><call><name>ParseHashV</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"txid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>&gt;</argument_list></name></type> <name>vHash</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>vHash</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>&gt;</argument_list></name></type> <name>vHashOut</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>ZapSelectTx</name></name><argument_list>(<argument><expr><name>vHash</name></expr></argument>, <argument><expr><name>vHashOut</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>DBErrors</name><operator>::</operator><name>LOAD_OK</name></name></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_WALLET_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Could not properly delete the transaction."</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><call><name><name>vHashOut</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_PARAMETER</name></expr></argument>, <argument><expr><literal type="string">"Transaction does not exist in wallet."</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>NullUniValue</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>UniValue</name></type> <name>importpubkey</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>JSONRPCRequest</name><modifier>&amp;</modifier></type> <name>request</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CWallet</name></expr></argument>&gt;</argument_list></name> <specifier>const</specifier></type> <name>wallet</name> <init>= <expr><call><name>GetWalletForJSONRPCRequest</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CWallet</name><modifier>*</modifier> <specifier>const</specifier></type> <name>pwallet</name> <init>= <expr><call><name><name>wallet</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EnsureWalletIsAvailable</name><argument_list>(<argument><expr><name>pwallet</name></expr></argument>, <argument><expr><name><name>request</name><operator>.</operator><name>fHelp</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>NullUniValue</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>RPCHelpMan</name><argument_list>{<argument><expr><literal type="string">"importpubkey"</literal></expr></argument>,
                <argument><expr><literal type="string">"\nAdds a public key (in hex) that can be watched as if it were in your wallet but cannot be used to spend. Requires a new wallet backup.\n"</literal>
                <literal type="string">"Hint: use importmulti to import more than one public key.\n"</literal>
            <literal type="string">"\nNote: This call can take over an hour to complete if rescan is true, during that time, other rpc calls\n"</literal>
            <literal type="string">"may report that the imported pubkey exists but related transactions are still missing, leading to temporarily incorrect/bogus balances and unspent outputs until rescan completes.\n"</literal>
            <literal type="string">"Note: Use \"getwalletinfo\" to query the scanning progress.\n"</literal></expr></argument>,
                <block>{<block_content>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"pubkey"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"The hex-encoded public key"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"label"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR</name></name></expr><operator>,</operator> <comment type="block">/* default */</comment> <expr><literal type="string">"\"\""</literal></expr><operator>,</operator> <expr><literal type="string">"An optional label"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"rescan"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>BOOL</name></name></expr><operator>,</operator> <comment type="block">/* default */</comment> <expr><literal type="string">"true"</literal></expr><operator>,</operator> <expr><literal type="string">"Rescan the wallet for transactions"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                <expr_stmt/>}</block_content></block>,
                <argument><expr><call><name>RPCResults</name><argument_list>{}</argument_list></call></expr></argument>,
                <argument><expr><call><name>RPCExamples</name><argument_list>{
            <argument><expr><literal type="string">"\nImport a public key with rescan\n"</literal>
            <operator>+</operator> <call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"importpubkey"</literal></expr></argument>, <argument><expr><literal type="string">"\"mypubkey\""</literal></expr></argument>)</argument_list></call> <operator>+</operator>
            <literal type="string">"\nImport using a label without rescan\n"</literal>
            <operator>+</operator> <call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"importpubkey"</literal></expr></argument>, <argument><expr><literal type="string">"\"mypubkey\" \"testing\" false"</literal></expr></argument>)</argument_list></call> <operator>+</operator>
            <literal type="string">"\nAs a JSON-RPC call\n"</literal>
            <operator>+</operator> <macro><name>HelpExampleRpc</name><argument_list>(<argument><literal type="string">"importpubkey"</literal></argument>, <argument><literal type="string">"\"mypubkey\", \"testing\", false"</literal></argument>)</argument_list></macro></expr></argument>
                }</argument_list></call></expr></argument>,
            }</argument_list></call><operator>.</operator><call><name>Check</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>EnsureLegacyScriptPubKeyMan</name><argument_list>(<argument><expr><operator>*</operator><name>wallet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>strLabel</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>strLabel</name> <operator>=</operator> <name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">// Whether to perform rescan after import</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>fRescan</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>fRescan</name> <operator>=</operator> <name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><call><name>get_bool</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>fRescan</name> <operator>&amp;&amp;</operator> <call><name><name>pwallet</name><operator>-&gt;</operator><name>chain</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>havePruned</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="line">// Exit early and print an error.</comment>
        <comment type="line">// If a block is pruned after this check, we will import the key(s),</comment>
        <comment type="line">// but fail the rescan with a generic error.</comment>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_WALLET_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Rescan is disabled when blocks are pruned"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>WalletRescanReserver</name></type> <name>reserver</name><argument_list>(<argument><expr><name>pwallet</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>fRescan</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>reserver</name><operator>.</operator><name>reserve</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_WALLET_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Wallet is currently rescanning. Abort existing rescan or wait."</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsHex</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><literal type="string">"Pubkey must be a hex string"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>data</name><argument_list>(<argument><expr><call><name>ParseHex</name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CPubKey</name></type> <name>pubKey</name><argument_list>(<argument><expr><call><name><name>data</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>data</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pubKey</name><operator>.</operator><name>IsFullyValid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><literal type="string">"Pubkey is not a valid public key"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

    <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>locked_chain</name> <init>= <expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>chain</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pwallet</name><operator>-&gt;</operator><name>cs_wallet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>CScript</name></expr></argument>&gt;</argument_list></name></type> <name>script_pub_keys</name></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>dest</name> <range>: <expr><call><name>GetAllDestinationsForKey</name><argument_list>(<argument><expr><name>pubKey</name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>script_pub_keys</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name>GetScriptForDestination</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>MarkDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>ImportScriptPubKeys</name></name><argument_list>(<argument><expr><name>strLabel</name></expr></argument>, <argument><expr><name>script_pub_keys</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument> <comment type="block">/* have_solving_data */</comment>, <argument><expr><literal type="boolean">true</literal></expr></argument> <comment type="block">/* apply_label */</comment>, <argument><expr><literal type="number">1</literal></expr></argument> <comment type="block">/* timestamp */</comment>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>ImportPubKeys</name></name><argument_list>(<argument><expr><block>{<macro><name>pubKey</name></macro><expr><operator>.</operator><macro><name>GetID</name><argument_list>()</argument_list></macro></expr>}</block></expr></argument>, <block>{<block_content><block>{<block_content><expr><call><name><name>pubKey</name><operator>.</operator><name>GetID</name></name><argument_list>()</argument_list></call></expr><operator>,</operator> <expr><name>pubKey</name></expr></block_content>}</block></block_content>}</block></argument_list></call></expr></expr_stmt> <operator>,</operator> <block>{<block_content/>}</block> <comment type="block">/* key_origins */</comment><operator>,</operator> <expr_stmt><expr><literal type="boolean">false</literal></expr> <comment type="block">/* add_keypool */</comment><operator>,</operator> <expr><literal type="boolean">false</literal></expr> <comment type="block">/* internal */</comment><operator>,</operator> <expr><literal type="number">1</literal></expr></expr_stmt> <comment type="block">/* timestamp */</comment>)</block_content></block><empty_stmt>;</empty_stmt>
    </block_content>}</block></function>
    <if_stmt><if>if <condition>(<expr><name>fRescan</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>RescanWallet</name><argument_list>(<argument><expr><operator>*</operator><name>pwallet</name></expr></argument>, <argument><expr><name>reserver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <block>{<block_content>
            <decl_stmt><decl><type><name>auto</name></type> <name>locked_chain</name> <init>= <expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>chain</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pwallet</name><operator>-&gt;</operator><name>cs_wallet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>ReacceptWalletTransactions</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>NullUniValue</name></expr>;</return>
}


UniValue <macro><name>importwallet</name><argument_list>(<argument>const JSONRPCRequest&amp; request</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CWallet</name></expr></argument>&gt;</argument_list></name> <specifier>const</specifier></type> <name>wallet</name> <init>= <expr><call><name>GetWalletForJSONRPCRequest</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CWallet</name><modifier>*</modifier> <specifier>const</specifier></type> <name>pwallet</name> <init>= <expr><call><name><name>wallet</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EnsureWalletIsAvailable</name><argument_list>(<argument><expr><name>pwallet</name></expr></argument>, <argument><expr><name><name>request</name><operator>.</operator><name>fHelp</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>NullUniValue</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>RPCHelpMan</name><argument_list>{<argument><expr><literal type="string">"importwallet"</literal></expr></argument>,
                <argument><expr><literal type="string">"\nImports keys from a wallet dump file (see dumpwallet). Requires a new wallet backup to include imported keys.\n"</literal>
                <literal type="string">"Note: Use \"getwalletinfo\" to query the scanning progress.\n"</literal></expr></argument>,
                <block>{<block_content>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"filename"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"The wallet file"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                <expr_stmt/>}</block_content></block>,
                <argument><expr><call><name>RPCResults</name><argument_list>{}</argument_list></call></expr></argument>,
                <argument><expr><call><name>RPCExamples</name><argument_list>{
            <argument><expr><literal type="string">"\nDump the wallet\n"</literal>
            <operator>+</operator> <call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"dumpwallet"</literal></expr></argument>, <argument><expr><literal type="string">"\"test\""</literal></expr></argument>)</argument_list></call> <operator>+</operator>
            <literal type="string">"\nImport the wallet\n"</literal>
            <operator>+</operator> <call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"importwallet"</literal></expr></argument>, <argument><expr><literal type="string">"\"test\""</literal></expr></argument>)</argument_list></call> <operator>+</operator>
            <literal type="string">"\nImport using the json rpc call\n"</literal>
            <operator>+</operator> <macro><name>HelpExampleRpc</name><argument_list>(<argument><literal type="string">"importwallet"</literal></argument>, <argument><literal type="string">"\"test\""</literal></argument>)</argument_list></macro></expr></argument>
                }</argument_list></call></expr></argument>,
            }</argument_list></call><operator>.</operator><call><name>Check</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>EnsureLegacyScriptPubKeyMan</name><argument_list>(<argument><expr><operator>*</operator><name>wallet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>chain</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>havePruned</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="line">// Exit early and print an error.</comment>
        <comment type="line">// If a block is pruned after this check, we will import the key(s),</comment>
        <comment type="line">// but fail the rescan with a generic error.</comment>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_WALLET_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Importing wallets is disabled when blocks are pruned"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <function_decl><type><name>WalletRescanReserver</name></type> <name>reserver</name><parameter_list>(<parameter><decl><type><name>pwallet</name></type></decl></parameter>)</parameter_list>;</function_decl>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>reserver</name><operator>.</operator><name>reserve</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_WALLET_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Wallet is currently rescanning. Abort existing rescan or wait."</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>nTimeBegin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>fGood</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>
    <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>locked_chain</name> <init>= <expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>chain</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pwallet</name><operator>-&gt;</operator><name>cs_wallet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>EnsureWalletIsUnlocked</name><argument_list>(<argument><expr><name>pwallet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>fsbridge</name><operator>::</operator><name>ifstream</name></name></type> <name>file</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>file</name><operator>.</operator><name>open</name></name><argument_list>(<argument><expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>in</name></name> <operator>|</operator> <name><name>std</name><operator>::</operator><name>ios</name><operator>::</operator><name>ate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>file</name><operator>.</operator><name>is_open</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_PARAMETER</name></expr></argument>, <argument><expr><literal type="string">"Cannot open wallet dump file"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type> <name>tip_height</name> <init>= <expr><call><name><name>locked_chain</name><operator>-&gt;</operator><name>getHeight</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>nTimeBegin</name> <operator>=</operator> <ternary><condition><expr><name>tip_height</name></expr> ?</condition><then> <expr><call><name><name>locked_chain</name><operator>-&gt;</operator><name>getBlockTime</name></name><argument_list>(<argument><expr><operator>*</operator><name>tip_height</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>int64_t</name></type> <name>nFilesize</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>max</name></name><argument_list>(<argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator><call><name><name>file</name><operator>.</operator><name>tellg</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>file</name><operator>.</operator><name>seekg</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>file</name><operator>.</operator><name>beg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Use uiInterface.ShowProgress instead of pwallet.ShowProgress because pwallet.ShowProgress has a cancel button tied to AbortRescan which</comment>
        <comment type="line">// we don't want for this progress bar showing the import progress. uiInterface.ShowProgress does not have a cancel button.</comment>
        <expr_stmt><expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>chain</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>showProgress</name><argument_list>(<argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"%s "</literal> <operator>+</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"Importing..."</literal></expr></argument>)</argument_list></call><operator>.</operator><name>translated</name></expr></argument>, <argument><expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>GetDisplayName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// show progress dialog in GUI</comment>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>CKey</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>keys</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>CScript</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>scripts</name></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>file</name><operator>.</operator><name>good</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>chain</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>showProgress</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>max</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>min</name></name><argument_list>(<argument><expr><literal type="number">50</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><call><name><name>file</name><operator>.</operator><name>tellg</name></name><argument_list>()</argument_list></call> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><name>nFilesize</name><operator>)</operator> <operator>*</operator> <literal type="number">100</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>line</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>std</name><operator>::</operator><name>getline</name></name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>line</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>||</operator> <name><name>line</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string</name></name></expr></argument>&gt;</argument_list></name></type> <name>vstr</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>boost</name><operator>::</operator><name>split</name></name><argument_list>(<argument><expr><name>vstr</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><call><name><name>boost</name><operator>::</operator><name>is_any_of</name></name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>vstr</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <decl_stmt><decl><type><name>CKey</name></type> <name>key</name> <init>= <expr><call><name>DecodeSecret</name><argument_list>(<argument><expr><name><name>vstr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>key</name><operator>.</operator><name>IsValid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>nTime</name> <init>= <expr><call><name>ParseISO8601DateTime</name><argument_list>(<argument><expr><name><name>vstr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>strLabel</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type> <name>fLabel</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>nStr</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</init> <condition><expr><name>nStr</name> <operator>&lt;</operator> <call><name><name>vstr</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>nStr</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>vstr</name><index>[<expr><name>nStr</name></expr>]</index></name><operator>.</operator><call><name>front</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>vstr</name><index>[<expr><name>nStr</name></expr>]</index></name> <operator>==</operator> <literal type="string">"change=1"</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>fLabel</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>vstr</name><index>[<expr><name>nStr</name></expr>]</index></name> <operator>==</operator> <literal type="string">"reserve=1"</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>fLabel</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>vstr</name><index>[<expr><name>nStr</name></expr>]</index></name><operator>.</operator><call><name>substr</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="string">"label="</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>strLabel</name> <operator>=</operator> <call><name>DecodeDumpString</name><argument_list>(<argument><expr><name><name>vstr</name><index>[<expr><name>nStr</name></expr>]</index></name><operator>.</operator><call><name>substr</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>fLabel</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><call><name><name>keys</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>make_tuple</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>nTime</name></expr></argument>, <argument><expr><name>fLabel</name></expr></argument>, <argument><expr><name>strLabel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if<condition>(<expr><call><name>IsHex</name><argument_list>(<argument><expr><name><name>vstr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>vData</name><argument_list>(<argument><expr><call><name>ParseHex</name><argument_list>(<argument><expr><name><name>vstr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>CScript</name></type> <name>script</name> <init>= <expr><call><name>CScript</name><argument_list>(<argument><expr><call><name><name>vData</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>vData</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>birth_time</name> <init>= <expr><call><name>ParseISO8601DateTime</name><argument_list>(<argument><expr><name><name>vstr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>scripts</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>CScript</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><name>birth_time</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name><name>file</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// We now know whether we are importing private keys, so we can error if private keys are disabled</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>keys</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name><name>pwallet</name><operator>-&gt;</operator><name>IsWalletFlagSet</name></name><argument_list>(<argument><expr><name>WALLET_FLAG_DISABLE_PRIVATE_KEYS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>chain</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>showProgress</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// hide progress dialog in GUI</comment>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_WALLET_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Importing wallets is disabled when private keys are disabled"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>total</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><call><name><name>keys</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>+</operator> <call><name><name>scripts</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>progress</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>key_tuple</name> <range>: <expr><name>keys</name></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>chain</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>showProgress</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>max</name></name><argument_list>(<argument><expr><literal type="number">50</literal></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>min</name></name><argument_list>(<argument><expr><literal type="number">75</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>progress</name> <operator>/</operator> <name>total</name><operator>)</operator> <operator>*</operator> <literal type="number">100</literal><operator>)</operator> <operator>+</operator> <literal type="number">50</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>CKey</name><modifier>&amp;</modifier></type> <name>key</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>get</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>key_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>time</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>get</name><argument_list type="generic">&lt;<argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>key_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>has_label</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>get</name><argument_list type="generic">&lt;<argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>key_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>label</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>get</name><argument_list type="generic">&lt;<argument><expr><literal type="number">3</literal></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>key_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>CPubKey</name></type> <name>pubkey</name> <init>= <expr><call><name><name>key</name><operator>.</operator><name>GetPubKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>CHECK_NONFATAL</name><argument_list>(<argument><expr><call><name><name>key</name><operator>.</operator><name>VerifyPubKey</name></name><argument_list>(<argument><expr><name>pubkey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>CKeyID</name></type> <name>keyid</name> <init>= <expr><call><name><name>pubkey</name><operator>.</operator><name>GetID</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>WalletLogPrintf</name></name><argument_list>(<argument><expr><literal type="string">"Importing %s...\n"</literal></expr></argument>, <argument><expr><call><name>EncodeDestination</name><argument_list>(<argument><expr><call><name>PKHash</name><argument_list>(<argument><expr><name>keyid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pwallet</name><operator>-&gt;</operator><name>ImportPrivKeys</name></name><argument_list>(<argument><expr><block>{</block></expr></argument></argument_list></call></expr></condition><block>{<block_content><expr><name>keyid</name></expr><operator>,</operator> <expr><name>key</name></expr></block_content>}</block></if></if_stmt></block_content>}</block></for><operator>,</operator> <expr_stmt><expr><name>time</name></expr></expr_stmt>)</block_content></block>)</block_content> <block>{<block_content>
                <expr_stmt><expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>WalletLogPrintf</name></name><argument_list>(<argument><expr><literal type="string">"Error importing key for %s\n"</literal></expr></argument>, <argument><expr><call><name>EncodeDestination</name><argument_list>(<argument><expr><call><name>PKHash</name><argument_list>(<argument><expr><name>keyid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>fGood</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block>

            if (has_label</block>)
                <expr_stmt><expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>SetAddressBook</name></name><argument_list>(<argument><expr><call><name>PKHash</name><argument_list>(<argument><expr><name>keyid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><literal type="string">"receive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>nTimeBegin</name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>min</name></name><argument_list>(<argument><expr><name>nTimeBegin</name></expr></argument>, <argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>progress</name><operator>++</operator></expr>;</expr_stmt>
        }
        for <expr_stmt><expr><operator>(</operator><specifier>const</specifier> <name>auto</name><operator>&amp;</operator> <name>script_pair</name> <operator>:</operator> <name>scripts</name><operator>)</operator> <block>{
            <expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>chain</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>showProgress</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>max</name></name><argument_list>(<argument><expr><literal type="number">50</literal></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>min</name></name><argument_list>(<argument><expr><literal type="number">75</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>progress</name> <operator>/</operator> <name>total</name><operator>)</operator> <operator>*</operator> <literal type="number">100</literal><operator>)</operator> <operator>+</operator> <literal type="number">50</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;
            <expr><specifier>const</specifier> <name>CScript</name><operator>&amp;</operator> <name>script</name> <operator>=</operator> <name><name>script_pair</name><operator>.</operator><name>first</name></name></expr>;
            <expr><name>int64_t</name> <name>time</name> <operator>=</operator> <name><name>script_pair</name><operator>.</operator><name>second</name></name></expr>;

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pwallet</name><operator>-&gt;</operator><name>ImportScripts</name></name><argument_list>(<argument><expr><block>{<expr><name>script</name></expr>}</block></expr></argument>, <argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>WalletLogPrintf</name></name><argument_list>(<argument><expr><literal type="string">"Error importing script %s\n"</literal></expr></argument>, <argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><name>script</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>fGood</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                <continue>continue;</continue>
            <expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>time</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>nTimeBegin</name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>min</name></name><argument_list>(<argument><expr><name>nTimeBegin</name></expr></argument>, <argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>progress</name><operator>++</operator></expr>;</expr_stmt>
        }
        pwallet<expr_stmt><expr><operator>-&gt;</operator><call><name>chain</name><argument_list>()</argument_list></call><operator>.</operator><call><name>showProgress</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// hide progress dialog in GUI</comment>
    }
    pwallet<expr_stmt><expr><operator>-&gt;</operator><call><name>chain</name><argument_list>()</argument_list></call><operator>.</operator><call><name>showProgress</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// hide progress dialog in GUI</comment>
    <expr_stmt><expr><call><name>RescanWallet</name><argument_list>(<argument><expr><operator>*</operator><name>pwallet</name></expr></argument>, <argument><expr><name>reserver</name></expr></argument>, <argument><expr><name>nTimeBegin</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument> <comment type="block">/* update */</comment>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>MarkDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fGood</name></expr>)</condition><block type="pseudo"><block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_WALLET_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error adding some keys/scripts to wallet"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

    <return>return <expr><name>NullUniValue</name></expr>;</return>
}

UniValue <macro><name>dumpprivkey</name><argument_list>(<argument>const JSONRPCRequest&amp; request</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CWallet</name></expr></argument>&gt;</argument_list></name> <specifier>const</specifier></type> <name>wallet</name> <init>= <expr><call><name>GetWalletForJSONRPCRequest</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CWallet</name><modifier>*</modifier> <specifier>const</specifier></type> <name>pwallet</name> <init>= <expr><call><name><name>wallet</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EnsureWalletIsAvailable</name><argument_list>(<argument><expr><name>pwallet</name></expr></argument>, <argument><expr><name><name>request</name><operator>.</operator><name>fHelp</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>NullUniValue</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>RPCHelpMan</name><argument_list>{<argument><expr><literal type="string">"dumpprivkey"</literal></expr></argument>,
                <argument><expr><literal type="string">"\nReveals the private key corresponding to 'address'.\n"</literal>
                <literal type="string">"Then the importprivkey can be used with this output\n"</literal></expr></argument>,
                <block>{<block_content>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"address"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"The bitcoin address for the private key"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                <expr_stmt/>}</block_content></block>,
                <argument><expr><call><name>RPCResult</name><argument_list>{
            <argument><expr><literal type="string">"\"key\"                (string) The private key\n"</literal></expr></argument>
                }</argument_list></call></expr></argument>,
                <argument><expr><call><name>RPCExamples</name><argument_list>{
                    <argument><expr><call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"dumpprivkey"</literal></expr></argument>, <argument><expr><literal type="string">"\"myaddress\""</literal></expr></argument>)</argument_list></call>
            <operator>+</operator> <call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"importprivkey"</literal></expr></argument>, <argument><expr><literal type="string">"\"mykey\""</literal></expr></argument>)</argument_list></call>
            <operator>+</operator> <macro><name>HelpExampleRpc</name><argument_list>(<argument><literal type="string">"dumpprivkey"</literal></argument>, <argument><literal type="string">"\"myaddress\""</literal></argument>)</argument_list></macro></expr></argument>
                }</argument_list></call></expr></argument>,
            }</argument_list></call><operator>.</operator><call><name>Check</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>LegacyScriptPubKeyMan</name><modifier>&amp;</modifier></type> <name>spk_man</name> <init>= <expr><call><name>EnsureLegacyScriptPubKeyMan</name><argument_list>(<argument><expr><operator>*</operator><name>wallet</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>locked_chain</name> <init>= <expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>chain</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pwallet</name><operator>-&gt;</operator><name>cs_wallet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>EnsureWalletIsUnlocked</name><argument_list>(<argument><expr><name>pwallet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>strAddress</name> <init>= <expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CTxDestination</name></type> <name>dest</name> <init>= <expr><call><name>DecodeDestination</name><argument_list>(<argument><expr><name>strAddress</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsValidDestination</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><literal type="string">"Invalid Bitcoin address"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>keyid</name> <init>= <expr><call><name>GetKeyForDestination</name><argument_list>(<argument><expr><name>spk_man</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>keyid</name><operator>.</operator><name>IsNull</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_TYPE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Address does not refer to a key"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>CKey</name></type> <name>vchSecret</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>spk_man</name><operator>.</operator><name>GetKey</name></name><argument_list>(<argument><expr><name>keyid</name></expr></argument>, <argument><expr><name>vchSecret</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_WALLET_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Private key for address "</literal> <operator>+</operator> <name>strAddress</name> <operator>+</operator> <literal type="string">" is not known"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name>EncodeSecret</name><argument_list>(<argument><expr><name>vchSecret</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>


<function><type><name>UniValue</name></type> <name>dumpwallet</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>JSONRPCRequest</name><modifier>&amp;</modifier></type> <name>request</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CWallet</name></expr></argument>&gt;</argument_list></name> <specifier>const</specifier></type> <name>wallet</name> <init>= <expr><call><name>GetWalletForJSONRPCRequest</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CWallet</name><modifier>*</modifier> <specifier>const</specifier></type> <name>pwallet</name> <init>= <expr><call><name><name>wallet</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EnsureWalletIsAvailable</name><argument_list>(<argument><expr><name>pwallet</name></expr></argument>, <argument><expr><name><name>request</name><operator>.</operator><name>fHelp</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>NullUniValue</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>RPCHelpMan</name><argument_list>{<argument><expr><literal type="string">"dumpwallet"</literal></expr></argument>,
                <argument><expr><literal type="string">"\nDumps all wallet keys in a human-readable format to a server-side file. This does not allow overwriting existing files.\n"</literal>
                <literal type="string">"Imported scripts are included in the dumpfile, but corresponding BIP173 addresses, etc. may not be added automatically by importwallet.\n"</literal>
                <literal type="string">"Note that if your wallet contains keys which are not derived from your HD seed (e.g. imported keys), these are not covered by\n"</literal>
                <literal type="string">"only backing up the seed itself, and must be backed up too (e.g. ensure you back up the whole dumpfile).\n"</literal></expr></argument>,
                <block>{<block_content>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"filename"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"The filename with path (either absolute or relative to bitcoind)"</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                <expr_stmt/>}</block_content></block>,
                <argument><expr><call><name>RPCResult</name><argument_list>{
            <argument><expr><literal type="string">"{                           (json object)\n"</literal>
            <literal type="string">"  \"filename\" : {        (string) The filename with full absolute path\n"</literal>
            <literal type="string">"}\n"</literal></expr></argument>
                }</argument_list></call></expr></argument>,
                <argument><expr><call><name>RPCExamples</name><argument_list>{
                    <argument><expr><call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"dumpwallet"</literal></expr></argument>, <argument><expr><literal type="string">"\"test\""</literal></expr></argument>)</argument_list></call>
            <operator>+</operator> <macro><name>HelpExampleRpc</name><argument_list>(<argument><literal type="string">"dumpwallet"</literal></argument>, <argument><literal type="string">"\"test\""</literal></argument>)</argument_list></macro></expr></argument>
                }</argument_list></call></expr></argument>,
            }</argument_list></call><operator>.</operator><call><name>Check</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>LegacyScriptPubKeyMan</name><modifier>&amp;</modifier></type> <name>spk_man</name> <init>= <expr><call><name>EnsureLegacyScriptPubKeyMan</name><argument_list>(<argument><expr><operator>*</operator><name>wallet</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>locked_chain</name> <init>= <expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>chain</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pwallet</name><operator>-&gt;</operator><name>cs_wallet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AssertLockHeld</name><argument_list>(<argument><expr><name><name>spk_man</name><operator>.</operator><name>cs_wallet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>EnsureWalletIsUnlocked</name><argument_list>(<argument><expr><name>pwallet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>fs</name><operator>::</operator><name>path</name></name></type> <name>filepath</name> <init>= <expr><name><name>request</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>filepath</name> <operator>=</operator> <call><name><name>fs</name><operator>::</operator><name>absolute</name></name><argument_list>(<argument><expr><name>filepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Prevent arbitrary files from being overwritten. There have been reports
     * that users have overwritten wallet files this way:
     * https://github.com/bitcoin/bitcoin/issues/9934
     * It may also avoid other security issues.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name><name>fs</name><operator>::</operator><name>exists</name></name><argument_list>(<argument><expr><name>filepath</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_PARAMETER</name></expr></argument>, <argument><expr><call><name><name>filepath</name><operator>.</operator><name>string</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="string">" already exists. If you are sure this is what you want, move it out of the way first"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name><name>fsbridge</name><operator>::</operator><name>ofstream</name></name></type> <name>file</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>file</name><operator>.</operator><name>open</name></name><argument_list>(<argument><expr><name>filepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>file</name><operator>.</operator><name>is_open</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_PARAMETER</name></expr></argument>, <argument><expr><literal type="string">"Cannot open wallet dump file"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>CKeyID</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name></type> <name>mapKeyBirth</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>CKeyID</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>mapKeyPool</name> <init>= <expr><call><name><name>spk_man</name><operator>.</operator><name>GetAllReserveKeys</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>GetKeyBirthTimes</name></name><argument_list>(<argument><expr><operator>*</operator><name>locked_chain</name></expr></argument>, <argument><expr><name>mapKeyBirth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>CScriptID</name></expr></argument>&gt;</argument_list></name></type> <name>scripts</name> <init>= <expr><call><name><name>spk_man</name><operator>.</operator><name>GetCScripts</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// sort time/key pairs</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>, <argument><expr><name>CKeyID</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type> <name>vKeyBirth</name></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>entry</name> <range>: <expr><name>mapKeyBirth</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>vKeyBirth</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>second</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>first</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name><name>mapKeyBirth</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>std</name><operator>::</operator><name>sort</name></name><argument_list>(<argument><expr><call><name><name>vKeyBirth</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>vKeyBirth</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// produce output</comment>
    <expr_stmt><expr><name>file</name> <operator>&lt;&lt;</operator> <call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"# Wallet dump created by Bitcoin %s\n"</literal></expr></argument>, <argument><expr><name>CLIENT_BUILD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>file</name> <operator>&lt;&lt;</operator> <call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"# * Created on %s\n"</literal></expr></argument>, <argument><expr><call><name>FormatISO8601DateTime</name><argument_list>(<argument><expr><call><name>GetTime</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type> <name>tip_height</name> <init>= <expr><call><name><name>locked_chain</name><operator>-&gt;</operator><name>getHeight</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>file</name> <operator>&lt;&lt;</operator> <call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"# * Best block at time of backup was %i (%s),\n"</literal></expr></argument>, <argument><expr><call><name><name>tip_height</name><operator>.</operator><name>get_value_or</name></name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><name>tip_height</name></expr> ?</condition><then> <expr><call><name><name>locked_chain</name><operator>-&gt;</operator><name>getBlockHash</name></name><argument_list>(<argument><expr><operator>*</operator><name>tip_height</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>ToString</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="string">"(missing block hash)"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>file</name> <operator>&lt;&lt;</operator> <call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"#   mined on %s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>tip_height</name></expr> ?</condition><then> <expr><call><name>FormatISO8601DateTime</name><argument_list>(<argument><expr><call><name><name>locked_chain</name><operator>-&gt;</operator><name>getBlockTime</name></name><argument_list>(<argument><expr><operator>*</operator><name>tip_height</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">"(missing block time)"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>file</name> <operator>&lt;&lt;</operator> <literal type="string">"\n"</literal></expr>;</expr_stmt>

    <comment type="line">// add the base58check encoded extended master if the wallet uses HD</comment>
    <decl_stmt><decl><type><name>CKeyID</name></type> <name>seed_id</name> <init>= <expr><call><name><name>spk_man</name><operator>.</operator><name>GetHDChain</name></name><argument_list>()</argument_list></call><operator>.</operator><name>seed_id</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>seed_id</name><operator>.</operator><name>IsNull</name></name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CKey</name></type> <name>seed</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>spk_man</name><operator>.</operator><name>GetKey</name></name><argument_list>(<argument><expr><name>seed_id</name></expr></argument>, <argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>CExtKey</name></type> <name>masterKey</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>masterKey</name><operator>.</operator><name>SetSeed</name></name><argument_list>(<argument><expr><call><name><name>seed</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>seed</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>file</name> <operator>&lt;&lt;</operator> <literal type="string">"# extended private masterkey: "</literal> <operator>&lt;&lt;</operator> <call><name>EncodeExtKey</name><argument_list>(<argument><expr><name>masterKey</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="string">"\n\n"</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>, <argument><expr><name>CKeyID</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list><operator>::</operator><name>const_iterator</name></name></type> <name>it</name> <init>= <expr><call><name><name>vKeyBirth</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>it</name> <operator>!=</operator> <call><name><name>vKeyBirth</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>it</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>CKeyID</name> <modifier>&amp;</modifier></type><name>keyid</name> <init>= <expr><name><name>it</name><operator>-&gt;</operator><name>second</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>strTime</name> <init>= <expr><call><name>FormatISO8601DateTime</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>first</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>strAddr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>strLabel</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CKey</name></type> <name>key</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>spk_man</name><operator>.</operator><name>GetKey</name></name><argument_list>(<argument><expr><name>keyid</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>file</name> <operator>&lt;&lt;</operator> <call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"%s %s "</literal></expr></argument>, <argument><expr><call><name>EncodeSecret</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>strTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>GetWalletAddressesForKey</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spk_man</name></expr></argument>, <argument><expr><name>pwallet</name></expr></argument>, <argument><expr><name>keyid</name></expr></argument>, <argument><expr><name>strAddr</name></expr></argument>, <argument><expr><name>strLabel</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
               <expr_stmt><expr><name>file</name> <operator>&lt;&lt;</operator> <call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"label=%s"</literal></expr></argument>, <argument><expr><name>strLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>keyid</name> <operator>==</operator> <name>seed_id</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>file</name> <operator>&lt;&lt;</operator> <literal type="string">"hdseed=1"</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>mapKeyPool</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>keyid</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>file</name> <operator>&lt;&lt;</operator> <literal type="string">"reserve=1"</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>spk_man</name><operator>.</operator><name>mapKeyMetadata</name><index>[<expr><name>keyid</name></expr>]</index></name><operator>.</operator><name>hdKeypath</name> <operator>==</operator> <literal type="string">"s"</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>file</name> <operator>&lt;&lt;</operator> <literal type="string">"inactivehdseed=1"</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>file</name> <operator>&lt;&lt;</operator> <literal type="string">"change=1"</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name>file</name> <operator>&lt;&lt;</operator> <call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">" # addr=%s%s\n"</literal></expr></argument>, <argument><expr><name>strAddr</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>spk_man</name><operator>.</operator><name>mapKeyMetadata</name><index>[<expr><name>keyid</name></expr>]</index></name><operator>.</operator><name>has_key_origin</name></expr> ?</condition><then> <expr><literal type="string">" hdkeypath="</literal><operator>+</operator><call><name>WriteHDKeypath</name><argument_list>(<argument><expr><name><name>spk_man</name><operator>.</operator><name>mapKeyMetadata</name><index>[<expr><name>keyid</name></expr>]</index></name><operator>.</operator><name><name>key_origin</name><operator>.</operator><name>path</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>file</name> <operator>&lt;&lt;</operator> <literal type="string">"\n"</literal></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CScriptID</name> <modifier>&amp;</modifier></type><name>scriptid</name> <range>: <expr><name>scripts</name></expr></range></decl></init>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>CScript</name></type> <name>script</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>create_time</name> <init>= <expr><literal type="string">"0"</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>address</name> <init>= <expr><call><name>EncodeDestination</name><argument_list>(<argument><expr><call><name>ScriptHash</name><argument_list>(<argument><expr><name>scriptid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// get birth times for scripts with metadata</comment>
        <decl_stmt><decl><type><name>auto</name></type> <name>it</name> <init>= <expr><call><name><name>spk_man</name><operator>.</operator><name>m_script_metadata</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>scriptid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>it</name> <operator>!=</operator> <call><name><name>spk_man</name><operator>.</operator><name>m_script_metadata</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>create_time</name> <operator>=</operator> <call><name>FormatISO8601DateTime</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>nCreateTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>(<expr><call><name><name>spk_man</name><operator>.</operator><name>GetCScript</name></name><argument_list>(<argument><expr><name>scriptid</name></expr></argument>, <argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>file</name> <operator>&lt;&lt;</operator> <call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"%s %s script=1"</literal></expr></argument>, <argument><expr><call><name>HexStr</name><argument_list>(<argument><expr><call><name><name>script</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>script</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>create_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>file</name> <operator>&lt;&lt;</operator> <call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">" # addr=%s\n"</literal></expr></argument>, <argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>file</name> <operator>&lt;&lt;</operator> <literal type="string">"\n"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>file</name> <operator>&lt;&lt;</operator> <literal type="string">"# End of dump\n"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>file</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>UniValue</name></type> <name>reply</name><argument_list>(<argument><expr><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>reply</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"filename"</literal></expr></argument>, <argument><expr><call><name><name>filepath</name><operator>.</operator><name>string</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>reply</name></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>ImportData</name>
<block>{<public type="default">
    <comment type="line">// Input data</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CScript</name></expr></argument>&gt;</argument_list></name></type> <name>redeemscript</name></decl>;</decl_stmt> <comment type="line" format="doxygen">//!&lt; Provided redeemScript; will be moved to `import_scripts` if relevant.</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CScript</name></expr></argument>&gt;</argument_list></name></type> <name>witnessscript</name></decl>;</decl_stmt> <comment type="line" format="doxygen">//!&lt; Provided witnessScript; will be moved to `import_scripts` if relevant.</comment>

    <comment type="line">// Output data</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>CScript</name></expr></argument>&gt;</argument_list></name></type> <name>import_scripts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>CKeyID</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name></type> <name>used_keys</name></decl>;</decl_stmt> <comment type="line" format="doxygen">//!&lt; Import these private keys if available (the value indicates whether if the key is required for solvability)</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>CKeyID</name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>CPubKey</name></expr></argument>, <argument><expr><name>KeyOriginInfo</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>key_origins</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<enum type="class">enum class <name>ScriptContext</name>
<block>{
    <decl><name>TOP</name></decl>, <comment type="line" format="doxygen">//!&lt; Top-level scriptPubKey</comment>
    <decl><name>P2SH</name></decl>, <comment type="line" format="doxygen">//!&lt; P2SH redeemScript</comment>
    <decl><name>WITNESS_V0</name></decl>, <comment type="line" format="doxygen">//!&lt; P2WSH witnessScript</comment>
}</block>;</enum>

<comment type="line">// Analyse the provided scriptPubKey, determining which keys and which redeem scripts from the ImportData struct are needed to spend it, and mark them as used.</comment>
<comment type="line">// Returns an error string, or the empty string for success.</comment>
<function><type><specifier>static</specifier> <name><name>std</name><operator>::</operator><name>string</name></name></type> <name>RecurseImportData</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CScript</name><modifier>&amp;</modifier></type> <name>script</name></decl></parameter>, <parameter><decl><type><name>ImportData</name><modifier>&amp;</modifier></type> <name>import_data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ScriptContext</name></type> <name>script_ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">// Use Solver to obtain script type and parsed pubkeys or hashes:</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>solverdata</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>txnouttype</name></type> <name>script_type</name> <init>= <expr><call><name>Solver</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><name>solverdata</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>script_type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>TX_PUBKEY</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>CPubKey</name></type> <name>pubkey</name><argument_list>(<argument><expr><name><name>solverdata</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>solverdata</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>import_data</name><operator>.</operator><name>used_keys</name><operator>.</operator><name>emplace</name></name><argument_list>(<argument><expr><call><name><name>pubkey</name><operator>.</operator><name>GetID</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="string">""</literal></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TX_PUBKEYHASH</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>CKeyID</name></type> <name>id</name> <init>= <expr><call><name>CKeyID</name><argument_list>(<argument><expr><call><name>uint160</name><argument_list>(<argument><expr><name><name>solverdata</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>import_data</name><operator>.</operator><name>used_keys</name><index>[<expr><name>id</name></expr>]</index></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        <return>return <expr><literal type="string">""</literal></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TX_SCRIPTHASH</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>script_ctx</name> <operator>==</operator> <name><name>ScriptContext</name><operator>::</operator><name>P2SH</name></name></expr>)</condition><block type="pseudo"><block_content> <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><literal type="string">"Trying to nest P2SH inside another P2SH"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>script_ctx</name> <operator>==</operator> <name><name>ScriptContext</name><operator>::</operator><name>WITNESS_V0</name></name></expr>)</condition><block type="pseudo"><block_content> <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><literal type="string">"Trying to nest P2SH inside a P2WSH"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>CHECK_NONFATAL</name><argument_list>(<argument><expr><name>script_ctx</name> <operator>==</operator> <name><name>ScriptContext</name><operator>::</operator><name>TOP</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>CScriptID</name></type> <name>id</name> <init>= <expr><call><name>CScriptID</name><argument_list>(<argument><expr><call><name>uint160</name><argument_list>(<argument><expr><name><name>solverdata</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>subscript</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name><name>import_data</name><operator>.</operator><name>redeemscript</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// Remove redeemscript from import_data to check for superfluous script later.</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>subscript</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="string">"missing redeemscript"</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>CScriptID</name><argument_list>(<argument><expr><operator>*</operator><name>subscript</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>id</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="string">"redeemScript does not match the scriptPubKey"</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name><name>import_data</name><operator>.</operator><name>import_scripts</name><operator>.</operator><name>emplace</name></name><argument_list>(<argument><expr><operator>*</operator><name>subscript</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>RecurseImportData</name><argument_list>(<argument><expr><operator>*</operator><name>subscript</name></expr></argument>, <argument><expr><name>import_data</name></expr></argument>, <argument><expr><name><name>ScriptContext</name><operator>::</operator><name>P2SH</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TX_MULTISIG</name></expr>:</case> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>&lt;</operator> <call><name><name>solverdata</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>CPubKey</name></type> <name>pubkey</name><argument_list>(<argument><expr><name><name>solverdata</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>solverdata</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>import_data</name><operator>.</operator><name>used_keys</name><operator>.</operator><name>emplace</name></name><argument_list>(<argument><expr><call><name><name>pubkey</name><operator>.</operator><name>GetID</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <return>return <expr><literal type="string">""</literal></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TX_WITNESS_V0_SCRIPTHASH</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>script_ctx</name> <operator>==</operator> <name><name>ScriptContext</name><operator>::</operator><name>WITNESS_V0</name></name></expr>)</condition><block type="pseudo"><block_content> <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><literal type="string">"Trying to nest P2WSH inside another P2WSH"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>uint256</name></type> <name>fullid</name><argument_list>(<argument><expr><name><name>solverdata</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CScriptID</name></type> <name>id</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>CRIPEMD160</name><argument_list>()</argument_list></call><operator>.</operator><call><name>Write</name><argument_list>(<argument><expr><call><name><name>fullid</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>fullid</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>Finalize</name><argument_list>(<argument><expr><call><name><name>id</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>subscript</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name><name>import_data</name><operator>.</operator><name>witnessscript</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// Remove redeemscript from import_data to check for superfluous script later.</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>subscript</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="string">"missing witnessscript"</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>CScriptID</name><argument_list>(<argument><expr><operator>*</operator><name>subscript</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>id</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="string">"witnessScript does not match the scriptPubKey or redeemScript"</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>script_ctx</name> <operator>==</operator> <name><name>ScriptContext</name><operator>::</operator><name>TOP</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>import_data</name><operator>.</operator><name>import_scripts</name><operator>.</operator><name>emplace</name></name><argument_list>(<argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Special rule for IsMine: native P2WSH requires the TOP script imported (see script/ismine.cpp)</comment>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>import_data</name><operator>.</operator><name>import_scripts</name><operator>.</operator><name>emplace</name></name><argument_list>(<argument><expr><operator>*</operator><name>subscript</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>RecurseImportData</name><argument_list>(<argument><expr><operator>*</operator><name>subscript</name></expr></argument>, <argument><expr><name>import_data</name></expr></argument>, <argument><expr><name><name>ScriptContext</name><operator>::</operator><name>WITNESS_V0</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TX_WITNESS_V0_KEYHASH</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>script_ctx</name> <operator>==</operator> <name><name>ScriptContext</name><operator>::</operator><name>WITNESS_V0</name></name></expr>)</condition><block type="pseudo"><block_content> <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><literal type="string">"Trying to nest P2WPKH inside P2WSH"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>CKeyID</name></type> <name>id</name> <init>= <expr><call><name>CKeyID</name><argument_list>(<argument><expr><call><name>uint160</name><argument_list>(<argument><expr><name><name>solverdata</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>import_data</name><operator>.</operator><name>used_keys</name><index>[<expr><name>id</name></expr>]</index></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>script_ctx</name> <operator>==</operator> <name><name>ScriptContext</name><operator>::</operator><name>TOP</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>import_data</name><operator>.</operator><name>import_scripts</name><operator>.</operator><name>emplace</name></name><argument_list>(<argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Special rule for IsMine: native P2WPKH requires the TOP script imported (see script/ismine.cpp)</comment>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="string">""</literal></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TX_NULL_DATA</name></expr>:</case>
        <return>return <expr><literal type="string">"unspendable script"</literal></expr>;</return>
    <case>case <expr><name>TX_NONSTANDARD</name></expr>:</case>
    <case>case <expr><name>TX_WITNESS_UNKNOWN</name></expr>:</case>
    <default>default:</default>
        <return>return <expr><literal type="string">"unrecognized script"</literal></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>UniValue</name></type> <name>ProcessImportLegacy</name><parameter_list>(<parameter><decl><type><name>ImportData</name><modifier>&amp;</modifier></type> <name>import_data</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>CKeyID</name></expr></argument>, <argument><expr><name>CPubKey</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>pubkey_map</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>CKeyID</name></expr></argument>, <argument><expr><name>CKey</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>privkey_map</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>CScript</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>script_pub_keys</name></decl></parameter>, <parameter><decl><type><name>bool</name><modifier>&amp;</modifier></type> <name>have_solving_data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UniValue</name><modifier>&amp;</modifier></type> <name>data</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CKeyID</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>ordered_pubkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>UniValue</name></type> <name>warnings</name><argument_list>(<argument><expr><name><name>UniValue</name><operator>::</operator><name>VARR</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>

    <comment type="line">// First ensure scriptPubKey has either a script or JSON with "address" string</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>UniValue</name><modifier>&amp;</modifier></type> <name>scriptPubKey</name> <init>= <expr><name><name>data</name><index>[<expr><literal type="string">"scriptPubKey"</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>isScript</name> <init>= <expr><call><name><name>scriptPubKey</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>UniValue</name><operator>::</operator><name>VSTR</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isScript</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><call><name><name>scriptPubKey</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name> <operator>&amp;&amp;</operator> <call><name><name>scriptPubKey</name><operator>.</operator><name>exists</name></name><argument_list>(<argument><expr><literal type="string">"address"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_PARAMETER</name></expr></argument>, <argument><expr><literal type="string">"scriptPubKey must be string with script or JSON with address string"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>output</name> <init>= <expr><ternary><condition><expr><name>isScript</name></expr> ?</condition><then> <expr><call><name><name>scriptPubKey</name><operator>.</operator><name>get_str</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><name><name>scriptPubKey</name><index>[<expr><literal type="string">"address"</literal></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <comment type="line">// Optional fields.</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>strRedeemScript</name> <init>= <expr><ternary><condition><expr><call><name><name>data</name><operator>.</operator><name>exists</name></name><argument_list>(<argument><expr><literal type="string">"redeemscript"</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>data</name><index>[<expr><literal type="string">"redeemscript"</literal></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>witness_script_hex</name> <init>= <expr><ternary><condition><expr><call><name><name>data</name><operator>.</operator><name>exists</name></name><argument_list>(<argument><expr><literal type="string">"witnessscript"</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>data</name><index>[<expr><literal type="string">"witnessscript"</literal></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>UniValue</name><modifier>&amp;</modifier></type> <name>pubKeys</name> <init>= <expr><ternary><condition><expr><call><name><name>data</name><operator>.</operator><name>exists</name></name><argument_list>(<argument><expr><literal type="string">"pubkeys"</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>data</name><index>[<expr><literal type="string">"pubkeys"</literal></expr>]</index></name><operator>.</operator><call><name>get_array</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>UniValue</name><argument_list>()</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>UniValue</name><modifier>&amp;</modifier></type> <name>keys</name> <init>= <expr><ternary><condition><expr><call><name><name>data</name><operator>.</operator><name>exists</name></name><argument_list>(<argument><expr><literal type="string">"keys"</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>data</name><index>[<expr><literal type="string">"keys"</literal></expr>]</index></name><operator>.</operator><call><name>get_array</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>UniValue</name><argument_list>()</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>internal</name> <init>= <expr><ternary><condition><expr><call><name><name>data</name><operator>.</operator><name>exists</name></name><argument_list>(<argument><expr><literal type="string">"internal"</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>data</name><index>[<expr><literal type="string">"internal"</literal></expr>]</index></name><operator>.</operator><call><name>get_bool</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="boolean">false</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>watchOnly</name> <init>= <expr><ternary><condition><expr><call><name><name>data</name><operator>.</operator><name>exists</name></name><argument_list>(<argument><expr><literal type="string">"watchonly"</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>data</name><index>[<expr><literal type="string">"watchonly"</literal></expr>]</index></name><operator>.</operator><call><name>get_bool</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="boolean">false</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>exists</name></name><argument_list>(<argument><expr><literal type="string">"range"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_PARAMETER</name></expr></argument>, <argument><expr><literal type="string">"Range should not be specified for a non-descriptor import"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Generate the script and destination for the scriptPubKey provided</comment>
    <decl_stmt><decl><type><name>CScript</name></type> <name>script</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isScript</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>CTxDestination</name></type> <name>dest</name> <init>= <expr><call><name>DecodeDestination</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsValidDestination</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><literal type="string">"Invalid address \""</literal> <operator>+</operator> <name>output</name> <operator>+</operator> <literal type="string">"\""</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>script</name> <operator>=</operator> <call><name>GetScriptForDestination</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsHex</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><literal type="string">"Invalid scriptPubKey \""</literal> <operator>+</operator> <name>output</name> <operator>+</operator> <literal type="string">"\""</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>vData</name><argument_list>(<argument><expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <expr_stmt><expr><name>script</name> <operator>=</operator> <call><name>CScript</name><argument_list>(<argument><expr><call><name><name>vData</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>vData</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>CTxDestination</name></type> <name>dest</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExtractDestination</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>internal</name></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_PARAMETER</name></expr></argument>, <argument><expr><literal type="string">"Internal must be set to true for nonstandard scriptPubKey imports."</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name><name>script_pub_keys</name><operator>.</operator><name>emplace</name></name><argument_list>(<argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Parse all arguments</comment>
    <if_stmt><if>if <condition>(<expr><call><name><name>strRedeemScript</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsHex</name><argument_list>(<argument><expr><name>strRedeemScript</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><literal type="string">"Invalid redeem script \""</literal> <operator>+</operator> <name>strRedeemScript</name> <operator>+</operator> <literal type="string">"\": must be hex string"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>parsed_redeemscript</name> <init>= <expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>strRedeemScript</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>import_data</name><operator>.</operator><name>redeemscript</name></name> <operator>=</operator> <call><name><name>MakeUnique</name><argument_list type="generic">&lt;<argument><expr><name>CScript</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>parsed_redeemscript</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>parsed_redeemscript</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>witness_script_hex</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsHex</name><argument_list>(<argument><expr><name>witness_script_hex</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><literal type="string">"Invalid witness script \""</literal> <operator>+</operator> <name>witness_script_hex</name> <operator>+</operator> <literal type="string">"\": must be hex string"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>parsed_witnessscript</name> <init>= <expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>witness_script_hex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>import_data</name><operator>.</operator><name>witnessscript</name></name> <operator>=</operator> <call><name><name>MakeUnique</name><argument_list type="generic">&lt;<argument><expr><name>CScript</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>parsed_witnessscript</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>parsed_witnessscript</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>pubKeys</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>str</name> <init>= <expr><name><name>pubKeys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsHex</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><literal type="string">"Pubkey \""</literal> <operator>+</operator> <name>str</name> <operator>+</operator> <literal type="string">"\" must be a hex string"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>parsed_pubkey</name> <init>= <expr><call><name>ParseHex</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CPubKey</name></type> <name>pubkey</name><argument_list>(<argument><expr><call><name><name>parsed_pubkey</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>parsed_pubkey</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pubkey</name><operator>.</operator><name>IsFullyValid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><literal type="string">"Pubkey \""</literal> <operator>+</operator> <name>str</name> <operator>+</operator> <literal type="string">"\" is not a valid public key"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>pubkey_map</name><operator>.</operator><name>emplace</name></name><argument_list>(<argument><expr><call><name><name>pubkey</name><operator>.</operator><name>GetID</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pubkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>ordered_pubkeys</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>pubkey</name><operator>.</operator><name>GetID</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>keys</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>str</name> <init>= <expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CKey</name></type> <name>key</name> <init>= <expr><call><name>DecodeSecret</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>key</name><operator>.</operator><name>IsValid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><literal type="string">"Invalid private key encoding"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>CPubKey</name></type> <name>pubkey</name> <init>= <expr><call><name><name>key</name><operator>.</operator><name>GetPubKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CKeyID</name></type> <name>id</name> <init>= <expr><call><name><name>pubkey</name><operator>.</operator><name>GetID</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>pubkey_map</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>pubkey_map</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>privkey_map</name><operator>.</operator><name>emplace</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>


    <comment type="line">// Verify and process input data</comment>
    <expr_stmt><expr><name>have_solving_data</name> <operator>=</operator> <name><name>import_data</name><operator>.</operator><name>redeemscript</name></name> <operator>||</operator> <name><name>import_data</name><operator>.</operator><name>witnessscript</name></name> <operator>||</operator> <call><name><name>pubkey_map</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>privkey_map</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>have_solving_data</name></expr>)</condition> <block>{<block_content>
        <comment type="line">// Match up data in import_data with the scriptPubKey in script.</comment>
        <decl_stmt><decl><type><name>auto</name></type> <name>error</name> <init>= <expr><call><name>RecurseImportData</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><name>import_data</name></expr></argument>, <argument><expr><name><name>ScriptContext</name><operator>::</operator><name>TOP</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Verify whether the watchonly option corresponds to the availability of private keys.</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>spendable</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>all_of</name></name><argument_list>(<argument><expr><call><name><name>import_data</name><operator>.</operator><name>used_keys</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>import_data</name><operator>.</operator><name>used_keys</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>CKeyID</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>used_key</name></decl></parameter>)</parameter_list><block>{<block_content> <return>return <expr><call><name><name>privkey_map</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name><name>used_key</name><operator>.</operator><name>first</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return> </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>watchOnly</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>spendable</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>warnings</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><literal type="string">"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>watchOnly</name> <operator>&amp;&amp;</operator> <name>spendable</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>warnings</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><literal type="string">"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Check that all required keys for solvability are provided.</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>error</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>require_key</name> <range>: <expr><name><name>import_data</name><operator>.</operator><name>used_keys</name></name></expr></range></decl></init>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>require_key</name><operator>.</operator><name>second</name></name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt> <comment type="line">// Not a required key</comment>
                <if_stmt><if>if <condition>(<expr><call><name><name>pubkey_map</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name><name>require_key</name><operator>.</operator><name>first</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name><name>privkey_map</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name><name>require_key</name><operator>.</operator><name>first</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>error</name> <operator>=</operator> <literal type="string">"some required keys are missing"</literal></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>error</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>warnings</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><literal type="string">"Importing as non-solvable: "</literal> <operator>+</operator> <name>error</name> <operator>+</operator> <literal type="string">". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>import_data</name> <operator>=</operator> <call><name>ImportData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>pubkey_map</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>privkey_map</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>have_solving_data</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="line">// RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.</comment>
            <if_stmt><if>if <condition>(<expr><name><name>import_data</name><operator>.</operator><name>redeemscript</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>warnings</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><literal type="string">"Ignoring redeemscript as this is not a P2SH script."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>import_data</name><operator>.</operator><name>witnessscript</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>warnings</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><literal type="string">"Ignoring witnessscript as this is not a (P2SH-)P2WSH script."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <for>for <control>(<init><decl><type><name>auto</name></type> <name>it</name> <init>= <expr><call><name><name>privkey_map</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>it</name> <operator>!=</operator> <call><name><name>privkey_map</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr/>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>auto</name></type> <name>oldit</name> <init>= <expr><name>it</name><operator>++</operator></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>import_data</name><operator>.</operator><name>used_keys</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name><name>oldit</name><operator>-&gt;</operator><name>first</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>warnings</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><literal type="string">"Ignoring irrelevant private key."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>privkey_map</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>oldit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <for>for <control>(<init><decl><type><name>auto</name></type> <name>it</name> <init>= <expr><call><name><name>pubkey_map</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>it</name> <operator>!=</operator> <call><name><name>pubkey_map</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr/>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>auto</name></type> <name>oldit</name> <init>= <expr><name>it</name><operator>++</operator></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>auto</name></type> <name>key_data_it</name> <init>= <expr><call><name><name>import_data</name><operator>.</operator><name>used_keys</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name><name>oldit</name><operator>-&gt;</operator><name>first</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>key_data_it</name> <operator>==</operator> <call><name><name>import_data</name><operator>.</operator><name>used_keys</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><name><name>key_data_it</name><operator>-&gt;</operator><name>second</name></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>warnings</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><literal type="string">"Ignoring public key \""</literal> <operator>+</operator> <call><name>HexStr</name><argument_list>(<argument><expr><name><name>oldit</name><operator>-&gt;</operator><name>first</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="string">"\" as it doesn't appear inside P2PKH or P2WPKH."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>pubkey_map</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>oldit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>warnings</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>UniValue</name></type> <name>ProcessImportDescriptor</name><parameter_list>(<parameter><decl><type><name>ImportData</name><modifier>&amp;</modifier></type> <name>import_data</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>CKeyID</name></expr></argument>, <argument><expr><name>CPubKey</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>pubkey_map</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>CKeyID</name></expr></argument>, <argument><expr><name>CKey</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>privkey_map</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>CScript</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>script_pub_keys</name></decl></parameter>, <parameter><decl><type><name>bool</name><modifier>&amp;</modifier></type> <name>have_solving_data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UniValue</name><modifier>&amp;</modifier></type> <name>data</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CKeyID</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>ordered_pubkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>UniValue</name></type> <name>warnings</name><argument_list>(<argument><expr><name><name>UniValue</name><operator>::</operator><name>VARR</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>descriptor</name> <init>= <expr><name><name>data</name><index>[<expr><literal type="string">"desc"</literal></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FlatSigningProvider</name></type> <name>keys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>error</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>parsed_desc</name> <init>= <expr><call><name>Parse</name><argument_list>(<argument><expr><name>descriptor</name></expr></argument>, <argument><expr><name>keys</name></expr></argument>, <argument><expr><name>error</name></expr></argument>, <comment type="block">/* require_checksum = */</comment> <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>parsed_desc</name></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>have_solving_data</name> <operator>=</operator> <call><name><name>parsed_desc</name><operator>-&gt;</operator><name>IsSolvable</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>watch_only</name> <init>= <expr><ternary><condition><expr><call><name><name>data</name><operator>.</operator><name>exists</name></name><argument_list>(<argument><expr><literal type="string">"watchonly"</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>data</name><index>[<expr><literal type="string">"watchonly"</literal></expr>]</index></name><operator>.</operator><call><name>get_bool</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="boolean">false</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>range_start</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>range_end</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>parsed_desc</name><operator>-&gt;</operator><name>IsRange</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>data</name><operator>.</operator><name>exists</name></name><argument_list>(<argument><expr><literal type="string">"range"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_PARAMETER</name></expr></argument>, <argument><expr><literal type="string">"Range should not be specified for an un-ranged descriptor"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>parsed_desc</name><operator>-&gt;</operator><name>IsRange</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>data</name><operator>.</operator><name>exists</name></name><argument_list>(<argument><expr><literal type="string">"range"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_PARAMETER</name></expr></argument>, <argument><expr><literal type="string">"Descriptor is ranged, please specify the range"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>std</name><operator>::</operator><name>tie</name></name><argument_list>(<argument><expr><name>range_start</name></expr></argument>, <argument><expr><name>range_end</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>ParseDescriptorRange</name><argument_list>(<argument><expr><name><name>data</name><index>[<expr><literal type="string">"range"</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>UniValue</name><modifier>&amp;</modifier></type> <name>priv_keys</name> <init>= <expr><ternary><condition><expr><call><name><name>data</name><operator>.</operator><name>exists</name></name><argument_list>(<argument><expr><literal type="string">"keys"</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>data</name><index>[<expr><literal type="string">"keys"</literal></expr>]</index></name><operator>.</operator><call><name>get_array</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>UniValue</name><argument_list>()</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <comment type="line">// Expand all descriptors to get public keys and scripts, and private keys if available.</comment>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>range_start</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>range_end</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>FlatSigningProvider</name></type> <name>out_keys</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CScript</name></expr></argument>&gt;</argument_list></name></type> <name>scripts_temp</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>parsed_desc</name><operator>-&gt;</operator><name>Expand</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>keys</name></expr></argument>, <argument><expr><name>scripts_temp</name></expr></argument>, <argument><expr><name>out_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>std</name><operator>::</operator><name>copy</name></name><argument_list>(<argument><expr><call><name><name>scripts_temp</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>scripts_temp</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>inserter</name></name><argument_list>(<argument><expr><name>script_pub_keys</name></expr></argument>, <argument><expr><call><name><name>script_pub_keys</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>key_pair</name> <range>: <expr><name><name>out_keys</name><operator>.</operator><name>pubkeys</name></name></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>ordered_pubkeys</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name><name>key_pair</name><operator>.</operator><name>first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>x</name> <range>: <expr><name><name>out_keys</name><operator>.</operator><name>scripts</name></name></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>import_data</name><operator>.</operator><name>import_scripts</name><operator>.</operator><name>emplace</name></name><argument_list>(<argument><expr><name><name>x</name><operator>.</operator><name>second</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name><name>parsed_desc</name><operator>-&gt;</operator><name>ExpandPrivate</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>keys</name></expr></argument>, <argument><expr><name>out_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>std</name><operator>::</operator><name>copy</name></name><argument_list>(<argument><expr><call><name><name>out_keys</name><operator>.</operator><name>pubkeys</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>out_keys</name><operator>.</operator><name>pubkeys</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>inserter</name></name><argument_list>(<argument><expr><name>pubkey_map</name></expr></argument>, <argument><expr><call><name><name>pubkey_map</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>std</name><operator>::</operator><name>copy</name></name><argument_list>(<argument><expr><call><name><name>out_keys</name><operator>.</operator><name>keys</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>out_keys</name><operator>.</operator><name>keys</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>inserter</name></name><argument_list>(<argument><expr><name>privkey_map</name></expr></argument>, <argument><expr><call><name><name>privkey_map</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>import_data</name><operator>.</operator><name>key_origins</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>out_keys</name><operator>.</operator><name>origins</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>out_keys</name><operator>.</operator><name>origins</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>priv_keys</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>str</name> <init>= <expr><name><name>priv_keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CKey</name></type> <name>key</name> <init>= <expr><call><name>DecodeSecret</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>key</name><operator>.</operator><name>IsValid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_INVALID_ADDRESS_OR_KEY</name></expr></argument>, <argument><expr><literal type="string">"Invalid private key encoding"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>CPubKey</name></type> <name>pubkey</name> <init>= <expr><call><name><name>key</name><operator>.</operator><name>GetPubKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CKeyID</name></type> <name>id</name> <init>= <expr><call><name><name>pubkey</name><operator>.</operator><name>GetID</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Check if this private key corresponds to a public key from the descriptor</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pubkey_map</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>warnings</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><literal type="string">"Ignoring irrelevant private key."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name><name>privkey_map</name><operator>.</operator><name>emplace</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="line">// Check if all the public keys have corresponding private keys in the import for spendability.</comment>
    <comment type="line">// This does not take into account threshold multisigs which could be spendable without all keys.</comment>
    <comment type="line">// Thus, threshold multisigs without all keys will be considered not spendable here, even if they are,</comment>
    <comment type="line">// perhaps triggering a false warning message. This is consistent with the current wallet IsMine check.</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>spendable</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>all_of</name></name><argument_list>(<argument><expr><call><name><name>pubkey_map</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pubkey_map</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>,
        <argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>CKeyID</name></expr></argument>, <argument><expr><name>CPubKey</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>used_key</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <return>return <expr><call><name><name>privkey_map</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name><name>used_key</name><operator>.</operator><name>first</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
        </block_content>}</block></lambda></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>std</name><operator>::</operator><name>all_of</name></name><argument_list>(<argument><expr><call><name><name>import_data</name><operator>.</operator><name>key_origins</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>import_data</name><operator>.</operator><name>key_origins</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>,
        <argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>CKeyID</name></expr></argument>, <argument><expr><name><name>std</name><operator>::</operator><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>CPubKey</name></expr></argument>, <argument><expr><name>KeyOriginInfo</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>entry</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <return>return <expr><call><name><name>privkey_map</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>first</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
        </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>watch_only</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>spendable</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>warnings</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><literal type="string">"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>watch_only</name> <operator>&amp;&amp;</operator> <name>spendable</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>warnings</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><literal type="string">"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>warnings</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>UniValue</name></type> <name>ProcessImport</name><argument_list>(<argument><expr><name>CWallet</name> <operator>*</operator> <specifier>const</specifier> <name>pwallet</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>UniValue</name><operator>&amp;</operator> <name>data</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>int64_t</name> <name>timestamp</name></expr></argument>)</argument_list> <name>EXCLUSIVE_LOCKS_REQUIRED</name><argument_list>(<argument><expr><name><name>pwallet</name><operator>-&gt;</operator><name>cs_wallet</name></name></expr></argument>)</argument_list>
<argument_list>{
    <argument><expr><name>UniValue</name> <call><name>warnings</name><argument_list>(<argument><expr><name><name>UniValue</name><operator>::</operator><name>VARR</name></name></expr></argument>)</argument_list></call></expr></argument>;
    <argument><expr><name>UniValue</name> <call><name>result</name><argument_list>(<argument><expr><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></expr></argument>)</argument_list></call></expr></argument>;

    <argument><expr><macro><name>try</name></macro> <block>{
        <expr><specifier>const</specifier> <name>bool</name> <name>internal</name> <operator>=</operator> <call><name><name>data</name><operator>.</operator><name>exists</name></name><argument_list>(<argument><expr><literal type="string">"internal"</literal></expr></argument>)</argument_list></call> <operator>?</operator> <name><name>data</name><index>[<expr><literal type="string">"internal"</literal></expr>]</index></name><operator>.</operator><call><name>get_bool</name><argument_list>()</argument_list></call> <operator>:</operator> <literal type="boolean">false</literal></expr>;
        <comment type="line">// Internal addresses should not have a label</comment>
        <if_stmt><if>if <condition>(<expr><name>internal</name> <operator>&amp;&amp;</operator> <call><name><name>data</name><operator>.</operator><name>exists</name></name><argument_list>(<argument><expr><literal type="string">"label"</literal></expr></argument>)</argument_list></call></expr>)</condition> <expr_stmt><expr><block>{
            <throw>throw <argument_list>JSONRPCError<argument><expr><operator>(</operator><name>RPC_INVALID_PARAMETER</name><operator>,</operator> <literal type="string">"Internal addresses should not have a label"</literal><operator>)</operator></expr></argument></argument_list></throw>;
        }</block>
        <specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><operator>&amp;</operator> <name>label</name> <operator>=</operator> <ternary><condition><expr><call><name><name>data</name><operator>.</operator><name>exists</name></name><argument_list>(<argument><expr><literal type="string">"label"</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>data</name><index>[<expr><literal type="string">"label"</literal></expr>]</index></name><operator>.</operator><call><name>get_str</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr>;</expr_stmt></if></if_stmt>
        <specifier>const</specifier> <name>bool</name> <name>add_keypool</name> <operator>=</operator> <ternary><condition><expr><call><name><name>data</name><operator>.</operator><name>exists</name></name><argument_list>(<argument><expr><literal type="string">"keypool"</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>data</name><index>[<expr><literal type="string">"keypool"</literal></expr>]</index></name><operator>.</operator><call><name>get_bool</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="boolean">false</literal></expr></else></ternary></block></expr></argument>;

        <comment type="line">// Add to keypool only works with privkeys disabled</comment>
        if <argument><expr><operator>(</operator><name>add_keypool</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>pwallet</name><operator>-&gt;</operator><name>IsWalletFlagSet</name></name><argument_list>(<argument><expr><name>WALLET_FLAG_DISABLE_PRIVATE_KEYS</name></expr></argument>)</argument_list></call><operator>)</operator> <block>{
            <throw>throw <argument_list>JSONRPCError<argument><expr><operator>(</operator><name>RPC_INVALID_PARAMETER</name><operator>,</operator> <literal type="string">"Keys can only be imported to the keypool when private keys are disabled"</literal><operator>)</operator></expr></argument></argument_list></throw>;
        }</block>

        <name>ImportData</name> <name>import_data</name></expr></argument>;
        <argument><expr><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>CKeyID</name></expr></argument>, <argument><expr><name>CPubKey</name></expr></argument>&gt;</argument_list></name> <name>pubkey_map</name></expr></argument>;
        <argument><expr><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>CKeyID</name></expr></argument>, <argument><expr><name>CKey</name></expr></argument>&gt;</argument_list></name> <name>privkey_map</name></expr></argument>;
        <argument><expr><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>CScript</name></expr></argument>&gt;</argument_list></name> <name>script_pub_keys</name></expr></argument>;
        <argument><expr><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CKeyID</name></expr></argument>&gt;</argument_list></name> <name>ordered_pubkeys</name></expr></argument>;
        <argument><expr><name>bool</name> <name>have_solving_data</name></expr></argument>;

        if <argument><expr><operator>(</operator><call><name><name>data</name><operator>.</operator><name>exists</name></name><argument_list>(<argument><expr><literal type="string">"scriptPubKey"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>data</name><operator>.</operator><name>exists</name></name><argument_list>(<argument><expr><literal type="string">"desc"</literal></expr></argument>)</argument_list></call><operator>)</operator> <block>{
            <throw>throw <argument_list>JSONRPCError<argument><expr><operator>(</operator><name>RPC_INVALID_PARAMETER</name><operator>,</operator> <literal type="string">"Both a descriptor and a scriptPubKey should not be provided."</literal><operator>)</operator></expr></argument></argument_list></throw>;
        }</block></expr></argument> <if_stmt><if type="elseif">else if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>exists</name></name><argument_list>(<argument><expr><literal type="string">"scriptPubKey"</literal></expr></argument>)</argument_list></call></expr>)</condition> <expr_stmt><expr><block>{
            <expr><name>warnings</name> <operator>=</operator> <call><name>ProcessImportLegacy</name><argument_list>(<argument><expr><name>import_data</name></expr></argument>, <argument><expr><name>pubkey_map</name></expr></argument>, <argument><expr><name>privkey_map</name></expr></argument>, <argument><expr><name>script_pub_keys</name></expr></argument>, <argument><expr><name>have_solving_data</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>ordered_pubkeys</name></expr></argument>)</argument_list></call></expr>;
        }</block></expr></expr_stmt></if> <if type="elseif">else if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>exists</name></name><argument_list>(<argument><expr><literal type="string">"desc"</literal></expr></argument>)</argument_list></call></expr>)</condition> <expr_stmt><expr><block>{
            <expr><name>warnings</name> <operator>=</operator> <call><name>ProcessImportDescriptor</name><argument_list>(<argument><expr><name>import_data</name></expr></argument>, <argument><expr><name>pubkey_map</name></expr></argument>, <argument><expr><name>privkey_map</name></expr></argument>, <argument><expr><name>script_pub_keys</name></expr></argument>, <argument><expr><name>have_solving_data</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>ordered_pubkeys</name></expr></argument>)</argument_list></call></expr>;
        }</block></expr></expr_stmt></if> <else>else <expr_stmt><expr><block>{
            <throw>throw <argument_list>JSONRPCError<argument><expr><operator>(</operator><name>RPC_INVALID_PARAMETER</name><operator>,</operator> <literal type="string">"Either a descriptor or scriptPubKey must be provided."</literal><operator>)</operator></expr></argument></argument_list></throw>;
        }</block></expr></expr_stmt></else></if_stmt></argument_list></decl></decl_stmt>

        <comment type="line">// If private keys are disabled, abort if private keys are being imported</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>IsWalletFlagSet</name></name><argument_list>(<argument><expr><name>WALLET_FLAG_DISABLE_PRIVATE_KEYS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>privkey_map</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_WALLET_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Cannot import private keys to a wallet with private keys disabled"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Check whether we have any work to do</comment>
        <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CScript</name><modifier>&amp;</modifier></type> <name>script</name> <range>: <expr><name>script_pub_keys</name></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>IsMine</name></name><argument_list>(<argument><expr><name>script</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>ISMINE_SPENDABLE</name></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_WALLET_ERROR</name></expr></argument>, <argument><expr><literal type="string">"The wallet already contains the private key for this address or script (\""</literal> <operator>+</operator> <call><name>HexStr</name><argument_list>(<argument><expr><call><name><name>script</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>script</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="string">"\")"</literal></expr></argument>)</argument_list></call></expr>;</throw>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="line">// All good, time to import</comment>
        <expr_stmt><expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>MarkDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pwallet</name><operator>-&gt;</operator><name>ImportScripts</name></name><argument_list>(<argument><expr><name><name>import_data</name><operator>.</operator><name>import_scripts</name></name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_WALLET_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error adding script to wallet"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pwallet</name><operator>-&gt;</operator><name>ImportPrivKeys</name></name><argument_list>(<argument><expr><name>privkey_map</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_WALLET_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error adding key to wallet"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pwallet</name><operator>-&gt;</operator><name>ImportPubKeys</name></name><argument_list>(<argument><expr><name>ordered_pubkeys</name></expr></argument>, <argument><expr><name>pubkey_map</name></expr></argument>, <argument><expr><name><name>import_data</name><operator>.</operator><name>key_origins</name></name></expr></argument>, <argument><expr><name>add_keypool</name></expr></argument>, <argument><expr><name>internal</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_WALLET_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error adding address to wallet"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pwallet</name><operator>-&gt;</operator><name>ImportScriptPubKeys</name></name><argument_list>(<argument><expr><name>label</name></expr></argument>, <argument><expr><name>script_pub_keys</name></expr></argument>, <argument><expr><name>have_solving_data</name></expr></argument>, <argument><expr><operator>!</operator><name>internal</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_WALLET_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error adding address to wallet"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"success"</literal></expr></argument>, <argument><expr><call><name>UniValue</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    } catch <expr_stmt><expr><operator>(</operator><specifier>const</specifier> <name>UniValue</name><operator>&amp;</operator> <name>e</name><operator>)</operator> <block>{
        <expr><call><name><name>result</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"success"</literal></expr></argument>, <argument><expr><call><name>UniValue</name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
        <expr><call><name><name>result</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"error"</literal></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;
    }</block></expr></expr_stmt> <catch>catch <parameter_list>(<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"success"</literal></expr></argument>, <argument><expr><call><name>UniValue</name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"error"</literal></expr></argument>, <argument><expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_MISC_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Missing required fields"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></catch>
    <if_stmt><if>if <condition>(<expr><call><name><name>warnings</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"warnings"</literal></expr></argument>, <argument><expr><name>warnings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>result</name></expr>;</return>
}

static <function><type><name>int64_t</name></type> <name>GetImportTimestamp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UniValue</name><modifier>&amp;</modifier></type> <name>data</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>now</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>exists</name></name><argument_list>(<argument><expr><literal type="string">"timestamp"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>UniValue</name><modifier>&amp;</modifier></type> <name>timestamp</name> <init>= <expr><name><name>data</name><index>[<expr><literal type="string">"timestamp"</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>timestamp</name><operator>.</operator><name>isNum</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><call><name><name>timestamp</name><operator>.</operator><name>get_int64</name></name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>timestamp</name><operator>.</operator><name>isStr</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>timestamp</name><operator>.</operator><name>get_str</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="string">"now"</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>now</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_TYPE_ERROR</name></expr></argument>, <argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"Expected number or \"now\" timestamp value for key. got type %s"</literal></expr></argument>, <argument><expr><call><name>uvTypeName</name><argument_list>(<argument><expr><call><name><name>timestamp</name><operator>.</operator><name>type</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>
    <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_TYPE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Missing required timestamp field for key"</literal></expr></argument>)</argument_list></call></expr>;</throw>
</block_content>}</block></function>

<function><type><name>UniValue</name></type> <name>importmulti</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>JSONRPCRequest</name><modifier>&amp;</modifier></type> <name>mainRequest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CWallet</name></expr></argument>&gt;</argument_list></name> <specifier>const</specifier></type> <name>wallet</name> <init>= <expr><call><name>GetWalletForJSONRPCRequest</name><argument_list>(<argument><expr><name>mainRequest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CWallet</name><modifier>*</modifier> <specifier>const</specifier></type> <name>pwallet</name> <init>= <expr><call><name><name>wallet</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EnsureWalletIsAvailable</name><argument_list>(<argument><expr><name>pwallet</name></expr></argument>, <argument><expr><name><name>mainRequest</name><operator>.</operator><name>fHelp</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>NullUniValue</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>RPCHelpMan</name><argument_list>{<argument><expr><literal type="string">"importmulti"</literal></expr></argument>,
                <argument><expr><literal type="string">"\nImport addresses/scripts (with private or public keys, redeem script (P2SH)), optionally rescanning the blockchain from the earliest creation time of the imported scripts. Requires a new wallet backup.\n"</literal>
                <literal type="string">"If an address/script is imported without all of the private keys required to spend from that address, it will be watchonly. The 'watchonly' option must be set to true in this case or a warning will be returned.\n"</literal>
                <literal type="string">"Conversely, if all the private keys are provided and the address/script is spendable, the watchonly option must be set to false, or a warning will be returned.\n"</literal>
            <literal type="string">"\nNote: This call can take over an hour to complete if rescan is true, during that time, other rpc calls\n"</literal>
            <literal type="string">"may report that the imported keys, addresses or scripts exist but related transactions are still missing.\n"</literal>
            <literal type="string">"Note: Use \"getwalletinfo\" to query the scanning progress.\n"</literal></expr></argument>,
                <block>{<block_content>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"requests"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>ARR</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr><operator>,</operator> <expr><literal type="string">"Data to be imported"</literal></expr><operator>,</operator>
                        <expr><block>{
                            <expr><block>{<expr><literal type="string">""</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>OBJ</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>OMITTED</name></name></expr>, <expr><literal type="string">""</literal></expr>,
                                <expr><block>{
                                    <expr><block>{<expr><literal type="string">"desc"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>OMITTED</name></name></expr>, <expr><literal type="string">"Descriptor to import. If using descriptor, do not also provide address/scriptPubKey, scripts, or pubkeys"</literal></expr>}</block></expr>,
                                    <expr><block>{<expr><literal type="string">"scriptPubKey"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr>, <expr><literal type="string">"Type of scriptPubKey (string for script, json for address). Should not be provided if using a descriptor"</literal></expr>,
                                        <comment type="block">/* oneline_description */</comment> <expr><literal type="string">""</literal></expr>, <expr><block>{<expr><literal type="string">"\"&lt;script&gt;\" | { \"address\":\"&lt;address&gt;\" }"</literal></expr>, <expr><literal type="string">"string / json"</literal></expr>}</block></expr>
                                    }</block></expr>,
                                    <expr><block>{<expr><literal type="string">"timestamp"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>NUM</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>NO</name></name></expr>, <expr><literal type="string">"Creation time of the key in seconds since epoch (Jan 1 1970 GMT),\n"</literal>
        <literal type="string">"                                                              or the string \"now\" to substitute the current synced blockchain time. The timestamp of the oldest\n"</literal>
        <literal type="string">"                                                              key will determine how far back blockchain rescans need to begin for missing wallet transactions.\n"</literal>
        <literal type="string">"                                                              \"now\" can be specified to bypass scanning, for keys which are known to never have been used, and\n"</literal>
        <literal type="string">"                                                              0 can be specified to scan the entire blockchain. Blocks up to 2 hours before the earliest key\n"</literal>
        <literal type="string">"                                                              creation time of all keys being imported by the importmulti call will be scanned."</literal></expr>,
                                        <comment type="block">/* oneline_description */</comment> <expr><literal type="string">""</literal></expr>, <expr><block>{<expr><literal type="string">"timestamp | \"now\""</literal></expr>, <expr><literal type="string">"integer / string"</literal></expr>}</block></expr>
                                    }</block></expr>,
                                    <expr><block>{<expr><literal type="string">"redeemscript"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>OMITTED</name></name></expr>, <expr><literal type="string">"Allowed only if the scriptPubKey is a P2SH or P2SH-P2WSH address/scriptPubKey"</literal></expr>}</block></expr>,
                                    <expr><block>{<expr><literal type="string">"witnessscript"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>OMITTED</name></name></expr>, <expr><literal type="string">"Allowed only if the scriptPubKey is a P2SH-P2WSH or P2WSH address/scriptPubKey"</literal></expr>}</block></expr>,
                                    <expr><block>{<expr><literal type="string">"pubkeys"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>ARR</name></name></expr>, <comment type="block">/* default */</comment> <expr><literal type="string">"empty array"</literal></expr>, <expr><literal type="string">"Array of strings giving pubkeys to import. They must occur in P2PKH or P2WPKH scripts. They are not required when the private key is also provided (see the \"keys\" argument)."</literal></expr>,
                                        <expr><block>{
                                            <expr><block>{<expr><literal type="string">"pubKey"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>OMITTED</name></name></expr>, <expr><literal type="string">""</literal></expr>}</block></expr>,
                                        }</block></expr>
                                    }</block></expr>,
                                    <expr><block>{<expr><literal type="string">"keys"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>ARR</name></name></expr>, <comment type="block">/* default */</comment> <expr><literal type="string">"empty array"</literal></expr>, <expr><literal type="string">"Array of strings giving private keys to import. The corresponding public keys must occur in the output or redeemscript."</literal></expr>,
                                        <expr><block>{
                                            <expr><block>{<expr><literal type="string">"key"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>OMITTED</name></name></expr>, <expr><literal type="string">""</literal></expr>}</block></expr>,
                                        }</block></expr>
                                    }</block></expr>,
                                    <expr><block>{<expr><literal type="string">"range"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>RANGE</name></name></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>OMITTED</name></name></expr>, <expr><literal type="string">"If a ranged descriptor is used, this specifies the end or the range (in the form [begin,end]) to import"</literal></expr>}</block></expr>,
                                    <expr><block>{<expr><literal type="string">"internal"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>BOOL</name></name></expr>, <comment type="block">/* default */</comment> <expr><literal type="string">"false"</literal></expr>, <expr><literal type="string">"Stating whether matching outputs should be treated as not incoming payments (also known as change)"</literal></expr>}</block></expr>,
                                    <expr><block>{<expr><literal type="string">"watchonly"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>BOOL</name></name></expr>, <comment type="block">/* default */</comment> <expr><literal type="string">"false"</literal></expr>, <expr><literal type="string">"Stating whether matching outputs should be considered watchonly."</literal></expr>}</block></expr>,
                                    <expr><block>{<expr><literal type="string">"label"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>STR</name></name></expr>, <comment type="block">/* default */</comment> <expr><literal type="string">"''"</literal></expr>, <expr><literal type="string">"Label to assign to the address, only allowed with internal=false"</literal></expr>}</block></expr>,
                                    <expr><block>{<expr><literal type="string">"keypool"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>BOOL</name></name></expr>, <comment type="block">/* default */</comment> <expr><literal type="string">"false"</literal></expr>, <expr><literal type="string">"Stating whether imported public keys should be added to the keypool for when users request new addresses. Only allowed when wallet private keys are disabled"</literal></expr>}</block></expr>,
                                }</block></expr>,
                            }</block></expr>,
                        }</block></expr><operator>,</operator>
                        <expr><literal type="string">"\"requests\""</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                    <block>{<block_content><expr_stmt><expr><literal type="string">"options"</literal></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>OBJ</name></name></expr><operator>,</operator> <expr><name><name>RPCArg</name><operator>::</operator><name>Optional</name><operator>::</operator><name>OMITTED_NAMED_ARG</name></name></expr><operator>,</operator> <expr><literal type="string">""</literal></expr><operator>,</operator>
                        <expr><block>{
                            <expr><block>{<expr><literal type="string">"rescan"</literal></expr>, <expr><name><name>RPCArg</name><operator>::</operator><name>Type</name><operator>::</operator><name>BOOL</name></name></expr>, <comment type="block">/* default */</comment> <expr><literal type="string">"true"</literal></expr>, <expr><literal type="string">"Stating if should rescan the blockchain after all imports"</literal></expr>}</block></expr>,
                        }</block></expr><operator>,</operator>
                        <expr><literal type="string">"\"options\""</literal></expr></expr_stmt>}</block_content></block><operator>,</operator>
                <expr_stmt/>}</block_content></block>,
                <argument><expr><call><name>RPCResult</name><argument_list>{
            <argument><expr><literal type="string">"\nResponse is an array with the same size as the input that has the execution result :\n"</literal>
            <literal type="string">"  [{\"success\": true}, {\"success\": true, \"warnings\": [\"Ignoring irrelevant private key\"]}, {\"success\": false, \"error\": {\"code\": -1, \"message\": \"Internal Server Error\"}}, ...]\n"</literal></expr></argument>
                }</argument_list></call></expr></argument>,
                <argument><expr><call><name>RPCExamples</name><argument_list>{
                    <argument><expr><call><name>HelpExampleCli</name><argument_list>(<argument><expr><literal type="string">"importmulti"</literal></expr></argument>, <argument><expr><literal type="string">"'[{ \"scriptPubKey\": { \"address\": \"&lt;my address&gt;\" }, \"timestamp\":1455191478 }, "</literal>
                                          <literal type="string">"{ \"scriptPubKey\": { \"address\": \"&lt;my 2nd address&gt;\" }, \"label\": \"example 2\", \"timestamp\": 1455191480 }]'"</literal></expr></argument>)</argument_list></call> <operator>+</operator>
                    <macro><name>HelpExampleCli</name><argument_list>(<argument><literal type="string">"importmulti"</literal></argument>, <argument><literal type="string">"'[{ \"scriptPubKey\": { \"address\": \"&lt;my address&gt;\" }, \"timestamp\":1455191478 }]' '{ \"rescan\": false}'"</literal></argument>)</argument_list></macro></expr></argument>
                }</argument_list></call></expr></argument>,
            }</argument_list></call><operator>.</operator><call><name>Check</name><argument_list>(<argument><expr><name>mainRequest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <expr_stmt><expr><call><name>RPCTypeCheck</name><argument_list>(<argument><expr><name><name>mainRequest</name><operator>.</operator><name>params</name></name></expr></argument>, <block>{<block_content><expr><name><name>UniValue</name><operator>::</operator><name>VARR</name></name></expr><operator>,</operator> <expr><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></expr></block_content>}</block></argument_list></call></expr></expr_stmt>)</block_content></block>;</function>

    <expr_stmt><expr><call><name>EnsureLegacyScriptPubKeyMan</name><argument_list>(<argument><expr><operator>*</operator><name>wallet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>UniValue</name><modifier>&amp;</modifier></type> <name>requests</name> <init>= <expr><name><name>mainRequest</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <comment type="line">//Default options</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>fRescan</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mainRequest</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>UniValue</name><modifier>&amp;</modifier></type> <name>options</name> <init>= <expr><name><name>mainRequest</name><operator>.</operator><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>options</name><operator>.</operator><name>exists</name></name><argument_list>(<argument><expr><literal type="string">"rescan"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>fRescan</name> <operator>=</operator> <name><name>options</name><index>[<expr><literal type="string">"rescan"</literal></expr>]</index></name><operator>.</operator><call><name>get_bool</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <function_decl><type><name>WalletRescanReserver</name></type> <name>reserver</name><parameter_list>(<parameter><decl><type><name>pwallet</name></type></decl></parameter>)</parameter_list>;</function_decl>
    <if_stmt><if>if <condition>(<expr><name>fRescan</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>reserver</name><operator>.</operator><name>reserve</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_WALLET_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Wallet is currently rescanning. Abort existing rescan or wait."</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>now</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>fRunScan</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>nLowestTimestamp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <function_decl><type><name>UniValue</name></type> <name>response</name><parameter_list>(<parameter><decl><type><name><name>UniValue</name><operator>::</operator><name>VARR</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
    <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>locked_chain</name> <init>= <expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>chain</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pwallet</name><operator>-&gt;</operator><name>cs_wallet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>EnsureWalletIsUnlocked</name><argument_list>(<argument><expr><name>pwallet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Verify all timestamps are present before importing any keys.</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type> <name>tip_height</name> <init>= <expr><call><name><name>locked_chain</name><operator>-&gt;</operator><name>getHeight</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>now</name> <operator>=</operator> <ternary><condition><expr><name>tip_height</name></expr> ?</condition><then> <expr><call><name><name>locked_chain</name><operator>-&gt;</operator><name>getBlockMedianTimePast</name></name><argument_list>(<argument><expr><operator>*</operator><name>tip_height</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><specifier>const</specifier> <name>UniValue</name><modifier>&amp;</modifier></type> <name>data</name> <range>: <expr><call><name><name>requests</name><operator>.</operator><name>getValues</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>GetImportTimestamp</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>minimumTimestamp</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>fRescan</name> <operator>&amp;&amp;</operator> <name>tip_height</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>nLowestTimestamp</name> <operator>=</operator> <call><name><name>locked_chain</name><operator>-&gt;</operator><name>getBlockTime</name></name><argument_list>(<argument><expr><operator>*</operator><name>tip_height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>fRescan</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <for>for <control>(<init><decl><type><specifier>const</specifier> <name>UniValue</name><modifier>&amp;</modifier></type> <name>data</name> <range>: <expr><call><name><name>requests</name><operator>.</operator><name>getValues</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>timestamp</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>max</name></name><argument_list>(<argument><expr><call><name>GetImportTimestamp</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>minimumTimestamp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>UniValue</name></type> <name>result</name> <init>= <expr><call><name>ProcessImport</name><argument_list>(<argument><expr><name>pwallet</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>response</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fRescan</name></expr>)</condition> <block>{<block_content>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// If at least one request was successful then allow rescan.</comment>
            <if_stmt><if>if <condition>(<expr><name><name>result</name><index>[<expr><literal type="string">"success"</literal></expr>]</index></name><operator>.</operator><call><name>get_bool</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>fRunScan</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Get the lowest timestamp.</comment>
            <if_stmt><if>if <condition>(<expr><name>timestamp</name> <operator>&lt;</operator> <name>nLowestTimestamp</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>nLowestTimestamp</name> <operator>=</operator> <name>timestamp</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
    <if_stmt><if>if <condition>(<expr><name>fRescan</name> <operator>&amp;&amp;</operator> <name>fRunScan</name> <operator>&amp;&amp;</operator> <call><name><name>requests</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>scannedTime</name> <init>= <expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>RescanFromTime</name></name><argument_list>(<argument><expr><name>nLowestTimestamp</name></expr></argument>, <argument><expr><name>reserver</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument> <comment type="block">/* update */</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <block>{<block_content>
            <decl_stmt><decl><type><name>auto</name></type> <name>locked_chain</name> <init>= <expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>chain</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>lock</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>pwallet</name><operator>-&gt;</operator><name>cs_wallet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>ReacceptWalletTransactions</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <if_stmt><if>if <condition>(<expr><call><name><name>pwallet</name><operator>-&gt;</operator><name>IsAbortingRescan</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name>JSONRPCError</name><argument_list>(<argument><expr><name>RPC_MISC_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Rescan aborted by user."</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>scannedTime</name> <operator>&gt;</operator> <name>nLowestTimestamp</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>UniValue</name></expr></argument>&gt;</argument_list></name></type> <name>results</name> <init>= <expr><call><name><name>response</name><operator>.</operator><name>getValues</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>response</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>response</name><operator>.</operator><name>setArray</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><specifier>const</specifier> <name>UniValue</name><modifier>&amp;</modifier></type> <name>request</name> <range>: <expr><call><name><name>requests</name><operator>.</operator><name>getValues</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
                <comment type="line">// If key creation date is within the successfully scanned</comment>
                <comment type="line">// range, or if the import result already has an error set, let</comment>
                <comment type="line">// the result stand unmodified. Otherwise replace the result</comment>
                <comment type="line">// with an error message.</comment>
                <if_stmt><if>if <condition>(<expr><name>scannedTime</name> <operator>&lt;=</operator> <call><name>GetImportTimestamp</name><argument_list>(<argument><expr><name>request</name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>results</name><operator>.</operator><name>at</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>exists</name><argument_list>(<argument><expr><literal type="string">"error"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>response</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>results</name><operator>.</operator><name>at</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <decl_stmt><decl><type><name>UniValue</name></type> <name>result</name> <init>= <expr><call><name>UniValue</name><argument_list>(<argument><expr><name><name>UniValue</name><operator>::</operator><name>VOBJ</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>pushKV</name></name><argument_list>(<argument><expr><literal type="string">"success"</literal></expr></argument>, <argument><expr><call><name>UniValue</name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>pushKV</name></name><argument_list>(
                        <argument><expr><literal type="string">"error"</literal></expr></argument>,
                        <argument><expr><call><name>JSONRPCError</name><argument_list>(
                            <argument><expr><name>RPC_MISC_ERROR</name></expr></argument>,
                            <argument><expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"Rescan failed for key with creation timestamp %d. There was an error reading a "</literal>
                                      <literal type="string">"block from time %d, which is after or within %d seconds of key creation, and "</literal>
                                      <literal type="string">"could contain transactions pertaining to the key. As a result, transactions "</literal>
                                      <literal type="string">"and coins using this key may not appear in the wallet. This error could be "</literal>
                                      <literal type="string">"caused by pruning or data corruption (see bitcoind log for details) and could "</literal>
                                      <literal type="string">"be dealt with by downloading and rescanning the relevant blocks (see -reindex "</literal>
                                      <literal type="string">"and -rescan options)."</literal></expr></argument>,
                                <argument><expr><call><name>GetImportTimestamp</name><argument_list>(<argument><expr><name>request</name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>scannedTime</name> <operator>-</operator> <name>TIMESTAMP_WINDOW</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>TIMESTAMP_WINDOW</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>response</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>response</name></expr>;</return>
}
</unit>
