<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/mmm/Projects/bitcoin/src/leveldb/include/leveldb/env.h"><comment type="line">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</comment>
<comment type="line">// Use of this source code is governed by a BSD-style license that can be</comment>
<comment type="line">// found in the LICENSE file. See the AUTHORS file for names of contributors.</comment>
<comment type="line">//</comment>
<comment type="line">// An Env is an interface used by the leveldb implementation to access</comment>
<comment type="line">// operating system functionality like the filesystem etc.  Callers</comment>
<comment type="line">// may wish to provide a custom Env object when opening a database to</comment>
<comment type="line">// get fine gain control; e.g., to rate limit file system operations.</comment>
<comment type="line">//</comment>
<comment type="line">// All Env implementations are safe for concurrent access from</comment>
<comment type="line">// multiple threads without any external synchronization.</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>STORAGE_LEVELDB_INCLUDE_ENV_H_</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORAGE_LEVELDB_INCLUDE_ENV_H_</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"leveldb/status.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>leveldb</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>FileLock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Logger</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>RandomAccessFile</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>SequentialFile</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Slice</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>WritableFile</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>Env</name> <block>{<block_content>
 <label><name>public</name>:</label>
  <macro><name>Env</name><argument_list>()</argument_list></macro> <block>{<block_content> </block_content>}</block>
  <expr_stmt><expr><name>virtual</name> <operator>~</operator><call><name>Env</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Return a default environment suitable for the current operating</comment>
  <comment type="line">// system.  Sophisticated users may wish to provide their own Env</comment>
  <comment type="line">// implementation instead of relying on this default environment.</comment>
  <comment type="line">//</comment>
  <comment type="line">// The result of Default() belongs to leveldb and must never be deleted.</comment>
  <function_decl><type><specifier>static</specifier> <name>Env</name><modifier>*</modifier></type> <name>Default</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="line">// Create a brand new sequentially-readable file with the specified name.</comment>
  <comment type="line">// On success, stores a pointer to the new file in *result and returns OK.</comment>
  <comment type="line">// On failure stores NULL in *result and returns non-OK.  If the file does</comment>
  <comment type="line">// not exist, returns a non-OK status.</comment>
  <comment type="line">//</comment>
  <comment type="line">// The returned file will only be accessed by one thread at a time.</comment>
  <decl_stmt><decl><type><name>virtual</name> <name>Status</name></type> <name>NewSequentialFile</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>fname</name></expr></argument>,
                                   <argument><expr><name>SequentialFile</name><operator>*</operator><operator>*</operator> <name>result</name></expr></argument>)</argument_list> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="line">// Create a brand new random access read-only file with the</comment>
  <comment type="line">// specified name.  On success, stores a pointer to the new file in</comment>
  <comment type="line">// *result and returns OK.  On failure stores NULL in *result and</comment>
  <comment type="line">// returns non-OK.  If the file does not exist, returns a non-OK</comment>
  <comment type="line">// status.</comment>
  <comment type="line">//</comment>
  <comment type="line">// The returned file may be concurrently accessed by multiple threads.</comment>
  <decl_stmt><decl><type><name>virtual</name> <name>Status</name></type> <name>NewRandomAccessFile</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>fname</name></expr></argument>,
                                     <argument><expr><name>RandomAccessFile</name><operator>*</operator><operator>*</operator> <name>result</name></expr></argument>)</argument_list> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="line">// Create an object that writes to a new file with the specified</comment>
  <comment type="line">// name.  Deletes any existing file with the same name and creates a</comment>
  <comment type="line">// new file.  On success, stores a pointer to the new file in</comment>
  <comment type="line">// *result and returns OK.  On failure stores NULL in *result and</comment>
  <comment type="line">// returns non-OK.</comment>
  <comment type="line">//</comment>
  <comment type="line">// The returned file will only be accessed by one thread at a time.</comment>
  <decl_stmt><decl><type><name>virtual</name> <name>Status</name></type> <name>NewWritableFile</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>fname</name></expr></argument>,
                                 <argument><expr><name>WritableFile</name><operator>*</operator><operator>*</operator> <name>result</name></expr></argument>)</argument_list> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="line">// Create an object that either appends to an existing file, or</comment>
  <comment type="line">// writes to a new file (if the file does not exist to begin with).</comment>
  <comment type="line">// On success, stores a pointer to the new file in *result and</comment>
  <comment type="line">// returns OK.  On failure stores NULL in *result and returns</comment>
  <comment type="line">// non-OK.</comment>
  <comment type="line">//</comment>
  <comment type="line">// The returned file will only be accessed by one thread at a time.</comment>
  <comment type="line">//</comment>
  <comment type="line">// May return an IsNotSupportedError error if this Env does</comment>
  <comment type="line">// not allow appending to an existing file.  Users of Env (including</comment>
  <comment type="line">// the leveldb implementation) must be prepared to deal with</comment>
  <comment type="line">// an Env that does not support appending.</comment>
  <decl_stmt><decl><type><name>virtual</name> <name>Status</name></type> <name>NewAppendableFile</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>fname</name></expr></argument>,
                                   <argument><expr><name>WritableFile</name><operator>*</operator><operator>*</operator> <name>result</name></expr></argument>)</argument_list></decl>;</decl_stmt>

  <comment type="line">// Returns true iff the named file exists.</comment>
  <decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>FileExists</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>fname</name></expr></argument>)</argument_list> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="line">// Store in *result the names of the children of the specified directory.</comment>
  <comment type="line">// The names are relative to "dir".</comment>
  <comment type="line">// Original contents of *results are dropped.</comment>
  <decl_stmt><decl><type><name>virtual</name> <name>Status</name></type> <name>GetChildren</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>dir</name></expr></argument>,
                             <argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <name>result</name></expr></argument>)</argument_list> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="line">// Delete the named file.</comment>
  <decl_stmt><decl><type><name>virtual</name> <name>Status</name></type> <name>DeleteFile</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>fname</name></expr></argument>)</argument_list> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="line">// Create the specified directory.</comment>
  <decl_stmt><decl><type><name>virtual</name> <name>Status</name></type> <name>CreateDir</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>dirname</name></expr></argument>)</argument_list> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="line">// Delete the specified directory.</comment>
  <decl_stmt><decl><type><name>virtual</name> <name>Status</name></type> <name>DeleteDir</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>dirname</name></expr></argument>)</argument_list> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="line">// Store the size of fname in *file_size.</comment>
  <decl_stmt><decl><type><name>virtual</name> <name>Status</name></type> <name>GetFileSize</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>fname</name></expr></argument>, <argument><expr><name>uint64_t</name><operator>*</operator> <name>file_size</name></expr></argument>)</argument_list> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="line">// Rename file src to target.</comment>
  <decl_stmt><decl><type><name>virtual</name> <name>Status</name></type> <name>RenameFile</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>src</name></expr></argument>,
                            <argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>target</name></expr></argument>)</argument_list> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="line">// Lock the specified file.  Used to prevent concurrent access to</comment>
  <comment type="line">// the same db by multiple processes.  On failure, stores NULL in</comment>
  <comment type="line">// *lock and returns non-OK.</comment>
  <comment type="line">//</comment>
  <comment type="line">// On success, stores a pointer to the object that represents the</comment>
  <comment type="line">// acquired lock in *lock and returns OK.  The caller should call</comment>
  <comment type="line">// UnlockFile(*lock) to release the lock.  If the process exits,</comment>
  <comment type="line">// the lock will be automatically released.</comment>
  <comment type="line">//</comment>
  <comment type="line">// If somebody else already holds the lock, finishes immediately</comment>
  <comment type="line">// with a failure.  I.e., this call does not wait for existing locks</comment>
  <comment type="line">// to go away.</comment>
  <comment type="line">//</comment>
  <comment type="line">// May create the named file if it does not already exist.</comment>
  <decl_stmt><decl><type><name>virtual</name> <name>Status</name></type> <name>LockFile</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>fname</name></expr></argument>, <argument><expr><name>FileLock</name><operator>*</operator><operator>*</operator> <name>lock</name></expr></argument>)</argument_list> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="line">// Release the lock acquired by a previous successful call to LockFile.</comment>
  <comment type="line">// REQUIRES: lock was returned by a successful LockFile() call</comment>
  <comment type="line">// REQUIRES: lock has not already been unlocked.</comment>
  <function_decl><type><name>virtual</name> <name>Status</name></type> <name>UnlockFile</name><parameter_list>(<parameter><decl><type><name>FileLock</name><modifier>*</modifier></type> <name>lock</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>

  <comment type="line">// Arrange to run "(*function)(arg)" once in a background thread.</comment>
  <comment type="line">//</comment>
  <comment type="line">// "function" may run in an unspecified thread.  Multiple functions</comment>
  <comment type="line">// added to the same Env may run concurrently in different threads.</comment>
  <comment type="line">// I.e., the caller may not assume that background work items are</comment>
  <comment type="line">// serialized.</comment>
  <function_decl><type><name>virtual</name> <name>void</name></type> <name>Schedule</name><parameter_list>(
      <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>function</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>arg</name></decl></parameter>)</parameter_list></function_decl></parameter>,
      <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>arg</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>

  <comment type="line">// Start a new thread, invoking "function(arg)" within the new thread.</comment>
  <comment type="line">// When "function(arg)" returns, the thread will be destroyed.</comment>
  <function_decl><type><name>virtual</name> <name>void</name></type> <name>StartThread</name><parameter_list>(<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>function</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>arg</name></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>arg</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>

  <comment type="line">// *path is set to a temporary directory that can be used for testing. It may</comment>
  <comment type="line">// or many not have just been created. The directory may or may not differ</comment>
  <comment type="line">// between runs of the same process, but subsequent calls will return the</comment>
  <comment type="line">// same directory.</comment>
  <decl_stmt><decl><type><name>virtual</name> <name>Status</name></type> <name>GetTestDirectory</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>string</name><operator>*</operator> <name>path</name></expr></argument>)</argument_list> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="line">// Create and return a log file for storing informational messages.</comment>
  <decl_stmt><decl><type><name>virtual</name> <name>Status</name></type> <name>NewLogger</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>fname</name></expr></argument>, <argument><expr><name>Logger</name><operator>*</operator><operator>*</operator> <name>result</name></expr></argument>)</argument_list> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="line">// Returns the number of micro-seconds since some fixed point in time. Only</comment>
  <comment type="line">// useful for computing deltas of time.</comment>
  <function_decl><type><name>virtual</name> <name>uint64_t</name></type> <name>NowMicros</name><parameter_list>()</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>

  <comment type="line">// Sleep/delay the thread for the prescribed number of micro-seconds.</comment>
  <function_decl><type><name>virtual</name> <name>void</name></type> <name>SleepForMicroseconds</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>micros</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>

 <label><name>private</name>:</label>
  <comment type="line">// No copying allowed</comment>
  <expr_stmt><expr><call><name>Env</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Env</name><operator>&amp;</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>void</name></type> <name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>Env</name><operator>&amp;</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="line">// A file abstraction for reading sequentially through a file</comment>
<decl_stmt><decl><type><name>class</name></type> <name>SequentialFile</name> <block>{<block_content>
 <label><name>public</name>:</label>
  <macro><name>SequentialFile</name><argument_list>()</argument_list></macro> <block>{<block_content> </block_content>}</block>
  <expr_stmt><expr><name>virtual</name> <operator>~</operator><call><name>SequentialFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Read up to "n" bytes from the file.  "scratch[0..n-1]" may be</comment>
  <comment type="line">// written by this routine.  Sets "*result" to the data that was</comment>
  <comment type="line">// read (including if fewer than "n" bytes were successfully read).</comment>
  <comment type="line">// May set "*result" to point at data in "scratch[0..n-1]", so</comment>
  <comment type="line">// "scratch[0..n-1]" must be live when "*result" is used.</comment>
  <comment type="line">// If an error was encountered, returns a non-OK status.</comment>
  <comment type="line">//</comment>
  <comment type="line">// REQUIRES: External synchronization</comment>
  <function_decl><type><name>virtual</name> <name>Status</name></type> <name>Read</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>Slice</name><modifier>*</modifier></type> <name>result</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>scratch</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>

  <comment type="line">// Skip "n" bytes from the file. This is guaranteed to be no</comment>
  <comment type="line">// slower that reading the same data, but may be faster.</comment>
  <comment type="line">//</comment>
  <comment type="line">// If end of file is reached, skipping will stop at the end of the</comment>
  <comment type="line">// file, and Skip will return OK.</comment>
  <comment type="line">//</comment>
  <comment type="line">// REQUIRES: External synchronization</comment>
  <function_decl><type><name>virtual</name> <name>Status</name></type> <name>Skip</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>n</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>

  <comment type="line">// Get a name for the file, only for error reporting</comment>
  <expr_stmt><expr><name>virtual</name> <name>std</name><operator>::</operator><name>string</name> <macro><name>GetName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

 <label><name>private</name>:</label>
  <comment type="line">// No copying allowed</comment>
  <expr_stmt><expr><call><name>SequentialFile</name><argument_list>(<argument><expr><specifier>const</specifier> <name>SequentialFile</name><operator>&amp;</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>void</name></type> <name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>SequentialFile</name><operator>&amp;</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="line">// A file abstraction for randomly reading the contents of a file.</comment>
<decl_stmt><decl><type><name>class</name></type> <name>RandomAccessFile</name> <block>{<block_content>
 <label><name>public</name>:</label>
  <macro><name>RandomAccessFile</name><argument_list>()</argument_list></macro> <block>{<block_content> </block_content>}</block>
  <expr_stmt><expr><name>virtual</name> <operator>~</operator><call><name>RandomAccessFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Read up to "n" bytes from the file starting at "offset".</comment>
  <comment type="line">// "scratch[0..n-1]" may be written by this routine.  Sets "*result"</comment>
  <comment type="line">// to the data that was read (including if fewer than "n" bytes were</comment>
  <comment type="line">// successfully read).  May set "*result" to point at data in</comment>
  <comment type="line">// "scratch[0..n-1]", so "scratch[0..n-1]" must be live when</comment>
  <comment type="line">// "*result" is used.  If an error was encountered, returns a non-OK</comment>
  <comment type="line">// status.</comment>
  <comment type="line">//</comment>
  <comment type="line">// Safe for concurrent use by multiple threads.</comment>
  <decl_stmt><decl><type><name>virtual</name> <name>Status</name></type> <name>Read</name><argument_list>(<argument><expr><name>uint64_t</name> <name>offset</name></expr></argument>, <argument><expr><name>size_t</name> <name>n</name></expr></argument>, <argument><expr><name>Slice</name><operator>*</operator> <name>result</name></expr></argument>,
                      <argument><expr><name>char</name><operator>*</operator> <name>scratch</name></expr></argument>)</argument_list> const <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="line">// Get a name for the file, only for error reporting</comment>
  <expr_stmt><expr><name>virtual</name> <name>std</name><operator>::</operator><name>string</name> <macro><name>GetName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

 <label><name>private</name>:</label>
  <comment type="line">// No copying allowed</comment>
  <expr_stmt><expr><call><name>RandomAccessFile</name><argument_list>(<argument><expr><specifier>const</specifier> <name>RandomAccessFile</name><operator>&amp;</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>void</name></type> <name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>RandomAccessFile</name><operator>&amp;</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="line">// A file abstraction for sequential writing.  The implementation</comment>
<comment type="line">// must provide buffering since callers may append small fragments</comment>
<comment type="line">// at a time to the file.</comment>
<decl_stmt><decl><type><name>class</name></type> <name>WritableFile</name> <block>{<block_content>
 <label><name>public</name>:</label>
  <macro><name>WritableFile</name><argument_list>()</argument_list></macro> <block>{<block_content> </block_content>}</block>
  <expr_stmt><expr><name>virtual</name> <operator>~</operator><call><name>WritableFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <function_decl><type><name>virtual</name> <name>Status</name></type> <name>Append</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Slice</name><modifier>&amp;</modifier></type> <name>data</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>
  <function_decl><type><name>virtual</name> <name>Status</name></type> <name>Close</name><parameter_list>()</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>
  <function_decl><type><name>virtual</name> <name>Status</name></type> <name>Flush</name><parameter_list>()</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>
  <function_decl><type><name>virtual</name> <name>Status</name></type> <name>Sync</name><parameter_list>()</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>

  <comment type="line">// Get a name for the file, only for error reporting</comment>
  <expr_stmt><expr><name>virtual</name> <name>std</name><operator>::</operator><name>string</name> <macro><name>GetName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

 <label><name>private</name>:</label>
  <comment type="line">// No copying allowed</comment>
  <expr_stmt><expr><call><name>WritableFile</name><argument_list>(<argument><expr><specifier>const</specifier> <name>WritableFile</name><operator>&amp;</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>void</name></type> <name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>WritableFile</name><operator>&amp;</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="line">// An interface for writing log messages.</comment>
<decl_stmt><decl><type><name>class</name></type> <name>Logger</name> <block>{<block_content>
 <label><name>public</name>:</label>
  <macro><name>Logger</name><argument_list>()</argument_list></macro> <block>{<block_content> </block_content>}</block>
  <expr_stmt><expr><name>virtual</name> <operator>~</operator><call><name>Logger</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Write an entry to the log file with the specified format.</comment>
  <function_decl><type><name>virtual</name> <name>void</name></type> <name>Logv</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>format</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>

 <label><name>private</name>:</label>
  <comment type="line">// No copying allowed</comment>
  <expr_stmt><expr><call><name>Logger</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Logger</name><operator>&amp;</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>void</name></type> <name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>Logger</name><operator>&amp;</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<comment type="line">// Identifies a locked file.</comment>
<decl_stmt><decl><type><name>class</name></type> <name>FileLock</name> <block>{<block_content>
 <label><name>public</name>:</label>
  <macro><name>FileLock</name><argument_list>()</argument_list></macro> <block>{<block_content> </block_content>}</block>
  <expr_stmt><expr><name>virtual</name> <operator>~</operator><call><name>FileLock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
 <label><name>private</name>:</label>
  <comment type="line">// No copying allowed</comment>
  <expr_stmt><expr><call><name>FileLock</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FileLock</name><operator>&amp;</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>void</name></type> <name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>FileLock</name><operator>&amp;</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="line">// Log the specified data to *info_log if info_log is non-NULL.</comment>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>Log</name><parameter_list>(<parameter><decl><type><name>Logger</name><modifier>*</modifier></type> <name>info_log</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<cpp:if>#   <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call></expr></cpp:if>
    __attribute__<parameter_list>(<parameter/></parameter_list>(__format__ <parameter_list>(<parameter><decl><type><name>__printf__</name></type></decl></parameter>, <parameter/></parameter_list>2<operator>,</operator> 3</function_decl>)</block_content></block></decl>)</decl_stmt>)
<cpp:endif>#   <cpp:directive>endif</cpp:directive></cpp:endif>
    <empty_stmt>;</empty_stmt>

<comment type="line">// A utility routine: write "data" to the named file.</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <name>Status</name></type> <name>WriteStringToFile</name><argument_list>(<argument><expr><name>Env</name><operator>*</operator> <name>env</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Slice</name><operator>&amp;</operator> <name>data</name></expr></argument>,
                                <argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>fname</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<comment type="line">// A utility routine: read contents of named file into *data</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <name>Status</name></type> <name>ReadFileToString</name><argument_list>(<argument><expr><name>Env</name><operator>*</operator> <name>env</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>fname</name></expr></argument>,
                               <argument><expr><name>std</name><operator>::</operator><name>string</name><operator>*</operator> <name>data</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<comment type="line">// An implementation of Env that forwards all calls to another Env.</comment>
<comment type="line">// May be useful to clients who wish to override just part of the</comment>
<comment type="line">// functionality of another Env.</comment>
<decl_stmt><decl><type><name>class</name></type> <name>EnvWrapper</name> <range>: <expr><name>public</name> <name>Env</name> <block>{
 <expr><name>public</name><operator>:</operator>
  <comment type="line">// Initialize an EnvWrapper that delegates all calls to *t</comment>
  <name>explicit</name> <call><name>EnvWrapper</name><argument_list>(<argument><expr><name>Env</name><operator>*</operator> <name>t</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>target_</name><argument_list>(<argument>t</argument>)</argument_list></macro> <block>{ }</block>
  <name>virtual</name> <operator>~</operator><call><name>EnvWrapper</name><argument_list>()</argument_list></call></expr>;

  <comment type="line">// Return the target to which this Env forwards all calls</comment>
  <expr><name>Env</name><operator>*</operator> <macro><name>target</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>target_</name></expr>;</return> }</block>

  <comment type="line">// The following text is boilerplate that forwards all methods to target()</comment>
  <name>Status</name> <macro><name>NewSequentialFile</name><argument_list>(<argument>const std::string&amp; f</argument>, <argument>SequentialFile** r</argument>)</argument_list></macro> <block>{
    <return>return <expr><call><name><name>target_</name><operator>-&gt;</operator><name>NewSequentialFile</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block>
  <name>Status</name> <macro><name>NewRandomAccessFile</name><argument_list>(<argument>const std::string&amp; f</argument>, <argument>RandomAccessFile** r</argument>)</argument_list></macro> <block>{
    <return>return <expr><call><name><name>target_</name><operator>-&gt;</operator><name>NewRandomAccessFile</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block>
  <name>Status</name> <macro><name>NewWritableFile</name><argument_list>(<argument>const std::string&amp; f</argument>, <argument>WritableFile** r</argument>)</argument_list></macro> <block>{
    <return>return <expr><call><name><name>target_</name><operator>-&gt;</operator><name>NewWritableFile</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block>
  <name>Status</name> <macro><name>NewAppendableFile</name><argument_list>(<argument>const std::string&amp; f</argument>, <argument>WritableFile** r</argument>)</argument_list></macro> <block>{
    <return>return <expr><call><name><name>target_</name><operator>-&gt;</operator><name>NewAppendableFile</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block>
  <name>bool</name> <macro><name>FileExists</name><argument_list>(<argument>const std::string&amp; f</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>target_</name><operator>-&gt;</operator><name>FileExists</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
  <name>Status</name> <macro><name>GetChildren</name><argument_list>(<argument>const std::string&amp; dir</argument>, <argument>std::vector&lt;std::string&gt;* r</argument>)</argument_list></macro> <block>{
    <return>return <expr><call><name><name>target_</name><operator>-&gt;</operator><name>GetChildren</name></name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block>
  <name>Status</name> <macro><name>DeleteFile</name><argument_list>(<argument>const std::string&amp; f</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>target_</name><operator>-&gt;</operator><name>DeleteFile</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
  <name>Status</name> <macro><name>CreateDir</name><argument_list>(<argument>const std::string&amp; d</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>target_</name><operator>-&gt;</operator><name>CreateDir</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
  <name>Status</name> <macro><name>DeleteDir</name><argument_list>(<argument>const std::string&amp; d</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>target_</name><operator>-&gt;</operator><name>DeleteDir</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
  <name>Status</name> <macro><name>GetFileSize</name><argument_list>(<argument>const std::string&amp; f</argument>, <argument>uint64_t* s</argument>)</argument_list></macro> <block>{
    <return>return <expr><call><name><name>target_</name><operator>-&gt;</operator><name>GetFileSize</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block>
  <name>Status</name> <macro><name>RenameFile</name><argument_list>(<argument>const std::string&amp; s</argument>, <argument>const std::string&amp; t</argument>)</argument_list></macro> <block>{
    <return>return <expr><call><name><name>target_</name><operator>-&gt;</operator><name>RenameFile</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block>
  <name>Status</name> <macro><name>LockFile</name><argument_list>(<argument>const std::string&amp; f</argument>, <argument>FileLock** l</argument>)</argument_list></macro> <block>{
    <return>return <expr><call><name><name>target_</name><operator>-&gt;</operator><name>LockFile</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block>
  <name>Status</name> <macro><name>UnlockFile</name><argument_list>(<argument>FileLock* l</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>target_</name><operator>-&gt;</operator><name>UnlockFile</name></name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
  <name>void</name> <macro><name>Schedule</name><argument_list>(<argument>void (*f)(void*)</argument>, <argument>void* a</argument>)</argument_list></macro> <block>{
    <return>return <expr><call><name><name>target_</name><operator>-&gt;</operator><name>Schedule</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block>
  <name>void</name> <macro><name>StartThread</name><argument_list>(<argument>void (*f)(void*)</argument>, <argument>void* a</argument>)</argument_list></macro> <block>{
    <return>return <expr><call><name><name>target_</name><operator>-&gt;</operator><name>StartThread</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block>
  <name>virtual</name> <name>Status</name> <macro><name>GetTestDirectory</name><argument_list>(<argument>std::string* path</argument>)</argument_list></macro> <block>{
    <return>return <expr><call><name><name>target_</name><operator>-&gt;</operator><name>GetTestDirectory</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block>
  <name>virtual</name> <name>Status</name> <macro><name>NewLogger</name><argument_list>(<argument>const std::string&amp; fname</argument>, <argument>Logger** result</argument>)</argument_list></macro> <block>{
    <return>return <expr><call><name><name>target_</name><operator>-&gt;</operator><name>NewLogger</name></name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block>
  <name>uint64_t</name> <macro><name>NowMicros</name><argument_list>()</argument_list></macro> <block>{
    <return>return <expr><call><name><name>target_</name><operator>-&gt;</operator><name>NowMicros</name></name><argument_list>()</argument_list></call></expr>;</return>
  }</block>
  <name>void</name> <macro><name>SleepForMicroseconds</name><argument_list>(<argument>int micros</argument>)</argument_list></macro> <block>{
    <expr><call><name><name>target_</name><operator>-&gt;</operator><name>SleepForMicroseconds</name></name><argument_list>(<argument><expr><name>micros</name></expr></argument>)</argument_list></call></expr>;
  }</block>
 <name>private</name><operator>:</operator>
  <name>Env</name><operator>*</operator> <name>target_</name></expr>;
}</block></expr></range></decl>;</decl_stmt>

}  <comment type="line">// namespace leveldb</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="line">// STORAGE_LEVELDB_INCLUDE_ENV_H_</comment>
</unit>
