<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C++" filename="/home/mmm/Projects/bitcoin/src/script/interpreter.cpp"><comment type="line">// Copyright (c) 2009-2010 Satoshi Nakamoto</comment>
<comment type="line">// Copyright (c) 2009-2018 The Bitcoin Core developers</comment>
<comment type="line">// Distributed under the MIT software license, see the accompanying</comment>
<comment type="line">// file COPYING or http://www.opensource.org/licenses/mit-license.php.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;script/interpreter.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;crypto/ripemd160.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;crypto/sha1.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;crypto/sha256.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pubkey.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;script/script.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;uint256.h&gt;</cpp:file></cpp:include>

<typedef>typedef <type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>valtype</name>;</typedef>

<namespace>namespace <block>{

<function><type><specifier>inline</specifier> <name>bool</name></type> <name>set_success</name><parameter_list>(<parameter><decl><type><name>ScriptError</name><modifier>*</modifier></type> <name>ret</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>ret</name> <operator>=</operator> <name>SCRIPT_ERR_OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>bool</name></type> <name>set_error</name><parameter_list>(<parameter><decl><type><name>ScriptError</name><modifier>*</modifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ScriptError</name></type> <name>serror</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>ret</name> <operator>=</operator> <name>serror</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
</block_content>}</block></function>

}</block></namespace> <comment type="line">// namespace</comment>

<function><type><name>bool</name></type> <name>CastToBool</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>valtype</name><modifier>&amp;</modifier></type> <name>vch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>vch</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>vch</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Can be negative zero</comment>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <call><name><name>vch</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>vch</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Script is a stack machine (like Forth) that evaluates a predicate
 * returning a bool indicating valid or not.  There are no loops.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>stacktop</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(stack.at(stack.size()+(i)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>altstacktop</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(altstack.at(altstack.size()+(i)))</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>popstack</name><parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>valtype</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>stack</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <throw>throw <expr><call><name><name>std</name><operator>::</operator><name>runtime_error</name></name><argument_list>(<argument><expr><literal type="string">"popstack(): stack empty"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>pop_back</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name> <specifier>static</specifier></type> <name>IsCompressedOrUncompressedPubKey</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>valtype</name> <modifier>&amp;</modifier></type><name>vchPubKey</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name><name>vchPubKey</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name><name>CPubKey</name><operator>::</operator><name>COMPRESSED_SIZE</name></name></expr>)</condition> <block>{<block_content>
        <comment type="line">//  Non-canonical public key: too short</comment>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>vchPubKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x04</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>vchPubKey</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name><name>CPubKey</name><operator>::</operator><name>SIZE</name></name></expr>)</condition> <block>{<block_content>
            <comment type="line">//  Non-canonical public key: invalid length for uncompressed key</comment>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>vchPubKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x02</literal> <operator>||</operator> <name><name>vchPubKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x03</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>vchPubKey</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name><name>CPubKey</name><operator>::</operator><name>COMPRESSED_SIZE</name></name></expr>)</condition> <block>{<block_content>
            <comment type="line">//  Non-canonical public key: invalid length for compressed key</comment>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="line">//  Non-canonical public key: neither compressed nor uncompressed</comment>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name> <specifier>static</specifier></type> <name>IsCompressedPubKey</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>valtype</name> <modifier>&amp;</modifier></type><name>vchPubKey</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name><name>vchPubKey</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name><name>CPubKey</name><operator>::</operator><name>COMPRESSED_SIZE</name></name></expr>)</condition> <block>{<block_content>
        <comment type="line">//  Non-canonical public key: invalid length for compressed key</comment>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>vchPubKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0x02</literal> <operator>&amp;&amp;</operator> <name><name>vchPubKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0x03</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">//  Non-canonical public key: invalid prefix for compressed key</comment>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * A canonical signature exists of: &lt;30&gt; &lt;total len&gt; &lt;02&gt; &lt;len R&gt; &lt;R&gt; &lt;02&gt; &lt;len S&gt; &lt;S&gt; &lt;hashtype&gt;
 * Where R and S are not negative (their first byte has its highest bit not set), and not
 * excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,
 * in which case a single 0 byte is necessary and even required).
 *
 * See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623
 *
 * This function is consensus-critical since BIP66.
 */</comment>
<function><type><name>bool</name> <specifier>static</specifier></type> <name>IsValidSignatureEncoding</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>sig</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="line">// Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S] [sighash]</comment>
    <comment type="line">// * total-length: 1-byte length descriptor of everything that follows,</comment>
    <comment type="line">//   excluding the sighash byte.</comment>
    <comment type="line">// * R-length: 1-byte length descriptor of the R value that follows.</comment>
    <comment type="line">// * R: arbitrary-length big-endian encoded R value. It must use the shortest</comment>
    <comment type="line">//   possible encoding for a positive integer (which means no null bytes at</comment>
    <comment type="line">//   the start, except a single one when the next byte has its highest bit set).</comment>
    <comment type="line">// * S-length: 1-byte length descriptor of the S value that follows.</comment>
    <comment type="line">// * S: arbitrary-length big-endian encoded S value. The same rules apply.</comment>
    <comment type="line">// * sighash: 1-byte value indicating what data is hashed (not part of the DER</comment>
    <comment type="line">//   signature)</comment>

    <comment type="line">// Minimum and maximum size constraints.</comment>
    <if_stmt><if>if <condition>(<expr><call><name><name>sig</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">9</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>sig</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">73</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// A signature is of type 0x30 (compound).</comment>
    <if_stmt><if>if <condition>(<expr><name><name>sig</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0x30</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// Make sure the length covers the entire signature.</comment>
    <if_stmt><if>if <condition>(<expr><name><name>sig</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <call><name><name>sig</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// Extract the length of the R element.</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>lenR</name> <init>= <expr><name><name>sig</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <comment type="line">// Make sure the length of the S element is still inside the signature.</comment>
    <if_stmt><if>if <condition>(<expr><literal type="number">5</literal> <operator>+</operator> <name>lenR</name> <operator>&gt;=</operator> <call><name><name>sig</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// Extract the length of the S element.</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>lenS</name> <init>= <expr><name><name>sig</name><index>[<expr><literal type="number">5</literal> <operator>+</operator> <name>lenR</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <comment type="line">// Verify that the length of the signature matches the sum of the length</comment>
    <comment type="line">// of the elements.</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>lenR</name> <operator>+</operator> <name>lenS</name> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>!=</operator> <call><name><name>sig</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// Check whether the R element is an integer.</comment>
    <if_stmt><if>if <condition>(<expr><name><name>sig</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0x02</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// Zero-length integers are not allowed for R.</comment>
    <if_stmt><if>if <condition>(<expr><name>lenR</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// Negative numbers are not allowed for R.</comment>
    <if_stmt><if>if <condition>(<expr><name><name>sig</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// Null bytes at the start of R are not allowed, unless R would</comment>
    <comment type="line">// otherwise be interpreted as a negative number.</comment>
    <if_stmt><if>if <condition>(<expr><name>lenR</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>sig</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x00</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>sig</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// Check whether the S element is an integer.</comment>
    <if_stmt><if>if <condition>(<expr><name><name>sig</name><index>[<expr><name>lenR</name> <operator>+</operator> <literal type="number">4</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0x02</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// Zero-length integers are not allowed for S.</comment>
    <if_stmt><if>if <condition>(<expr><name>lenS</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// Negative numbers are not allowed for S.</comment>
    <if_stmt><if>if <condition>(<expr><name><name>sig</name><index>[<expr><name>lenR</name> <operator>+</operator> <literal type="number">6</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// Null bytes at the start of S are not allowed, unless S would otherwise be</comment>
    <comment type="line">// interpreted as a negative number.</comment>
    <if_stmt><if>if <condition>(<expr><name>lenS</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>sig</name><index>[<expr><name>lenR</name> <operator>+</operator> <literal type="number">6</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x00</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>sig</name><index>[<expr><name>lenR</name> <operator>+</operator> <literal type="number">7</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name> <specifier>static</specifier></type> <name>IsLowDERSignature</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>valtype</name> <modifier>&amp;</modifier></type><name>vchSig</name></decl></parameter>, <parameter><decl><type><name>ScriptError</name><modifier>*</modifier></type> <name>serror</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsValidSignatureEncoding</name><argument_list>(<argument><expr><name>vchSig</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_SIG_DER</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="line">// https://bitcoin.stackexchange.com/a/12556:</comment>
    <comment type="line">//     Also note that inside transaction signatures, an extra hashtype byte</comment>
    <comment type="line">//     follows the actual signature data.</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>vchSigCopy</name><argument_list>(<argument><expr><call><name><name>vchSig</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>vchSig</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call> <operator>+</operator> <call><name><name>vchSig</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <comment type="line">// If the S value is above the order of the curve divided by two, its</comment>
    <comment type="line">// complement modulo the order could have been used instead, which is</comment>
    <comment type="line">// one byte shorter when encoded correctly.</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>CPubKey</name><operator>::</operator><name>CheckLowS</name></name><argument_list>(<argument><expr><name>vchSigCopy</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_SIG_HIGH_S</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name> <specifier>static</specifier></type> <name>IsDefinedHashtypeSignature</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>valtype</name> <modifier>&amp;</modifier></type><name>vchSig</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name><name>vchSig</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>nHashType</name> <init>= <expr><name><name>vchSig</name><index>[<expr><call><name><name>vchSig</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><operator>~</operator><operator>(</operator><name>SIGHASH_ANYONECANPAY</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>nHashType</name> <argument_list type="generic">&lt; <argument><expr><name>SIGHASH_ALL</name> <operator>||</operator> <name>nHashType</name></expr></argument> &gt;</argument_list></name> <name>SIGHASH_SINGLE</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>CheckSignatureEncoding</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>vchSig</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>ScriptError</name><modifier>*</modifier></type> <name>serror</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="line">// Empty signature. Not strictly DER encoded, but allowed to provide a</comment>
    <comment type="line">// compact way to provide an invalid signature for use with CHECK(MULTI)SIG</comment>
    <if_stmt><if>if <condition>(<expr><call><name><name>vchSig</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>SCRIPT_VERIFY_DERSIG</name> <operator>|</operator> <name>SCRIPT_VERIFY_LOW_S</name> <operator>|</operator> <name>SCRIPT_VERIFY_STRICTENC</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsValidSignatureEncoding</name><argument_list>(<argument><expr><name>vchSig</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_SIG_DER</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SCRIPT_VERIFY_LOW_S</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsLowDERSignature</name><argument_list>(<argument><expr><name>vchSig</name></expr></argument>, <argument><expr><name>serror</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="line">// serror is set</comment>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SCRIPT_VERIFY_STRICTENC</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsDefinedHashtypeSignature</name><argument_list>(<argument><expr><name>vchSig</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_SIG_HASHTYPE</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name> <specifier>static</specifier></type> <name>CheckPubKeyEncoding</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>valtype</name> <modifier>&amp;</modifier></type><name>vchPubKey</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SigVersion</name> <modifier>&amp;</modifier></type><name>sigversion</name></decl></parameter>, <parameter><decl><type><name>ScriptError</name><modifier>*</modifier></type> <name>serror</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SCRIPT_VERIFY_STRICTENC</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsCompressedOrUncompressedPubKey</name><argument_list>(<argument><expr><name>vchPubKey</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_PUBKEYTYPE</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="line">// Only compressed keys are accepted in segwit</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SCRIPT_VERIFY_WITNESS_PUBKEYTYPE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>sigversion</name> <operator>==</operator> <name><name>SigVersion</name><operator>::</operator><name>WITNESS_V0</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsCompressedPubKey</name><argument_list>(<argument><expr><name>vchPubKey</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_WITNESS_PUBKEYTYPE</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name> <specifier>static</specifier></type> <name>CheckMinimalPush</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>valtype</name><modifier>&amp;</modifier></type> <name>data</name></decl></parameter>, <parameter><decl><type><name>opcodetype</name></type> <name>opcode</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="line">// Excludes OP_1NEGATE, OP_1-16 since they are by definition minimal</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>opcode</name> <operator>&amp;&amp;</operator> <name>opcode</name> <operator>&lt;=</operator> <name>OP_PUSHDATA4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// Should have used OP_0.</comment>
        <return>return <expr><name>opcode</name> <operator>==</operator> <name>OP_0</name></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="number">16</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// Should have used OP_1 .. OP_16.</comment>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x81</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// Should have used OP_1NEGATE.</comment>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <literal type="number">75</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// Must have used a direct push (opcode indicating number of bytes pushed + those bytes).</comment>
        <return>return <expr><name>opcode</name> <operator>==</operator> <call><name><name>data</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <literal type="number">255</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// Must have used OP_PUSHDATA.</comment>
        <return>return <expr><name>opcode</name> <operator>==</operator> <name>OP_PUSHDATA1</name></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <literal type="number">65535</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// Must have used OP_PUSHDATA2.</comment>
        <return>return <expr><name>opcode</name> <operator>==</operator> <name>OP_PUSHDATA2</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>FindAndDelete</name><parameter_list>(<parameter><decl><type><name>CScript</name><modifier>&amp;</modifier></type> <name>script</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CScript</name><modifier>&amp;</modifier></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nFound</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>b</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>nFound</name></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>CScript</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>CScript</name><operator>::</operator><name>const_iterator</name></name></type> <name>pc</name> <init>= <expr><call><name><name>script</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>pc2</name> <init>= <expr><call><name><name>script</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>end</name> <init>= <expr><call><name><name>script</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>opcodetype</name></type> <name>opcode</name></decl>;</decl_stmt>
    <do>do
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pc2</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>size_t</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name>end</name> <operator>-</operator> <name>pc</name></expr></argument>)</argument_list></cast> <operator>&gt;=</operator> <call><name><name>b</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>std</name><operator>::</operator><name>equal</name></name><argument_list>(<argument><expr><call><name><name>b</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>b</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>pc</name> <operator>=</operator> <name>pc</name> <operator>+</operator> <call><name><name>b</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>++</operator><name>nFound</name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><name>pc2</name> <operator>=</operator> <name>pc</name></expr>;</expr_stmt>
    </block_content>}</block>
    while <condition>(<expr><call><name><name>script</name><operator>.</operator><name>GetOp</name></name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

    <if_stmt><if>if <condition>(<expr><name>nFound</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pc2</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>script</name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>nFound</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>EvalScript</name><parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name><modifier>&amp;</modifier></type> <name>stack</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CScript</name><modifier>&amp;</modifier></type> <name>script</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BaseSignatureChecker</name><modifier>&amp;</modifier></type> <name>checker</name></decl></parameter>, <parameter><decl><type><name>SigVersion</name></type> <name>sigversion</name></decl></parameter>, <parameter><decl><type><name>ScriptError</name><modifier>*</modifier></type> <name>serror</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>CScriptNum</name></type> <name>bnZero</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>CScriptNum</name></type> <name>bnOne</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <comment type="line">// static const CScriptNum bnFalse(0);</comment>
    <comment type="line">// static const CScriptNum bnTrue(1);</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>valtype</name></type> <name>vchFalse</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <comment type="line">// static const valtype vchZero(0);</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>valtype</name></type> <name>vchTrue</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>CScript</name><operator>::</operator><name>const_iterator</name></name></type> <name>pc</name> <init>= <expr><call><name><name>script</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>CScript</name><operator>::</operator><name>const_iterator</name></name></type> <name>pend</name> <init>= <expr><call><name><name>script</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>CScript</name><operator>::</operator><name>const_iterator</name></name></type> <name>pbegincodehash</name> <init>= <expr><call><name><name>script</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>opcodetype</name></type> <name>opcode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>valtype</name></type> <name>vchPushValue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name></type> <name>vfExec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>valtype</name></expr></argument>&gt;</argument_list></name></type> <name>altstack</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_UNKNOWN_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>script</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>MAX_SCRIPT_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_SCRIPT_SIZE</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nOpCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>fRequireMinimal</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SCRIPT_VERIFY_MINIMALDATA</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <try>try
    <block>{<block_content>
        <while>while <condition>(<expr><name>pc</name> <operator>&lt;</operator> <name>pend</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type> <name>fExec</name> <init>= <expr><operator>!</operator><call><name>count</name><argument_list>(<argument><expr><call><name><name>vfExec</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>vfExec</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">//</comment>
            <comment type="line">// Read instruction</comment>
            <comment type="line">//</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>script</name><operator>.</operator><name>GetOp</name></name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>opcode</name></expr></argument>, <argument><expr><name>vchPushValue</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_BAD_OPCODE</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>vchPushValue</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>MAX_SCRIPT_ELEMENT_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_PUSH_SIZE</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

            <comment type="line">// Note how OP_RESERVED does not count towards the opcode limit.</comment>
            <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>&gt;</operator> <name>OP_16</name> <operator>&amp;&amp;</operator> <operator>++</operator><name>nOpCount</name> <operator>&gt;</operator> <name>MAX_OPS_PER_SCRIPT</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_OP_COUNT</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_CAT</name> <operator>||</operator>
                <name>opcode</name> <operator>==</operator> <name>OP_SUBSTR</name> <operator>||</operator>
                <name>opcode</name> <operator>==</operator> <name>OP_LEFT</name> <operator>||</operator>
                <name>opcode</name> <operator>==</operator> <name>OP_RIGHT</name> <operator>||</operator>
                <name>opcode</name> <operator>==</operator> <name>OP_INVERT</name> <operator>||</operator>
                <name>opcode</name> <operator>==</operator> <name>OP_AND</name> <operator>||</operator>
                <name>opcode</name> <operator>==</operator> <name>OP_OR</name> <operator>||</operator>
                <name>opcode</name> <operator>==</operator> <name>OP_XOR</name> <operator>||</operator>
                <name>opcode</name> <operator>==</operator> <name>OP_2MUL</name> <operator>||</operator>
                <name>opcode</name> <operator>==</operator> <name>OP_2DIV</name> <operator>||</operator>
                <name>opcode</name> <operator>==</operator> <name>OP_MUL</name> <operator>||</operator>
                <name>opcode</name> <operator>==</operator> <name>OP_DIV</name> <operator>||</operator>
                <name>opcode</name> <operator>==</operator> <name>OP_MOD</name> <operator>||</operator>
                <name>opcode</name> <operator>==</operator> <name>OP_LSHIFT</name> <operator>||</operator>
                <name>opcode</name> <operator>==</operator> <name>OP_RSHIFT</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_DISABLED_OPCODE</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt> <comment type="line">// Disabled opcodes (CVE-2010-5137).</comment>

            <comment type="line">// With SCRIPT_VERIFY_CONST_SCRIPTCODE, OP_CODESEPARATOR in non-segwit script is rejected even in an unexecuted branch</comment>
            <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_CODESEPARATOR</name> <operator>&amp;&amp;</operator> <name>sigversion</name> <operator>==</operator> <name><name>SigVersion</name><operator>::</operator><name>BASE</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SCRIPT_VERIFY_CONST_SCRIPTCODE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_OP_CODESEPARATOR</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>fExec</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>&lt;=</operator> <name>opcode</name> <operator>&amp;&amp;</operator> <name>opcode</name> <operator>&lt;=</operator> <name>OP_PUSHDATA4</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>fRequireMinimal</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>CheckMinimalPush</name><argument_list>(<argument><expr><name>vchPushValue</name></expr></argument>, <argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_MINIMALDATA</name></expr></argument>)</argument_list></call></expr>;</return>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>vchPushValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>fExec</name> <operator>||</operator> <operator>(</operator><name>OP_IF</name> <operator>&lt;=</operator> <name>opcode</name> <operator>&amp;&amp;</operator> <name>opcode</name> <operator>&lt;=</operator> <name>OP_ENDIF</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <switch>switch <condition>(<expr><name>opcode</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">//</comment>
                <comment type="line">// Push value</comment>
                <comment type="line">//</comment>
                <case>case <expr><name>OP_1NEGATE</name></expr>:</case>
                <case>case <expr><name>OP_1</name></expr>:</case>
                <case>case <expr><name>OP_2</name></expr>:</case>
                <case>case <expr><name>OP_3</name></expr>:</case>
                <case>case <expr><name>OP_4</name></expr>:</case>
                <case>case <expr><name>OP_5</name></expr>:</case>
                <case>case <expr><name>OP_6</name></expr>:</case>
                <case>case <expr><name>OP_7</name></expr>:</case>
                <case>case <expr><name>OP_8</name></expr>:</case>
                <case>case <expr><name>OP_9</name></expr>:</case>
                <case>case <expr><name>OP_10</name></expr>:</case>
                <case>case <expr><name>OP_11</name></expr>:</case>
                <case>case <expr><name>OP_12</name></expr>:</case>
                <case>case <expr><name>OP_13</name></expr>:</case>
                <case>case <expr><name>OP_14</name></expr>:</case>
                <case>case <expr><name>OP_15</name></expr>:</case>
                <case>case <expr><name>OP_16</name></expr>:</case>
                <block>{<block_content>
                    <comment type="line">// ( -- value)</comment>
                    <decl_stmt><decl><type><name>CScriptNum</name></type> <name>bn</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>opcode</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>OP_1</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>bn</name><operator>.</operator><name>getvch</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="line">// The result of these opcodes should always be the minimal way to push the data</comment>
                    <comment type="line">// they push, so no need for a CheckMinimalPush here.</comment>
                </block_content>}</block>
                <break>break;</break>


                <comment type="line">//</comment>
                <comment type="line">// Control</comment>
                <comment type="line">//</comment>
                <case>case <expr><name>OP_NOP</name></expr>:</case>
                    <break>break;</break>

                <case>case <expr><name>OP_CHECKLOCKTIMEVERIFY</name></expr>:</case>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                        <comment type="line">// not enabled; treat as a NOP2</comment>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

                    <comment type="line">// Note that elsewhere numeric opcodes are limited to</comment>
                    <comment type="line">// operands in the range -2**31+1 to 2**31-1, however it is</comment>
                    <comment type="line">// legal for opcodes to produce results exceeding that</comment>
                    <comment type="line">// range. This limitation is implemented by CScriptNum's</comment>
                    <comment type="line">// default 4-byte limit.</comment>
                    <comment type="line">//</comment>
                    <comment type="line">// If we kept to that limit we'd have a year 2038 problem,</comment>
                    <comment type="line">// even though the nLockTime field in transactions</comment>
                    <comment type="line">// themselves is uint32 which only becomes meaningless</comment>
                    <comment type="line">// after the year 2106.</comment>
                    <comment type="line">//</comment>
                    <comment type="line">// Thus as a special case we tell CScriptNum to accept up</comment>
                    <comment type="line">// to 5-byte bignums, which are good until 2**39-1, well</comment>
                    <comment type="line">// beyond the 2**32-1 limit of the nLockTime field itself.</comment>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>CScriptNum</name></type> <name>nLockTime</name><argument_list>(<argument><expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fRequireMinimal</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></decl>;</decl_stmt>

                    <comment type="line">// In the rare event that the argument may be &lt; 0 due to</comment>
                    <comment type="line">// some arithmetic being done first, you can always use</comment>
                    <comment type="line">// 0 MAX CHECKLOCKTIMEVERIFY.</comment>
                    <if_stmt><if>if <condition>(<expr><name>nLockTime</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_NEGATIVE_LOCKTIME</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

                    <comment type="line">// Actually compare the specified lock time with the transaction.</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>checker</name><operator>.</operator><name>CheckLockTime</name></name><argument_list>(<argument><expr><name>nLockTime</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_UNSATISFIED_LOCKTIME</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

                    <break>break;</break>
                </block_content>}</block>

                <case>case <expr><name>OP_CHECKSEQUENCEVERIFY</name></expr>:</case>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SCRIPT_VERIFY_CHECKSEQUENCEVERIFY</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                        <comment type="line">// not enabled; treat as a NOP3</comment>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

                    <comment type="line">// nSequence, like nLockTime, is a 32-bit unsigned integer</comment>
                    <comment type="line">// field. See the comment in CHECKLOCKTIMEVERIFY regarding</comment>
                    <comment type="line">// 5-byte numeric operands.</comment>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>CScriptNum</name></type> <name>nSequence</name><argument_list>(<argument><expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fRequireMinimal</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></decl>;</decl_stmt>

                    <comment type="line">// In the rare event that the argument may be &lt; 0 due to</comment>
                    <comment type="line">// some arithmetic being done first, you can always use</comment>
                    <comment type="line">// 0 MAX CHECKSEQUENCEVERIFY.</comment>
                    <if_stmt><if>if <condition>(<expr><name>nSequence</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_NEGATIVE_LOCKTIME</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

                    <comment type="line">// To provide for future soft-fork extensibility, if the</comment>
                    <comment type="line">// operand has the disabled lock-time flag set,</comment>
                    <comment type="line">// CHECKSEQUENCEVERIFY behaves as a NOP.</comment>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>nSequence</name> <operator>&amp;</operator> <name><name>CTxIn</name><operator>::</operator><name>SEQUENCE_LOCKTIME_DISABLE_FLAG</name></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>

                    <comment type="line">// Compare the specified sequence number with the input.</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>checker</name><operator>.</operator><name>CheckSequence</name></name><argument_list>(<argument><expr><name>nSequence</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_UNSATISFIED_LOCKTIME</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

                    <break>break;</break>
                </block_content>}</block>

                <case>case <expr><name>OP_NOP1</name></expr>:</case> <case>case <expr><name>OP_NOP4</name></expr>:</case> <case>case <expr><name>OP_NOP5</name></expr>:</case>
                <case>case <expr><name>OP_NOP6</name></expr>:</case> <case>case <expr><name>OP_NOP7</name></expr>:</case> <case>case <expr><name>OP_NOP8</name></expr>:</case> <case>case <expr><name>OP_NOP9</name></expr>:</case> <case>case <expr><name>OP_NOP10</name></expr>:</case>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS</name></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                </block_content>}</block>
                <break>break;</break>

                <case>case <expr><name>OP_IF</name></expr>:</case>
                <case>case <expr><name>OP_NOTIF</name></expr>:</case>
                <block>{<block_content>
                    <comment type="line">// &lt;expression&gt; if [statements] [else [statements]] endif</comment>
                    <decl_stmt><decl><type><name>bool</name></type> <name>fValue</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>fExec</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                            <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_UNBALANCED_CONDITIONAL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                        <decl_stmt><decl><type><name>valtype</name><modifier>&amp;</modifier></type> <name>vch</name> <init>= <expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><name>sigversion</name> <operator>==</operator> <name><name>SigVersion</name><operator>::</operator><name>WITNESS_V0</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SCRIPT_VERIFY_MINIMALIF</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><call><name><name>vch</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                                <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_MINIMALIF</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                            <if_stmt><if>if <condition>(<expr><call><name><name>vch</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>vch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                                <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_MINIMALIF</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><name>fValue</name> <operator>=</operator> <call><name>CastToBool</name><argument_list>(<argument><expr><name>vch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_NOTIF</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>fValue</name> <operator>=</operator> <operator>!</operator><name>fValue</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <expr_stmt><expr><call><name>popstack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name><name>vfExec</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>fValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

                <case>case <expr><name>OP_ELSE</name></expr>:</case>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name><name>vfExec</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_UNBALANCED_CONDITIONAL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name><name>vfExec</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call> <operator>=</operator> <operator>!</operator><call><name><name>vfExec</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

                <case>case <expr><name>OP_ENDIF</name></expr>:</case>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name><name>vfExec</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_UNBALANCED_CONDITIONAL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name><name>vfExec</name><operator>.</operator><name>pop_back</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

                <case>case <expr><name>OP_VERIFY</name></expr>:</case>
                <block>{<block_content>
                    <comment type="line">// (true -- ) or</comment>
                    <comment type="line">// (false -- false) and return</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <decl_stmt><decl><type><name>bool</name></type> <name>fValue</name> <init>= <expr><call><name>CastToBool</name><argument_list>(<argument><expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>fValue</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>popstack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_VERIFY</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
                </block_content>}</block>
                <break>break;</break>

                <case>case <expr><name>OP_RETURN</name></expr>:</case>
                <block>{<block_content>
                    <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_OP_RETURN</name></expr></argument>)</argument_list></call></expr>;</return>
                </block_content>}</block>
                <break>break;</break>


                <comment type="line">//</comment>
                <comment type="line">// Stack ops</comment>
                <comment type="line">//</comment>
                <case>case <expr><name>OP_TOALTSTACK</name></expr>:</case>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name><name>altstack</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>popstack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

                <case>case <expr><name>OP_FROMALTSTACK</name></expr>:</case>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name><name>altstack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_ALTSTACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>altstacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>popstack</name><argument_list>(<argument><expr><name>altstack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

                <case>case <expr><name>OP_2DROP</name></expr>:</case>
                <block>{<block_content>
                    <comment type="line">// (x1 x2 -- )</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>popstack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>popstack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

                <case>case <expr><name>OP_2DUP</name></expr>:</case>
                <block>{<block_content>
                    <comment type="line">// (x1 x2 -- x1 x2 x1 x2)</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <decl_stmt><decl><type><name>valtype</name></type> <name>vch1</name> <init>= <expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>valtype</name></type> <name>vch2</name> <init>= <expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>vch1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>vch2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

                <case>case <expr><name>OP_3DUP</name></expr>:</case>
                <block>{<block_content>
                    <comment type="line">// (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <decl_stmt><decl><type><name>valtype</name></type> <name>vch1</name> <init>= <expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>valtype</name></type> <name>vch2</name> <init>= <expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>valtype</name></type> <name>vch3</name> <init>= <expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>vch1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>vch2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>vch3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

                <case>case <expr><name>OP_2OVER</name></expr>:</case>
                <block>{<block_content>
                    <comment type="line">// (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <decl_stmt><decl><type><name>valtype</name></type> <name>vch1</name> <init>= <expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>valtype</name></type> <name>vch2</name> <init>= <expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>vch1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>vch2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

                <case>case <expr><name>OP_2ROT</name></expr>:</case>
                <block>{<block_content>
                    <comment type="line">// (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">6</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <decl_stmt><decl><type><name>valtype</name></type> <name>vch1</name> <init>= <expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>valtype</name></type> <name>vch2</name> <init>= <expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><call><name><name>stack</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call><operator>-</operator><literal type="number">6</literal></expr></argument>, <argument><expr><call><name><name>stack</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call><operator>-</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>vch1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>vch2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

                <case>case <expr><name>OP_2SWAP</name></expr>:</case>
                <block>{<block_content>
                    <comment type="line">// (x1 x2 x3 x4 -- x3 x4 x1 x2)</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>swap</name><argument_list>(<argument><expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>swap</name><argument_list>(<argument><expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

                <case>case <expr><name>OP_IFDUP</name></expr>:</case>
                <block>{<block_content>
                    <comment type="line">// (x - 0 | x x)</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <decl_stmt><decl><type><name>valtype</name></type> <name>vch</name> <init>= <expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>CastToBool</name><argument_list>(<argument><expr><name>vch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>vch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block>
                <break>break;</break>

                <case>case <expr><name>OP_DEPTH</name></expr>:</case>
                <block>{<block_content>
                    <comment type="line">// -- stacksize</comment>
                    <decl_stmt><decl><type><name>CScriptNum</name></type> <name>bn</name><argument_list>(<argument><expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>bn</name><operator>.</operator><name>getvch</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

                <case>case <expr><name>OP_DROP</name></expr>:</case>
                <block>{<block_content>
                    <comment type="line">// (x -- )</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>popstack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

                <case>case <expr><name>OP_DUP</name></expr>:</case>
                <block>{<block_content>
                    <comment type="line">// (x -- x x)</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <decl_stmt><decl><type><name>valtype</name></type> <name>vch</name> <init>= <expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>vch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

                <case>case <expr><name>OP_NIP</name></expr>:</case>
                <block>{<block_content>
                    <comment type="line">// (x1 x2 -- x2)</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><call><name><name>stack</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

                <case>case <expr><name>OP_OVER</name></expr>:</case>
                <block>{<block_content>
                    <comment type="line">// (x1 x2 -- x1 x2 x1)</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <decl_stmt><decl><type><name>valtype</name></type> <name>vch</name> <init>= <expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>vch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

                <case>case <expr><name>OP_PICK</name></expr>:</case>
                <case>case <expr><name>OP_ROLL</name></expr>:</case>
                <block>{<block_content>
                    <comment type="line">// (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)</comment>
                    <comment type="line">// (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>CScriptNum</name><argument_list>(<argument><expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fRequireMinimal</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getint</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>popstack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>n</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <decl_stmt><decl><type><name>valtype</name></type> <name>vch</name> <init>= <expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><name>n</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_ROLL</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><call><name><name>stack</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call><operator>-</operator><name>n</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>vch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

                <case>case <expr><name>OP_ROT</name></expr>:</case>
                <block>{<block_content>
                    <comment type="line">// (x1 x2 x3 -- x2 x3 x1)</comment>
                    <comment type="line">//  x2 x1 x3  after first swap</comment>
                    <comment type="line">//  x2 x3 x1  after second swap</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>swap</name><argument_list>(<argument><expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>swap</name><argument_list>(<argument><expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

                <case>case <expr><name>OP_SWAP</name></expr>:</case>
                <block>{<block_content>
                    <comment type="line">// (x1 x2 -- x2 x1)</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>swap</name><argument_list>(<argument><expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

                <case>case <expr><name>OP_TUCK</name></expr>:</case>
                <block>{<block_content>
                    <comment type="line">// (x1 x2 -- x2 x1 x2)</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <decl_stmt><decl><type><name>valtype</name></type> <name>vch</name> <init>= <expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>stack</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>vch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>


                <case>case <expr><name>OP_SIZE</name></expr>:</case>
                <block>{<block_content>
                    <comment type="line">// (in -- in size)</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <decl_stmt><decl><type><name>CScriptNum</name></type> <name>bn</name><argument_list>(<argument><expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>bn</name><operator>.</operator><name>getvch</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>


                <comment type="line">//</comment>
                <comment type="line">// Bitwise logic</comment>
                <comment type="line">//</comment>
                <case>case <expr><name>OP_EQUAL</name></expr>:</case>
                <case>case <expr><name>OP_EQUALVERIFY</name></expr>:</case>
                <comment type="line">//case OP_NOTEQUAL: // use OP_NUMNOTEQUAL</comment>
                <block>{<block_content>
                    <comment type="line">// (x1 x2 - bool)</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <decl_stmt><decl><type><name>valtype</name><modifier>&amp;</modifier></type> <name>vch1</name> <init>= <expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>valtype</name><modifier>&amp;</modifier></type> <name>vch2</name> <init>= <expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>bool</name></type> <name>fEqual</name> <init>= <expr><operator>(</operator><name>vch1</name> <operator>==</operator> <name>vch2</name><operator>)</operator></expr></init></decl>;</decl_stmt>
                    <comment type="line">// OP_NOTEQUAL is disabled because it would be too easy to say</comment>
                    <comment type="line">// something like n != 1 and have some wiseguy pass in 1 with extra</comment>
                    <comment type="line">// zero bytes after it (numerically, 0x01 == 0x0001 == 0x000001)</comment>
                    <comment type="line">//if (opcode == OP_NOTEQUAL)</comment>
                    <comment type="line">//    fEqual = !fEqual;</comment>
                    <expr_stmt><expr><call><name>popstack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>popstack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><ternary><condition><expr><name>fEqual</name></expr> ?</condition><then> <expr><name>vchTrue</name></expr> </then><else>: <expr><name>vchFalse</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_EQUALVERIFY</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>fEqual</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>popstack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                        <else>else<block type="pseudo"><block_content>
                            <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_EQUALVERIFY</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block>
                <break>break;</break>


                <comment type="line">//</comment>
                <comment type="line">// Numeric</comment>
                <comment type="line">//</comment>
                <case>case <expr><name>OP_1ADD</name></expr>:</case>
                <case>case <expr><name>OP_1SUB</name></expr>:</case>
                <case>case <expr><name>OP_NEGATE</name></expr>:</case>
                <case>case <expr><name>OP_ABS</name></expr>:</case>
                <case>case <expr><name>OP_NOT</name></expr>:</case>
                <case>case <expr><name>OP_0NOTEQUAL</name></expr>:</case>
                <block>{<block_content>
                    <comment type="line">// (in -- out)</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <decl_stmt><decl><type><name>CScriptNum</name></type> <name>bn</name><argument_list>(<argument><expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fRequireMinimal</name></expr></argument>)</argument_list></decl>;</decl_stmt>
                    <switch>switch <condition>(<expr><name>opcode</name></expr>)</condition>
                    <block>{<block_content>
                    <case>case <expr><name>OP_1ADD</name></expr>:</case>       <expr_stmt><expr><name>bn</name> <operator>+=</operator> <name>bnOne</name></expr>;</expr_stmt> <break>break;</break>
                    <case>case <expr><name>OP_1SUB</name></expr>:</case>       <expr_stmt><expr><name>bn</name> <operator>-=</operator> <name>bnOne</name></expr>;</expr_stmt> <break>break;</break>
                    <case>case <expr><name>OP_NEGATE</name></expr>:</case>     <expr_stmt><expr><name>bn</name> <operator>=</operator> <operator>-</operator><name>bn</name></expr>;</expr_stmt> <break>break;</break>
                    <case>case <expr><name>OP_ABS</name></expr>:</case>        <if_stmt><if>if <condition>(<expr><name>bn</name> <operator>&lt;</operator> <name>bnZero</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bn</name> <operator>=</operator> <operator>-</operator><name>bn</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <break>break;</break>
                    <case>case <expr><name>OP_NOT</name></expr>:</case>        <expr_stmt><expr><name>bn</name> <operator>=</operator> <operator>(</operator><name>bn</name> <operator>==</operator> <name>bnZero</name><operator>)</operator></expr>;</expr_stmt> <break>break;</break>
                    <case>case <expr><name>OP_0NOTEQUAL</name></expr>:</case>  <expr_stmt><expr><name>bn</name> <operator>=</operator> <operator>(</operator><name>bn</name> <operator>!=</operator> <name>bnZero</name><operator>)</operator></expr>;</expr_stmt> <break>break;</break>
                    <default>default:</default>            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><literal type="string">"invalid opcode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
                    </block_content>}</block></switch>
                    <expr_stmt><expr><call><name>popstack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>bn</name><operator>.</operator><name>getvch</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

                <case>case <expr><name>OP_ADD</name></expr>:</case>
                <case>case <expr><name>OP_SUB</name></expr>:</case>
                <case>case <expr><name>OP_BOOLAND</name></expr>:</case>
                <case>case <expr><name>OP_BOOLOR</name></expr>:</case>
                <case>case <expr><name>OP_NUMEQUAL</name></expr>:</case>
                <case>case <expr><name>OP_NUMEQUALVERIFY</name></expr>:</case>
                <case>case <expr><name>OP_NUMNOTEQUAL</name></expr>:</case>
                <case>case <expr><name>OP_LESSTHAN</name></expr>:</case>
                <case>case <expr><name>OP_GREATERTHAN</name></expr>:</case>
                <case>case <expr><name>OP_LESSTHANOREQUAL</name></expr>:</case>
                <case>case <expr><name>OP_GREATERTHANOREQUAL</name></expr>:</case>
                <case>case <expr><name>OP_MIN</name></expr>:</case>
                <case>case <expr><name>OP_MAX</name></expr>:</case>
                <block>{<block_content>
                    <comment type="line">// (x1 x2 -- out)</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <decl_stmt><decl><type><name>CScriptNum</name></type> <name>bn1</name><argument_list>(<argument><expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fRequireMinimal</name></expr></argument>)</argument_list></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>CScriptNum</name></type> <name>bn2</name><argument_list>(<argument><expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fRequireMinimal</name></expr></argument>)</argument_list></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>CScriptNum</name></type> <name>bn</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
                    <switch>switch <condition>(<expr><name>opcode</name></expr>)</condition>
                    <block>{<block_content>
                    <case>case <expr><name>OP_ADD</name></expr>:</case>
                        <expr_stmt><expr><name>bn</name> <operator>=</operator> <name>bn1</name> <operator>+</operator> <name>bn2</name></expr>;</expr_stmt>
                        <break>break;</break>

                    <case>case <expr><name>OP_SUB</name></expr>:</case>
                        <expr_stmt><expr><name>bn</name> <operator>=</operator> <name>bn1</name> <operator>-</operator> <name>bn2</name></expr>;</expr_stmt>
                        <break>break;</break>

                    <case>case <expr><name>OP_BOOLAND</name></expr>:</case>             <expr_stmt><expr><name>bn</name> <operator>=</operator> <operator>(</operator><name>bn1</name> <operator>!=</operator> <name>bnZero</name> <operator>&amp;&amp;</operator> <name>bn2</name> <operator>!=</operator> <name>bnZero</name><operator>)</operator></expr>;</expr_stmt> <break>break;</break>
                    <case>case <expr><name>OP_BOOLOR</name></expr>:</case>              <expr_stmt><expr><name>bn</name> <operator>=</operator> <operator>(</operator><name>bn1</name> <operator>!=</operator> <name>bnZero</name> <operator>||</operator> <name>bn2</name> <operator>!=</operator> <name>bnZero</name><operator>)</operator></expr>;</expr_stmt> <break>break;</break>
                    <case>case <expr><name>OP_NUMEQUAL</name></expr>:</case>            <expr_stmt><expr><name>bn</name> <operator>=</operator> <operator>(</operator><name>bn1</name> <operator>==</operator> <name>bn2</name><operator>)</operator></expr>;</expr_stmt> <break>break;</break>
                    <case>case <expr><name>OP_NUMEQUALVERIFY</name></expr>:</case>      <expr_stmt><expr><name>bn</name> <operator>=</operator> <operator>(</operator><name>bn1</name> <operator>==</operator> <name>bn2</name><operator>)</operator></expr>;</expr_stmt> <break>break;</break>
                    <case>case <expr><name>OP_NUMNOTEQUAL</name></expr>:</case>         <expr_stmt><expr><name>bn</name> <operator>=</operator> <operator>(</operator><name>bn1</name> <operator>!=</operator> <name>bn2</name><operator>)</operator></expr>;</expr_stmt> <break>break;</break>
                    <case>case <expr><name>OP_LESSTHAN</name></expr>:</case>            <expr_stmt><expr><name>bn</name> <operator>=</operator> <operator>(</operator><name>bn1</name> <operator>&lt;</operator> <name>bn2</name><operator>)</operator></expr>;</expr_stmt> <break>break;</break>
                    <case>case <expr><name>OP_GREATERTHAN</name></expr>:</case>         <expr_stmt><expr><name>bn</name> <operator>=</operator> <operator>(</operator><name>bn1</name> <operator>&gt;</operator> <name>bn2</name><operator>)</operator></expr>;</expr_stmt> <break>break;</break>
                    <case>case <expr><name>OP_LESSTHANOREQUAL</name></expr>:</case>     <expr_stmt><expr><name>bn</name> <operator>=</operator> <operator>(</operator><name>bn1</name> <operator>&lt;=</operator> <name>bn2</name><operator>)</operator></expr>;</expr_stmt> <break>break;</break>
                    <case>case <expr><name>OP_GREATERTHANOREQUAL</name></expr>:</case>  <expr_stmt><expr><name>bn</name> <operator>=</operator> <operator>(</operator><name>bn1</name> <operator>&gt;=</operator> <name>bn2</name><operator>)</operator></expr>;</expr_stmt> <break>break;</break>
                    <case>case <expr><name>OP_MIN</name></expr>:</case>                 <expr_stmt><expr><name>bn</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>bn1</name> <operator>&lt;</operator> <name>bn2</name></expr> ?</condition><then> <expr><name>bn1</name></expr> </then><else>: <expr><name>bn2</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt> <break>break;</break>
                    <case>case <expr><name>OP_MAX</name></expr>:</case>                 <expr_stmt><expr><name>bn</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>bn1</name> <operator>&gt;</operator> <name>bn2</name></expr> ?</condition><then> <expr><name>bn1</name></expr> </then><else>: <expr><name>bn2</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt> <break>break;</break>
                    <default>default:</default>                     <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><literal type="string">"invalid opcode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
                    </block_content>}</block></switch>
                    <expr_stmt><expr><call><name>popstack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>popstack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>bn</name><operator>.</operator><name>getvch</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_NUMEQUALVERIFY</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><call><name>CastToBool</name><argument_list>(<argument><expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>popstack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                        <else>else<block type="pseudo"><block_content>
                            <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_NUMEQUALVERIFY</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block>
                <break>break;</break>

                <case>case <expr><name>OP_WITHIN</name></expr>:</case>
                <block>{<block_content>
                    <comment type="line">// (x min max -- out)</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <decl_stmt><decl><type><name>CScriptNum</name></type> <name>bn1</name><argument_list>(<argument><expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fRequireMinimal</name></expr></argument>)</argument_list></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>CScriptNum</name></type> <name>bn2</name><argument_list>(<argument><expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fRequireMinimal</name></expr></argument>)</argument_list></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>CScriptNum</name></type> <name>bn3</name><argument_list>(<argument><expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fRequireMinimal</name></expr></argument>)</argument_list></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>bool</name></type> <name>fValue</name> <init>= <expr><operator>(</operator><name>bn2</name> <operator>&lt;=</operator> <name>bn1</name> <operator>&amp;&amp;</operator> <name>bn1</name> <operator>&lt;</operator> <name>bn3</name><operator>)</operator></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>popstack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>popstack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>popstack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><ternary><condition><expr><name>fValue</name></expr> ?</condition><then> <expr><name>vchTrue</name></expr> </then><else>: <expr><name>vchFalse</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>


                <comment type="line">//</comment>
                <comment type="line">// Crypto</comment>
                <comment type="line">//</comment>
                <case>case <expr><name>OP_RIPEMD160</name></expr>:</case>
                <case>case <expr><name>OP_SHA1</name></expr>:</case>
                <case>case <expr><name>OP_SHA256</name></expr>:</case>
                <case>case <expr><name>OP_HASH160</name></expr>:</case>
                <case>case <expr><name>OP_HASH256</name></expr>:</case>
                <block>{<block_content>
                    <comment type="line">// (in -- hash)</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <decl_stmt><decl><type><name>valtype</name><modifier>&amp;</modifier></type> <name>vch</name> <init>= <expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>valtype</name></type> <name>vchHash</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>opcode</name> <operator>==</operator> <name>OP_RIPEMD160</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_SHA1</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_HASH160</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">20</literal></expr> </then><else>: <expr><literal type="number">32</literal></expr></else></ternary></expr></argument>)</argument_list></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_RIPEMD160</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>CRIPEMD160</name><argument_list>()</argument_list></call><operator>.</operator><call><name>Write</name><argument_list>(<argument><expr><call><name><name>vch</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>vch</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>Finalize</name><argument_list>(<argument><expr><call><name><name>vchHash</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <if type="elseif">else if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_SHA1</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>CSHA1</name><argument_list>()</argument_list></call><operator>.</operator><call><name>Write</name><argument_list>(<argument><expr><call><name><name>vch</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>vch</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>Finalize</name><argument_list>(<argument><expr><call><name><name>vchHash</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <if type="elseif">else if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_SHA256</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>CSHA256</name><argument_list>()</argument_list></call><operator>.</operator><call><name>Write</name><argument_list>(<argument><expr><call><name><name>vch</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>vch</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>Finalize</name><argument_list>(<argument><expr><call><name><name>vchHash</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <if type="elseif">else if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_HASH160</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>CHash160</name><argument_list>()</argument_list></call><operator>.</operator><call><name>Write</name><argument_list>(<argument><expr><call><name><name>vch</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>vch</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>Finalize</name><argument_list>(<argument><expr><call><name><name>vchHash</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <if type="elseif">else if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_HASH256</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>CHash256</name><argument_list>()</argument_list></call><operator>.</operator><call><name>Write</name><argument_list>(<argument><expr><call><name><name>vch</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>vch</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>Finalize</name><argument_list>(<argument><expr><call><name><name>vchHash</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>popstack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>vchHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

                <case>case <expr><name>OP_CODESEPARATOR</name></expr>:</case>
                <block>{<block_content>
                    <comment type="line">// If SCRIPT_VERIFY_CONST_SCRIPTCODE flag is set, use of OP_CODESEPARATOR is rejected in pre-segwit</comment>
                    <comment type="line">// script, even in an unexecuted branch (this is checked above the opcode case statement).</comment>

                    <comment type="line">// Hash starts after the code separator</comment>
                    <expr_stmt><expr><name>pbegincodehash</name> <operator>=</operator> <name>pc</name></expr>;</expr_stmt>
                </block_content>}</block>
                <break>break;</break>

                <case>case <expr><name>OP_CHECKSIG</name></expr>:</case>
                <case>case <expr><name>OP_CHECKSIGVERIFY</name></expr>:</case>
                <block>{<block_content>
                    <comment type="line">// (sig pubkey -- bool)</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

                    <decl_stmt><decl><type><name>valtype</name><modifier>&amp;</modifier></type> <name>vchSig</name>    <init>= <expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>valtype</name><modifier>&amp;</modifier></type> <name>vchPubKey</name> <init>= <expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Subset of script starting at the most recent codeseparator</comment>
                    <decl_stmt><decl><type><name>CScript</name></type> <name>scriptCode</name><argument_list>(<argument><expr><name>pbegincodehash</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>)</argument_list></decl>;</decl_stmt>

                    <comment type="line">// Drop the signature in pre-segwit scripts but not segwit scripts</comment>
                    <if_stmt><if>if <condition>(<expr><name>sigversion</name> <operator>==</operator> <name><name>SigVersion</name><operator>::</operator><name>BASE</name></name></expr>)</condition> <block>{<block_content>
                        <decl_stmt><decl><type><name>int</name></type> <name>found</name> <init>= <expr><call><name>FindAndDelete</name><argument_list>(<argument><expr><name>scriptCode</name></expr></argument>, <argument><expr><call><name>CScript</name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <name>vchSig</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><name>found</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SCRIPT_VERIFY_CONST_SCRIPTCODE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                            <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_SIG_FINDANDDELETE</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckSignatureEncoding</name><argument_list>(<argument><expr><name>vchSig</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>serror</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>CheckPubKeyEncoding</name><argument_list>(<argument><expr><name>vchPubKey</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>sigversion</name></expr></argument>, <argument><expr><name>serror</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <comment type="line">//serror is set</comment>
                        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                    <decl_stmt><decl><type><name>bool</name></type> <name>fSuccess</name> <init>= <expr><call><name><name>checker</name><operator>.</operator><name>CheckSig</name></name><argument_list>(<argument><expr><name>vchSig</name></expr></argument>, <argument><expr><name>vchPubKey</name></expr></argument>, <argument><expr><name>scriptCode</name></expr></argument>, <argument><expr><name>sigversion</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fSuccess</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SCRIPT_VERIFY_NULLFAIL</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name><name>vchSig</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_SIG_NULLFAIL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

                    <expr_stmt><expr><call><name>popstack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>popstack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><ternary><condition><expr><name>fSuccess</name></expr> ?</condition><then> <expr><name>vchTrue</name></expr> </then><else>: <expr><name>vchFalse</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_CHECKSIGVERIFY</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>fSuccess</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>popstack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                        <else>else<block type="pseudo"><block_content>
                            <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_CHECKSIGVERIFY</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block>
                <break>break;</break>

                <case>case <expr><name>OP_CHECKMULTISIG</name></expr>:</case>
                <case>case <expr><name>OP_CHECKMULTISIGVERIFY</name></expr>:</case>
                <block>{<block_content>
                    <comment type="line">// ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)</comment>

                    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

                    <decl_stmt><decl><type><name>int</name></type> <name>nKeysCount</name> <init>= <expr><call><name>CScriptNum</name><argument_list>(<argument><expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fRequireMinimal</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getint</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>nKeysCount</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>nKeysCount</name></expr></argument> &gt;</argument_list></name> <name>MAX_PUBKEYS_PER_MULTISIG</name></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_PUBKEY_COUNT</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>nOpCount</name> <operator>+=</operator> <name>nKeysCount</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>nOpCount</name> <operator>&gt;</operator> <name>MAX_OPS_PER_SCRIPT</name></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_OP_COUNT</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>ikey</name> <init>= <expr><operator>++</operator><name>i</name></expr></init></decl>;</decl_stmt>
                    <comment type="line">// ikey2 is the position of last non-signature item in the stack. Top stack item = 1.</comment>
                    <comment type="line">// With SCRIPT_VERIFY_NULLFAIL, this is used for cleanup if operation fails.</comment>
                    <decl_stmt><decl><type><name>int</name></type> <name>ikey2</name> <init>= <expr><name>nKeysCount</name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>i</name> <operator>+=</operator> <name>nKeysCount</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

                    <decl_stmt><decl><type><name>int</name></type> <name>nSigsCount</name> <init>= <expr><call><name>CScriptNum</name><argument_list>(<argument><expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fRequireMinimal</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getint</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>nSigsCount</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>nSigsCount</name></expr></argument> &gt;</argument_list></name> <name>nKeysCount</name></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_SIG_COUNT</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>isig</name> <init>= <expr><operator>++</operator><name>i</name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>i</name> <operator>+=</operator> <name>nSigsCount</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

                    <comment type="line">// Subset of script starting at the most recent codeseparator</comment>
                    <decl_stmt><decl><type><name>CScript</name></type> <name>scriptCode</name><argument_list>(<argument><expr><name>pbegincodehash</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>)</argument_list></decl>;</decl_stmt>

                    <comment type="line">// Drop the signature in pre-segwit scripts but not segwit scripts</comment>
                    <for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>nSigsCount</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>valtype</name><modifier>&amp;</modifier></type> <name>vchSig</name> <init>= <expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><name>isig</name><operator>-</operator><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><name>sigversion</name> <operator>==</operator> <name><name>SigVersion</name><operator>::</operator><name>BASE</name></name></expr>)</condition> <block>{<block_content>
                            <decl_stmt><decl><type><name>int</name></type> <name>found</name> <init>= <expr><call><name>FindAndDelete</name><argument_list>(<argument><expr><name>scriptCode</name></expr></argument>, <argument><expr><call><name>CScript</name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <name>vchSig</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <if_stmt><if>if <condition>(<expr><name>found</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SCRIPT_VERIFY_CONST_SCRIPTCODE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                                <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_SIG_FINDANDDELETE</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>

                    <decl_stmt><decl><type><name>bool</name></type> <name>fSuccess</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>
                    <while>while <condition>(<expr><name>fSuccess</name> <operator>&amp;&amp;</operator> <name>nSigsCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>valtype</name><modifier>&amp;</modifier></type> <name>vchSig</name>    <init>= <expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><name>isig</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>valtype</name><modifier>&amp;</modifier></type> <name>vchPubKey</name> <init>= <expr><call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><name>ikey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <comment type="line">// Note how this makes the exact order of pubkey/signature evaluation</comment>
                        <comment type="line">// distinguishable by CHECKMULTISIG NOT if the STRICTENC flag is set.</comment>
                        <comment type="line">// See the script_(in)valid tests for details.</comment>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckSignatureEncoding</name><argument_list>(<argument><expr><name>vchSig</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>serror</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>CheckPubKeyEncoding</name><argument_list>(<argument><expr><name>vchPubKey</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>sigversion</name></expr></argument>, <argument><expr><name>serror</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                            <comment type="line">// serror is set</comment>
                            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                        </block_content>}</block></if></if_stmt>

                        <comment type="line">// Check signature</comment>
                        <decl_stmt><decl><type><name>bool</name></type> <name>fOk</name> <init>= <expr><call><name><name>checker</name><operator>.</operator><name>CheckSig</name></name><argument_list>(<argument><expr><name>vchSig</name></expr></argument>, <argument><expr><name>vchPubKey</name></expr></argument>, <argument><expr><name>scriptCode</name></expr></argument>, <argument><expr><name>sigversion</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><name>fOk</name></expr>)</condition> <block>{<block_content>
                            <expr_stmt><expr><name>isig</name><operator>++</operator></expr>;</expr_stmt>
                            <expr_stmt><expr><name>nSigsCount</name><operator>--</operator></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><name>ikey</name><operator>++</operator></expr>;</expr_stmt>
                        <expr_stmt><expr><name>nKeysCount</name><operator>--</operator></expr>;</expr_stmt>

                        <comment type="line">// If there are more signatures left than keys left,</comment>
                        <comment type="line">// then too many signatures have failed. Exit early,</comment>
                        <comment type="line">// without checking any further signatures.</comment>
                        <if_stmt><if>if <condition>(<expr><name>nSigsCount</name> <operator>&gt;</operator> <name>nKeysCount</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>fSuccess</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></while>

                    <comment type="line">// Clean up stack of actual arguments</comment>
                    <while>while <condition>(<expr><name>i</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                        <comment type="line">// If the operation failed, we require that all signatures must be empty vector</comment>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fSuccess</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SCRIPT_VERIFY_NULLFAIL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>ikey2</name> <operator>&amp;&amp;</operator> <call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_SIG_NULLFAIL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                        <if_stmt><if>if <condition>(<expr><name>ikey2</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>ikey2</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <expr_stmt><expr><call><name>popstack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></while>

                    <comment type="line">// A bug causes CHECKMULTISIG to consume one extra argument</comment>
                    <comment type="line">// whose contents were not checked in any way.</comment>
                    <comment type="line">//</comment>
                    <comment type="line">// Unfortunately this is a potential source of mutability,</comment>
                    <comment type="line">// so optionally verify it is exactly equal to zero prior</comment>
                    <comment type="line">// to removing it from the stack.</comment>
                    <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_INVALID_STACK_OPERATION</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SCRIPT_VERIFY_NULLDUMMY</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>stacktop</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_SIG_NULLDUMMY</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>popstack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><ternary><condition><expr><name>fSuccess</name></expr> ?</condition><then> <expr><name>vchTrue</name></expr> </then><else>: <expr><name>vchFalse</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_CHECKMULTISIGVERIFY</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>fSuccess</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>popstack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                        <else>else<block type="pseudo"><block_content>
                            <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_CHECKMULTISIGVERIFY</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block>
                <break>break;</break>

                <default>default:</default>
                    <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_BAD_OPCODE</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></switch></block_content></block></if></if_stmt>

            <comment type="line">// Size limits</comment>
            <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>+</operator> <call><name><name>altstack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>MAX_STACK_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_STACK_SIZE</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block>
    <catch>catch <parameter_list>(<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_UNKNOWN_ERROR</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></catch></try>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>vfExec</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_UNBALANCED_CONDITIONAL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><call><name>set_success</name><argument_list>(<argument><expr><name>serror</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<namespace>namespace <block>{

<comment type="block" format="doxygen">/**
 * Wrapper that serializes like CTransaction, but with the modifications
 *  required for the signature hash done in-place
 */</comment>
<class><template>template <parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>&gt;</parameter_list></template>
class <name>CTransactionSignatureSerializer</name>
<block>{<private type="default">
</private><private>private:
    <decl_stmt><decl><type><specifier>const</specifier> <name>T</name><modifier>&amp;</modifier></type> <name>txTo</name></decl>;</decl_stmt>             <comment type="line" format="doxygen">//!&lt; reference to the spending transaction (the one being serialized)</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CScript</name><modifier>&amp;</modifier></type> <name>scriptCode</name></decl>;</decl_stmt> <comment type="line" format="doxygen">//!&lt; output script being consumed</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>nIn</name></decl>;</decl_stmt>    <comment type="line" format="doxygen">//!&lt; input index of txTo being signed</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>fAnyoneCanPay</name></decl>;</decl_stmt>  <comment type="line" format="doxygen">//!&lt; whether the hashtype has the SIGHASH_ANYONECANPAY flag set</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>fHashSingle</name></decl>;</decl_stmt>    <comment type="line" format="doxygen">//!&lt; whether the hashtype is SIGHASH_SINGLE</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>fHashNone</name></decl>;</decl_stmt>      <comment type="line" format="doxygen">//!&lt; whether the hashtype is SIGHASH_NONE</comment>

</private><public>public:
    <constructor><name>CTransactionSignatureSerializer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>T</name><modifier>&amp;</modifier></type> <name>txToIn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CScript</name><modifier>&amp;</modifier></type> <name>scriptCodeIn</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nInIn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nHashTypeIn</name></decl></parameter>)</parameter_list> <member_init_list>:
        <call><name>txTo</name><argument_list>(<argument><expr><name>txToIn</name></expr></argument>)</argument_list></call>, <call><name>scriptCode</name><argument_list>(<argument><expr><name>scriptCodeIn</name></expr></argument>)</argument_list></call>, <call><name>nIn</name><argument_list>(<argument><expr><name>nInIn</name></expr></argument>)</argument_list></call>,
        <call><name>fAnyoneCanPay</name><argument_list>(<argument><expr><operator>!</operator><operator>!</operator><operator>(</operator><name>nHashTypeIn</name> <operator>&amp;</operator> <name>SIGHASH_ANYONECANPAY</name><operator>)</operator></expr></argument>)</argument_list></call>,
        <call><name>fHashSingle</name><argument_list>(<argument><expr><operator>(</operator><name>nHashTypeIn</name> <operator>&amp;</operator> <literal type="number">0x1f</literal><operator>)</operator> <operator>==</operator> <name>SIGHASH_SINGLE</name></expr></argument>)</argument_list></call>,
        <call><name>fHashNone</name><argument_list>(<argument><expr><operator>(</operator><name>nHashTypeIn</name> <operator>&amp;</operator> <literal type="number">0x1f</literal><operator>)</operator> <operator>==</operator> <name>SIGHASH_NONE</name></expr></argument>)</argument_list></call> </member_init_list><block>{<block_content/>}</block></constructor>

    <comment type="block" format="doxygen">/** Serialize the passed scriptCode, skipping OP_CODESEPARATORs */</comment>
    <function><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>S</name></parameter>&gt;</parameter_list></template>
    <type><name>void</name></type> <name>SerializeScriptCode</name><parameter_list>(<parameter><decl><type><name>S</name> <modifier>&amp;</modifier></type><name>s</name></decl></parameter>)</parameter_list> <specifier>const</specifier> <block>{<block_content>
        <decl_stmt><decl><type><name><name>CScript</name><operator>::</operator><name>const_iterator</name></name></type> <name>it</name> <init>= <expr><call><name><name>scriptCode</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>CScript</name><operator>::</operator><name>const_iterator</name></name></type> <name>itBegin</name> <init>= <expr><name>it</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>opcodetype</name></type> <name>opcode</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nCodeSeparators</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>scriptCode</name><operator>.</operator><name>GetOp</name></name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_CODESEPARATOR</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>nCodeSeparators</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name><operator>::</operator><name>WriteCompactSize</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name><name>scriptCode</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>nCodeSeparators</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>it</name> <operator>=</operator> <name>itBegin</name></expr>;</expr_stmt>
        <while>while <condition>(<expr><call><name><name>scriptCode</name><operator>.</operator><name>GetOp</name></name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><name>opcode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_CODESEPARATOR</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>s</name><operator>.</operator><name>write</name></name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>itBegin</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>it</name><operator>-</operator><name>itBegin</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>itBegin</name> <operator>=</operator> <name>it</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><name>itBegin</name> <operator>!=</operator> <call><name><name>scriptCode</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>s</name><operator>.</operator><name>write</name></name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>itBegin</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>it</name><operator>-</operator><name>itBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="doxygen">/** Serialize an input of txTo */</comment>
    <function><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>S</name></parameter>&gt;</parameter_list></template>
    <type><name>void</name></type> <name>SerializeInput</name><parameter_list>(<parameter><decl><type><name>S</name> <modifier>&amp;</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nInput</name></decl></parameter>)</parameter_list> <specifier>const</specifier> <block>{<block_content>
        <comment type="line">// In case of SIGHASH_ANYONECANPAY, only the input being signed is serialized</comment>
        <if_stmt><if>if <condition>(<expr><name>fAnyoneCanPay</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>nInput</name> <operator>=</operator> <name>nIn</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="line">// Serialize the prevout</comment>
        <expr_stmt><expr><call><name><operator>::</operator><name>Serialize</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>txTo</name><operator>.</operator><name>vin</name><index>[<expr><name>nInput</name></expr>]</index></name><operator>.</operator><name>prevout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// Serialize the script</comment>
        <if_stmt><if>if <condition>(<expr><name>nInput</name> <operator>!=</operator> <name>nIn</name></expr>)</condition><block type="pseudo"><block_content>
            <comment type="line">// Blank out other inputs' signatures</comment>
            <expr_stmt><expr><call><name><operator>::</operator><name>Serialize</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>CScript</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>SerializeScriptCode</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <comment type="line">// Serialize the nSequence</comment>
        <if_stmt><if>if <condition>(<expr><name>nInput</name> <operator>!=</operator> <name>nIn</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>fHashSingle</name> <operator>||</operator> <name>fHashNone</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <comment type="line">// let the others update at will</comment>
            <expr_stmt><expr><call><name><operator>::</operator><name>Serialize</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><operator>::</operator><name>Serialize</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>txTo</name><operator>.</operator><name>vin</name><index>[<expr><name>nInput</name></expr>]</index></name><operator>.</operator><name>nSequence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="doxygen">/** Serialize an output of txTo */</comment>
    <function><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>S</name></parameter>&gt;</parameter_list></template>
    <type><name>void</name></type> <name>SerializeOutput</name><parameter_list>(<parameter><decl><type><name>S</name> <modifier>&amp;</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nOutput</name></decl></parameter>)</parameter_list> <specifier>const</specifier> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>fHashSingle</name> <operator>&amp;&amp;</operator> <name>nOutput</name> <operator>!=</operator> <name>nIn</name></expr>)</condition><block type="pseudo"><block_content>
            <comment type="line">// Do not lock-in the txout payee at other indices as txin</comment>
            <expr_stmt><expr><call><name><operator>::</operator><name>Serialize</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>CTxOut</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><operator>::</operator><name>Serialize</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>txTo</name><operator>.</operator><name>vout</name><index>[<expr><name>nOutput</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="doxygen">/** Serialize txTo */</comment>
    <function><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>S</name></parameter>&gt;</parameter_list></template>
    <type><name>void</name></type> <name>Serialize</name><parameter_list>(<parameter><decl><type><name>S</name> <modifier>&amp;</modifier></type><name>s</name></decl></parameter>)</parameter_list> <specifier>const</specifier> <block>{<block_content>
        <comment type="line">// Serialize nVersion</comment>
        <expr_stmt><expr><call><name><operator>::</operator><name>Serialize</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>txTo</name><operator>.</operator><name>nVersion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// Serialize vin</comment>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nInputs</name> <init>= <expr><ternary><condition><expr><name>fAnyoneCanPay</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><call><name><name>txTo</name><operator>.</operator><name>vin</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><operator>::</operator><name>WriteCompactSize</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>nInputs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>nInput</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>nInput</name> <operator>&lt;</operator> <name>nInputs</name></expr>;</condition> <incr><expr><name>nInput</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
             <expr_stmt><expr><call><name>SerializeInput</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>nInput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <comment type="line">// Serialize vout</comment>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nOutputs</name> <init>= <expr><ternary><condition><expr><name>fHashNone</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><ternary><condition><expr><name>fHashSingle</name></expr> ?</condition><then> <expr><name>nIn</name><operator>+</operator><literal type="number">1</literal></expr> </then><else>: <expr><call><name><name>txTo</name><operator>.</operator><name>vout</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></else></ternary><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><operator>::</operator><name>WriteCompactSize</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>nOutputs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>nOutput</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>nOutput</name> <operator>&lt;</operator> <name>nOutputs</name></expr>;</condition> <incr><expr><name>nOutput</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
             <expr_stmt><expr><call><name>SerializeOutput</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>nOutput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <comment type="line">// Serialize nLockTime</comment>
        <expr_stmt><expr><call><name><operator>::</operator><name>Serialize</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>txTo</name><operator>.</operator><name>nLockTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>
</public>}</block>;</class>

<function><template>template <parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>&gt;</parameter_list></template>
<type><name>uint256</name></type> <name>GetPrevoutHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>T</name><modifier>&amp;</modifier></type> <name>txTo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CHashWriter</name></type> <name>ss</name><argument_list>(<argument><expr><name>SER_GETHASH</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>txin</name> <range>: <expr><name><name>txTo</name><operator>.</operator><name>vin</name></name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><name>ss</name> <operator>&lt;&lt;</operator> <name><name>txin</name><operator>.</operator><name>prevout</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><call><name><name>ss</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><template>template <parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>&gt;</parameter_list></template>
<type><name>uint256</name></type> <name>GetSequenceHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>T</name><modifier>&amp;</modifier></type> <name>txTo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CHashWriter</name></type> <name>ss</name><argument_list>(<argument><expr><name>SER_GETHASH</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>txin</name> <range>: <expr><name><name>txTo</name><operator>.</operator><name>vin</name></name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><name>ss</name> <operator>&lt;&lt;</operator> <name><name>txin</name><operator>.</operator><name>nSequence</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><call><name><name>ss</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><template>template <parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>&gt;</parameter_list></template>
<type><name>uint256</name></type> <name>GetOutputsHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>T</name><modifier>&amp;</modifier></type> <name>txTo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CHashWriter</name></type> <name>ss</name><argument_list>(<argument><expr><name>SER_GETHASH</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>txout</name> <range>: <expr><name><name>txTo</name><operator>.</operator><name>vout</name></name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><name>ss</name> <operator>&lt;&lt;</operator> <name>txout</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><call><name><name>ss</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

}</block></namespace> <comment type="line">// namespace</comment>

<constructor><template>template <parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>&gt;</parameter_list></template>
<name><name>PrecomputedTransactionData</name><operator>::</operator><name>PrecomputedTransactionData</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>T</name><modifier>&amp;</modifier></type> <name>txTo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">// Cache is calculated only for transactions with witness</comment>
    <if_stmt><if>if <condition>(<expr><call><name><name>txTo</name><operator>.</operator><name>HasWitness</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>hashPrevouts</name> <operator>=</operator> <call><name>GetPrevoutHash</name><argument_list>(<argument><expr><name>txTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>hashSequence</name> <operator>=</operator> <call><name>GetSequenceHash</name><argument_list>(<argument><expr><name>txTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>hashOutputs</name> <operator>=</operator> <call><name>GetOutputsHash</name><argument_list>(<argument><expr><name>txTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ready</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></constructor>

<comment type="line">// explicit instantiation</comment>
<constructor_decl><specifier>template</specifier> <name><name>PrecomputedTransactionData</name><operator>::</operator><name>PrecomputedTransactionData</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CTransaction</name><modifier>&amp;</modifier></type> <name>txTo</name></decl></parameter>)</parameter_list>;</constructor_decl>
<constructor_decl><specifier>template</specifier> <name><name>PrecomputedTransactionData</name><operator>::</operator><name>PrecomputedTransactionData</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CMutableTransaction</name><modifier>&amp;</modifier></type> <name>txTo</name></decl></parameter>)</parameter_list>;</constructor_decl>

<function><template>template <parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>&gt;</parameter_list></template>
<type><name>uint256</name></type> <name>SignatureHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CScript</name><modifier>&amp;</modifier></type> <name>scriptCode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>T</name><modifier>&amp;</modifier></type> <name>txTo</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nIn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nHashType</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CAmount</name><modifier>&amp;</modifier></type> <name>amount</name></decl></parameter>, <parameter><decl><type><name>SigVersion</name></type> <name>sigversion</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PrecomputedTransactionData</name><modifier>*</modifier></type> <name>cache</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nIn</name> <operator>&lt;</operator> <call><name><name>txTo</name><operator>.</operator><name>vin</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>sigversion</name> <operator>==</operator> <name><name>SigVersion</name><operator>::</operator><name>WITNESS_V0</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>uint256</name></type> <name>hashPrevouts</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint256</name></type> <name>hashSequence</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint256</name></type> <name>hashOutputs</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>cacheready</name> <init>= <expr><name>cache</name> <operator>&amp;&amp;</operator> <name><name>cache</name><operator>-&gt;</operator><name>ready</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>nHashType</name> <operator>&amp;</operator> <name>SIGHASH_ANYONECANPAY</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>hashPrevouts</name> <operator>=</operator> <ternary><condition><expr><name>cacheready</name></expr> ?</condition><then> <expr><name><name>cache</name><operator>-&gt;</operator><name>hashPrevouts</name></name></expr> </then><else>: <expr><call><name>GetPrevoutHash</name><argument_list>(<argument><expr><name>txTo</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>nHashType</name> <operator>&amp;</operator> <name>SIGHASH_ANYONECANPAY</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>nHashType</name> <operator>&amp;</operator> <literal type="number">0x1f</literal><operator>)</operator> <operator>!=</operator> <name>SIGHASH_SINGLE</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>nHashType</name> <operator>&amp;</operator> <literal type="number">0x1f</literal><operator>)</operator> <operator>!=</operator> <name>SIGHASH_NONE</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>hashSequence</name> <operator>=</operator> <ternary><condition><expr><name>cacheready</name></expr> ?</condition><then> <expr><name><name>cache</name><operator>-&gt;</operator><name>hashSequence</name></name></expr> </then><else>: <expr><call><name>GetSequenceHash</name><argument_list>(<argument><expr><name>txTo</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>


        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>nHashType</name> <operator>&amp;</operator> <literal type="number">0x1f</literal><operator>)</operator> <operator>!=</operator> <name>SIGHASH_SINGLE</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>nHashType</name> <operator>&amp;</operator> <literal type="number">0x1f</literal><operator>)</operator> <operator>!=</operator> <name>SIGHASH_NONE</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>hashOutputs</name> <operator>=</operator> <ternary><condition><expr><name>cacheready</name></expr> ?</condition><then> <expr><name><name>cache</name><operator>-&gt;</operator><name>hashOutputs</name></name></expr> </then><else>: <expr><call><name>GetOutputsHash</name><argument_list>(<argument><expr><name>txTo</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>nHashType</name> <operator>&amp;</operator> <literal type="number">0x1f</literal><operator>)</operator> <operator>==</operator> <name>SIGHASH_SINGLE</name> <operator>&amp;&amp;</operator> <name>nIn</name> <operator>&lt;</operator> <call><name><name>txTo</name><operator>.</operator><name>vout</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>CHashWriter</name></type> <name>ss</name><argument_list>(<argument><expr><name>SER_GETHASH</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
            <expr_stmt><expr><name>ss</name> <operator>&lt;&lt;</operator> <name><name>txTo</name><operator>.</operator><name>vout</name><index>[<expr><name>nIn</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>hashOutputs</name> <operator>=</operator> <call><name><name>ss</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>CHashWriter</name></type> <name>ss</name><argument_list>(<argument><expr><name>SER_GETHASH</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
        <comment type="line">// Version</comment>
        <expr_stmt><expr><name>ss</name> <operator>&lt;&lt;</operator> <name><name>txTo</name><operator>.</operator><name>nVersion</name></name></expr>;</expr_stmt>
        <comment type="line">// Input prevouts/nSequence (none/all, depending on flags)</comment>
        <expr_stmt><expr><name>ss</name> <operator>&lt;&lt;</operator> <name>hashPrevouts</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ss</name> <operator>&lt;&lt;</operator> <name>hashSequence</name></expr>;</expr_stmt>
        <comment type="line">// The input being signed (replacing the scriptSig with scriptCode + amount)</comment>
        <comment type="line">// The prevout may already be contained in hashPrevout, and the nSequence</comment>
        <comment type="line">// may already be contain in hashSequence.</comment>
        <expr_stmt><expr><name>ss</name> <operator>&lt;&lt;</operator> <name><name>txTo</name><operator>.</operator><name>vin</name><index>[<expr><name>nIn</name></expr>]</index></name><operator>.</operator><name>prevout</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ss</name> <operator>&lt;&lt;</operator> <name>scriptCode</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ss</name> <operator>&lt;&lt;</operator> <name>amount</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ss</name> <operator>&lt;&lt;</operator> <name><name>txTo</name><operator>.</operator><name>vin</name><index>[<expr><name>nIn</name></expr>]</index></name><operator>.</operator><name>nSequence</name></expr>;</expr_stmt>
        <comment type="line">// Outputs (none/one/all, depending on flags)</comment>
        <expr_stmt><expr><name>ss</name> <operator>&lt;&lt;</operator> <name>hashOutputs</name></expr>;</expr_stmt>
        <comment type="line">// Locktime</comment>
        <expr_stmt><expr><name>ss</name> <operator>&lt;&lt;</operator> <name><name>txTo</name><operator>.</operator><name>nLockTime</name></name></expr>;</expr_stmt>
        <comment type="line">// Sighash type</comment>
        <expr_stmt><expr><name>ss</name> <operator>&lt;&lt;</operator> <name>nHashType</name></expr>;</expr_stmt>

        <return>return <expr><call><name><name>ss</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint256</name></type> <name>one</name><argument_list>(<argument><expr><call><name>uint256S</name><argument_list>(<argument><expr><literal type="string">"0000000000000000000000000000000000000000000000000000000000000001"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

    <comment type="line">// Check for invalid use of SIGHASH_SINGLE</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>nHashType</name> <operator>&amp;</operator> <literal type="number">0x1f</literal><operator>)</operator> <operator>==</operator> <name>SIGHASH_SINGLE</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>nIn</name> <operator>&gt;=</operator> <call><name><name>txTo</name><operator>.</operator><name>vout</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="line">//  nOut out of range</comment>
            <return>return <expr><name>one</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Wrapper to serialize only the necessary parts of the transaction being signed</comment>
    <decl_stmt><decl><type><name><name>CTransactionSignatureSerializer</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>txTmp</name><argument_list>(<argument><expr><name>txTo</name></expr></argument>, <argument><expr><name>scriptCode</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>, <argument><expr><name>nHashType</name></expr></argument>)</argument_list></decl>;</decl_stmt>

    <comment type="line">// Serialize and hash</comment>
    <decl_stmt><decl><type><name>CHashWriter</name></type> <name>ss</name><argument_list>(<argument><expr><name>SER_GETHASH</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><name>ss</name> <operator>&lt;&lt;</operator> <name>txTmp</name> <operator>&lt;&lt;</operator> <name>nHashType</name></expr>;</expr_stmt>
    <return>return <expr><call><name><name>ss</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><template>template <parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>&gt;</parameter_list></template>
<type><name>bool</name></type> <name><name><name>GenericTransactionSignatureChecker</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>VerifySignature</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>vchSig</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CPubKey</name><modifier>&amp;</modifier></type> <name>pubkey</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint256</name><modifier>&amp;</modifier></type> <name>sighash</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <return>return <expr><call><name><name>pubkey</name><operator>.</operator><name>Verify</name></name><argument_list>(<argument><expr><name>sighash</name></expr></argument>, <argument><expr><name>vchSig</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><template>template <parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>&gt;</parameter_list></template>
<type><name>bool</name></type> <name><name><name>GenericTransactionSignatureChecker</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>CheckSig</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>vchSigIn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>vchPubKey</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CScript</name><modifier>&amp;</modifier></type> <name>scriptCode</name></decl></parameter>, <parameter><decl><type><name>SigVersion</name></type> <name>sigversion</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <decl_stmt><decl><type><name>CPubKey</name></type> <name>pubkey</name><argument_list>(<argument><expr><name>vchPubKey</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pubkey</name><operator>.</operator><name>IsValid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// Hash type is one byte tacked on to the end of the signature</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>vchSig</name><argument_list>(<argument><expr><name>vchSigIn</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>vchSig</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nHashType</name> <init>= <expr><call><name><name>vchSig</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>vchSig</name><operator>.</operator><name>pop_back</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>uint256</name></type> <name>sighash</name> <init>= <expr><call><name>SignatureHash</name><argument_list>(<argument><expr><name>scriptCode</name></expr></argument>, <argument><expr><operator>*</operator><name>txTo</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>, <argument><expr><name>nHashType</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>sigversion</name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>txdata</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VerifySignature</name><argument_list>(<argument><expr><name>vchSig</name></expr></argument>, <argument><expr><name>pubkey</name></expr></argument>, <argument><expr><name>sighash</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<function><template>template <parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>&gt;</parameter_list></template>
<type><name>bool</name></type> <name><name><name>GenericTransactionSignatureChecker</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>CheckLockTime</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CScriptNum</name><modifier>&amp;</modifier></type> <name>nLockTime</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <comment type="line">// There are two kinds of nLockTime: lock-by-blockheight</comment>
    <comment type="line">// and lock-by-blocktime, distinguished by whether</comment>
    <comment type="line">// nLockTime &lt; LOCKTIME_THRESHOLD.</comment>
    <comment type="line">//</comment>
    <comment type="line">// We want to compare apples to apples, so fail the script</comment>
    <comment type="line">// unless the type of nLockTime being tested is the same as</comment>
    <comment type="line">// the nLockTime in the transaction.</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator>
        <operator>(</operator><name><name>txTo</name><operator>-&gt;</operator><name>nLockTime</name></name> <operator>&lt;</operator>  <name>LOCKTIME_THRESHOLD</name> <operator>&amp;&amp;</operator> <name>nLockTime</name> <operator>&lt;</operator>  <name>LOCKTIME_THRESHOLD</name><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name><name>txTo</name><operator>-&gt;</operator><name>nLockTime</name></name> <operator>&gt;=</operator> <name>LOCKTIME_THRESHOLD</name> <operator>&amp;&amp;</operator> <name>nLockTime</name> <operator>&gt;=</operator> <name>LOCKTIME_THRESHOLD</name><operator>)</operator>
    <operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// Now that we know we're comparing apples-to-apples, the</comment>
    <comment type="line">// comparison is a simple numeric one.</comment>
    <if_stmt><if>if <condition>(<expr><name>nLockTime</name> <operator>&gt;</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name><name>txTo</name><operator>-&gt;</operator><name>nLockTime</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// Finally the nLockTime feature can be disabled and thus</comment>
    <comment type="line">// CHECKLOCKTIMEVERIFY bypassed if every txin has been</comment>
    <comment type="line">// finalized by setting nSequence to maxint. The</comment>
    <comment type="line">// transaction would be allowed into the blockchain, making</comment>
    <comment type="line">// the opcode ineffective.</comment>
    <comment type="line">//</comment>
    <comment type="line">// Testing if this vin is not final is sufficient to</comment>
    <comment type="line">// prevent this condition. Alternatively we could test all</comment>
    <comment type="line">// inputs, but testing just this input minimizes the data</comment>
    <comment type="line">// required to prove correct CHECKLOCKTIMEVERIFY execution.</comment>
    <if_stmt><if>if <condition>(<expr><name><name>CTxIn</name><operator>::</operator><name>SEQUENCE_FINAL</name></name> <operator>==</operator> <name><name>txTo</name><operator>-&gt;</operator><name>vin</name><index>[<expr><name>nIn</name></expr>]</index></name><operator>.</operator><name>nSequence</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<function><template>template <parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>&gt;</parameter_list></template>
<type><name>bool</name></type> <name><name><name>GenericTransactionSignatureChecker</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>CheckSequence</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CScriptNum</name><modifier>&amp;</modifier></type> <name>nSequence</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <comment type="line">// Relative lock times are supported by comparing the passed</comment>
    <comment type="line">// in operand to the sequence number of the input.</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>txToSequence</name> <init>= <expr><operator>(</operator><name>int64_t</name><operator>)</operator><name><name>txTo</name><operator>-&gt;</operator><name>vin</name><index>[<expr><name>nIn</name></expr>]</index></name><operator>.</operator><name>nSequence</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// Fail if the transaction's version number is not set high</comment>
    <comment type="line">// enough to trigger BIP 68 rules.</comment>
    <if_stmt><if>if <condition>(<expr><cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>uint32_t</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name><name>txTo</name><operator>-&gt;</operator><name>nVersion</name></name></expr></argument>)</argument_list></cast> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// Sequence numbers with their most significant bit set are not</comment>
    <comment type="line">// consensus constrained. Testing that the transaction's sequence</comment>
    <comment type="line">// number do not have this bit set prevents using this property</comment>
    <comment type="line">// to get around a CHECKSEQUENCEVERIFY check.</comment>
    <if_stmt><if>if <condition>(<expr><name>txToSequence</name> <operator>&amp;</operator> <name><name>CTxIn</name><operator>::</operator><name>SEQUENCE_LOCKTIME_DISABLE_FLAG</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// Mask off any bits that do not have consensus-enforced meaning</comment>
    <comment type="line">// before doing the integer comparisons</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>nLockTimeMask</name> <init>= <expr><name><name>CTxIn</name><operator>::</operator><name>SEQUENCE_LOCKTIME_TYPE_FLAG</name></name> <operator>|</operator> <name><name>CTxIn</name><operator>::</operator><name>SEQUENCE_LOCKTIME_MASK</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>txToSequenceMasked</name> <init>= <expr><name>txToSequence</name> <operator>&amp;</operator> <name>nLockTimeMask</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CScriptNum</name></type> <name>nSequenceMasked</name> <init>= <expr><name>nSequence</name> <operator>&amp;</operator> <name>nLockTimeMask</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// There are two kinds of nSequence: lock-by-blockheight</comment>
    <comment type="line">// and lock-by-blocktime, distinguished by whether</comment>
    <comment type="line">// nSequenceMasked &lt; CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG.</comment>
    <comment type="line">//</comment>
    <comment type="line">// We want to compare apples to apples, so fail the script</comment>
    <comment type="line">// unless the type of nSequenceMasked being tested is the same as</comment>
    <comment type="line">// the nSequenceMasked in the transaction.</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator>
        <operator>(</operator><name>txToSequenceMasked</name> <operator>&lt;</operator>  <name><name>CTxIn</name><operator>::</operator><name>SEQUENCE_LOCKTIME_TYPE_FLAG</name></name> <operator>&amp;&amp;</operator> <name>nSequenceMasked</name> <operator>&lt;</operator>  <name><name>CTxIn</name><operator>::</operator><name>SEQUENCE_LOCKTIME_TYPE_FLAG</name></name><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name>txToSequenceMasked</name> <operator>&gt;=</operator> <name><name>CTxIn</name><operator>::</operator><name>SEQUENCE_LOCKTIME_TYPE_FLAG</name></name> <operator>&amp;&amp;</operator> <name>nSequenceMasked</name> <operator>&gt;=</operator> <name><name>CTxIn</name><operator>::</operator><name>SEQUENCE_LOCKTIME_TYPE_FLAG</name></name><operator>)</operator>
    <operator>)</operator></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Now that we know we're comparing apples-to-apples, the</comment>
    <comment type="line">// comparison is a simple numeric one.</comment>
    <if_stmt><if>if <condition>(<expr><name>nSequenceMasked</name> <operator>&gt;</operator> <name>txToSequenceMasked</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<comment type="line">// explicit instantiation</comment>
<class_decl><specifier>template</specifier> class <name><name>GenericTransactionSignatureChecker</name><argument_list type="generic">&lt;<argument><expr><name>CTransaction</name></expr></argument>&gt;</argument_list></name>;</class_decl>
<class_decl><specifier>template</specifier> class <name><name>GenericTransactionSignatureChecker</name><argument_list type="generic">&lt;<argument><expr><name>CMutableTransaction</name></expr></argument>&gt;</argument_list></name>;</class_decl>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>VerifyWitnessProgram</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CScriptWitness</name><modifier>&amp;</modifier></type> <name>witness</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>witversion</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>program</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BaseSignatureChecker</name><modifier>&amp;</modifier></type> <name>checker</name></decl></parameter>, <parameter><decl><type><name>ScriptError</name><modifier>*</modifier></type> <name>serror</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type> <name>stack</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CScript</name></type> <name>scriptPubKey</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>witversion</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>program</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>WITNESS_V0_SCRIPTHASH_SIZE</name></expr>)</condition> <block>{<block_content>
            <comment type="line">// Version 0 segregated witness program: SHA256(CScript) inside the program, CScript + inputs in witness</comment>
            <if_stmt><if>if <condition>(<expr><call><name><name>witness</name><operator>.</operator><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>scriptPubKey</name> <operator>=</operator> <call><name>CScript</name><argument_list>(<argument><expr><call><name><name>witness</name><operator>.</operator><name>stack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>witness</name><operator>.</operator><name>stack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>stack</name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>witness</name><operator>.</operator><name>stack</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>witness</name><operator>.</operator><name>stack</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>uint256</name></type> <name>hashScriptPubKey</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>CSHA256</name><argument_list>()</argument_list></call><operator>.</operator><call><name>Write</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scriptPubKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name><name>scriptPubKey</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>Finalize</name><argument_list>(<argument><expr><call><name><name>hashScriptPubKey</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><call><name><name>hashScriptPubKey</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>program</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>program</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>WITNESS_V0_KEYHASH_SIZE</name></expr>)</condition> <block>{<block_content>
            <comment type="line">// Special case for pay-to-pubkeyhash; signature + pubkey in witness</comment>
            <if_stmt><if>if <condition>(<expr><call><name><name>witness</name><operator>.</operator><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
                <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH</name></expr></argument>)</argument_list></call></expr>;</return> <comment type="line">// 2 items in witness</comment>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>scriptPubKey</name> <operator>&lt;&lt;</operator> <name>OP_DUP</name> <operator>&lt;&lt;</operator> <name>OP_HASH160</name> <operator>&lt;&lt;</operator> <name>program</name> <operator>&lt;&lt;</operator> <name>OP_EQUALVERIFY</name> <operator>&lt;&lt;</operator> <name>OP_CHECKSIG</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>stack</name> <operator>=</operator> <name><name>witness</name><operator>.</operator><name>stack</name></name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="line">// Higher version witness scripts return true for future softfork compatibility</comment>
        <return>return <expr><call><name>set_success</name><argument_list>(<argument><expr><name>serror</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// Disallow stack item size &gt; MAX_SCRIPT_ELEMENT_SIZE in witness stack</comment>
    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>at</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>MAX_SCRIPT_ELEMENT_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_PUSH_SIZE</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EvalScript</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>scriptPubKey</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>checker</name></expr></argument>, <argument><expr><name><name>SigVersion</name><operator>::</operator><name>WITNESS_V0</name></name></expr></argument>, <argument><expr><name>serror</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Scripts inside witness implicitly require cleanstack behaviour</comment>
    <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_CLEANSTACK</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CastToBool</name><argument_list>(<argument><expr><call><name><name>stack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_EVAL_FALSE</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>VerifyScript</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CScript</name><modifier>&amp;</modifier></type> <name>scriptSig</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CScript</name><modifier>&amp;</modifier></type> <name>scriptPubKey</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CScriptWitness</name><modifier>*</modifier></type> <name>witness</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BaseSignatureChecker</name><modifier>&amp;</modifier></type> <name>checker</name></decl></parameter>, <parameter><decl><type><name>ScriptError</name><modifier>*</modifier></type> <name>serror</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>CScriptWitness</name></type> <name>emptyWitness</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>witness</name> <operator>==</operator> <literal type="null">nullptr</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>witness</name> <operator>=</operator> <operator>&amp;</operator><name>emptyWitness</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>hadWitness</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_UNKNOWN_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SCRIPT_VERIFY_SIGPUSHONLY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>scriptSig</name><operator>.</operator><name>IsPushOnly</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_SIG_PUSHONLY</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// scriptSig and scriptPubKey must be evaluated sequentially on the same stack</comment>
    <comment type="line">// rather than being simply concatenated (see CVE-2010-5141)</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type> <name>stack</name></decl>, <decl><type ref="prev"/><name>stackCopy</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EvalScript</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>scriptSig</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>checker</name></expr></argument>, <argument><expr><name><name>SigVersion</name><operator>::</operator><name>BASE</name></name></expr></argument>, <argument><expr><name>serror</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <comment type="line">// serror is set</comment>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>SCRIPT_VERIFY_P2SH</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>stackCopy</name> <operator>=</operator> <name>stack</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EvalScript</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>scriptPubKey</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>checker</name></expr></argument>, <argument><expr><name><name>SigVersion</name><operator>::</operator><name>BASE</name></name></expr></argument>, <argument><expr><name>serror</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <comment type="line">// serror is set</comment>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_EVAL_FALSE</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>CastToBool</name><argument_list>(<argument><expr><call><name><name>stack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_EVAL_FALSE</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// Bare witness programs</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>witnessversion</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>witnessprogram</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>SCRIPT_VERIFY_WITNESS</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>scriptPubKey</name><operator>.</operator><name>IsWitnessProgram</name></name><argument_list>(<argument><expr><name>witnessversion</name></expr></argument>, <argument><expr><name>witnessprogram</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>hadWitness</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>scriptSig</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <comment type="line">// The scriptSig must be _exactly_ CScript(), otherwise we reintroduce malleability.</comment>
                <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_WITNESS_MALLEATED</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VerifyWitnessProgram</name><argument_list>(<argument><expr><operator>*</operator><name>witness</name></expr></argument>, <argument><expr><name>witnessversion</name></expr></argument>, <argument><expr><name>witnessprogram</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>checker</name></expr></argument>, <argument><expr><name>serror</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <comment type="line">// Bypass the cleanstack check at the end. The actual stack is obviously not clean</comment>
            <comment type="line">// for witness programs.</comment>
            <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Additional validation for spend-to-script-hash transactions:</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SCRIPT_VERIFY_P2SH</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name><name>scriptPubKey</name><operator>.</operator><name>IsPayToScriptHash</name></name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// scriptSig must be literals-only or validation fails</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>scriptSig</name><operator>.</operator><name>IsPushOnly</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_SIG_PUSHONLY</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <comment type="line">// Restore stack.</comment>
        <expr_stmt><expr><call><name>swap</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>stackCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// stack cannot be empty here, because if it was the</comment>
        <comment type="line">// P2SH  HASH &lt;&gt; EQUAL  scriptPubKey would be evaluated with</comment>
        <comment type="line">// an empty stack and the EvalScript above would return false.</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>stack</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><specifier>const</specifier> <name>valtype</name><modifier>&amp;</modifier></type> <name>pubKeySerialized</name> <init>= <expr><call><name><name>stack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CScript</name></type> <name>pubKey2</name><argument_list>(<argument><expr><call><name><name>pubKeySerialized</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pubKeySerialized</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>popstack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EvalScript</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>pubKey2</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>checker</name></expr></argument>, <argument><expr><name><name>SigVersion</name><operator>::</operator><name>BASE</name></name></expr></argument>, <argument><expr><name>serror</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <comment type="line">// serror is set</comment>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_EVAL_FALSE</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CastToBool</name><argument_list>(<argument><expr><call><name><name>stack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_EVAL_FALSE</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <comment type="line">// P2SH witness program</comment>
        <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>SCRIPT_VERIFY_WITNESS</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>pubKey2</name><operator>.</operator><name>IsWitnessProgram</name></name><argument_list>(<argument><expr><name>witnessversion</name></expr></argument>, <argument><expr><name>witnessprogram</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>hadWitness</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>scriptSig</name> <operator>!=</operator> <call><name>CScript</name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <call><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>pubKey2</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pubKey2</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <comment type="line">// The scriptSig must be _exactly_ a single push of the redeemScript. Otherwise we</comment>
                    <comment type="line">// reintroduce malleability.</comment>
                    <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_WITNESS_MALLEATED_P2SH</name></expr></argument>)</argument_list></call></expr>;</return>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VerifyWitnessProgram</name><argument_list>(<argument><expr><operator>*</operator><name>witness</name></expr></argument>, <argument><expr><name>witnessversion</name></expr></argument>, <argument><expr><name>witnessprogram</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>checker</name></expr></argument>, <argument><expr><name>serror</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>
                <comment type="line">// Bypass the cleanstack check at the end. The actual stack is obviously not clean</comment>
                <comment type="line">// for witness programs.</comment>
                <expr_stmt><expr><call><name><name>stack</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// The CLEANSTACK check is only performed after potential P2SH evaluation,</comment>
    <comment type="line">// as the non-P2SH evaluation of a P2SH script will obviously not result in</comment>
    <comment type="line">// a clean stack (the P2SH inputs remain). The same holds for witness evaluation.</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SCRIPT_VERIFY_CLEANSTACK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// Disallow CLEANSTACK without P2SH, as otherwise a switch CLEANSTACK-&gt;P2SH+CLEANSTACK</comment>
        <comment type="line">// would be possible, which is not a softfork (and P2SH should be one).</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SCRIPT_VERIFY_P2SH</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SCRIPT_VERIFY_WITNESS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_CLEANSTACK</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>SCRIPT_VERIFY_WITNESS</name></expr>)</condition> <block>{<block_content>
        <comment type="line">// We can't check for correct unexpected witness data if P2SH was off, so require</comment>
        <comment type="line">// that WITNESS implies P2SH. Otherwise, going from WITNESS-&gt;P2SH+WITNESS would be</comment>
        <comment type="line">// possible, which is not a softfork.</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SCRIPT_VERIFY_P2SH</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>hadWitness</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>witness</name><operator>-&gt;</operator><name>IsNull</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><call><name>set_error</name><argument_list>(<argument><expr><name>serror</name></expr></argument>, <argument><expr><name>SCRIPT_ERR_WITNESS_UNEXPECTED</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><call><name>set_success</name><argument_list>(<argument><expr><name>serror</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name> <specifier>static</specifier></type> <name>WitnessSigOps</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>witversion</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>witprogram</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CScriptWitness</name><modifier>&amp;</modifier></type> <name>witness</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>witversion</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>witprogram</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>WITNESS_V0_KEYHASH_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>witprogram</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>WITNESS_V0_SCRIPTHASH_SIZE</name> <operator>&amp;&amp;</operator> <call><name><name>witness</name><operator>.</operator><name>stack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>CScript</name></type> <name>subscript</name><argument_list>(<argument><expr><call><name><name>witness</name><operator>.</operator><name>stack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>witness</name><operator>.</operator><name>stack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
            <return>return <expr><call><name><name>subscript</name><operator>.</operator><name>GetSigOpCount</name></name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Future flags may be implemented here.</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>CountWitnessSigOps</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CScript</name><modifier>&amp;</modifier></type> <name>scriptSig</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CScript</name><modifier>&amp;</modifier></type> <name>scriptPubKey</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CScriptWitness</name><modifier>*</modifier></type> <name>witness</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>CScriptWitness</name></type> <name>witnessEmpty</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SCRIPT_VERIFY_WITNESS</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SCRIPT_VERIFY_P2SH</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>witnessversion</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>witnessprogram</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>scriptPubKey</name><operator>.</operator><name>IsWitnessProgram</name></name><argument_list>(<argument><expr><name>witnessversion</name></expr></argument>, <argument><expr><name>witnessprogram</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>WitnessSigOps</name><argument_list>(<argument><expr><name>witnessversion</name></expr></argument>, <argument><expr><name>witnessprogram</name></expr></argument>, <argument><expr><ternary><condition><expr><name>witness</name></expr> ?</condition><then> <expr><operator>*</operator><name>witness</name></expr> </then><else>: <expr><name>witnessEmpty</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name><name>scriptPubKey</name><operator>.</operator><name>IsPayToScriptHash</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>scriptSig</name><operator>.</operator><name>IsPushOnly</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name><name>CScript</name><operator>::</operator><name>const_iterator</name></name></type> <name>pc</name> <init>= <expr><call><name><name>scriptSig</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>data</name></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>pc</name> <operator>&lt;</operator> <call><name><name>scriptSig</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>opcodetype</name></type> <name>opcode</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>scriptSig</name><operator>.</operator><name>GetOp</name></name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>opcode</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <decl_stmt><decl><type><name>CScript</name></type> <name>subscript</name><argument_list>(<argument><expr><call><name><name>data</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>data</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>subscript</name><operator>.</operator><name>IsWitnessProgram</name></name><argument_list>(<argument><expr><name>witnessversion</name></expr></argument>, <argument><expr><name>witnessprogram</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><call><name>WitnessSigOps</name><argument_list>(<argument><expr><name>witnessversion</name></expr></argument>, <argument><expr><name>witnessprogram</name></expr></argument>, <argument><expr><ternary><condition><expr><name>witness</name></expr> ?</condition><then> <expr><operator>*</operator><name>witness</name></expr> </then><else>: <expr><name>witnessEmpty</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
