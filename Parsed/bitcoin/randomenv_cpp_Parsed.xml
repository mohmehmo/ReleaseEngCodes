<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C++" filename="/home/mmm/Projects/bitcoin/src/randomenv.cpp"><comment type="line">// Copyright (c) 2009-2010 Satoshi Nakamoto</comment>
<comment type="line">// Copyright (c) 2009-2019 The Bitcoin Core developers</comment>
<comment type="line">// Distributed under the MIT software license, see the accompanying</comment>
<comment type="line">// file COPYING or http://www.opensource.org/licenses/mit-license.php.</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CONFIG_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;config/bitcoin-config.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;randomenv.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;clientversion.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;compat/cpuid.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;crypto/sha512.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;support/cleanse.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/time.h&gt;</cpp:file></cpp:include> <comment type="line">// for GetTime()</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;compat.h&gt;</cpp:file></cpp:include> <comment type="line">// for Windows API</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;algorithm&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;atomic&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;chrono&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;climits&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;thread&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include> <comment type="line">// must go before a number of other headers</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/utsname.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__MACH__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mach/clock.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mach/mach.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mach/mach_time.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_DECL_GETIFADDRS</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ifaddrs.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_SYSCTL</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/sysctl.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_VM_VM_PARAM_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vm/vm_param.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_SYS_RESOURCES_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resources.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_SYS_VMMETER_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/vmmeter.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__linux__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/auxv.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line" format="doxygen">//! Necessary on some platforms</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>environ</name></decl>;</decl_stmt>

<namespace>namespace <block>{

<function><type><name>void</name></type> <name>RandAddSeedPerfmon</name><parameter_list>(<parameter><decl><type><name>CSHA512</name><modifier>&amp;</modifier></type> <name>hasher</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <comment type="line">// Seed with the entire set of perfmon data</comment>

    <comment type="line">// This can take up to 2 seconds, so only do it every 10 minutes</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name><name>std</name><operator>::</operator><name>atomic</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>seconds</name></name></expr></argument>&gt;</argument_list></name></type> <name>last_perfmon</name><argument_list>{<argument><expr><macro><name>std</name></macro><name><operator>::</operator><name>chrono</name><operator>::</operator><name>seconds</name></name><block>{<expr><literal type="number">0</literal></expr>}</block></expr></argument>}</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>last_time</name> <init>= <expr><call><name><name>last_perfmon</name><operator>.</operator><name>load</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>current_time</name> <init>= <expr><call><name><name>GetTime</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>seconds</name></name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>current_time</name> <operator>&lt;</operator> <name>last_time</name> <operator>+</operator> <call><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>minutes</name></name><argument_list>{<argument><expr><literal type="number">10</literal></expr></argument>}</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>last_perfmon</name> <operator>=</operator> <name>current_time</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></type> <name>vData</name><argument_list>(<argument><expr><literal type="number">250000</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>nSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>nMaxSize</name> <init>= <expr><literal type="number">10000000</literal></expr></init></decl>;</decl_stmt> <comment type="line">// Bail out at more than 10MB of performance data</comment>
    <while>while <condition>(<expr><literal type="boolean">true</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>nSize</name> <operator>=</operator> <call><name><name>vData</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>RegQueryValueExA</name><argument_list>(<argument><expr><name>HKEY_PERFORMANCE_DATA</name></expr></argument>, <argument><expr><literal type="string">"Global"</literal></expr></argument>, <argument><expr><literal type="null">nullptr</literal></expr></argument>, <argument><expr><literal type="null">nullptr</literal></expr></argument>, <argument><expr><call><name><name>vData</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>nSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>ERROR_MORE_DATA</name> <operator>||</operator> <call><name><name>vData</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>nMaxSize</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name><name>vData</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>max</name></name><argument_list>(<argument><expr><operator>(</operator><call><name><name>vData</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>*</operator> <literal type="number">3</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>nMaxSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Grow size of buffer exponentially</comment>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>RegCloseKey</name><argument_list>(<argument><expr><name>HKEY_PERFORMANCE_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>ERROR_SUCCESS</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>hasher</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><call><name><name>vData</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memory_cleanse</name><argument_list>(<argument><expr><call><name><name>vData</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="line">// Performance data is only a best-effort attempt at improving the</comment>
        <comment type="line">// situation when the OS randomness (and other sources) aren't</comment>
        <comment type="line">// adequate. As a result, failure to read it is isn't considered critical,</comment>
        <comment type="line">// so we don't call RandFailure().</comment>
        <comment type="line">// TODO: Add logging when the logger is made functional before global</comment>
        <comment type="line">// constructors have been invoked.</comment>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** Helper to easily feed data into a CSHA512.
 *
 * Note that this does not serialize the passed object (like stream.h's &lt;&lt; operators do).
 * Its raw memory representation is used directly.
 */</comment>
<function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>&gt;</parameter_list></template>
<type><name>CSHA512</name><modifier>&amp;</modifier></type> <name>operator<name>&lt;&lt;</name></name><parameter_list>(<parameter><decl><type><name>CSHA512</name><modifier>&amp;</modifier></type> <name>hasher</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>T</name><modifier>&amp;</modifier></type> <name>data</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <assert type="static">static_assert<argument_list>(<argument><expr><operator>!</operator><name><name>std</name><operator>::</operator><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name><typename>typename</typename> <name>std</name><operator>::</operator><name>decay</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list><operator>::</operator><name>type</name></name></expr></argument>, <argument><expr><name>char</name><operator>*</operator></expr></argument>&gt;</argument_list><operator>::</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"Calling operator&lt;&lt;(CSHA512, char*) is probably not what you want"</literal></expr></argument>)</argument_list>;</assert>
    <assert type="static">static_assert<argument_list>(<argument><expr><operator>!</operator><name><name>std</name><operator>::</operator><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name><typename>typename</typename> <name>std</name><operator>::</operator><name>decay</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list><operator>::</operator><name>type</name></name></expr></argument>, <argument><expr><name>unsigned</name> <name>char</name><operator>*</operator></expr></argument>&gt;</argument_list><operator>::</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"Calling operator&lt;&lt;(CSHA512, unsigned char*) is probably not what you want"</literal></expr></argument>)</argument_list>;</assert>
    <assert type="static">static_assert<argument_list>(<argument><expr><operator>!</operator><name><name>std</name><operator>::</operator><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name><typename>typename</typename> <name>std</name><operator>::</operator><name>decay</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list><operator>::</operator><name>type</name></name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>&gt;</argument_list><operator>::</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"Calling operator&lt;&lt;(CSHA512, const char*) is probably not what you want"</literal></expr></argument>)</argument_list>;</assert>
    <assert type="static">static_assert<argument_list>(<argument><expr><operator>!</operator><name><name>std</name><operator>::</operator><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name><typename>typename</typename> <name>std</name><operator>::</operator><name>decay</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list><operator>::</operator><name>type</name></name></expr></argument>, <argument><expr><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator></expr></argument>&gt;</argument_list><operator>::</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"Calling operator&lt;&lt;(CSHA512, const unsigned char*) is probably not what you want"</literal></expr></argument>)</argument_list>;</assert>
    <expr_stmt><expr><call><name><name>hasher</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>hasher</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<function><type><name>void</name></type> <name>AddSockaddr</name><parameter_list>(<parameter><decl><type><name>CSHA512</name><modifier>&amp;</modifier></type> <name>hasher</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>sockaddr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <literal type="null">nullptr</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <switch>switch <condition>(<expr><name><name>addr</name><operator>-&gt;</operator><name>sa_family</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>AF_INET</name></expr>:</case>
        <expr_stmt><expr><call><name><name>hasher</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>addr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sockaddr_in</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AF_INET6</name></expr>:</case>
        <expr_stmt><expr><call><name><name>hasher</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>addr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sockaddr_in6</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <default>default:</default>
        <expr_stmt><expr><call><name><name>hasher</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>addr</name><operator>-&gt;</operator><name>sa_family</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>addr</name><operator>-&gt;</operator><name>sa_family</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>AddFile</name><parameter_list>(<parameter><decl><type><name>CSHA512</name><modifier>&amp;</modifier></type> <name>hasher</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>sb</name> <init>= <expr><block>{}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>f</name> <init>= <expr><call><name>open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>f</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>fbuf</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>hasher</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>f</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>hasher</name> <operator>&lt;&lt;</operator> <name>sb</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <do>do <block>{<block_content>
            <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>fbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>hasher</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><name>fbuf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>total</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
            <comment type="block">/* not bothering with EINTR handling. */</comment>
        </block_content>}</block> while <condition>(<expr><name>n</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>fbuf</name></expr></argument>)</argument_list></sizeof> <operator>&amp;&amp;</operator> <name>total</name> <operator>&lt;</operator> <literal type="number">1048576</literal></expr>)</condition>;</do> <comment type="line">// Read only the first 1 Mbyte</comment>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>AddPath</name><parameter_list>(<parameter><decl><type><name>CSHA512</name><modifier>&amp;</modifier></type> <name>hasher</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>sb</name> <init>= <expr><block>{}</block></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>hasher</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>path</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>hasher</name> <operator>&lt;&lt;</operator> <name>sb</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_SYSCTL</name></expr></cpp:if>
<function><template>template<parameter_list>&lt;<parameter><type><name>int</name><modifier>...</modifier></type> <name>S</name></parameter>&gt;</parameter_list></template>
<type><name>void</name></type> <name>AddSysctl</name><parameter_list>(<parameter><decl><type><name>CSHA512</name><modifier>&amp;</modifier></type> <name>hasher</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name><name>CTL</name><index>[<expr><sizeof type="pack">sizeof...<argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{<expr><name>S</name><operator>...</operator></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buffer</name><index>[<expr><literal type="number">65536</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>siz</name> <init>= <expr><literal type="number">65536</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>sysctl</name><argument_list>(<argument><expr><name>CTL</name></expr></argument>, <argument><expr><sizeof type="pack">sizeof...<argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>siz</name></expr></argument>, <argument><expr><literal type="null">nullptr</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ENOMEM</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>hasher</name> <operator>&lt;&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CTL</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>hasher</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>CTL</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CTL</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>siz</name> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>siz</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>hasher</name> <operator>&lt;&lt;</operator> <name>siz</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>hasher</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>siz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETCPUID</name></cpp:ifdef>
<function><type><name>void</name> <specifier>inline</specifier></type> <name>AddCPUID</name><parameter_list>(<parameter><decl><type><name>CSHA512</name><modifier>&amp;</modifier></type> <name>hasher</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>leaf</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>subleaf</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name><modifier>&amp;</modifier></type> <name>ax</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name><modifier>&amp;</modifier></type> <name>bx</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name><modifier>&amp;</modifier></type> <name>cx</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name><modifier>&amp;</modifier></type> <name>dx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>GetCPUID</name><argument_list>(<argument><expr><name>leaf</name></expr></argument>, <argument><expr><name>subleaf</name></expr></argument>, <argument><expr><name>ax</name></expr></argument>, <argument><expr><name>bx</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>dx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hasher</name> <operator>&lt;&lt;</operator> <name>leaf</name> <operator>&lt;&lt;</operator> <name>subleaf</name> <operator>&lt;&lt;</operator> <name>ax</name> <operator>&lt;&lt;</operator> <name>bx</name> <operator>&lt;&lt;</operator> <name>cx</name> <operator>&lt;&lt;</operator> <name>dx</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>AddAllCPUID</name><parameter_list>(<parameter><decl><type><name>CSHA512</name><modifier>&amp;</modifier></type> <name>hasher</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>ax</name></decl>, <decl><type ref="prev"/><name>bx</name></decl>, <decl><type ref="prev"/><name>cx</name></decl>, <decl><type ref="prev"/><name>dx</name></decl>;</decl_stmt>
    <comment type="line">// Iterate over all standard leaves</comment>
    <expr_stmt><expr><call><name>AddCPUID</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ax</name></expr></argument>, <argument><expr><name>bx</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>dx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Returns max leaf in ax</comment>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>max</name> <init>= <expr><name>ax</name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>uint32_t</name></type> <name>leaf</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>leaf</name> <operator>&lt;=</operator> <name>max</name> <operator>&amp;&amp;</operator> <name>leaf</name> <operator>&lt;=</operator> <literal type="number">0xFF</literal></expr>;</condition> <incr><expr><operator>++</operator><name>leaf</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>maxsub</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>uint32_t</name></type> <name>subleaf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>subleaf</name> <operator>&lt;=</operator> <literal type="number">0xFF</literal></expr>;</condition> <incr><expr><operator>++</operator><name>subleaf</name></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>AddCPUID</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>, <argument><expr><name>leaf</name></expr></argument>, <argument><expr><name>subleaf</name></expr></argument>, <argument><expr><name>ax</name></expr></argument>, <argument><expr><name>bx</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>dx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// Iterate subleafs for leaf values 4, 7, 11, 13</comment>
            <if_stmt><if>if <condition>(<expr><name>leaf</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ax</name> <operator>&amp;</operator> <literal type="number">0x1f</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>leaf</name> <operator>==</operator> <literal type="number">7</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>subleaf</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>maxsub</name> <operator>=</operator> <name>ax</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>subleaf</name> <operator>==</operator> <name>maxsub</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>leaf</name> <operator>==</operator> <literal type="number">11</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>cx</name> <operator>&amp;</operator> <literal type="number">0xff00</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>leaf</name> <operator>==</operator> <literal type="number">13</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>ax</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bx</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cx</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>dx</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <comment type="line">// For any other leaf, stop after subleaf 0.</comment>
                <break>break;</break>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>
    <comment type="line">// Iterate over all extended leaves</comment>
    <expr_stmt><expr><call><name>AddCPUID</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>, <argument><expr><literal type="number">0x80000000</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ax</name></expr></argument>, <argument><expr><name>bx</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>dx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Returns max extended leaf in ax</comment>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>ext_max</name> <init>= <expr><name>ax</name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>uint32_t</name></type> <name>leaf</name> <init>= <expr><literal type="number">0x80000001</literal></expr></init></decl>;</init> <condition><expr><name>leaf</name> <operator>&lt;=</operator> <name>ext_max</name> <operator>&amp;&amp;</operator> <name>leaf</name> <operator>&lt;=</operator> <literal type="number">0x800000FF</literal></expr>;</condition> <incr><expr><operator>++</operator><name>leaf</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>AddCPUID</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>, <argument><expr><name>leaf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ax</name></expr></argument>, <argument><expr><name>bx</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>dx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></namespace> <comment type="line">// namespace</comment>

<function><type><name>void</name></type> <name>RandAddDynamicEnv</name><parameter_list>(<parameter><decl><type><name>CSHA512</name><modifier>&amp;</modifier></type> <name>hasher</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>RandAddSeedPerfmon</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Various clocks</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <decl_stmt><decl><type><name>FILETIME</name></type> <name>ftime</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>GetSystemTimeAsFileTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ftime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hasher</name> <operator>&lt;&lt;</operator> <name>ftime</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>__MACH__</name></cpp:ifndef>
    <comment type="line">// On non-MacOS systems, use various clock_gettime() calls.</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>ts</name> <init>= <expr><block>{}</block></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>CLOCK_MONOTONIC</name></cpp:ifdef>
    <expr_stmt><expr><call><name>clock_gettime</name><argument_list>(<argument><expr><name>CLOCK_MONOTONIC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hasher</name> <operator>&lt;&lt;</operator> <name>ts</name></expr>;</expr_stmt>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>CLOCK_REALTIME</name></cpp:ifdef>
    <expr_stmt><expr><call><name>clock_gettime</name><argument_list>(<argument><expr><name>CLOCK_REALTIME</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hasher</name> <operator>&lt;&lt;</operator> <name>ts</name></expr>;</expr_stmt>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>CLOCK_BOOTTIME</name></cpp:ifdef>
    <expr_stmt><expr><call><name>clock_gettime</name><argument_list>(<argument><expr><name>CLOCK_BOOTTIME</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hasher</name> <operator>&lt;&lt;</operator> <name>ts</name></expr>;</expr_stmt>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
    <comment type="line">// On MacOS use mach_absolute_time (number of CPU ticks since boot) as a replacement for CLOCK_MONOTONIC,</comment>
    <comment type="line">// and clock_get_time for CALENDAR_CLOCK as a replacement for CLOCK_REALTIME.</comment>
    <expr_stmt><expr><name>hasher</name> <operator>&lt;&lt;</operator> <call><name>mach_absolute_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// From https://gist.github.com/jbenet/1087739</comment>
    <decl_stmt><decl><type><name>clock_serv_t</name></type> <name>cclock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mach_timespec_t</name></type> <name>mts</name> <init>= <expr><block>{}</block></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>host_get_clock_service</name><argument_list>(<argument><expr><call><name>mach_host_self</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>CALENDAR_CLOCK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cclock</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>KERN_SUCCESS</name> <operator>&amp;&amp;</operator> <call><name>clock_get_time</name><argument_list>(<argument><expr><name>cclock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mts</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>KERN_SUCCESS</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>hasher</name> <operator>&lt;&lt;</operator> <name>mts</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>mach_port_deallocate</name><argument_list>(<argument><expr><call><name>mach_task_self</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>cclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="line">// gettimeofday is available on all UNIX systems, but only has microsecond precision.</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name> <init>= <expr><block>{}</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hasher</name> <operator>&lt;&lt;</operator> <name>tv</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="line">// Probably redundant, but also use all the clocks C++11 provides:</comment>
    <expr_stmt><expr><name>hasher</name> <operator>&lt;&lt;</operator> <call><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>system_clock</name><operator>::</operator><name>now</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>time_since_epoch</name><argument_list>()</argument_list></call><operator>.</operator><call><name>count</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hasher</name> <operator>&lt;&lt;</operator> <call><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>steady_clock</name><operator>::</operator><name>now</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>time_since_epoch</name><argument_list>()</argument_list></call><operator>.</operator><call><name>count</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hasher</name> <operator>&lt;&lt;</operator> <call><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>high_resolution_clock</name><operator>::</operator><name>now</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>time_since_epoch</name><argument_list>()</argument_list></call><operator>.</operator><call><name>count</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
    <comment type="line">// Current resource usage.</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>rusage</name></name></type> <name>usage</name> <init>= <expr><block>{}</block></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>getrusage</name><argument_list>(<argument><expr><name>RUSAGE_SELF</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>usage</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>hasher</name> <operator>&lt;&lt;</operator> <name>usage</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__linux__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>AddFile</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>, <argument><expr><literal type="string">"/proc/diskstats"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AddFile</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>, <argument><expr><literal type="string">"/proc/vmstat"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AddFile</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>, <argument><expr><literal type="string">"/proc/schedstat"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AddFile</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>, <argument><expr><literal type="string">"/proc/zoneinfo"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AddFile</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>, <argument><expr><literal type="string">"/proc/meminfo"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AddFile</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>, <argument><expr><literal type="string">"/proc/softirqs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AddFile</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>, <argument><expr><literal type="string">"/proc/stat"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AddFile</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>, <argument><expr><literal type="string">"/proc/self/schedstat"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AddFile</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>, <argument><expr><literal type="string">"/proc/self/status"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_SYSCTL</name></expr></cpp:if>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>CTL_KERN</name></cpp:ifdef>
<cpp:if>#    <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>KERN_PROC</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>KERN_PROC_ALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name><name>AddSysctl</name><argument_list type="generic">&lt;<argument><expr><name>CTL_KERN</name></expr></argument>, <argument><expr><name>KERN_PROC</name></expr></argument>, <argument><expr><name>KERN_PROC_ALL</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>CTL_HW</name></cpp:ifdef>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>HW_DISKSTATS</name></cpp:ifdef>
    <expr_stmt><expr><call><name><name>AddSysctl</name><argument_list type="generic">&lt;<argument><expr><name>CTL_HW</name></expr></argument>, <argument><expr><name>HW_DISKSTATS</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>CTL_VM</name></cpp:ifdef>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>VM_LOADAVG</name></cpp:ifdef>
    <expr_stmt><expr><call><name><name>AddSysctl</name><argument_list type="generic">&lt;<argument><expr><name>CTL_VM</name></expr></argument>, <argument><expr><name>VM_LOADAVG</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>VM_TOTAL</name></cpp:ifdef>
    <expr_stmt><expr><call><name><name>AddSysctl</name><argument_list type="generic">&lt;<argument><expr><name>CTL_VM</name></expr></argument>, <argument><expr><name>VM_TOTAL</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>VM_METER</name></cpp:ifdef>
    <expr_stmt><expr><call><name><name>AddSysctl</name><argument_list type="generic">&lt;<argument><expr><name>CTL_VM</name></expr></argument>, <argument><expr><name>VM_METER</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">// Stack and heap location</comment>
    <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>addr</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><literal type="number">4097</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>hasher</name> <operator>&lt;&lt;</operator> <operator>&amp;</operator><name>addr</name> <operator>&lt;&lt;</operator> <name>addr</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>RandAddStaticEnv</name><parameter_list>(<parameter><decl><type><name>CSHA512</name><modifier>&amp;</modifier></type> <name>hasher</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">// Some compile-time static properties</comment>
    <expr_stmt><expr><name>hasher</name> <operator>&lt;&lt;</operator> <operator>(</operator><name>CHAR_MIN</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&lt;&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>&lt;&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof> <operator>&lt;&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__GNUC_MINOR__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__GNUC_PATCHLEVEL__</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><name>hasher</name> <operator>&lt;&lt;</operator> <name>__GNUC__</name> <operator>&lt;&lt;</operator> <name>__GNUC_MINOR__</name> <operator>&lt;&lt;</operator> <name>__GNUC_PATCHLEVEL__</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
    <expr_stmt><expr><name>hasher</name> <operator>&lt;&lt;</operator> <name>_MSC_VER</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>hasher</name> <operator>&lt;&lt;</operator> <name>__cplusplus</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_XOPEN_VERSION</name></cpp:ifdef>
    <expr_stmt><expr><name>hasher</name> <operator>&lt;&lt;</operator> <name>_XOPEN_VERSION</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__VERSION__</name></cpp:ifdef>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>COMPILER_VERSION</name> <init>= <expr><name>__VERSION__</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>hasher</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>COMPILER_VERSION</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>COMPILER_VERSION</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">// Bitcoin client version</comment>
    <expr_stmt><expr><name>hasher</name> <operator>&lt;&lt;</operator> <name>CLIENT_VERSION</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__linux__</name></cpp:ifdef>
    <comment type="line">// Information available through getauxval()</comment>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>AT_HWCAP</name></cpp:ifdef>
    <expr_stmt><expr><name>hasher</name> <operator>&lt;&lt;</operator> <call><name>getauxval</name><argument_list>(<argument><expr><name>AT_HWCAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>AT_HWCAP2</name></cpp:ifdef>
    <expr_stmt><expr><name>hasher</name> <operator>&lt;&lt;</operator> <call><name>getauxval</name><argument_list>(<argument><expr><name>AT_HWCAP2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>AT_RANDOM</name></cpp:ifdef>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name><modifier>*</modifier></type> <name>random_aux</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><call><name>getauxval</name><argument_list>(<argument><expr><name>AT_RANDOM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>random_aux</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>hasher</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><name>random_aux</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>AT_PLATFORM</name></cpp:ifdef>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>platform_str</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>getauxval</name><argument_list>(<argument><expr><name>AT_PLATFORM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>platform_str</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>hasher</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>platform_str</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>platform_str</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>AT_EXECFN</name></cpp:ifdef>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>exec_str</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>getauxval</name><argument_list>(<argument><expr><name>AT_EXECFN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>exec_str</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>hasher</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>exec_str</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>exec_str</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// __linux__</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETCPUID</name></cpp:ifdef>
    <expr_stmt><expr><call><name>AddAllCPUID</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">// Memory locations</comment>
    <expr_stmt><expr><name>hasher</name> <operator>&lt;&lt;</operator> <operator>&amp;</operator><name>hasher</name> <operator>&lt;&lt;</operator> <operator>&amp;</operator><name>RandAddStaticEnv</name> <operator>&lt;&lt;</operator> <operator>&amp;</operator><name>malloc</name> <operator>&lt;&lt;</operator> <operator>&amp;</operator><name>errno</name> <operator>&lt;&lt;</operator> <operator>&amp;</operator><name>environ</name></expr>;</expr_stmt>

    <comment type="line">// Hostname</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>hname</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>gethostname</name><argument_list>(<argument><expr><name>hname</name></expr></argument>, <argument><expr><literal type="number">256</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>hasher</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>hname</name></expr></argument>, <argument><expr><call><name>strnlen</name><argument_list>(<argument><expr><name>hname</name></expr></argument>, <argument><expr><literal type="number">256</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_DECL_GETIFADDRS</name></expr></cpp:if>
    <comment type="line">// Network interfaces</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>ifaddrs</name></name> <modifier>*</modifier></type><name>ifad</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>getifaddrs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ifad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>ifaddrs</name></name> <modifier>*</modifier></type><name>ifit</name> <init>= <expr><name>ifad</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>ifit</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>hasher</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ifit</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ifit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>hasher</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>ifit</name><operator>-&gt;</operator><name>ifa_name</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>ifit</name><operator>-&gt;</operator><name>ifa_name</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>hasher</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>ifit</name><operator>-&gt;</operator><name>ifa_flags</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ifit</name><operator>-&gt;</operator><name>ifa_flags</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AddSockaddr</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>, <argument><expr><name><name>ifit</name><operator>-&gt;</operator><name>ifa_addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AddSockaddr</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>, <argument><expr><name><name>ifit</name><operator>-&gt;</operator><name>ifa_netmask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AddSockaddr</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>, <argument><expr><name><name>ifit</name><operator>-&gt;</operator><name>ifa_dstaddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ifit</name> <operator>=</operator> <name><name>ifit</name><operator>-&gt;</operator><name>ifa_next</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>freeifaddrs</name><argument_list>(<argument><expr><name>ifad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
    <comment type="line">// UNIX kernel information</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>utsname</name></name></type> <name>name</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>uname</name><argument_list>(<argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>hasher</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>name</name><operator>.</operator><name>sysname</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>name</name><operator>.</operator><name>sysname</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>hasher</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>name</name><operator>.</operator><name>nodename</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>name</name><operator>.</operator><name>nodename</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>hasher</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>name</name><operator>.</operator><name>release</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>name</name><operator>.</operator><name>release</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>hasher</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>name</name><operator>.</operator><name>version</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>name</name><operator>.</operator><name>version</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>hasher</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>name</name><operator>.</operator><name>machine</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>name</name><operator>.</operator><name>machine</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Path and filesystem provided data */</comment>
    <expr_stmt><expr><call><name>AddPath</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AddPath</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AddPath</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>, <argument><expr><literal type="string">"/tmp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AddPath</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>, <argument><expr><literal type="string">"/home"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AddPath</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>, <argument><expr><literal type="string">"/proc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__linux__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>AddFile</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>, <argument><expr><literal type="string">"/proc/cmdline"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AddFile</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>, <argument><expr><literal type="string">"/proc/cpuinfo"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AddFile</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>, <argument><expr><literal type="string">"/proc/version"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>AddFile</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>, <argument><expr><literal type="string">"/etc/passwd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AddFile</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>, <argument><expr><literal type="string">"/etc/group"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AddFile</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>, <argument><expr><literal type="string">"/etc/hosts"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AddFile</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>, <argument><expr><literal type="string">"/etc/resolv.conf"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AddFile</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>, <argument><expr><literal type="string">"/etc/timezone"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AddFile</name><argument_list>(<argument><expr><name>hasher</name></expr></argument>, <argument><expr><literal type="string">"/etc/localtime"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">// For MacOS/BSDs, gather data through sysctl instead of /proc. Not all of these</comment>
    <comment type="line">// will exist on every system.</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_SYSCTL</name></expr></cpp:if>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>CTL_HW</name></cpp:ifdef>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>HW_MACHINE</name></cpp:ifdef>
    <expr_stmt><expr><call><name><name>AddSysctl</name><argument_list type="generic">&lt;<argument><expr><name>CTL_HW</name></expr></argument>, <argument><expr><name>HW_MACHINE</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>HW_MODEL</name></cpp:ifdef>
    <expr_stmt><expr><call><name><name>AddSysctl</name><argument_list type="generic">&lt;<argument><expr><name>CTL_HW</name></expr></argument>, <argument><expr><name>HW_MODEL</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>HW_NCPU</name></cpp:ifdef>
    <expr_stmt><expr><call><name><name>AddSysctl</name><argument_list type="generic">&lt;<argument><expr><name>CTL_HW</name></expr></argument>, <argument><expr><name>HW_NCPU</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>HW_PHYSMEM</name></cpp:ifdef>
    <expr_stmt><expr><call><name><name>AddSysctl</name><argument_list type="generic">&lt;<argument><expr><name>CTL_HW</name></expr></argument>, <argument><expr><name>HW_PHYSMEM</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>HW_USERMEM</name></cpp:ifdef>
    <expr_stmt><expr><call><name><name>AddSysctl</name><argument_list type="generic">&lt;<argument><expr><name>CTL_HW</name></expr></argument>, <argument><expr><name>HW_USERMEM</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>HW_MACHINE_ARCH</name></cpp:ifdef>
    <expr_stmt><expr><call><name><name>AddSysctl</name><argument_list type="generic">&lt;<argument><expr><name>CTL_HW</name></expr></argument>, <argument><expr><name>HW_MACHINE_ARCH</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>HW_REALMEM</name></cpp:ifdef>
    <expr_stmt><expr><call><name><name>AddSysctl</name><argument_list type="generic">&lt;<argument><expr><name>CTL_HW</name></expr></argument>, <argument><expr><name>HW_REALMEM</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>HW_CPU_FREQ</name></cpp:ifdef>
    <expr_stmt><expr><call><name><name>AddSysctl</name><argument_list type="generic">&lt;<argument><expr><name>CTL_HW</name></expr></argument>, <argument><expr><name>HW_CPU_FREQ</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>HW_BUS_FREQ</name></cpp:ifdef>
    <expr_stmt><expr><call><name><name>AddSysctl</name><argument_list type="generic">&lt;<argument><expr><name>CTL_HW</name></expr></argument>, <argument><expr><name>HW_BUS_FREQ</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>HW_CACHELINE</name></cpp:ifdef>
    <expr_stmt><expr><call><name><name>AddSysctl</name><argument_list type="generic">&lt;<argument><expr><name>CTL_HW</name></expr></argument>, <argument><expr><name>HW_CACHELINE</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>CTL_KERN</name></cpp:ifdef>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>KERN_BOOTFILE</name></cpp:ifdef>
     <expr_stmt><expr><call><name><name>AddSysctl</name><argument_list type="generic">&lt;<argument><expr><name>CTL_KERN</name></expr></argument>, <argument><expr><name>KERN_BOOTFILE</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>KERN_BOOTTIME</name></cpp:ifdef>
     <expr_stmt><expr><call><name><name>AddSysctl</name><argument_list type="generic">&lt;<argument><expr><name>CTL_KERN</name></expr></argument>, <argument><expr><name>KERN_BOOTTIME</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>KERN_CLOCKRATE</name></cpp:ifdef>
     <expr_stmt><expr><call><name><name>AddSysctl</name><argument_list type="generic">&lt;<argument><expr><name>CTL_KERN</name></expr></argument>, <argument><expr><name>KERN_CLOCKRATE</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>KERN_HOSTID</name></cpp:ifdef>
     <expr_stmt><expr><call><name><name>AddSysctl</name><argument_list type="generic">&lt;<argument><expr><name>CTL_KERN</name></expr></argument>, <argument><expr><name>KERN_HOSTID</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>KERN_HOSTUUID</name></cpp:ifdef>
     <expr_stmt><expr><call><name><name>AddSysctl</name><argument_list type="generic">&lt;<argument><expr><name>CTL_KERN</name></expr></argument>, <argument><expr><name>KERN_HOSTUUID</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>KERN_HOSTNAME</name></cpp:ifdef>
     <expr_stmt><expr><call><name><name>AddSysctl</name><argument_list type="generic">&lt;<argument><expr><name>CTL_KERN</name></expr></argument>, <argument><expr><name>KERN_HOSTNAME</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>KERN_OSRELDATE</name></cpp:ifdef>
     <expr_stmt><expr><call><name><name>AddSysctl</name><argument_list type="generic">&lt;<argument><expr><name>CTL_KERN</name></expr></argument>, <argument><expr><name>KERN_OSRELDATE</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>KERN_OSRELEASE</name></cpp:ifdef>
     <expr_stmt><expr><call><name><name>AddSysctl</name><argument_list type="generic">&lt;<argument><expr><name>CTL_KERN</name></expr></argument>, <argument><expr><name>KERN_OSRELEASE</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>KERN_OSREV</name></cpp:ifdef>
     <expr_stmt><expr><call><name><name>AddSysctl</name><argument_list type="generic">&lt;<argument><expr><name>CTL_KERN</name></expr></argument>, <argument><expr><name>KERN_OSREV</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>KERN_OSTYPE</name></cpp:ifdef>
     <expr_stmt><expr><call><name><name>AddSysctl</name><argument_list type="generic">&lt;<argument><expr><name>CTL_KERN</name></expr></argument>, <argument><expr><name>KERN_OSTYPE</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>KERN_POSIX1</name></cpp:ifdef>
     <expr_stmt><expr><call><name><name>AddSysctl</name><argument_list type="generic">&lt;<argument><expr><name>CTL_KERN</name></expr></argument>, <argument><expr><name>KERN_OSREV</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#    <cpp:directive>ifdef</cpp:directive> <name>KERN_VERSION</name></cpp:ifdef>
     <expr_stmt><expr><call><name><name>AddSysctl</name><argument_list type="generic">&lt;<argument><expr><name>CTL_KERN</name></expr></argument>, <argument><expr><name>KERN_VERSION</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hasher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">// Env variables</comment>
    <if_stmt><if>if <condition>(<expr><name>environ</name></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name><name>environ</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>hasher</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>environ</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>environ</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Process, thread, user, session, group, ... ids.</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <expr_stmt><expr><name>hasher</name> <operator>&lt;&lt;</operator> <call><name>GetCurrentProcessId</name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <call><name>GetCurrentThreadId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>hasher</name> <operator>&lt;&lt;</operator> <call><name>getpid</name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <call><name>getppid</name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <call><name>getsid</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <call><name>getpgid</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <call><name>getuid</name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <call><name>geteuid</name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <call><name>getgid</name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <call><name>getegid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>hasher</name> <operator>&lt;&lt;</operator> <call><name><name>std</name><operator>::</operator><name>this_thread</name><operator>::</operator><name>get_id</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
