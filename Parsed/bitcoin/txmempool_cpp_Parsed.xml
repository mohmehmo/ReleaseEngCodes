<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C++" filename="/home/mmm/Projects/bitcoin/src/txmempool.cpp"><comment type="line">// Copyright (c) 2009-2010 Satoshi Nakamoto</comment>
<comment type="line">// Copyright (c) 2009-2018 The Bitcoin Core developers</comment>
<comment type="line">// Distributed under the MIT software license, see the accompanying</comment>
<comment type="line">// file COPYING or http://www.opensource.org/licenses/mit-license.php.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;txmempool.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;consensus/consensus.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;consensus/tx_verify.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;consensus/validation.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optional.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;validation.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;policy/policy.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;policy/fees.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;policy/settings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;reverse_iterator.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/system.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/moneystr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;validationinterface.h&gt;</cpp:file></cpp:include>

<constructor><name><name>CTxMemPoolEntry</name><operator>::</operator><name>CTxMemPoolEntry</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CTransactionRef</name><modifier>&amp;</modifier></type> <name>_tx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CAmount</name><modifier>&amp;</modifier></type> <name>_nFee</name></decl></parameter>,
                                 <parameter><decl><type><name>int64_t</name></type> <name>_nTime</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>_entryHeight</name></decl></parameter>,
                                 <parameter><decl><type><name>bool</name></type> <name>_spendsCoinbase</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>_sigOpsCost</name></decl></parameter>, <parameter><decl><type><name>LockPoints</name></type> <name>lp</name></decl></parameter>)</parameter_list>
    <member_init_list>: <call><name>tx</name><argument_list>(<argument><expr><name>_tx</name></expr></argument>)</argument_list></call>, <call><name>nFee</name><argument_list>(<argument><expr><name>_nFee</name></expr></argument>)</argument_list></call>, <call><name>nTxWeight</name><argument_list>(<argument><expr><call><name>GetTransactionWeight</name><argument_list>(<argument><expr><operator>*</operator><name>tx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>, <call><name>nUsageSize</name><argument_list>(<argument><expr><call><name>RecursiveDynamicUsage</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>, <call><name>nTime</name><argument_list>(<argument><expr><name>_nTime</name></expr></argument>)</argument_list></call>, <call><name>entryHeight</name><argument_list>(<argument><expr><name>_entryHeight</name></expr></argument>)</argument_list></call>,
    <call><name>spendsCoinbase</name><argument_list>(<argument><expr><name>_spendsCoinbase</name></expr></argument>)</argument_list></call>, <call><name>sigOpCost</name><argument_list>(<argument><expr><name>_sigOpsCost</name></expr></argument>)</argument_list></call>, <call><name>lockPoints</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call>
</member_init_list><block>{<block_content>
    <expr_stmt><expr><name>nCountWithDescendants</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>nSizeWithDescendants</name> <operator>=</operator> <call><name>GetTxSize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nModFeesWithDescendants</name> <operator>=</operator> <name>nFee</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>feeDelta</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>nCountWithAncestors</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>nSizeWithAncestors</name> <operator>=</operator> <call><name>GetTxSize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nModFeesWithAncestors</name> <operator>=</operator> <name>nFee</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nSigOpCostWithAncestors</name> <operator>=</operator> <name>sigOpCost</name></expr>;</expr_stmt>
</block_content>}</block></constructor>

<function><type><name>void</name></type> <name><name>CTxMemPoolEntry</name><operator>::</operator><name>UpdateFeeDelta</name></name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>newFeeDelta</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>nModFeesWithDescendants</name> <operator>+=</operator> <name>newFeeDelta</name> <operator>-</operator> <name>feeDelta</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nModFeesWithAncestors</name> <operator>+=</operator> <name>newFeeDelta</name> <operator>-</operator> <name>feeDelta</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>feeDelta</name> <operator>=</operator> <name>newFeeDelta</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CTxMemPoolEntry</name><operator>::</operator><name>UpdateLockPoints</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LockPoints</name><modifier>&amp;</modifier></type> <name>lp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>lockPoints</name> <operator>=</operator> <name>lp</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name><name>CTxMemPoolEntry</name><operator>::</operator><name>GetTxSize</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <return>return <expr><call><name>GetVirtualTransactionSize</name><argument_list>(<argument><expr><name>nTxWeight</name></expr></argument>, <argument><expr><name>sigOpCost</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Update the given tx for any in-mempool descendants.</comment>
<comment type="line">// Assumes that setMemPoolChildren is correct for the given tx and all</comment>
<comment type="line">// descendants.</comment>
<function><type><name>void</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>UpdateForDescendants</name></name><parameter_list>(<parameter><decl><type><name>txiter</name></type> <name>updateIt</name></decl></parameter>, <parameter><decl><type><name>cacheMap</name> <modifier>&amp;</modifier></type><name>cachedDescendants</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>setExclude</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>setEntries</name></type> <name>stageEntries</name></decl>, <decl><type ref="prev"/><name>setAllDescendants</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>stageEntries</name> <operator>=</operator> <call><name>GetMemPoolChildren</name><argument_list>(<argument><expr><name>updateIt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>!</operator><call><name><name>stageEntries</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>txiter</name></type> <name>cit</name> <init>= <expr><operator>*</operator><call><name><name>stageEntries</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>setAllDescendants</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>cit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>stageEntries</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>cit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>setEntries</name> <modifier>&amp;</modifier></type><name>setChildren</name> <init>= <expr><call><name>GetMemPoolChildren</name><argument_list>(<argument><expr><name>cit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>txiter</name></type> <name>childEntry</name> <range>: <expr><name>setChildren</name></expr></range></decl></init>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name><name>cacheMap</name><operator>::</operator><name>iterator</name></name></type> <name>cacheIt</name> <init>= <expr><call><name><name>cachedDescendants</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>childEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>cacheIt</name> <operator>!=</operator> <call><name><name>cachedDescendants</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <comment type="line">// We've already calculated this one, just add the entries for this set</comment>
                <comment type="line">// but don't traverse again.</comment>
                <for>for <control>(<init><decl><type><name>txiter</name></type> <name>cacheEntry</name> <range>: <expr><name><name>cacheIt</name><operator>-&gt;</operator><name>second</name></name></expr></range></decl></init>)</control> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>setAllDescendants</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name><name>setAllDescendants</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>childEntry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <comment type="line">// Schedule for later processing</comment>
                <expr_stmt><expr><call><name><name>stageEntries</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>childEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></while>
    <comment type="line">// setAllDescendants now contains all in-mempool descendants of updateIt.</comment>
    <comment type="line">// Update and add to cached descendant map</comment>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>modifySize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CAmount</name></type> <name>modifyFee</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>modifyCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>txiter</name></type> <name>cit</name> <range>: <expr><name>setAllDescendants</name></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>setExclude</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><call><name><name>cit</name><operator>-&gt;</operator><name>GetTx</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetHash</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>modifySize</name> <operator>+=</operator> <call><name><name>cit</name><operator>-&gt;</operator><name>GetTxSize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>modifyFee</name> <operator>+=</operator> <call><name><name>cit</name><operator>-&gt;</operator><name>GetModifiedFee</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>modifyCount</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cachedDescendants</name><index>[<expr><name>updateIt</name></expr>]</index></name><operator>.</operator><call><name>insert</name><argument_list>(<argument><expr><name>cit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// Update ancestor state for each descendant</comment>
            <expr_stmt><expr><call><name><name>mapTx</name><operator>.</operator><name>modify</name></name><argument_list>(<argument><expr><name>cit</name></expr></argument>, <argument><expr><call><name>update_ancestor_state</name><argument_list>(<argument><expr><call><name><name>updateIt</name><operator>-&gt;</operator><name>GetTxSize</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>updateIt</name><operator>-&gt;</operator><name>GetModifiedFee</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>updateIt</name><operator>-&gt;</operator><name>GetSigOpCost</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name><name>mapTx</name><operator>.</operator><name>modify</name></name><argument_list>(<argument><expr><name>updateIt</name></expr></argument>, <argument><expr><call><name>update_descendant_state</name><argument_list>(<argument><expr><name>modifySize</name></expr></argument>, <argument><expr><name>modifyFee</name></expr></argument>, <argument><expr><name>modifyCount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// vHashesToUpdate is the set of transaction hashes from a disconnected block</comment>
<comment type="line">// which has been re-added to the mempool.</comment>
<comment type="line">// for each entry, look for descendants that are outside vHashesToUpdate, and</comment>
<comment type="line">// add fee/size information for such descendants to the parent.</comment>
<comment type="line">// for each such descendant, also update the ancestor state to include the parent.</comment>
<function><type><name>void</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>UpdateTransactionsFromBlock</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>vHashesToUpdate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>AssertLockHeld</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// For each entry in vHashesToUpdate, store the set of in-mempool, but not</comment>
    <comment type="line">// in-vHashesToUpdate transactions, so that we don't have to recalculate</comment>
    <comment type="line">// descendants when we come across a previously seen entry.</comment>
    <decl_stmt><decl><type><name>cacheMap</name></type> <name>mapMemPoolDescendantsToUpdate</name></decl>;</decl_stmt>

    <comment type="line">// Use a set for lookups into vHashesToUpdate (these entries are already</comment>
    <comment type="line">// accounted for in the state of their ancestors)</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>&gt;</argument_list></name></type> <name>setAlreadyIncluded</name><argument_list>(<argument><expr><call><name><name>vHashesToUpdate</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>vHashesToUpdate</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

    <comment type="line">// Iterate in reverse, so that whenever we are looking at a transaction</comment>
    <comment type="line">// we are sure that all in-mempool descendants have already been processed.</comment>
    <comment type="line">// This maximizes the benefit of the descendant cache and guarantees that</comment>
    <comment type="line">// setMemPoolChildren will be updated, an assumption made in</comment>
    <comment type="line">// UpdateForDescendants.</comment>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <name>uint256</name> <modifier>&amp;</modifier></type><name>hash</name> <range>: <expr><call><name>reverse_iterate</name><argument_list>(<argument><expr><name>vHashesToUpdate</name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <comment type="line">// we cache the in-mempool children to avoid duplicate updates</comment>
        <decl_stmt><decl><type><name>setEntries</name></type> <name>setChildren</name></decl>;</decl_stmt>
        <comment type="line">// calculate children from mapNextTx</comment>
        <decl_stmt><decl><type><name>txiter</name></type> <name>it</name> <init>= <expr><call><name><name>mapTx</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>it</name> <operator>==</operator> <call><name><name>mapTx</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>iter</name> <init>= <expr><call><name><name>mapNextTx</name><operator>.</operator><name>lower_bound</name></name><argument_list>(<argument><expr><call><name>COutPoint</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// First calculate the children, and update setMemPoolChildren to</comment>
        <comment type="line">// include them, and update their setMemPoolParents to include this tx.</comment>
        <for>for <control>(<init>;</init> <condition><expr><name>iter</name> <operator>!=</operator> <call><name><name>mapNextTx</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>iter</name><operator>-&gt;</operator><name>first</name><operator>-&gt;</operator><name>hash</name></name> <operator>==</operator> <name>hash</name></expr>;</condition> <incr><expr><operator>++</operator><name>iter</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>uint256</name> <modifier>&amp;</modifier></type><name>childHash</name> <init>= <expr><call><name><name>iter</name><operator>-&gt;</operator><name>second</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>txiter</name></type> <name>childIter</name> <init>= <expr><call><name><name>mapTx</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>childHash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>childIter</name> <operator>!=</operator> <call><name><name>mapTx</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// We can skip updating entries we've encountered before or that</comment>
            <comment type="line">// are in the block (which are already accounted for).</comment>
            <if_stmt><if>if <condition>(<expr><call><name><name>setChildren</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>childIter</name></expr></argument>)</argument_list></call><operator>.</operator><name>second</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>setAlreadyIncluded</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>childHash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>UpdateChild</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><name>childIter</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>UpdateParent</name><argument_list>(<argument><expr><name>childIter</name></expr></argument>, <argument><expr><name>it</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>UpdateForDescendants</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><name>mapMemPoolDescendantsToUpdate</name></expr></argument>, <argument><expr><name>setAlreadyIncluded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>CalculateMemPoolAncestors</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CTxMemPoolEntry</name> <modifier>&amp;</modifier></type><name>entry</name></decl></parameter>, <parameter><decl><type><name>setEntries</name> <modifier>&amp;</modifier></type><name>setAncestors</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>limitAncestorCount</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>limitAncestorSize</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>limitDescendantCount</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>limitDescendantSize</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>string</name></name> <modifier>&amp;</modifier></type><name>errString</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fSearchForParents</name></decl></parameter> <comment type="block">/* = true */</comment>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <decl_stmt><decl><type><name>setEntries</name></type> <name>parentHashes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CTransaction</name> <modifier>&amp;</modifier></type><name>tx</name> <init>= <expr><call><name><name>entry</name><operator>.</operator><name>GetTx</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>fSearchForParents</name></expr>)</condition> <block>{<block_content>
        <comment type="line">// Get parents of this transaction that are in the mempool</comment>
        <comment type="line">// GetMemPoolParents() is only valid for entries in the mempool, so we</comment>
        <comment type="line">// iterate mapTx to find parents.</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>tx</name><operator>.</operator><name>vin</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>txiter</name></expr></argument>&gt;</argument_list></name></type> <name>piter</name> <init>= <expr><call><name>GetIter</name><argument_list>(<argument><expr><name><name>tx</name><operator>.</operator><name>vin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>prevout</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>piter</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>parentHashes</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><operator>*</operator><name>piter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>parentHashes</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name>limitAncestorCount</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>errString</name> <operator>=</operator> <call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"too many unconfirmed parents [limit: %u]"</literal></expr></argument>, <argument><expr><name>limitAncestorCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="line">// If we're not searching for parents, we require this to be an</comment>
        <comment type="line">// entry in the mempool already.</comment>
        <decl_stmt><decl><type><name>txiter</name></type> <name>it</name> <init>= <expr><call><name><name>mapTx</name><operator>.</operator><name>iterator_to</name></name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>parentHashes</name> <operator>=</operator> <call><name>GetMemPoolParents</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <decl_stmt><decl><type><name>size_t</name></type> <name>totalSizeWithAncestors</name> <init>= <expr><call><name><name>entry</name><operator>.</operator><name>GetTxSize</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><operator>!</operator><call><name><name>parentHashes</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>txiter</name></type> <name>stageit</name> <init>= <expr><operator>*</operator><call><name><name>parentHashes</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>setAncestors</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>stageit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>parentHashes</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>stageit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>totalSizeWithAncestors</name> <operator>+=</operator> <call><name><name>stageit</name><operator>-&gt;</operator><name>GetTxSize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>stageit</name><operator>-&gt;</operator><name>GetSizeWithDescendants</name></name><argument_list>()</argument_list></call> <operator>+</operator> <call><name><name>entry</name><operator>.</operator><name>GetTxSize</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>limitDescendantSize</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>errString</name> <operator>=</operator> <call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"exceeds descendant size limit for tx %s [limit: %u]"</literal></expr></argument>, <argument><expr><call><name><name>stageit</name><operator>-&gt;</operator><name>GetTx</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetHash</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ToString</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>limitDescendantSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>stageit</name><operator>-&gt;</operator><name>GetCountWithDescendants</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name>limitDescendantCount</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>errString</name> <operator>=</operator> <call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"too many descendants for tx %s [limit: %u]"</literal></expr></argument>, <argument><expr><call><name><name>stageit</name><operator>-&gt;</operator><name>GetTx</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetHash</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ToString</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>limitDescendantCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>totalSizeWithAncestors</name> <operator>&gt;</operator> <name>limitAncestorSize</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>errString</name> <operator>=</operator> <call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"exceeds ancestor size limit [limit: %u]"</literal></expr></argument>, <argument><expr><name>limitAncestorSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><specifier>const</specifier> <name>setEntries</name> <modifier>&amp;</modifier></type> <name>setMemPoolParents</name> <init>= <expr><call><name>GetMemPoolParents</name><argument_list>(<argument><expr><name>stageit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>txiter</name></type> <name>phash</name> <range>: <expr><name>setMemPoolParents</name></expr></range></decl></init>)</control> <block>{<block_content>
            <comment type="line">// If this is a new ancestor, add it.</comment>
            <if_stmt><if>if <condition>(<expr><call><name><name>setAncestors</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>phash</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>parentHashes</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>phash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>parentHashes</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>+</operator> <call><name><name>setAncestors</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name>limitAncestorCount</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>errString</name> <operator>=</operator> <call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"too many unconfirmed ancestors [limit: %u]"</literal></expr></argument>, <argument><expr><name>limitAncestorCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></while>

    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>UpdateAncestorsOf</name></name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>add</name></decl></parameter>, <parameter><decl><type><name>txiter</name></type> <name>it</name></decl></parameter>, <parameter><decl><type><name>setEntries</name> <modifier>&amp;</modifier></type><name>setAncestors</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>setEntries</name></type> <name>parentIters</name> <init>= <expr><call><name>GetMemPoolParents</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// add or remove this tx as a child of each parent</comment>
    <for>for <control>(<init><decl><type><name>txiter</name></type> <name>piter</name> <range>: <expr><name>parentIters</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>UpdateChild</name><argument_list>(<argument><expr><name>piter</name></expr></argument>, <argument><expr><name>it</name></expr></argument>, <argument><expr><name>add</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>updateCount</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>add</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>updateSize</name> <init>= <expr><name>updateCount</name> <operator>*</operator> <call><name><name>it</name><operator>-&gt;</operator><name>GetTxSize</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CAmount</name></type> <name>updateFee</name> <init>= <expr><name>updateCount</name> <operator>*</operator> <call><name><name>it</name><operator>-&gt;</operator><name>GetModifiedFee</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>txiter</name></type> <name>ancestorIt</name> <range>: <expr><name>setAncestors</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>mapTx</name><operator>.</operator><name>modify</name></name><argument_list>(<argument><expr><name>ancestorIt</name></expr></argument>, <argument><expr><call><name>update_descendant_state</name><argument_list>(<argument><expr><name>updateSize</name></expr></argument>, <argument><expr><name>updateFee</name></expr></argument>, <argument><expr><name>updateCount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>UpdateEntryForAncestors</name></name><parameter_list>(<parameter><decl><type><name>txiter</name></type> <name>it</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>setEntries</name> <modifier>&amp;</modifier></type><name>setAncestors</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>updateCount</name> <init>= <expr><call><name><name>setAncestors</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>updateSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CAmount</name></type> <name>updateFee</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>updateSigOpsCost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>txiter</name></type> <name>ancestorIt</name> <range>: <expr><name>setAncestors</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><name>updateSize</name> <operator>+=</operator> <call><name><name>ancestorIt</name><operator>-&gt;</operator><name>GetTxSize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>updateFee</name> <operator>+=</operator> <call><name><name>ancestorIt</name><operator>-&gt;</operator><name>GetModifiedFee</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>updateSigOpsCost</name> <operator>+=</operator> <call><name><name>ancestorIt</name><operator>-&gt;</operator><name>GetSigOpCost</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name><name>mapTx</name><operator>.</operator><name>modify</name></name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><call><name>update_ancestor_state</name><argument_list>(<argument><expr><name>updateSize</name></expr></argument>, <argument><expr><name>updateFee</name></expr></argument>, <argument><expr><name>updateCount</name></expr></argument>, <argument><expr><name>updateSigOpsCost</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>UpdateChildrenForRemoval</name></name><parameter_list>(<parameter><decl><type><name>txiter</name></type> <name>it</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>setEntries</name> <modifier>&amp;</modifier></type><name>setMemPoolChildren</name> <init>= <expr><call><name>GetMemPoolChildren</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>txiter</name></type> <name>updateIt</name> <range>: <expr><name>setMemPoolChildren</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>UpdateParent</name><argument_list>(<argument><expr><name>updateIt</name></expr></argument>, <argument><expr><name>it</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>UpdateForRemoveFromMempool</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>setEntries</name> <modifier>&amp;</modifier></type><name>entriesToRemove</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>updateDescendants</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">// For each entry, walk back all ancestors and decrement size associated with this</comment>
    <comment type="line">// transaction</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>nNoLimit</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>numeric_limits</name><argument_list type="generic">&lt;<argument><expr><name>uint64_t</name></expr></argument>&gt;</argument_list><operator>::</operator><name>max</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>updateDescendants</name></expr>)</condition> <block>{<block_content>
        <comment type="line">// updateDescendants should be true whenever we're not recursively</comment>
        <comment type="line">// removing a tx and all its descendants, eg when a transaction is</comment>
        <comment type="line">// confirmed in a block.</comment>
        <comment type="line">// Here we only update statistics and not data in mapLinks (which</comment>
        <comment type="line">// we need to preserve until we're finished with all operations that</comment>
        <comment type="line">// need to traverse the mempool).</comment>
        <for>for <control>(<init><decl><type><name>txiter</name></type> <name>removeIt</name> <range>: <expr><name>entriesToRemove</name></expr></range></decl></init>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>setEntries</name></type> <name>setDescendants</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>CalculateDescendants</name><argument_list>(<argument><expr><name>removeIt</name></expr></argument>, <argument><expr><name>setDescendants</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>setDescendants</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>removeIt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// don't update state for self</comment>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>modifySize</name> <init>= <expr><operator>-</operator><operator>(</operator><operator>(</operator><name>int64_t</name><operator>)</operator><call><name><name>removeIt</name><operator>-&gt;</operator><name>GetTxSize</name></name><argument_list>()</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>CAmount</name></type> <name>modifyFee</name> <init>= <expr><operator>-</operator><call><name><name>removeIt</name><operator>-&gt;</operator><name>GetModifiedFee</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>modifySigOps</name> <init>= <expr><operator>-</operator><call><name><name>removeIt</name><operator>-&gt;</operator><name>GetSigOpCost</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>txiter</name></type> <name>dit</name> <range>: <expr><name>setDescendants</name></expr></range></decl></init>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name><name>mapTx</name><operator>.</operator><name>modify</name></name><argument_list>(<argument><expr><name>dit</name></expr></argument>, <argument><expr><call><name>update_ancestor_state</name><argument_list>(<argument><expr><name>modifySize</name></expr></argument>, <argument><expr><name>modifyFee</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>modifySigOps</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init><decl><type><name>txiter</name></type> <name>removeIt</name> <range>: <expr><name>entriesToRemove</name></expr></range></decl></init>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>setEntries</name></type> <name>setAncestors</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>CTxMemPoolEntry</name> <modifier>&amp;</modifier></type><name>entry</name> <init>= <expr><operator>*</operator><name>removeIt</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>dummy</name></decl>;</decl_stmt>
        <comment type="line">// Since this is a tx that is already in the mempool, we can call CMPA</comment>
        <comment type="line">// with fSearchForParents = false.  If the mempool is in a consistent</comment>
        <comment type="line">// state, then using true or false should both be correct, though false</comment>
        <comment type="line">// should be a bit faster.</comment>
        <comment type="line">// However, if we happen to be in the middle of processing a reorg, then</comment>
        <comment type="line">// the mempool can be in an inconsistent state.  In this case, the set</comment>
        <comment type="line">// of ancestors reachable via mapLinks will be the same as the set of</comment>
        <comment type="line">// ancestors whose packages include this transaction, because when we</comment>
        <comment type="line">// add a new transaction to the mempool in addUnchecked(), we assume it</comment>
        <comment type="line">// has no children, and in the case of a reorg where that assumption is</comment>
        <comment type="line">// false, the in-mempool children aren't linked to the in-block tx's</comment>
        <comment type="line">// until UpdateTransactionsFromBlock() is called.</comment>
        <comment type="line">// So if we're being called during a reorg, ie before</comment>
        <comment type="line">// UpdateTransactionsFromBlock() has been called, then mapLinks[] will</comment>
        <comment type="line">// differ from the set of mempool parents we'd calculate by searching,</comment>
        <comment type="line">// and it's important that we use the mapLinks[] notion of ancestor</comment>
        <comment type="line">// transactions as the set of things to update for removal.</comment>
        <expr_stmt><expr><call><name>CalculateMemPoolAncestors</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>setAncestors</name></expr></argument>, <argument><expr><name>nNoLimit</name></expr></argument>, <argument><expr><name>nNoLimit</name></expr></argument>, <argument><expr><name>nNoLimit</name></expr></argument>, <argument><expr><name>nNoLimit</name></expr></argument>, <argument><expr><name>dummy</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// Note that UpdateAncestorsOf severs the child links that point to</comment>
        <comment type="line">// removeIt in the entries for the parents of removeIt.</comment>
        <expr_stmt><expr><call><name>UpdateAncestorsOf</name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name>removeIt</name></expr></argument>, <argument><expr><name>setAncestors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <comment type="line">// After updating all the ancestor sizes, we can now sever the link between each</comment>
    <comment type="line">// transaction being removed and any mempool children (ie, update setMemPoolParents</comment>
    <comment type="line">// for each direct child of a transaction being removed).</comment>
    <for>for <control>(<init><decl><type><name>txiter</name></type> <name>removeIt</name> <range>: <expr><name>entriesToRemove</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>UpdateChildrenForRemoval</name><argument_list>(<argument><expr><name>removeIt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CTxMemPoolEntry</name><operator>::</operator><name>UpdateDescendantState</name></name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>modifySize</name></decl></parameter>, <parameter><decl><type><name>CAmount</name></type> <name>modifyFee</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>modifyCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>nSizeWithDescendants</name> <operator>+=</operator> <name>modifySize</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>int64_t</name><argument_list>(<argument><expr><name>nSizeWithDescendants</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nModFeesWithDescendants</name> <operator>+=</operator> <name>modifyFee</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nCountWithDescendants</name> <operator>+=</operator> <name>modifyCount</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>int64_t</name><argument_list>(<argument><expr><name>nCountWithDescendants</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CTxMemPoolEntry</name><operator>::</operator><name>UpdateAncestorState</name></name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>modifySize</name></decl></parameter>, <parameter><decl><type><name>CAmount</name></type> <name>modifyFee</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>modifyCount</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>modifySigOps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>nSizeWithAncestors</name> <operator>+=</operator> <name>modifySize</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>int64_t</name><argument_list>(<argument><expr><name>nSizeWithAncestors</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nModFeesWithAncestors</name> <operator>+=</operator> <name>modifyFee</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nCountWithAncestors</name> <operator>+=</operator> <name>modifyCount</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>int64_t</name><argument_list>(<argument><expr><name>nCountWithAncestors</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nSigOpCostWithAncestors</name> <operator>+=</operator> <name>modifySigOps</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>int</name><argument_list>(<argument><expr><name>nSigOpCostWithAncestors</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<constructor><name><name>CTxMemPool</name><operator>::</operator><name>CTxMemPool</name></name><parameter_list>(<parameter><decl><type><name>CBlockPolicyEstimator</name><modifier>*</modifier></type> <name>estimator</name></decl></parameter>)</parameter_list>
    <member_init_list>: <call><name>nTransactionsUpdated</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call>, <call><name>minerPolicyEstimator</name><argument_list>(<argument><expr><name>estimator</name></expr></argument>)</argument_list></call>
</member_init_list><block>{<block_content>
    <expr_stmt><expr><call><name>_clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">//lock free clear</comment>

    <comment type="line">// Sanity checks off by default for performance, because otherwise</comment>
    <comment type="line">// accepting transactions becomes O(N^2) where N is the number</comment>
    <comment type="line">// of transactions in the pool</comment>
    <expr_stmt><expr><name>nCheckFrequency</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></constructor>

<function><type><name>bool</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>isSpent</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>COutPoint</name><modifier>&amp;</modifier></type> <name>outpoint</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name><name>mapNextTx</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>outpoint</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>int</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>GetTransactionsUpdated</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <return>return <expr><name>nTransactionsUpdated</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>AddTransactionsUpdated</name></name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>nTransactionsUpdated</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>addUnchecked</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CTxMemPoolEntry</name> <modifier>&amp;</modifier></type><name>entry</name></decl></parameter>, <parameter><decl><type><name>setEntries</name> <modifier>&amp;</modifier></type><name>setAncestors</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>validFeeEstimate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>NotifyEntryAdded</name><argument_list>(<argument><expr><call><name><name>entry</name><operator>.</operator><name>GetSharedTx</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Add to memory pool without checking anything.</comment>
    <comment type="line">// Used by AcceptToMemoryPool(), which DOES do</comment>
    <comment type="line">// all the appropriate checks.</comment>
    <decl_stmt><decl><type><name><name>indexed_transaction_set</name><operator>::</operator><name>iterator</name></name></type> <name>newit</name> <init>= <expr><call><name><name>mapTx</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call><operator>.</operator><name>first</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>mapLinks</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name>make_pair</name><argument_list>(<argument><expr><name>newit</name></expr></argument>, <argument><expr><call><name>TxLinks</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Update transaction for any feeDelta created by PrioritiseTransaction</comment>
    <comment type="line">// TODO: refactor so that the fee delta is calculated before inserting</comment>
    <comment type="line">// into mapTx.</comment>
    <decl_stmt><decl><type><name>CAmount</name></type> <name>delta</name><argument_list>{<argument><expr><literal type="number">0</literal></expr></argument>}</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ApplyDelta</name><argument_list>(<argument><expr><call><name><name>entry</name><operator>.</operator><name>GetTx</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetHash</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>delta</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>mapTx</name><operator>.</operator><name>modify</name></name><argument_list>(<argument><expr><name>newit</name></expr></argument>, <argument><expr><call><name>update_fee_delta</name><argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Update cachedInnerUsage to include contained transaction's usage.</comment>
    <comment type="line">// (When we update the entry for in-mempool parents, memory usage will be</comment>
    <comment type="line">// further updated.)</comment>
    <expr_stmt><expr><name>cachedInnerUsage</name> <operator>+=</operator> <call><name><name>entry</name><operator>.</operator><name>DynamicMemoryUsage</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>CTransaction</name><modifier>&amp;</modifier></type> <name>tx</name> <init>= <expr><call><name><name>newit</name><operator>-&gt;</operator><name>GetTx</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>&gt;</argument_list></name></type> <name>setParentTransactions</name></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>tx</name><operator>.</operator><name>vin</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>mapNextTx</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tx</name><operator>.</operator><name>vin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>prevout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>setParentTransactions</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name><name>tx</name><operator>.</operator><name>vin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>prevout</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <comment type="line">// Don't bother worrying about child transactions of this one.</comment>
    <comment type="line">// Normal case of a new transaction arriving is that there can't be any</comment>
    <comment type="line">// children, because such children would be orphans.</comment>
    <comment type="line">// An exception to that is if a transaction enters that used to be in a block.</comment>
    <comment type="line">// In that case, our disconnect block logic will call UpdateTransactionsFromBlock</comment>
    <comment type="line">// to clean up the mess we're leaving here.</comment>

    <comment type="line">// Update ancestors with information about this tx</comment>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>pit</name> <range>: <expr><call><name>GetIterSet</name><argument_list>(<argument><expr><name>setParentTransactions</name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>UpdateParent</name><argument_list>(<argument><expr><name>newit</name></expr></argument>, <argument><expr><name>pit</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>UpdateAncestorsOf</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><name>newit</name></expr></argument>, <argument><expr><name>setAncestors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UpdateEntryForAncestors</name><argument_list>(<argument><expr><name>newit</name></expr></argument>, <argument><expr><name>setAncestors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>nTransactionsUpdated</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>totalTxSize</name> <operator>+=</operator> <call><name><name>entry</name><operator>.</operator><name>GetTxSize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>minerPolicyEstimator</name></expr>)</condition> <block>{<block_content><expr_stmt><expr><call><name><name>minerPolicyEstimator</name><operator>-&gt;</operator><name>processTransaction</name></name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>validFeeEstimate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name><name>vTxHashes</name><operator>.</operator><name>emplace_back</name></name><argument_list>(<argument><expr><call><name><name>tx</name><operator>.</operator><name>GetWitnessHash</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>newit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newit</name><operator>-&gt;</operator><name>vTxHashesIdx</name></name> <operator>=</operator> <call><name><name>vTxHashes</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>removeUnchecked</name></name><parameter_list>(<parameter><decl><type><name>txiter</name></type> <name>it</name></decl></parameter>, <parameter><decl><type><name>MemPoolRemovalReason</name></type> <name>reason</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CTransactionRef</name></type> <name>ptx</name> <init>= <expr><call><name><name>it</name><operator>-&gt;</operator><name>GetSharedTx</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NotifyEntryRemoved</name><argument_list>(<argument><expr><name>ptx</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>reason</name> <operator>!=</operator> <name><name>MemPoolRemovalReason</name><operator>::</operator><name>BLOCK</name></name> <operator>&amp;&amp;</operator> <name>reason</name> <operator>!=</operator> <name><name>MemPoolRemovalReason</name><operator>::</operator><name>CONFLICT</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>GetMainSignals</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransactionRemovedFromMempool</name><argument_list>(<argument><expr><name>ptx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>uint256</name></type> <name>hash</name> <init>= <expr><call><name><name>it</name><operator>-&gt;</operator><name>GetTx</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetHash</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CTxIn</name><modifier>&amp;</modifier></type> <name>txin</name> <range>: <expr><call><name><name>it</name><operator>-&gt;</operator><name>GetTx</name></name><argument_list>()</argument_list></call><operator>.</operator><name>vin</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name><name>mapNextTx</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name><name>txin</name><operator>.</operator><name>prevout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <if_stmt><if>if <condition>(<expr><call><name><name>vTxHashes</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>vTxHashes</name><index>[<expr><name><name>it</name><operator>-&gt;</operator><name>vTxHashesIdx</name></name></expr>]</index></name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><call><name><name>vTxHashes</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>vTxHashes</name><index>[<expr><name><name>it</name><operator>-&gt;</operator><name>vTxHashesIdx</name></name></expr>]</index></name><operator>.</operator><name><name>second</name><operator>-&gt;</operator><name>vTxHashesIdx</name></name> <operator>=</operator> <name><name>it</name><operator>-&gt;</operator><name>vTxHashesIdx</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>vTxHashes</name><operator>.</operator><name>pop_back</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>vTxHashes</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>*</operator> <literal type="number">2</literal> <operator>&lt;</operator> <call><name><name>vTxHashes</name><operator>.</operator><name>capacity</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>vTxHashes</name><operator>.</operator><name>shrink_to_fit</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name><name>vTxHashes</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name>totalTxSize</name> <operator>-=</operator> <call><name><name>it</name><operator>-&gt;</operator><name>GetTxSize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cachedInnerUsage</name> <operator>-=</operator> <call><name><name>it</name><operator>-&gt;</operator><name>DynamicMemoryUsage</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cachedInnerUsage</name> <operator>-=</operator> <call><name><name>memusage</name><operator>::</operator><name>DynamicUsage</name></name><argument_list>(<argument><expr><name><name>mapLinks</name><index>[<expr><name>it</name></expr>]</index></name><operator>.</operator><name>parents</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name><name>memusage</name><operator>::</operator><name>DynamicUsage</name></name><argument_list>(<argument><expr><name><name>mapLinks</name><index>[<expr><name>it</name></expr>]</index></name><operator>.</operator><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mapLinks</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mapTx</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nTransactionsUpdated</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>minerPolicyEstimator</name></expr>)</condition> <block>{<block_content><expr_stmt><expr><call><name><name>minerPolicyEstimator</name><operator>-&gt;</operator><name>removeTx</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="line">// Calculates descendants of entry that are not already in setDescendants, and adds to</comment>
<comment type="line">// setDescendants. Assumes entryit is already a tx in the mempool and setMemPoolChildren</comment>
<comment type="line">// is correct for tx and all descendants.</comment>
<comment type="line">// Also assumes that if an entry is in setDescendants already, then all</comment>
<comment type="line">// in-mempool descendants of it are already in setDescendants as well, so that we</comment>
<comment type="line">// can save time by not iterating over those entries.</comment>
<function><type><name>void</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>CalculateDescendants</name></name><parameter_list>(<parameter><decl><type><name>txiter</name></type> <name>entryit</name></decl></parameter>, <parameter><decl><type><name>setEntries</name><modifier>&amp;</modifier></type> <name>setDescendants</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <decl_stmt><decl><type><name>setEntries</name></type> <name>stage</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>setDescendants</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>entryit</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>stage</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>entryit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="line">// Traverse down the children of entry, only adding children that are not</comment>
    <comment type="line">// accounted for in setDescendants already (because those children have either</comment>
    <comment type="line">// already been walked, or will be walked in this iteration).</comment>
    <while>while <condition>(<expr><operator>!</operator><call><name><name>stage</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>txiter</name></type> <name>it</name> <init>= <expr><operator>*</operator><call><name><name>stage</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>setDescendants</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>stage</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><specifier>const</specifier> <name>setEntries</name> <modifier>&amp;</modifier></type><name>setChildren</name> <init>= <expr><call><name>GetMemPoolChildren</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>txiter</name></type> <name>childiter</name> <range>: <expr><name>setChildren</name></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>setDescendants</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>childiter</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>stage</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>childiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>removeRecursive</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CTransaction</name> <modifier>&amp;</modifier></type><name>origTx</name></decl></parameter>, <parameter><decl><type><name>MemPoolRemovalReason</name></type> <name>reason</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">// Remove transaction from memory pool</comment>
    <expr_stmt><expr><call><name>AssertLockHeld</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>setEntries</name></type> <name>txToRemove</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>txiter</name></type> <name>origit</name> <init>= <expr><call><name><name>mapTx</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><call><name><name>origTx</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>origit</name> <operator>!=</operator> <call><name><name>mapTx</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>txToRemove</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>origit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="line">// When recursively removing but origTx isn't in the mempool</comment>
            <comment type="line">// be sure to remove any children that are in the pool. This can</comment>
            <comment type="line">// happen during chain re-orgs if origTx isn't re-accepted into</comment>
            <comment type="line">// the mempool for any reason.</comment>
            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>origTx</name><operator>.</operator><name>vout</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>auto</name></type> <name>it</name> <init>= <expr><call><name><name>mapNextTx</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><call><name>COutPoint</name><argument_list>(<argument><expr><call><name><name>origTx</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>it</name> <operator>==</operator> <call><name><name>mapNextTx</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
                <decl_stmt><decl><type><name>txiter</name></type> <name>nextit</name> <init>= <expr><call><name><name>mapTx</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><call><name><name>it</name><operator>-&gt;</operator><name>second</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nextit</name> <operator>!=</operator> <call><name><name>mapTx</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>txToRemove</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>nextit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>
        <decl_stmt><decl><type><name>setEntries</name></type> <name>setAllRemoves</name></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>txiter</name></type> <name>it</name> <range>: <expr><name>txToRemove</name></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>CalculateDescendants</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><name>setAllRemoves</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>RemoveStaged</name><argument_list>(<argument><expr><name>setAllRemoves</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>removeForReorg</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CCoinsViewCache</name> <modifier>*</modifier></type><name>pcoins</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nMemPoolHeight</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">// Remove transactions spending a coinbase which are now immature and no-longer-final transactions</comment>
    <expr_stmt><expr><call><name>AssertLockHeld</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>setEntries</name></type> <name>txToRemove</name></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name><name>indexed_transaction_set</name><operator>::</operator><name>const_iterator</name></name></type> <name>it</name> <init>= <expr><call><name><name>mapTx</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>it</name> <operator>!=</operator> <call><name><name>mapTx</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>it</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>CTransaction</name><modifier>&amp;</modifier></type> <name>tx</name> <init>= <expr><call><name><name>it</name><operator>-&gt;</operator><name>GetTx</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LockPoints</name></type> <name>lp</name> <init>= <expr><call><name><name>it</name><operator>-&gt;</operator><name>GetLockPoints</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>validLP</name> <init>=  <expr><call><name>TestLockPointValidity</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckFinalTx</name><argument_list>(<argument><expr><name>tx</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>CheckSequenceLocks</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>tx</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lp</name></expr></argument>, <argument><expr><name>validLP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="line">// Note if CheckSequenceLocks fails the LockPoints may still be invalid</comment>
            <comment type="line">// So it's critical that we remove the tx and not depend on the LockPoints.</comment>
            <expr_stmt><expr><call><name><name>txToRemove</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>it</name><operator>-&gt;</operator><name>GetSpendsCoinbase</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CTxIn</name><modifier>&amp;</modifier></type> <name>txin</name> <range>: <expr><name><name>tx</name><operator>.</operator><name>vin</name></name></expr></range></decl></init>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name><name>indexed_transaction_set</name><operator>::</operator><name>const_iterator</name></name></type> <name>it2</name> <init>= <expr><call><name><name>mapTx</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name><name>txin</name><operator>.</operator><name>prevout</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>it2</name> <operator>!=</operator> <call><name><name>mapTx</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>Coin</name> <modifier>&amp;</modifier></type><name>coin</name> <init>= <expr><call><name><name>pcoins</name><operator>-&gt;</operator><name>AccessCoin</name></name><argument_list>(<argument><expr><name><name>txin</name><operator>.</operator><name>prevout</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>nCheckFrequency</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>coin</name><operator>.</operator><name>IsSpent</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>coin</name><operator>.</operator><name>IsSpent</name></name><argument_list>()</argument_list></call> <operator>||</operator> <operator>(</operator><call><name><name>coin</name><operator>.</operator><name>IsCoinBase</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>signed</name> <name>long</name><operator>)</operator><name>nMemPoolHeight</name><operator>)</operator> <operator>-</operator> <name><name>coin</name><operator>.</operator><name>nHeight</name></name> <operator>&lt;</operator> <name>COINBASE_MATURITY</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>txToRemove</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>validLP</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>mapTx</name><operator>.</operator><name>modify</name></name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><call><name>update_lock_points</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <decl_stmt><decl><type><name>setEntries</name></type> <name>setAllRemoves</name></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>txiter</name></type> <name>it</name> <range>: <expr><name>txToRemove</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>CalculateDescendants</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><name>setAllRemoves</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>RemoveStaged</name><argument_list>(<argument><expr><name>setAllRemoves</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name><name>MemPoolRemovalReason</name><operator>::</operator><name>REORG</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>removeConflicts</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CTransaction</name> <modifier>&amp;</modifier></type><name>tx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">// Remove transactions which depend on inputs of tx, recursively</comment>
    <expr_stmt><expr><call><name>AssertLockHeld</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CTxIn</name> <modifier>&amp;</modifier></type><name>txin</name> <range>: <expr><name><name>tx</name><operator>.</operator><name>vin</name></name></expr></range></decl></init>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>it</name> <init>= <expr><call><name><name>mapNextTx</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name><name>txin</name><operator>.</operator><name>prevout</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>it</name> <operator>!=</operator> <call><name><name>mapNextTx</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>CTransaction</name> <modifier>&amp;</modifier></type><name>txConflict</name> <init>= <expr><operator>*</operator><name><name>it</name><operator>-&gt;</operator><name>second</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>txConflict</name> <operator>!=</operator> <name>tx</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ClearPrioritisation</name><argument_list>(<argument><expr><call><name><name>txConflict</name><operator>.</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>removeRecursive</name><argument_list>(<argument><expr><name>txConflict</name></expr></argument>, <argument><expr><name><name>MemPoolRemovalReason</name><operator>::</operator><name>CONFLICT</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Called when a block is connected. Removes from mempool and updates the miner fee estimator.
 */</comment>
<function><type><name>void</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>removeForBlock</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CTransactionRef</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>vtx</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nBlockHeight</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>AssertLockHeld</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CTxMemPoolEntry</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>entries</name></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>tx</name> <range>: <expr><name>vtx</name></expr></range></decl></init>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>uint256</name></type> <name>hash</name> <init>= <expr><call><name><name>tx</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>indexed_transaction_set</name><operator>::</operator><name>iterator</name></name></type> <name>i</name> <init>= <expr><call><name><name>mapTx</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <call><name><name>mapTx</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>entries</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><operator>&amp;</operator><operator>*</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <comment type="line">// Before the txs in the new block have been removed from the mempool, update policy estimates</comment>
    <if_stmt><if>if <condition>(<expr><name>minerPolicyEstimator</name></expr>)</condition> <block>{<block_content><expr_stmt><expr><call><name><name>minerPolicyEstimator</name><operator>-&gt;</operator><name>processBlock</name></name><argument_list>(<argument><expr><name>nBlockHeight</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content>}</block></if></if_stmt>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>tx</name> <range>: <expr><name>vtx</name></expr></range></decl></init>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>txiter</name></type> <name>it</name> <init>= <expr><call><name><name>mapTx</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><call><name><name>tx</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>it</name> <operator>!=</operator> <call><name><name>mapTx</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>setEntries</name></type> <name>stage</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>stage</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RemoveStaged</name><argument_list>(<argument><expr><name>stage</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><name><name>MemPoolRemovalReason</name><operator>::</operator><name>BLOCK</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>removeConflicts</name><argument_list>(<argument><expr><operator>*</operator><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ClearPrioritisation</name><argument_list>(<argument><expr><call><name><name>tx</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>lastRollingFeeUpdate</name> <operator>=</operator> <call><name>GetTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>blockSinceLastRollingFeeBump</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>_clear</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name><name>mapLinks</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mapTx</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mapNextTx</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>totalTxSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>cachedInnerUsage</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>lastRollingFeeUpdate</name> <operator>=</operator> <call><name>GetTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>blockSinceLastRollingFeeBump</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rollingMinimumFeeRate</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>++</operator><name>nTransactionsUpdated</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>clear</name></name><parameter_list>()</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>_clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>CheckInputsAndUpdateCoins</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CTransaction</name><modifier>&amp;</modifier></type> <name>tx</name></decl></parameter>, <parameter><decl><type><name>CCoinsViewCache</name><modifier>&amp;</modifier></type> <name>mempoolDuplicate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>spendheight</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TxValidationState</name></type> <name>dummy_state</name></decl>;</decl_stmt> <comment type="line">// Not used. CheckTxInputs() should always pass</comment>
    <decl_stmt><decl><type><name>CAmount</name></type> <name>txfee</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>fCheckResult</name> <init>= <expr><call><name><name>tx</name><operator>.</operator><name>IsCoinBase</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>Consensus</name><operator>::</operator><name>CheckTxInputs</name></name><argument_list>(<argument><expr><name>tx</name></expr></argument>, <argument><expr><name>dummy_state</name></expr></argument>, <argument><expr><name>mempoolDuplicate</name></expr></argument>, <argument><expr><name>spendheight</name></expr></argument>, <argument><expr><name>txfee</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>fCheckResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UpdateCoins</name><argument_list>(<argument><expr><name>tx</name></expr></argument>, <argument><expr><name>mempoolDuplicate</name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>numeric_limits</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list><operator>::</operator><name>max</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>check</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CCoinsViewCache</name> <modifier>*</modifier></type><name>pcoins</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nCheckFrequency</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>GetRand</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>numeric_limits</name><argument_list type="generic">&lt;<argument><expr><name>uint32_t</name></expr></argument>&gt;</argument_list><operator>::</operator><name>max</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>nCheckFrequency</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>MEMPOOL</name></name></expr></argument>, <argument><expr><literal type="string">"Checking mempool with %u transactions and %u inputs\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name><name>mapTx</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name><name>mapNextTx</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>uint64_t</name></type> <name>checkTotal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>innerUsage</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>CCoinsViewCache</name></type> <name>mempoolDuplicate</name><argument_list>(<argument><expr><cast type="const">const_cast<argument_list type="generic">&lt;<argument><expr><name>CCoinsViewCache</name><operator>*</operator></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name>pcoins</name></expr></argument>)</argument_list></cast></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>spendheight</name> <init>= <expr><call><name>GetSpendHeight</name><argument_list>(<argument><expr><name>mempoolDuplicate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>list</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CTxMemPoolEntry</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>waitingOnDependants</name></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name><name>indexed_transaction_set</name><operator>::</operator><name>const_iterator</name></name></type> <name>it</name> <init>= <expr><call><name><name>mapTx</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>it</name> <operator>!=</operator> <call><name><name>mapTx</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>it</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>checkTotal</name> <operator>+=</operator> <call><name><name>it</name><operator>-&gt;</operator><name>GetTxSize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>innerUsage</name> <operator>+=</operator> <call><name><name>it</name><operator>-&gt;</operator><name>DynamicMemoryUsage</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>CTransaction</name><modifier>&amp;</modifier></type> <name>tx</name> <init>= <expr><call><name><name>it</name><operator>-&gt;</operator><name>GetTx</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>txlinksMap</name><operator>::</operator><name>const_iterator</name></name></type> <name>linksiter</name> <init>= <expr><call><name><name>mapLinks</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>linksiter</name> <operator>!=</operator> <call><name><name>mapLinks</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>TxLinks</name> <modifier>&amp;</modifier></type><name>links</name> <init>= <expr><name><name>linksiter</name><operator>-&gt;</operator><name>second</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>innerUsage</name> <operator>+=</operator> <call><name><name>memusage</name><operator>::</operator><name>DynamicUsage</name></name><argument_list>(<argument><expr><name><name>links</name><operator>.</operator><name>parents</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name><name>memusage</name><operator>::</operator><name>DynamicUsage</name></name><argument_list>(<argument><expr><name><name>links</name><operator>.</operator><name>children</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>fDependsWait</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>setEntries</name></type> <name>setParentCheck</name></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CTxIn</name> <modifier>&amp;</modifier></type><name>txin</name> <range>: <expr><name><name>tx</name><operator>.</operator><name>vin</name></name></expr></range></decl></init>)</control> <block>{<block_content>
            <comment type="line">// Check that every mempool transaction's inputs refer to available coins, or other mempool tx's.</comment>
            <decl_stmt><decl><type><name><name>indexed_transaction_set</name><operator>::</operator><name>const_iterator</name></name></type> <name>it2</name> <init>= <expr><call><name><name>mapTx</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name><name>txin</name><operator>.</operator><name>prevout</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>it2</name> <operator>!=</operator> <call><name><name>mapTx</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>CTransaction</name><modifier>&amp;</modifier></type> <name>tx2</name> <init>= <expr><call><name><name>it2</name><operator>-&gt;</operator><name>GetTx</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>tx2</name><operator>.</operator><name>vout</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name><name>txin</name><operator>.</operator><name>prevout</name><operator>.</operator><name>n</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>tx2</name><operator>.</operator><name>vout</name><index>[<expr><name><name>txin</name><operator>.</operator><name>prevout</name><operator>.</operator><name>n</name></name></expr>]</index></name><operator>.</operator><call><name>IsNull</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>fDependsWait</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>setParentCheck</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>it2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>pcoins</name><operator>-&gt;</operator><name>HaveCoin</name></name><argument_list>(<argument><expr><name><name>txin</name><operator>.</operator><name>prevout</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <comment type="line">// Check whether its inputs are marked in mapNextTx.</comment>
            <decl_stmt><decl><type><name>auto</name></type> <name>it3</name> <init>= <expr><call><name><name>mapNextTx</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name><name>txin</name><operator>.</operator><name>prevout</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>it3</name> <operator>!=</operator> <call><name><name>mapNextTx</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>it3</name><operator>-&gt;</operator><name>first</name></name> <operator>==</operator> <operator>&amp;</operator><name><name>txin</name><operator>.</operator><name>prevout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>it3</name><operator>-&gt;</operator><name>second</name></name> <operator>==</operator> <operator>&amp;</operator><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>setParentCheck</name> <operator>==</operator> <call><name>GetMemPoolParents</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// Verify ancestor state is correct.</comment>
        <decl_stmt><decl><type><name>setEntries</name></type> <name>setAncestors</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>nNoLimit</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>numeric_limits</name><argument_list type="generic">&lt;<argument><expr><name>uint64_t</name></expr></argument>&gt;</argument_list><operator>::</operator><name>max</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>dummy</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>CalculateMemPoolAncestors</name><argument_list>(<argument><expr><operator>*</operator><name>it</name></expr></argument>, <argument><expr><name>setAncestors</name></expr></argument>, <argument><expr><name>nNoLimit</name></expr></argument>, <argument><expr><name>nNoLimit</name></expr></argument>, <argument><expr><name>nNoLimit</name></expr></argument>, <argument><expr><name>nNoLimit</name></expr></argument>, <argument><expr><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>nCountCheck</name> <init>= <expr><call><name><name>setAncestors</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>nSizeCheck</name> <init>= <expr><call><name><name>it</name><operator>-&gt;</operator><name>GetTxSize</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CAmount</name></type> <name>nFeesCheck</name> <init>= <expr><call><name><name>it</name><operator>-&gt;</operator><name>GetModifiedFee</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>nSigOpCheck</name> <init>= <expr><call><name><name>it</name><operator>-&gt;</operator><name>GetSigOpCost</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>txiter</name></type> <name>ancestorIt</name> <range>: <expr><name>setAncestors</name></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><name>nSizeCheck</name> <operator>+=</operator> <call><name><name>ancestorIt</name><operator>-&gt;</operator><name>GetTxSize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>nFeesCheck</name> <operator>+=</operator> <call><name><name>ancestorIt</name><operator>-&gt;</operator><name>GetModifiedFee</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>nSigOpCheck</name> <operator>+=</operator> <call><name><name>ancestorIt</name><operator>-&gt;</operator><name>GetSigOpCost</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>it</name><operator>-&gt;</operator><name>GetCountWithAncestors</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>nCountCheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>it</name><operator>-&gt;</operator><name>GetSizeWithAncestors</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>nSizeCheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>it</name><operator>-&gt;</operator><name>GetSigOpCostWithAncestors</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>nSigOpCheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>it</name><operator>-&gt;</operator><name>GetModFeesWithAncestors</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>nFeesCheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Check children against mapNextTx</comment>
        <decl_stmt><decl><type><name><name>CTxMemPool</name><operator>::</operator><name>setEntries</name></name></type> <name>setChildrenCheck</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>iter</name> <init>= <expr><call><name><name>mapNextTx</name><operator>.</operator><name>lower_bound</name></name><argument_list>(<argument><expr><call><name>COutPoint</name><argument_list>(<argument><expr><call><name><name>it</name><operator>-&gt;</operator><name>GetTx</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetHash</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>child_sizes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init>;</init> <condition><expr><name>iter</name> <operator>!=</operator> <call><name><name>mapNextTx</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>iter</name><operator>-&gt;</operator><name>first</name><operator>-&gt;</operator><name>hash</name></name> <operator>==</operator> <call><name><name>it</name><operator>-&gt;</operator><name>GetTx</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetHash</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>iter</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>txiter</name></type> <name>childit</name> <init>= <expr><call><name><name>mapTx</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><call><name><name>iter</name><operator>-&gt;</operator><name>second</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>childit</name> <operator>!=</operator> <call><name><name>mapTx</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// mapNextTx points to in-mempool transactions</comment>
            <if_stmt><if>if <condition>(<expr><call><name><name>setChildrenCheck</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>childit</name></expr></argument>)</argument_list></call><operator>.</operator><name>second</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>child_sizes</name> <operator>+=</operator> <call><name><name>childit</name><operator>-&gt;</operator><name>GetTxSize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>setChildrenCheck</name> <operator>==</operator> <call><name>GetMemPoolChildren</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// Also check to make sure size is greater than sum with immediate children.</comment>
        <comment type="line">// just a sanity check, not definitive that this calc is correct...</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>it</name><operator>-&gt;</operator><name>GetSizeWithDescendants</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>child_sizes</name> <operator>+</operator> <call><name><name>it</name><operator>-&gt;</operator><name>GetTxSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>fDependsWait</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>waitingOnDependants</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>CheckInputsAndUpdateCoins</name><argument_list>(<argument><expr><name>tx</name></expr></argument>, <argument><expr><name>mempoolDuplicate</name></expr></argument>, <argument><expr><name>spendheight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>stepsSinceLastRemove</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><operator>!</operator><call><name><name>waitingOnDependants</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>CTxMemPoolEntry</name><modifier>*</modifier></type> <name>entry</name> <init>= <expr><call><name><name>waitingOnDependants</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>waitingOnDependants</name><operator>.</operator><name>pop_front</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>mempoolDuplicate</name><operator>.</operator><name>HaveInputs</name></name><argument_list>(<argument><expr><call><name><name>entry</name><operator>-&gt;</operator><name>GetTx</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>waitingOnDependants</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>stepsSinceLastRemove</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>stepsSinceLastRemove</name> <operator>&lt;</operator> <call><name><name>waitingOnDependants</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>CheckInputsAndUpdateCoins</name><argument_list>(<argument><expr><call><name><name>entry</name><operator>-&gt;</operator><name>GetTx</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>mempoolDuplicate</name></expr></argument>, <argument><expr><name>spendheight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>stepsSinceLastRemove</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>it</name> <init>= <expr><call><name><name>mapNextTx</name><operator>.</operator><name>cbegin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>it</name> <operator>!=</operator> <call><name><name>mapNextTx</name><operator>.</operator><name>cend</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>it</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>uint256</name></type> <name>hash</name> <init>= <expr><call><name><name>it</name><operator>-&gt;</operator><name>second</name><operator>-&gt;</operator><name>GetHash</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>indexed_transaction_set</name><operator>::</operator><name>const_iterator</name></name></type> <name>it2</name> <init>= <expr><call><name><name>mapTx</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>CTransaction</name><modifier>&amp;</modifier></type> <name>tx</name> <init>= <expr><call><name><name>it2</name><operator>-&gt;</operator><name>GetTx</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>it2</name> <operator>!=</operator> <call><name><name>mapTx</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tx</name> <operator>==</operator> <name><name>it</name><operator>-&gt;</operator><name>second</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>totalTxSize</name> <operator>==</operator> <name>checkTotal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>innerUsage</name> <operator>==</operator> <name>cachedInnerUsage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>CompareDepthAndScore</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint256</name><modifier>&amp;</modifier></type> <name>hasha</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint256</name><modifier>&amp;</modifier></type> <name>hashb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>indexed_transaction_set</name><operator>::</operator><name>const_iterator</name></name></type> <name>i</name> <init>= <expr><call><name><name>mapTx</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>hasha</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <call><name><name>mapTx</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name><name>indexed_transaction_set</name><operator>::</operator><name>const_iterator</name></name></type> <name>j</name> <init>= <expr><call><name><name>mapTx</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>hashb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <call><name><name>mapTx</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>counta</name> <init>= <expr><call><name><name>i</name><operator>-&gt;</operator><name>GetCountWithAncestors</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>countb</name> <init>= <expr><call><name><name>j</name><operator>-&gt;</operator><name>GetCountWithAncestors</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>counta</name> <operator>==</operator> <name>countb</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><call><name>CompareTxMemPoolEntryByScore</name><argument_list>()</argument_list></call><argument_list>(<argument><expr><operator>*</operator><name>i</name></expr></argument>, <argument><expr><operator>*</operator><name>j</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>counta</name> <operator>&lt;</operator> <name>countb</name></expr>;</return>
</block_content>}</block></function>

<namespace>namespace <block>{
<class>class <name>DepthAndScoreComparator</name>
<block>{<private type="default">
</private><public>public:
    <function type="operator"><type><name>bool</name></type> <name>operator<name>()</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>CTxMemPool</name><operator>::</operator><name>indexed_transaction_set</name><operator>::</operator><name>const_iterator</name></name><modifier>&amp;</modifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>CTxMemPool</name><operator>::</operator><name>indexed_transaction_set</name><operator>::</operator><name>const_iterator</name></name><modifier>&amp;</modifier></type> <name>b</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>counta</name> <init>= <expr><call><name><name>a</name><operator>-&gt;</operator><name>GetCountWithAncestors</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>countb</name> <init>= <expr><call><name><name>b</name><operator>-&gt;</operator><name>GetCountWithAncestors</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>counta</name> <operator>==</operator> <name>countb</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><call><call><name>CompareTxMemPoolEntryByScore</name><argument_list>()</argument_list></call><argument_list>(<argument><expr><operator>*</operator><name>a</name></expr></argument>, <argument><expr><operator>*</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>counta</name> <operator>&lt;</operator> <name>countb</name></expr>;</return>
    </block_content>}</block></function>
</public>}</block>;</class>
}</block></namespace> <comment type="line">// namespace</comment>

<function><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>CTxMemPool</name><operator>::</operator><name>indexed_transaction_set</name><operator>::</operator><name>const_iterator</name></name></expr></argument>&gt;</argument_list></name></type> <name><name>CTxMemPool</name><operator>::</operator><name>GetSortedDepthAndScore</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>indexed_transaction_set</name><operator>::</operator><name>const_iterator</name></name></expr></argument>&gt;</argument_list></name></type> <name>iters</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>AssertLockHeld</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>iters</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>mapTx</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><decl><type><name><name>indexed_transaction_set</name><operator>::</operator><name>iterator</name></name></type> <name>mi</name> <init>= <expr><call><name><name>mapTx</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>mi</name> <operator>!=</operator> <call><name><name>mapTx</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>mi</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>iters</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>mi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name><name>std</name><operator>::</operator><name>sort</name></name><argument_list>(<argument><expr><call><name><name>iters</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>iters</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>DepthAndScoreComparator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>iters</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>queryHashes</name></name><parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>vtxid</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>iters</name> <init>= <expr><call><name>GetSortedDepthAndScore</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name><name>vtxid</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>vtxid</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>mapTx</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><decl><type><name>auto</name></type> <name>it</name> <range>: <expr><name>iters</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>vtxid</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>it</name><operator>-&gt;</operator><name>GetTx</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetHash</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TxMempoolInfo</name></type> <name>GetInfo</name><parameter_list>(<parameter><decl><type><name><name>CTxMemPool</name><operator>::</operator><name>indexed_transaction_set</name><operator>::</operator><name>const_iterator</name></name></type> <name>it</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>TxMempoolInfo</name><argument_list>{<argument><expr><call><name><name>it</name><operator>-&gt;</operator><name>GetSharedTx</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>it</name><operator>-&gt;</operator><name>GetTime</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>it</name><operator>-&gt;</operator><name>GetFee</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>it</name><operator>-&gt;</operator><name>GetTxSize</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>it</name><operator>-&gt;</operator><name>GetModifiedFee</name></name><argument_list>()</argument_list></call> <operator>-</operator> <macro><name>it</name></macro><operator>-&gt;</operator><macro><name>GetFee</name><argument_list>()</argument_list></macro></expr></argument>}</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>TxMempoolInfo</name></expr></argument>&gt;</argument_list></name></type> <name><name>CTxMemPool</name><operator>::</operator><name>infoAll</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>iters</name> <init>= <expr><call><name>GetSortedDepthAndScore</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>TxMempoolInfo</name></expr></argument>&gt;</argument_list></name></type> <name>ret</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>ret</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>mapTx</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>it</name> <range>: <expr><name>iters</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>ret</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>GetInfo</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>CTransactionRef</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>get</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint256</name><modifier>&amp;</modifier></type> <name>hash</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>indexed_transaction_set</name><operator>::</operator><name>const_iterator</name></name></type> <name>i</name> <init>= <expr><call><name><name>mapTx</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <call><name><name>mapTx</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="null">nullptr</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name><name>i</name><operator>-&gt;</operator><name>GetSharedTx</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>TxMempoolInfo</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>info</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint256</name><modifier>&amp;</modifier></type> <name>hash</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>indexed_transaction_set</name><operator>::</operator><name>const_iterator</name></name></type> <name>i</name> <init>= <expr><call><name><name>mapTx</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <call><name><name>mapTx</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>TxMempoolInfo</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>GetInfo</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>PrioritiseTransaction</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint256</name><modifier>&amp;</modifier></type> <name>hash</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CAmount</name><modifier>&amp;</modifier></type> <name>nFeeDelta</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>CAmount</name> <modifier>&amp;</modifier></type><name>delta</name> <init>= <expr><name><name>mapDeltas</name><index>[<expr><name>hash</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>delta</name> <operator>+=</operator> <name>nFeeDelta</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>txiter</name></type> <name>it</name> <init>= <expr><call><name><name>mapTx</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>it</name> <operator>!=</operator> <call><name><name>mapTx</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>mapTx</name><operator>.</operator><name>modify</name></name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><call><name>update_fee_delta</name><argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// Now update all ancestors' modified fees with descendants</comment>
            <decl_stmt><decl><type><name>setEntries</name></type> <name>setAncestors</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uint64_t</name></type> <name>nNoLimit</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>numeric_limits</name><argument_list type="generic">&lt;<argument><expr><name>uint64_t</name></expr></argument>&gt;</argument_list><operator>::</operator><name>max</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>dummy</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>CalculateMemPoolAncestors</name><argument_list>(<argument><expr><operator>*</operator><name>it</name></expr></argument>, <argument><expr><name>setAncestors</name></expr></argument>, <argument><expr><name>nNoLimit</name></expr></argument>, <argument><expr><name>nNoLimit</name></expr></argument>, <argument><expr><name>nNoLimit</name></expr></argument>, <argument><expr><name>nNoLimit</name></expr></argument>, <argument><expr><name>dummy</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>txiter</name></type> <name>ancestorIt</name> <range>: <expr><name>setAncestors</name></expr></range></decl></init>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name><name>mapTx</name><operator>.</operator><name>modify</name></name><argument_list>(<argument><expr><name>ancestorIt</name></expr></argument>, <argument><expr><call><name>update_descendant_state</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nFeeDelta</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <comment type="line">// Now update all descendants' modified fees with ancestors</comment>
            <decl_stmt><decl><type><name>setEntries</name></type> <name>setDescendants</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>CalculateDescendants</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><name>setDescendants</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>setDescendants</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>txiter</name></type> <name>descendantIt</name> <range>: <expr><name>setDescendants</name></expr></range></decl></init>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name><name>mapTx</name><operator>.</operator><name>modify</name></name><argument_list>(<argument><expr><name>descendantIt</name></expr></argument>, <argument><expr><call><name>update_ancestor_state</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nFeeDelta</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><operator>++</operator><name>nTransactionsUpdated</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>LogPrintf</name><argument_list>(<argument><expr><literal type="string">"PrioritiseTransaction: %s feerate += %s\n"</literal></expr></argument>, <argument><expr><call><name><name>hash</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>FormatMoney</name><argument_list>(<argument><expr><name>nFeeDelta</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>ApplyDelta</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint256</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>CAmount</name> <modifier>&amp;</modifier></type><name>nFeeDelta</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>map</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>, <argument><expr><name>CAmount</name></expr></argument>&gt;</argument_list><operator>::</operator><name>const_iterator</name></name></type> <name>pos</name> <init>= <expr><call><name><name>mapDeltas</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>==</operator> <call><name><name>mapDeltas</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CAmount</name> <modifier>&amp;</modifier></type><name>delta</name> <init>= <expr><name><name>pos</name><operator>-&gt;</operator><name>second</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>nFeeDelta</name> <operator>+=</operator> <name>delta</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>ClearPrioritisation</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint256</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mapDeltas</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>CTransaction</name><modifier>*</modifier></type> <name><name>CTxMemPool</name><operator>::</operator><name>GetConflictTx</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>COutPoint</name><modifier>&amp;</modifier></type> <name>prevout</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>it</name> <init>= <expr><call><name><name>mapNextTx</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>prevout</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><ternary><condition><expr><name>it</name> <operator>==</operator> <call><name><name>mapNextTx</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="null">nullptr</literal></expr> </then><else>: <expr><name><name>it</name><operator>-&gt;</operator><name>second</name></name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name><name>CTxMemPool</name><operator>::</operator><name>txiter</name></name></expr></argument>&gt;</argument_list></name></type> <name><name>CTxMemPool</name><operator>::</operator><name>GetIter</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint256</name><modifier>&amp;</modifier></type> <name>txid</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <decl_stmt><decl><type><name>auto</name></type> <name>it</name> <init>= <expr><call><name><name>mapTx</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>txid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>it</name> <operator>!=</operator> <call><name><name>mapTx</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>it</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>txiter</name></expr></argument>&gt;</argument_list></name><argument_list>{}</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>CTxMemPool</name><operator>::</operator><name>setEntries</name></name></type> <name><name>CTxMemPool</name><operator>::</operator><name>GetIterSet</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>set</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>hashes</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>CTxMemPool</name><operator>::</operator><name>setEntries</name></name></type> <name>ret</name></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>&amp;</modifier></type> <name>h</name> <range>: <expr><name>hashes</name></expr></range></decl></init>)</control> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>mi</name> <init>= <expr><call><name>GetIter</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>mi</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>ret</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><operator>*</operator><name>mi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>HasNoInputsOf</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CTransaction</name> <modifier>&amp;</modifier></type><name>tx</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>tx</name><operator>.</operator><name>vin</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><call><name>exists</name><argument_list>(<argument><expr><name><name>tx</name><operator>.</operator><name>vin</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>prevout</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
</block_content>}</block></function>

<constructor><name><name>CCoinsViewMemPool</name><operator>::</operator><name>CCoinsViewMemPool</name></name><parameter_list>(<parameter><decl><type><name>CCoinsView</name><modifier>*</modifier></type> <name>baseIn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CTxMemPool</name><modifier>&amp;</modifier></type> <name>mempoolIn</name></decl></parameter>)</parameter_list> <member_init_list>: <call><name>CCoinsViewBacked</name><argument_list>(<argument><expr><name>baseIn</name></expr></argument>)</argument_list></call>, <call><name>mempool</name><argument_list>(<argument><expr><name>mempoolIn</name></expr></argument>)</argument_list></call> </member_init_list><block>{<block_content> </block_content>}</block></constructor>

<function><type><name>bool</name></type> <name><name>CCoinsViewMemPool</name><operator>::</operator><name>GetCoin</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>COutPoint</name> <modifier>&amp;</modifier></type><name>outpoint</name></decl></parameter>, <parameter><decl><type><name>Coin</name> <modifier>&amp;</modifier></type><name>coin</name></decl></parameter>)</parameter_list> <specifier>const</specifier> <block>{<block_content>
    <comment type="line">// If an entry in the mempool exists, always return that one, as it's guaranteed to never</comment>
    <comment type="line">// conflict with the underlying cache, and it cannot have pruned entries (as it contains full)</comment>
    <comment type="line">// transactions. First checking the underlying cache risks returning a pruned entry instead.</comment>
    <decl_stmt><decl><type><name>CTransactionRef</name></type> <name>ptx</name> <init>= <expr><call><name><name>mempool</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>outpoint</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>ptx</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>outpoint</name><operator>.</operator><name>n</name></name> <operator>&lt;</operator> <call><name><name>ptx</name><operator>-&gt;</operator><name>vout</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>coin</name> <operator>=</operator> <call><name>Coin</name><argument_list>(<argument><expr><name><name>ptx</name><operator>-&gt;</operator><name>vout</name><index>[<expr><name><name>outpoint</name><operator>.</operator><name>n</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>MEMPOOL_HEIGHT</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name><name>base</name><operator>-&gt;</operator><name>GetCoin</name></name><argument_list>(<argument><expr><name>outpoint</name></expr></argument>, <argument><expr><name>coin</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>DynamicMemoryUsage</name></name><parameter_list>()</parameter_list> <specifier>const</specifier> <block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Estimate the overhead of mapTx to be 12 pointers + an allocation, as no exact formula for boost::multi_index_contained is implemented.</comment>
    <return>return <expr><call><name><name>memusage</name><operator>::</operator><name>MallocUsage</name></name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CTxMemPoolEntry</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">12</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>*</operator> <call><name><name>mapTx</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>+</operator> <call><name><name>memusage</name><operator>::</operator><name>DynamicUsage</name></name><argument_list>(<argument><expr><name>mapNextTx</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name><name>memusage</name><operator>::</operator><name>DynamicUsage</name></name><argument_list>(<argument><expr><name>mapDeltas</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name><name>memusage</name><operator>::</operator><name>DynamicUsage</name></name><argument_list>(<argument><expr><name>mapLinks</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name><name>memusage</name><operator>::</operator><name>DynamicUsage</name></name><argument_list>(<argument><expr><name>vTxHashes</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>cachedInnerUsage</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>RemoveStaged</name></name><parameter_list>(<parameter><decl><type><name>setEntries</name> <modifier>&amp;</modifier></type><name>stage</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>updateDescendants</name></decl></parameter>, <parameter><decl><type><name>MemPoolRemovalReason</name></type> <name>reason</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>AssertLockHeld</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UpdateForRemoveFromMempool</name><argument_list>(<argument><expr><name>stage</name></expr></argument>, <argument><expr><name>updateDescendants</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>txiter</name></type> <name>it</name> <range>: <expr><name>stage</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>removeUnchecked</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>int</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>Expire</name></name><parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>seconds</name></name></type> <name>time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>AssertLockHeld</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>indexed_transaction_set</name><operator>::</operator><name>index</name><argument_list type="generic">&lt;<argument><expr><name>entry_time</name></expr></argument>&gt;</argument_list><operator>::</operator><name>type</name><operator>::</operator><name>iterator</name></name></type> <name>it</name> <init>= <expr><call><name><name>mapTx</name><operator>.</operator><name>get</name><argument_list type="generic">&lt;<argument><expr><name>entry_time</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>setEntries</name></type> <name>toremove</name></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>it</name> <operator>!=</operator> <call><name><name>mapTx</name><operator>.</operator><name>get</name><argument_list type="generic">&lt;<argument><expr><name>entry_time</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>it</name><operator>-&gt;</operator><name>GetTime</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>time</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>toremove</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>mapTx</name><operator>.</operator><name>project</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>it</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <decl_stmt><decl><type><name>setEntries</name></type> <name>stage</name></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>txiter</name></type> <name>removeit</name> <range>: <expr><name>toremove</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>CalculateDescendants</name><argument_list>(<argument><expr><name>removeit</name></expr></argument>, <argument><expr><name>stage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>RemoveStaged</name><argument_list>(<argument><expr><name>stage</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name><name>MemPoolRemovalReason</name><operator>::</operator><name>EXPIRY</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name><name>stage</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>addUnchecked</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CTxMemPoolEntry</name> <modifier>&amp;</modifier></type><name>entry</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>validFeeEstimate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>setEntries</name></type> <name>setAncestors</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>nNoLimit</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>numeric_limits</name><argument_list type="generic">&lt;<argument><expr><name>uint64_t</name></expr></argument>&gt;</argument_list><operator>::</operator><name>max</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>dummy</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>CalculateMemPoolAncestors</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>setAncestors</name></expr></argument>, <argument><expr><name>nNoLimit</name></expr></argument>, <argument><expr><name>nNoLimit</name></expr></argument>, <argument><expr><name>nNoLimit</name></expr></argument>, <argument><expr><name>nNoLimit</name></expr></argument>, <argument><expr><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>addUnchecked</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>setAncestors</name></expr></argument>, <argument><expr><name>validFeeEstimate</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>UpdateChild</name></name><parameter_list>(<parameter><decl><type><name>txiter</name></type> <name>entry</name></decl></parameter>, <parameter><decl><type><name>txiter</name></type> <name>child</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>add</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>setEntries</name></type> <name>s</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>add</name> <operator>&amp;&amp;</operator> <name><name>mapLinks</name><index>[<expr><name>entry</name></expr>]</index></name><operator>.</operator><call><name><name>children</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call><operator>.</operator><name>second</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>cachedInnerUsage</name> <operator>+=</operator> <call><name><name>memusage</name><operator>::</operator><name>IncrementalDynamicUsage</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>add</name> <operator>&amp;&amp;</operator> <name><name>mapLinks</name><index>[<expr><name>entry</name></expr>]</index></name><operator>.</operator><call><name><name>children</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>cachedInnerUsage</name> <operator>-=</operator> <call><name><name>memusage</name><operator>::</operator><name>IncrementalDynamicUsage</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>UpdateParent</name></name><parameter_list>(<parameter><decl><type><name>txiter</name></type> <name>entry</name></decl></parameter>, <parameter><decl><type><name>txiter</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>add</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>setEntries</name></type> <name>s</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>add</name> <operator>&amp;&amp;</operator> <name><name>mapLinks</name><index>[<expr><name>entry</name></expr>]</index></name><operator>.</operator><call><name><name>parents</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call><operator>.</operator><name>second</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>cachedInnerUsage</name> <operator>+=</operator> <call><name><name>memusage</name><operator>::</operator><name>IncrementalDynamicUsage</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>add</name> <operator>&amp;&amp;</operator> <name><name>mapLinks</name><index>[<expr><name>entry</name></expr>]</index></name><operator>.</operator><call><name><name>parents</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>cachedInnerUsage</name> <operator>-=</operator> <call><name><name>memusage</name><operator>::</operator><name>IncrementalDynamicUsage</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name><name>CTxMemPool</name><operator>::</operator><name>setEntries</name></name> <modifier>&amp;</modifier></type> <name><name>CTxMemPool</name><operator>::</operator><name>GetMemPoolParents</name></name><parameter_list>(<parameter><decl><type><name>txiter</name></type> <name>entry</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>entry</name> <operator>!=</operator> <call><name><name>mapTx</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>txlinksMap</name><operator>::</operator><name>const_iterator</name></name></type> <name>it</name> <init>= <expr><call><name><name>mapLinks</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>it</name> <operator>!=</operator> <call><name><name>mapLinks</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>it</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>parents</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name><name>CTxMemPool</name><operator>::</operator><name>setEntries</name></name> <modifier>&amp;</modifier></type> <name><name>CTxMemPool</name><operator>::</operator><name>GetMemPoolChildren</name></name><parameter_list>(<parameter><decl><type><name>txiter</name></type> <name>entry</name></decl></parameter>)</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>entry</name> <operator>!=</operator> <call><name><name>mapTx</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>txlinksMap</name><operator>::</operator><name>const_iterator</name></name></type> <name>it</name> <init>= <expr><call><name><name>mapLinks</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>it</name> <operator>!=</operator> <call><name><name>mapLinks</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>it</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>children</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>CFeeRate</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>GetMinFee</name></name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>sizelimit</name></decl></parameter>)</parameter_list> <specifier>const</specifier> <block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>blockSinceLastRollingFeeBump</name> <operator>||</operator> <name>rollingMinimumFeeRate</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>CFeeRate</name><argument_list>(<argument><expr><call><name>llround</name><argument_list>(<argument><expr><name>rollingMinimumFeeRate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>time</name> <init>= <expr><call><name>GetTime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>time</name> <operator>&gt;</operator> <name>lastRollingFeeUpdate</name> <operator>+</operator> <literal type="number">10</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>double</name></type> <name>halflife</name> <init>= <expr><name>ROLLING_FEE_HALFLIFE</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>DynamicMemoryUsage</name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>sizelimit</name> <operator>/</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>halflife</name> <operator>/=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>DynamicMemoryUsage</name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>sizelimit</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>halflife</name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>rollingMinimumFeeRate</name> <operator>=</operator> <name>rollingMinimumFeeRate</name> <operator>/</operator> <call><name>pow</name><argument_list>(<argument><expr><literal type="number">2.0</literal></expr></argument>, <argument><expr><operator>(</operator><name>time</name> <operator>-</operator> <name>lastRollingFeeUpdate</name><operator>)</operator> <operator>/</operator> <name>halflife</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>lastRollingFeeUpdate</name> <operator>=</operator> <name>time</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>rollingMinimumFeeRate</name> <operator>&lt;</operator> <operator>(</operator><name>double</name><operator>)</operator><call><name><name>incrementalRelayFee</name><operator>.</operator><name>GetFeePerK</name></name><argument_list>()</argument_list></call> <operator>/</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>rollingMinimumFeeRate</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <return>return <expr><call><name>CFeeRate</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name><name>std</name><operator>::</operator><name>max</name></name><argument_list>(<argument><expr><call><name>CFeeRate</name><argument_list>(<argument><expr><call><name>llround</name><argument_list>(<argument><expr><name>rollingMinimumFeeRate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>incrementalRelayFee</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>trackPackageRemoved</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CFeeRate</name><modifier>&amp;</modifier></type> <name>rate</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>AssertLockHeld</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>rate</name><operator>.</operator><name>GetFeePerK</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>rollingMinimumFeeRate</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>rollingMinimumFeeRate</name> <operator>=</operator> <call><name><name>rate</name><operator>.</operator><name>GetFeePerK</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>blockSinceLastRollingFeeBump</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>TrimToSize</name></name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>sizelimit</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>COutPoint</name></expr></argument>&gt;</argument_list></name><modifier>*</modifier></type> <name>pvNoSpendsRemaining</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>AssertLockHeld</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>unsigned</name></type> <name>nTxnRemoved</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CFeeRate</name></type> <name>maxFeeRateRemoved</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <while>while <condition>(<expr><operator>!</operator><call><name><name>mapTx</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>DynamicMemoryUsage</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>sizelimit</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name><name>indexed_transaction_set</name><operator>::</operator><name>index</name><argument_list type="generic">&lt;<argument><expr><name>descendant_score</name></expr></argument>&gt;</argument_list><operator>::</operator><name>type</name><operator>::</operator><name>iterator</name></name></type> <name>it</name> <init>= <expr><call><name><name>mapTx</name><operator>.</operator><name>get</name><argument_list type="generic">&lt;<argument><expr><name>descendant_score</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// We set the new mempool min fee to the feerate of the removed set, plus the</comment>
        <comment type="line">// "minimum reasonable fee rate" (ie some value under which we consider txn</comment>
        <comment type="line">// to have 0 fee). This way, we don't allow txn to enter mempool with feerate</comment>
        <comment type="line">// equal to txn which were removed with no block in between.</comment>
        <decl_stmt><decl><type><name>CFeeRate</name></type> <name>removed</name><argument_list>(<argument><expr><call><name><name>it</name><operator>-&gt;</operator><name>GetModFeesWithDescendants</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>it</name><operator>-&gt;</operator><name>GetSizeWithDescendants</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <expr_stmt><expr><name>removed</name> <operator>+=</operator> <name>incrementalRelayFee</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>trackPackageRemoved</name><argument_list>(<argument><expr><name>removed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>maxFeeRateRemoved</name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>max</name></name><argument_list>(<argument><expr><name>maxFeeRateRemoved</name></expr></argument>, <argument><expr><name>removed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>setEntries</name></type> <name>stage</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>CalculateDescendants</name><argument_list>(<argument><expr><call><name><name>mapTx</name><operator>.</operator><name>project</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nTxnRemoved</name> <operator>+=</operator> <call><name><name>stage</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CTransaction</name></expr></argument>&gt;</argument_list></name></type> <name>txn</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>pvNoSpendsRemaining</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>txn</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>stage</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>txiter</name></type> <name>iter</name> <range>: <expr><name>stage</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name><name>txn</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>iter</name><operator>-&gt;</operator><name>GetTx</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>RemoveStaged</name><argument_list>(<argument><expr><name>stage</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name><name>MemPoolRemovalReason</name><operator>::</operator><name>SIZELIMIT</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>pvNoSpendsRemaining</name></expr>)</condition> <block>{<block_content>
            <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CTransaction</name><modifier>&amp;</modifier></type> <name>tx</name> <range>: <expr><name>txn</name></expr></range></decl></init>)</control> <block>{<block_content>
                <for>for <control>(<init><decl><type><specifier>const</specifier> <name>CTxIn</name><modifier>&amp;</modifier></type> <name>txin</name> <range>: <expr><name><name>tx</name><operator>.</operator><name>vin</name></name></expr></range></decl></init>)</control> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>exists</name><argument_list>(<argument><expr><name><name>txin</name><operator>.</operator><name>prevout</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name><name>pvNoSpendsRemaining</name><operator>-&gt;</operator><name>push_back</name></name><argument_list>(<argument><expr><name><name>txin</name><operator>.</operator><name>prevout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><name>maxFeeRateRemoved</name> <operator>&gt;</operator> <call><name>CFeeRate</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>LogPrint</name><argument_list>(<argument><expr><name><name>BCLog</name><operator>::</operator><name>MEMPOOL</name></name></expr></argument>, <argument><expr><literal type="string">"Removed %u txn, rolling minimum fee bumped to %s\n"</literal></expr></argument>, <argument><expr><name>nTxnRemoved</name></expr></argument>, <argument><expr><call><name><name>maxFeeRateRemoved</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>uint64_t</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>CalculateDescendantMaximum</name></name><parameter_list>(<parameter><decl><type><name>txiter</name></type> <name>entry</name></decl></parameter>)</parameter_list> <specifier>const</specifier> <block>{<block_content>
    <comment type="line">// find parent with highest descendant count</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>txiter</name></expr></argument>&gt;</argument_list></name></type> <name>candidates</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>setEntries</name></type> <name>counted</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>candidates</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>maximum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><call><name><name>candidates</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>txiter</name></type> <name>candidate</name> <init>= <expr><call><name><name>candidates</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>candidates</name><operator>.</operator><name>pop_back</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>counted</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call><operator>.</operator><name>second</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>setEntries</name><modifier>&amp;</modifier></type> <name>parents</name> <init>= <expr><call><name>GetMemPoolParents</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>parents</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>maximum</name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>max</name></name><argument_list>(<argument><expr><name>maximum</name></expr></argument>, <argument><expr><call><name><name>candidate</name><operator>-&gt;</operator><name>GetCountWithDescendants</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <for>for <control>(<init><decl><type><name>txiter</name></type> <name>i</name> <range>: <expr><name>parents</name></expr></range></decl></init>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name><name>candidates</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>maximum</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>GetTransactionAncestry</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint256</name><modifier>&amp;</modifier></type> <name>txid</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>&amp;</modifier></type> <name>ancestors</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>&amp;</modifier></type> <name>descendants</name></decl></parameter>)</parameter_list> <specifier>const</specifier> <block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>it</name> <init>= <expr><call><name><name>mapTx</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>txid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>ancestors</name> <operator>=</operator> <name>descendants</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>it</name> <operator>!=</operator> <call><name><name>mapTx</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>ancestors</name> <operator>=</operator> <call><name><name>it</name><operator>-&gt;</operator><name>GetCountWithAncestors</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>descendants</name> <operator>=</operator> <call><name>CalculateDescendantMaximum</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>IsLoaded</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>m_is_loaded</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name><name>CTxMemPool</name><operator>::</operator><name>SetIsLoaded</name></name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>loaded</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>m_is_loaded</name> <operator>=</operator> <name>loaded</name></expr>;</expr_stmt>
</block_content>}</block></function>

<constructor><name><name>SaltedTxidHasher</name><operator>::</operator><name>SaltedTxidHasher</name></name><parameter_list>()</parameter_list> <member_init_list>: <call><name>k0</name><argument_list>(<argument><expr><call><name>GetRand</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>numeric_limits</name><argument_list type="generic">&lt;<argument><expr><name>uint64_t</name></expr></argument>&gt;</argument_list><operator>::</operator><name>max</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>, <call><name>k1</name><argument_list>(<argument><expr><call><name>GetRand</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>numeric_limits</name><argument_list type="generic">&lt;<argument><expr><name>uint64_t</name></expr></argument>&gt;</argument_list><operator>::</operator><name>max</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> </member_init_list><block>{<block_content/>}</block></constructor>
</unit>
