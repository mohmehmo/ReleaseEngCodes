<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/mmm/Projects/bitcoin/src/net.h"><comment type="line">// Copyright (c) 2009-2010 Satoshi Nakamoto</comment>
<comment type="line">// Copyright (c) 2009-2019 The Bitcoin Core developers</comment>
<comment type="line">// Distributed under the MIT software license, see the accompanying</comment>
<comment type="line">// file COPYING or http://www.opensource.org/licenses/mit-license.php.</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>BITCOIN_NET_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITCOIN_NET_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;addrdb.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;addrman.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;amount.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;bloom.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;compat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;crypto/siphash.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;hash.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limitedmap.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netaddress.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;net_permissions.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;policy/feerate.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;protocol.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;random.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;streams.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sync.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;uint256.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;threadinterrupt.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;atomic&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;deque&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;thread&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;memory&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;condition_variable&gt;</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;arpa/inet.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<decl_stmt><decl><type><name>class</name></type> <name>CScheduler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CNode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>BanMan</name></decl>;</decl_stmt>

<comment type="block" format="doxygen">/** Default for -whitelistrelay. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name>DEFAULT_WHITELISTRELAY</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** Default for -whitelistforcerelay. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name>DEFAULT_WHITELISTFORCERELAY</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block" format="doxygen">/** Time between pings automatically sent out for latency probing and keepalive (in seconds). */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>PING_INTERVAL</name> <init>= <expr><literal type="number">2</literal> <operator>*</operator> <literal type="number">60</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** Time after which to disconnect, after waiting for a ping response (or inactivity). */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>TIMEOUT_INTERVAL</name> <init>= <expr><literal type="number">20</literal> <operator>*</operator> <literal type="number">60</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** Run the feeler connection loop once every 2 minutes or 120 seconds. **/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>FEELER_INTERVAL</name> <init>= <expr><literal type="number">120</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** The maximum number of entries in an 'inv' protocol message */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>MAX_INV_SZ</name> <init>= <expr><literal type="number">50000</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** The maximum number of entries in a locator */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>MAX_LOCATOR_SZ</name> <init>= <expr><literal type="number">101</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** The maximum number of new addresses to accumulate before announcing. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>MAX_ADDR_TO_SEND</name> <init>= <expr><literal type="number">1000</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** Maximum length of incoming protocol messages (no message over 4 MB is currently acceptable). */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>MAX_PROTOCOL_MESSAGE_LENGTH</name> <init>= <expr><literal type="number">4</literal> <operator>*</operator> <literal type="number">1000</literal> <operator>*</operator> <literal type="number">1000</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** Maximum length of the user agent string in `version` message */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>MAX_SUBVERSION_LENGTH</name> <init>= <expr><literal type="number">256</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** Maximum number of automatic outgoing nodes over which we'll relay everything (blocks, tx, addrs, etc) */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>MAX_OUTBOUND_FULL_RELAY_CONNECTIONS</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** Maximum number of addnode outgoing nodes */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>MAX_ADDNODE_CONNECTIONS</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** Maximum number of block-relay-only outgoing connections */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>MAX_BLOCKS_ONLY_CONNECTIONS</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** -listen default */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name>DEFAULT_LISTEN</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** -upnp default */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_UPNP</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name>DEFAULT_UPNP</name> <init>= <expr><name>USE_UPNP</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name>DEFAULT_UPNP</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block" format="doxygen">/** The maximum number of peer connections to maintain. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>DEFAULT_MAX_PEER_CONNECTIONS</name> <init>= <expr><literal type="number">125</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** The default for -maxuploadtarget. 0 = Unlimited */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint64_t</name></type> <name>DEFAULT_MAX_UPLOAD_TARGET</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** The default timeframe for -maxuploadtarget. 1 day. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint64_t</name></type> <name>MAX_UPLOAD_TIMEFRAME</name> <init>= <expr><literal type="number">60</literal> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">24</literal></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** Default for blocks only*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name>DEFAULT_BLOCKSONLY</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<comment type="block" format="doxygen">/** -peertimeout default */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int64_t</name></type> <name>DEFAULT_PEER_CONNECT_TIMEOUT</name> <init>= <expr><literal type="number">60</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name>DEFAULT_FORCEDNSSEED</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>DEFAULT_MAXRECEIVEBUFFER</name> <init>= <expr><literal type="number">5</literal> <operator>*</operator> <literal type="number">1000</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>DEFAULT_MAXSENDBUFFER</name>    <init>= <expr><literal type="number">1</literal> <operator>*</operator> <literal type="number">1000</literal></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><name>int64_t</name></type> <name>NodeId</name>;</typedef>

<struct>struct <name>AddedNodeInfo</name>
<block>{
    <expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>strAddedNode</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>CService</name></type> <name>resolvedAddress</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>fConnected</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>fInbound</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><name>class</name></type> <name>CNodeStats</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CClientUIInterface</name></decl>;</decl_stmt>

<struct>struct <name>CSerializedNetMsg</name>
<block>{
    <expr_stmt><expr><call><name>CSerializedNetMsg</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CSerializedNetMsg</name><argument_list>(<argument><expr><name>CSerializedNetMsg</name><operator>&amp;&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>
    <decl_stmt><decl><type><name>CSerializedNetMsg</name><modifier>&amp;</modifier></type> <name>operator</name><init>=<expr><operator>(</operator><name>CSerializedNetMsg</name><operator>&amp;&amp;</operator><operator>)</operator> <operator>=</operator> default</expr></init></decl>;</decl_stmt>
    <comment type="line">// No copying, only moves.</comment>
    <expr_stmt><expr><call><name>CSerializedNetMsg</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CSerializedNetMsg</name><operator>&amp;</operator> <name>msg</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>CSerializedNetMsg</name><modifier>&amp;</modifier></type> <name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>CSerializedNetMsg</name><operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name> <name>data</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>command</name></expr>;</expr_stmt>
}</block>;</struct>


<decl_stmt><decl><type><name>class</name></type> <name>NetEventsInterface</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CConnman</name>
<block>{<block_content>
<label><name>public</name>:</label>

    <enum>enum <name>NumConnections</name> <block>{
        <decl><name>CONNECTIONS_NONE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
        <decl><name>CONNECTIONS_IN</name> <init>= <expr><operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>,
        <decl><name>CONNECTIONS_OUT</name> <init>= <expr><operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>,
        <decl><name>CONNECTIONS_ALL</name> <init>= <expr><operator>(</operator><name>CONNECTIONS_IN</name> <operator>|</operator> <name>CONNECTIONS_OUT</name><operator>)</operator></expr></init></decl>,
    }</block>;</enum>

    <struct>struct <name>Options</name>
    <block>{
        <decl_stmt><decl><type><name>ServiceFlags</name></type> <name>nLocalServices</name> <init>= <expr><name>NODE_NONE</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nMaxConnections</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>m_max_outbound_full_relay</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>m_max_outbound_block_relay</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nMaxAddnode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nMaxFeeler</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nBestHeight</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CClientUIInterface</name><modifier>*</modifier></type> <name>uiInterface</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>NetEventsInterface</name><modifier>*</modifier></type> <name>m_msgproc</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BanMan</name><modifier>*</modifier></type> <name>m_banman</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nSendBufferMaxSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nReceiveFloodSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>nMaxOutboundTimeframe</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>nMaxOutboundLimit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>m_peer_connect_timeout</name> <init>= <expr><name>DEFAULT_PEER_CONNECT_TIMEOUT</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>vSeedNodes</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>NetWhitelistPermissions</name></expr></argument>&gt;</argument_list></name> <name>vWhitelistedRange</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>NetWhitebindPermissions</name></expr></argument>&gt;</argument_list></name> <name>vWhiteBinds</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CService</name></expr></argument>&gt;</argument_list></name> <name>vBinds</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>m_use_addrman_outgoing</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>m_specified_outgoing</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>m_added_nodes</name></expr>;</expr_stmt>
    }</block>;</struct>

    <function><type><name>void</name></type> <name>Init</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Options</name><modifier>&amp;</modifier></type> <name>connOptions</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name>nLocalServices</name> <operator>=</operator> <name><name>connOptions</name><operator>.</operator><name>nLocalServices</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nMaxConnections</name> <operator>=</operator> <name><name>connOptions</name><operator>.</operator><name>nMaxConnections</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>m_max_outbound_full_relay</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>min</name><argument_list>(<argument><expr><name><name>connOptions</name><operator>.</operator><name>m_max_outbound_full_relay</name></name></expr></argument>, <argument><expr><name><name>connOptions</name><operator>.</operator><name>nMaxConnections</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>m_max_outbound_block_relay</name> <operator>=</operator> <name><name>connOptions</name><operator>.</operator><name>m_max_outbound_block_relay</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>m_use_addrman_outgoing</name> <operator>=</operator> <name><name>connOptions</name><operator>.</operator><name>m_use_addrman_outgoing</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nMaxAddnode</name> <operator>=</operator> <name><name>connOptions</name><operator>.</operator><name>nMaxAddnode</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nMaxFeeler</name> <operator>=</operator> <name><name>connOptions</name><operator>.</operator><name>nMaxFeeler</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>m_max_outbound</name> <operator>=</operator> <name>m_max_outbound_full_relay</name> <operator>+</operator> <name>m_max_outbound_block_relay</name> <operator>+</operator> <name>nMaxFeeler</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nBestHeight</name> <operator>=</operator> <name><name>connOptions</name><operator>.</operator><name>nBestHeight</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>clientInterface</name> <operator>=</operator> <name><name>connOptions</name><operator>.</operator><name>uiInterface</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>m_banman</name> <operator>=</operator> <name><name>connOptions</name><operator>.</operator><name>m_banman</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>m_msgproc</name> <operator>=</operator> <name><name>connOptions</name><operator>.</operator><name>m_msgproc</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nSendBufferMaxSize</name> <operator>=</operator> <name><name>connOptions</name><operator>.</operator><name>nSendBufferMaxSize</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nReceiveFloodSize</name> <operator>=</operator> <name><name>connOptions</name><operator>.</operator><name>nReceiveFloodSize</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>m_peer_connect_timeout</name> <operator>=</operator> <name><name>connOptions</name><operator>.</operator><name>m_peer_connect_timeout</name></name></expr>;</expr_stmt>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_totalBytesSent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>nMaxOutboundTimeframe</name> <operator>=</operator> <name><name>connOptions</name><operator>.</operator><name>nMaxOutboundTimeframe</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>nMaxOutboundLimit</name> <operator>=</operator> <name><name>connOptions</name><operator>.</operator><name>nMaxOutboundLimit</name></name></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><name>vWhitelistedRange</name> <operator>=</operator> <name><name>connOptions</name><operator>.</operator><name>vWhitelistedRange</name></name></expr>;</expr_stmt>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vAddedNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>vAddedNodes</name> <operator>=</operator> <name><name>connOptions</name><operator>.</operator><name>m_added_nodes</name></name></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></function>

    <macro><name>CConnman</name><argument_list>(<argument>uint64_t seed0</argument>, <argument>uint64_t seed1</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    <expr_stmt><expr><operator>~</operator><call><name>CConnman</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <function_decl><type><name>bool</name></type> <name>Start</name><parameter_list>(<parameter><decl><type><name>CScheduler</name><modifier>&amp;</modifier></type> <name>scheduler</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Options</name><modifier>&amp;</modifier></type> <name>options</name></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="line">// TODO: Remove NO_THREAD_SAFETY_ANALYSIS. Lock cs_vNodes before reading the variable vNodes.</comment>
    <comment type="line">//</comment>
    <comment type="line">// When removing NO_THREAD_SAFETY_ANALYSIS be aware of the following lock order requirements:</comment>
    <comment type="line">// * CheckForStaleTipAndEvictPeers locks cs_main before indirectly calling GetExtraOutboundCount</comment>
    <comment type="line">//   which locks cs_vNodes.</comment>
    <comment type="line">// * ProcessMessage locks cs_main and g_cs_orphans before indirectly calling ForEachNode which</comment>
    <comment type="line">//   locks cs_vNodes.</comment>
    <comment type="line">//</comment>
    <comment type="line">// Thus the implicit locking order requirement is: (1) cs_main, (2) g_cs_orphans, (3) cs_vNodes.</comment>
    <expr_stmt><expr><name>void</name> <macro><name>Stop</name><argument_list>()</argument_list></macro> <name>NO_THREAD_SAFETY_ANALYSIS</name></expr>;</expr_stmt>

    <function_decl><type><name>void</name></type> <name>Interrupt</name><parameter_list>()</parameter_list>;</function_decl>
    <expr_stmt><expr><name>bool</name> <macro><name>GetNetworkActive</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>fNetworkActive</name></expr>;</return> }</block></expr></expr_stmt><empty_stmt>;</empty_stmt>
    <expr_stmt><expr><name>bool</name> <macro><name>GetUseAddrmanOutgoing</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>m_use_addrman_outgoing</name></expr>;</return> }</block></expr></expr_stmt><empty_stmt>;</empty_stmt>
    <function_decl><type><name>void</name></type> <name>SetNetworkActive</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>active</name></decl></parameter>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>OpenNetworkConnection</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CAddress</name><modifier>&amp;</modifier></type> <name>addrConnect</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fCountFailure</name></decl></parameter>, <parameter><decl><type><name>CSemaphoreGrant</name> <modifier>*</modifier></type><name>grantOutbound</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>strDest</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fOneShot</name> <init>= <expr><name>false</name></expr></init></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fFeeler</name> <init>= <expr><name>false</name></expr></init></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>manual_connection</name> <init>= <expr><name>false</name></expr></init></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>block_relay_only</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
    <function_decl><type><name>bool</name></type> <name>CheckIncomingNonce</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>nonce</name></decl></parameter>)</parameter_list>;</function_decl>

    <decl_stmt><decl><type><name>bool</name></type> <name>ForNode</name><argument_list>(<argument><expr><name>NodeId</name> <name>id</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>function</name><argument_list type="generic">&lt;<argument><expr><name>bool</name><operator>(</operator><name>CNode</name><operator>*</operator> <name>pnode</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>func</name></expr></argument>)</argument_list></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>void</name></type> <name>PushMessage</name><argument_list>(<argument><expr><name>CNode</name><operator>*</operator> <name>pnode</name></expr></argument>, <argument><expr><name>CSerializedNetMsg</name><operator>&amp;&amp;</operator> <name>msg</name></expr></argument>)</argument_list></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Callable</name></expr></argument>&gt;</argument_list></name>
    <name>void</name></type> <name>ForEachNode</name><argument_list>(<argument><expr><name>Callable</name><operator>&amp;&amp;</operator> <name>func</name></expr></argument>)</argument_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>auto</name><operator>&amp;&amp;</operator> <name>node</name> <operator>:</operator> <name>vNodes</name></expr></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>NodeFullyConnected</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>func</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

    <decl_stmt><decl><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Callable</name></expr></argument>&gt;</argument_list></name>
    <name>void</name></type> <name>ForEachNode</name><argument_list>(<argument><expr><name>Callable</name><operator>&amp;&amp;</operator> <name>func</name></expr></argument>)</argument_list> const
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>auto</name><operator>&amp;&amp;</operator> <name>node</name> <operator>:</operator> <name>vNodes</name></expr></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>NodeFullyConnected</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>func</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

    <decl_stmt><decl><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Callable</name></expr></argument>, <argument><expr><name>typename</name> <name>CallableAfter</name></expr></argument>&gt;</argument_list></name>
    <name>void</name></type> <name>ForEachNodeThen</name><argument_list>(<argument><expr><name>Callable</name><operator>&amp;&amp;</operator> <name>pre</name></expr></argument>, <argument><expr><name>CallableAfter</name><operator>&amp;&amp;</operator> <name>post</name></expr></argument>)</argument_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>auto</name><operator>&amp;&amp;</operator> <name>node</name> <operator>:</operator> <name>vNodes</name></expr></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>NodeFullyConnected</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pre</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>post</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

    <decl_stmt><decl><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Callable</name></expr></argument>, <argument><expr><name>typename</name> <name>CallableAfter</name></expr></argument>&gt;</argument_list></name>
    <name>void</name></type> <name>ForEachNodeThen</name><argument_list>(<argument><expr><name>Callable</name><operator>&amp;&amp;</operator> <name>pre</name></expr></argument>, <argument><expr><name>CallableAfter</name><operator>&amp;&amp;</operator> <name>post</name></expr></argument>)</argument_list> const
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>auto</name><operator>&amp;&amp;</operator> <name>node</name> <operator>:</operator> <name>vNodes</name></expr></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>NodeFullyConnected</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pre</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>post</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

    <comment type="line">// Addrman functions</comment>
    <expr_stmt><expr><name>size_t</name> <macro><name>GetAddressCount</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
    <function_decl><type><name>void</name></type> <name>SetServices</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CService</name> <modifier>&amp;</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>ServiceFlags</name></type> <name>nServices</name></decl></parameter>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>MarkAddressGood</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CAddress</name><modifier>&amp;</modifier></type> <name>addr</name></decl></parameter>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>void</name></type> <name>AddNewAddresses</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CAddress</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>vAddr</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CAddress</name><operator>&amp;</operator> <name>addrFrom</name></expr></argument>, <argument><expr><name>int64_t</name> <name>nTimePenalty</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CAddress</name></expr></argument>&gt;</argument_list></name> <call><name>GetAddresses</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// This allows temporarily exceeding m_max_outbound_full_relay, with the goal of finding</comment>
    <comment type="line">// a peer that is better than all our current peers.</comment>
    <function_decl><type><name>void</name></type> <name>SetTryNewOutboundPeer</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>flag</name></decl></parameter>)</parameter_list>;</function_decl>
    <function_decl><type><name>bool</name></type> <name>GetTryNewOutboundPeer</name><parameter_list>()</parameter_list>;</function_decl>

    <comment type="line">// Return the number of outbound peers we have in excess of our target (eg,</comment>
    <comment type="line">// if we previously called SetTryNewOutboundPeer(true), and have since set</comment>
    <comment type="line">// to false, we may have extra peers that we wish to disconnect). This may</comment>
    <comment type="line">// return a value less than (num_outbound_connections - num_outbound_slots)</comment>
    <comment type="line">// in cases where some outbound connections are not yet fully connected, or</comment>
    <comment type="line">// not yet fully disconnected.</comment>
    <function_decl><type><name>int</name></type> <name>GetExtraOutboundCount</name><parameter_list>()</parameter_list>;</function_decl>

    <decl_stmt><decl><type><name>bool</name></type> <name>AddNode</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>node</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>RemoveAddedNode</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>node</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>AddedNodeInfo</name></expr></argument>&gt;</argument_list></name> <call><name>GetAddedNodeInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <function_decl><type><name>size_t</name></type> <name>GetNodeCount</name><parameter_list>(<parameter><decl><type><name>NumConnections</name></type> <name>num</name></decl></parameter>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>void</name></type> <name>GetNodeStats</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CNodeStats</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>vstats</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>DisconnectNode</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>node</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <function_decl><type><name>bool</name></type> <name>DisconnectNode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CSubNet</name><modifier>&amp;</modifier></type> <name>subnet</name></decl></parameter>)</parameter_list>;</function_decl>
    <function_decl><type><name>bool</name></type> <name>DisconnectNode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CNetAddr</name><modifier>&amp;</modifier></type> <name>addr</name></decl></parameter>)</parameter_list>;</function_decl>
    <function_decl><type><name>bool</name></type> <name>DisconnectNode</name><parameter_list>(<parameter><decl><type><name>NodeId</name></type> <name>id</name></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="line" format="doxygen">//! Used to convey which local services we are offering peers during node</comment>
    <comment type="line" format="doxygen">//! connection.</comment>
    <comment type="line" format="doxygen">//!</comment>
    <comment type="line" format="doxygen">//! The data returned by this is used in CNode construction,</comment>
    <comment type="line" format="doxygen">//! which is used to advertise which services we are offering</comment>
    <comment type="line" format="doxygen">//! that peer during `net_processing.cpp:PushNodeVersion()`.</comment>
    <expr_stmt><expr><name>ServiceFlags</name> <macro><name>GetLocalServices</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

    <comment type="line" format="doxygen">//!set the max outbound target in bytes</comment>
    <function_decl><type><name>void</name></type> <name>SetMaxOutboundTarget</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>limit</name></decl></parameter>)</parameter_list>;</function_decl>
    <function_decl><type><name>uint64_t</name></type> <name>GetMaxOutboundTarget</name><parameter_list>()</parameter_list>;</function_decl>

    <comment type="line" format="doxygen">//!set the timeframe for the max outbound target</comment>
    <function_decl><type><name>void</name></type> <name>SetMaxOutboundTimeframe</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>timeframe</name></decl></parameter>)</parameter_list>;</function_decl>
    <function_decl><type><name>uint64_t</name></type> <name>GetMaxOutboundTimeframe</name><parameter_list>()</parameter_list>;</function_decl>

    <comment type="line" format="doxygen">//! check if the outbound target is reached</comment>
    <comment type="line" format="doxygen">//! if param historicalBlockServingLimit is set true, the function will</comment>
    <comment type="line" format="doxygen">//! response true if the limit for serving historical blocks has been reached</comment>
    <function_decl><type><name>bool</name></type> <name>OutboundTargetReached</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>historicalBlockServingLimit</name></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="line" format="doxygen">//! response the bytes left in the current max outbound cycle</comment>
    <comment type="line" format="doxygen">//! in case of no limit, it will always response 0</comment>
    <function_decl><type><name>uint64_t</name></type> <name>GetOutboundTargetBytesLeft</name><parameter_list>()</parameter_list>;</function_decl>

    <comment type="line" format="doxygen">//! response the time in second left in the current max outbound cycle</comment>
    <comment type="line" format="doxygen">//! in case of no limit, it will always response 0</comment>
    <function_decl><type><name>uint64_t</name></type> <name>GetMaxOutboundTimeLeftInCycle</name><parameter_list>()</parameter_list>;</function_decl>

    <function_decl><type><name>uint64_t</name></type> <name>GetTotalBytesRecv</name><parameter_list>()</parameter_list>;</function_decl>
    <function_decl><type><name>uint64_t</name></type> <name>GetTotalBytesSent</name><parameter_list>()</parameter_list>;</function_decl>

    <function_decl><type><name>void</name></type> <name>SetBestHeight</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>)</parameter_list>;</function_decl>
    <expr_stmt><expr><name>int</name> <macro><name>GetBestHeight</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

    <comment type="block" format="doxygen">/** Get a unique deterministic randomizer. */</comment>
    <decl_stmt><decl><type><name>CSipHasher</name></type> <name>GetDeterministicRandomizer</name><argument_list>(<argument><expr><name>uint64_t</name> <name>id</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

    <expr_stmt><expr><name>unsigned</name> <name>int</name> <macro><name>GetReceiveFloodSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

    <function_decl><type><name>void</name></type> <name>WakeMessageHandler</name><parameter_list>()</parameter_list>;</function_decl>

    <comment type="block" format="doxygen">/** Attempts to obfuscate tx time through exponentially distributed emitting.
        Works assuming that a single interval is used.
        Variable intervals will result in privacy decrease.
    */</comment>
    <function_decl><type><name>int64_t</name></type> <name>PoissonNextSendInbound</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>now</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>average_interval_seconds</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>
    <struct>struct <name>ListenSocket</name> <block>{
    <label><name>public</name>:</label>
        <decl_stmt><decl><type><name>SOCKET</name></type> <name>socket</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>inline</specifier> <name>void</name></type> <name>AddSocketPermissionFlags</name><argument_list>(<argument><expr><name>NetPermissionFlags</name><operator>&amp;</operator> <name>flags</name></expr></argument>)</argument_list> const <block>{<block_content> <expr_stmt><expr><name>NetPermissions</name><operator>::</operator><call><name>AddFlag</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>m_permissions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></decl></decl_stmt>
        <macro><name>ListenSocket</name><argument_list>(<argument>SOCKET socket_</argument>, <argument>NetPermissionFlags permissions_</argument>)</argument_list></macro> : <expr_stmt><expr><call><name>socket</name><argument_list>(<argument><expr><name>socket_</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>m_permissions</name><argument_list>(<argument>permissions_</argument>)</argument_list></macro> <expr><block>{}</block>
    <name>private</name><operator>:</operator>
        <name>NetPermissionFlags</name> <name>m_permissions</name></expr>;</expr_stmt>
    }</block>;</struct>

    <decl_stmt><decl><type><name>bool</name></type> <name>BindListenPort</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CService</name><operator>&amp;</operator> <name>bindAddr</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>strError</name></expr></argument>, <argument><expr><name>NetPermissionFlags</name> <name>permissions</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <function_decl><type><name>bool</name></type> <name>Bind</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CService</name><modifier>&amp;</modifier></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>NetPermissionFlags</name></type> <name>permissions</name></decl></parameter>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>bool</name></type> <name>InitBinds</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CService</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>binds</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>NetWhitebindPermissions</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>whiteBinds</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <function_decl><type><name>void</name></type> <name>ThreadOpenAddedConnections</name><parameter_list>()</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>void</name></type> <name>AddOneShot</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>strDest</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <function_decl><type><name>void</name></type> <name>ProcessOneShot</name><parameter_list>()</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>void</name></type> <name>ThreadOpenConnections</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>connect</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <function_decl><type><name>void</name></type> <name>ThreadMessageHandler</name><parameter_list>()</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>AcceptConnection</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ListenSocket</name><modifier>&amp;</modifier></type> <name>hListenSocket</name></decl></parameter>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>DisconnectNodes</name><parameter_list>()</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>NotifyNumConnectionsChanged</name><parameter_list>()</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>InactivityCheck</name><parameter_list>(<parameter><decl><type><name>CNode</name> <modifier>*</modifier></type><name>pnode</name></decl></parameter>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>bool</name></type> <name>GenerateSelectSet</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>set</name><argument_list type="generic">&lt;<argument><expr><name>SOCKET</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>recv_set</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>set</name><argument_list type="generic">&lt;<argument><expr><name>SOCKET</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>send_set</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>set</name><argument_list type="generic">&lt;<argument><expr><name>SOCKET</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>error_set</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name></type> <name>SocketEvents</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>set</name><argument_list type="generic">&lt;<argument><expr><name>SOCKET</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>recv_set</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>set</name><argument_list type="generic">&lt;<argument><expr><name>SOCKET</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>send_set</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>set</name><argument_list type="generic">&lt;<argument><expr><name>SOCKET</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>error_set</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <function_decl><type><name>void</name></type> <name>SocketHandler</name><parameter_list>()</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>ThreadSocketHandler</name><parameter_list>()</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>ThreadDNSAddressSeed</name><parameter_list>()</parameter_list>;</function_decl>

    <decl_stmt><decl><type><name>uint64_t</name></type> <name>CalculateKeyedNetGroup</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CAddress</name><operator>&amp;</operator> <name>ad</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

    <function_decl><type><name>CNode</name><modifier>*</modifier></type> <name>FindNode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CNetAddr</name><modifier>&amp;</modifier></type> <name>ip</name></decl></parameter>)</parameter_list>;</function_decl>
    <function_decl><type><name>CNode</name><modifier>*</modifier></type> <name>FindNode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CSubNet</name><modifier>&amp;</modifier></type> <name>subNet</name></decl></parameter>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>CNode</name><modifier>*</modifier></type> <name>FindNode</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>addrName</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <function_decl><type><name>CNode</name><modifier>*</modifier></type> <name>FindNode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CService</name><modifier>&amp;</modifier></type> <name>addr</name></decl></parameter>)</parameter_list>;</function_decl>

    <function_decl><type><name>bool</name></type> <name>AttemptToEvictConnection</name><parameter_list>()</parameter_list>;</function_decl>
    <function_decl><type><name>CNode</name><modifier>*</modifier></type> <name>ConnectNode</name><parameter_list>(<parameter><decl><type><name>CAddress</name></type> <name>addrConnect</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pszDest</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fCountFailure</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>manual_connection</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>block_relay_only</name></decl></parameter>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>void</name></type> <name>AddWhitelistPermissionFlags</name><argument_list>(<argument><expr><name>NetPermissionFlags</name><operator>&amp;</operator> <name>flags</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CNetAddr</name> <operator>&amp;</operator><name>addr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

    <function_decl><type><name>void</name></type> <name>DeleteNode</name><parameter_list>(<parameter><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name></decl></parameter>)</parameter_list>;</function_decl>

    <function_decl><type><name>NodeId</name></type> <name>GetNewNodeId</name><parameter_list>()</parameter_list>;</function_decl>

    <decl_stmt><decl><type><name>size_t</name></type> <name>SocketSendData</name><argument_list>(<argument><expr><name>CNode</name> <operator>*</operator><name>pnode</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
    <function_decl><type><name>void</name></type> <name>DumpAddresses</name><parameter_list>()</parameter_list>;</function_decl>

    <comment type="line">// Network stats</comment>
    <function_decl><type><name>void</name></type> <name>RecordBytesRecv</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>bytes</name></decl></parameter>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>RecordBytesSent</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>bytes</name></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="line">// Whether the node should be passed out in ForEach* callbacks</comment>
    <function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>NodeFullyConnected</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CNode</name><modifier>*</modifier></type> <name>pnode</name></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="line">// Network usage totals</comment>
    <decl_stmt><decl><type><name>CCriticalSection</name></type> <name>cs_totalBytesRecv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CCriticalSection</name></type> <name>cs_totalBytesSent</name></decl>;</decl_stmt>
    <function_decl><type><name>uint64_t</name> <name>nTotalBytesRecv</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_totalBytesRecv</name></type></decl></parameter>)</parameter_list>;</function_decl>
    <function_decl><type><name>uint64_t</name> <name>nTotalBytesSent</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_totalBytesSent</name></type></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="line">// outbound limit &amp; stats</comment>
    <function_decl><type><name>uint64_t</name> <name>nMaxOutboundTotalBytesSentInCycle</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_totalBytesSent</name></type></decl></parameter>)</parameter_list>;</function_decl>
    <function_decl><type><name>uint64_t</name> <name>nMaxOutboundCycleStartTime</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_totalBytesSent</name></type></decl></parameter>)</parameter_list>;</function_decl>
    <function_decl><type><name>uint64_t</name> <name>nMaxOutboundLimit</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_totalBytesSent</name></type></decl></parameter>)</parameter_list>;</function_decl>
    <function_decl><type><name>uint64_t</name> <name>nMaxOutboundTimeframe</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_totalBytesSent</name></type></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="line">// P2P timeout in seconds</comment>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>m_peer_connect_timeout</name></decl>;</decl_stmt>

    <comment type="line">// Whitelisted ranges. Any node connecting from these is automatically</comment>
    <comment type="line">// whitelisted (as well as those connecting to whitelisted binds).</comment>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>NetWhitelistPermissions</name></expr></argument>&gt;</argument_list></name> <name>vWhitelistedRange</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nSendBufferMaxSize</name><block>{<block_content><expr><literal type="number">0</literal></expr></block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nReceiveFloodSize</name><block>{<block_content><expr><literal type="number">0</literal></expr></block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ListenSocket</name></expr></argument>&gt;</argument_list></name> <name>vhListenSocket</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>atomic</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>fNetworkActive</name><block>{<expr><name>true</name></expr>}</block></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>fAddressesInitialized</name><block>{<block_content><expr><name>false</name></expr></block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
    <decl_stmt><decl><type><name>CAddrMan</name></type> <name>addrman</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>deque</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>vOneShots</name> <call><name>GUARDED_BY</name><argument_list>(<argument><expr><name>cs_vOneShots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>CCriticalSection</name></type> <name>cs_vOneShots</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>vAddedNodes</name> <call><name>GUARDED_BY</name><argument_list>(<argument><expr><name>cs_vAddedNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>CCriticalSection</name></type> <name>cs_vAddedNodes</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CNode</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>vNodes</name> <call><name>GUARDED_BY</name><argument_list>(<argument><expr><name>cs_vNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>list</name><argument_list type="generic">&lt;<argument><expr><name>CNode</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>vNodesDisconnected</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>mutable</name> <name>CCriticalSection</name></type> <name>cs_vNodes</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>atomic</name><argument_list type="generic">&lt;<argument><expr><name>NodeId</name></expr></argument>&gt;</argument_list></name> <name>nLastNodeId</name><block>{<expr><literal type="number">0</literal></expr>}</block></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nPrevNodeCount</name><block>{<block_content><expr><literal type="number">0</literal></expr></block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

    <comment type="block" format="doxygen">/**
     * Services this instance offers.
     *
     * This data is replicated in each CNode instance we create during peer
     * connection (in ConnectNode()) under a member also called
     * nLocalServices.
     *
     * This data is not marked const, but after being set it should not
     * change. See the note in CNode::nLocalServices documentation.
     *
     * \sa CNode::nLocalServices
     */</comment>
    <decl_stmt><decl><type><name>ServiceFlags</name></type> <name>nLocalServices</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CSemaphore</name></expr></argument>&gt;</argument_list></name> <name>semOutbound</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CSemaphore</name></expr></argument>&gt;</argument_list></name> <name>semAddnode</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nMaxConnections</name></decl>;</decl_stmt>

    <comment type="line">// How many full-relay (tx, block, addr) outbound peers we want</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>m_max_outbound_full_relay</name></decl>;</decl_stmt>

    <comment type="line">// How many block-relay only outbound peers we want</comment>
    <comment type="line">// We do not relay tx or addr messages with these peers</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>m_max_outbound_block_relay</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>nMaxAddnode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nMaxFeeler</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>m_max_outbound</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>m_use_addrman_outgoing</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>atomic</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name> <name>nBestHeight</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>CClientUIInterface</name><modifier>*</modifier></type> <name>clientInterface</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NetEventsInterface</name><modifier>*</modifier></type> <name>m_msgproc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BanMan</name><modifier>*</modifier></type> <name>m_banman</name></decl>;</decl_stmt>

    <comment type="block" format="doxygen">/** SipHasher seeds for deterministic randomness */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>nSeed0</name></decl>, <decl><type ref="prev"/><name>nSeed1</name></decl>;</decl_stmt>

    <comment type="block" format="doxygen">/** flag for waking the message processor. */</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>fMsgProcWake</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>std</name><operator>::</operator><name>condition_variable</name> <name>condMsgProc</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>Mutex</name></type> <name>mutexMsgProc</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>atomic</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>flagInterruptMsgProc</name><block>{<expr><name>false</name></expr>}</block></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>CThreadInterrupt</name></type> <name>interruptNet</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>std</name><operator>::</operator><name>thread</name> <name>threadDNSAddressSeed</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name>thread</name> <name>threadSocketHandler</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name>thread</name> <name>threadOpenAddedConnections</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name>thread</name> <name>threadOpenConnections</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name>thread</name> <name>threadMessageHandler</name></expr>;</expr_stmt>

    <comment type="block" format="doxygen">/** flag for deciding to connect to an extra outbound peer,
     *  in excess of m_max_outbound_full_relay
     *  This takes the place of a feeler connection */</comment>
    <expr_stmt><expr><name>std</name><operator>::</operator><name>atomic_bool</name> <name>m_try_another_outbound_peer</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>atomic</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name> <name>m_next_send_inv_to_incoming</name><block>{<expr><literal type="number">0</literal></expr>}</block></expr>;</expr_stmt>

    <macro><name>friend</name></macro> <struct_decl>struct <name>CConnmanTest</name>;</struct_decl>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<function_decl><type><name>void</name></type> <name>Discover</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>StartMapPort</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>InterruptMapPort</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>StopMapPort</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>unsigned</name> <name>short</name></type> <name>GetListenPort</name><parameter_list>()</parameter_list>;</function_decl>

<struct>struct <name>CombinerAll</name>
<block>{
    <typedef>typedef <type><name>bool</name></type> <name>result_type</name>;</typedef>

    <expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>I</name></expr></argument>&gt;</argument_list></name>
    <name>bool</name> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><name>I</name> <name>first</name><operator>,</operator> <name>I</name> <name>last</name><operator>)</operator> <specifier>const</specifier>
    <block>{
        <while>while <condition>(<expr><name>first</name> <operator>!=</operator> <name>last</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><name>first</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><operator>++</operator><name>first</name></expr>;</expr_stmt>
        <expr_stmt/></block_content></block></while>}</block></expr></expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    }</block>
<decl/></struct>};

<comment type="block" format="doxygen">/**
 * Interface for message handling
 */</comment>
<decl_stmt><decl><type><name>class</name></type> <name>NetEventsInterface</name>
<block>{<block_content>
<label><name>public</name>:</label>
    <decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>ProcessMessages</name><argument_list>(<argument><expr><name>CNode</name><operator>*</operator> <name>pnode</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>atomic</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>interrupt</name></expr></argument>)</argument_list> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <function_decl><type><name>virtual</name> <name>bool</name></type> <name>SendMessages</name><parameter_list>(<parameter><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>
    <function_decl><type><name>virtual</name> <name>void</name></type> <name>InitializeNode</name><parameter_list>(<parameter><decl><type><name>CNode</name><modifier>*</modifier></type> <name>pnode</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>
    <function_decl><type><name>virtual</name> <name>void</name></type> <name>FinalizeNode</name><parameter_list>(<parameter><decl><type><name>NodeId</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>bool</name><modifier>&amp;</modifier></type> <name>update_connection_time</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>

<label><name>protected</name>:</label>
    <comment type="block" format="doxygen">/**
     * Protected destructor so that instances can only be deleted by derived classes.
     * If that restriction is no longer desired, this should be made public and virtual.
     */</comment>
    <expr_stmt><expr><operator>~</operator><call><name>NetEventsInterface</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<enum>enum
<block>{
    <decl><name>LOCAL_NONE</name></decl>,   <comment type="line">// unknown</comment>
    <decl><name>LOCAL_IF</name></decl>,     <comment type="line">// address a local interface listens on</comment>
    <decl><name>LOCAL_BIND</name></decl>,   <comment type="line">// address explicit bound to</comment>
    <decl><name>LOCAL_UPNP</name></decl>,   <comment type="line">// address reported by UPnP</comment>
    <decl><name>LOCAL_MANUAL</name></decl>, <comment type="line">// address explicitly specified (-externalip=)</comment>

    <decl><name>LOCAL_MAX</name></decl>
}</block>;</enum>

<function_decl><type><name>bool</name></type> <name>IsPeerAddrLocalGood</name><parameter_list>(<parameter><decl><type><name>CNode</name> <modifier>*</modifier></type><name>pnode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>AdvertiseLocal</name><parameter_list>(<parameter><decl><type><name>CNode</name> <modifier>*</modifier></type><name>pnode</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/**
 * Mark a network as reachable or unreachable (no automatic connects to it)
 * @note Networks are reachable by default
 */</comment>
<function_decl><type><name>void</name></type> <name>SetReachable</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>Network</name></name></type> <name>net</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>reachable</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block" format="doxygen">/** @returns true if the network is reachable, false otherwise */</comment>
<function_decl><type><name>bool</name></type> <name>IsReachable</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>Network</name></name></type> <name>net</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block" format="doxygen">/** @returns true if the address is in a reachable network, false otherwise */</comment>
<function_decl><type><name>bool</name></type> <name>IsReachable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CNetAddr</name><modifier>&amp;</modifier></type> <name>addr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>AddLocal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CService</name><modifier>&amp;</modifier></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nScore</name> <init>= <expr><name>LOCAL_NONE</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>AddLocal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CNetAddr</name><modifier>&amp;</modifier></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nScore</name> <init>= <expr><name>LOCAL_NONE</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>RemoveLocal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CService</name><modifier>&amp;</modifier></type> <name>addr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SeenLocal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CService</name><modifier>&amp;</modifier></type> <name>addr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>IsLocal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CService</name><modifier>&amp;</modifier></type> <name>addr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>GetLocal</name><parameter_list>(<parameter><decl><type><name>CService</name> <modifier>&amp;</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CNetAddr</name> <modifier>*</modifier></type><name>paddrPeer</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>CAddress</name></type> <name>GetLocalAddress</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CNetAddr</name> <modifier>*</modifier></type><name>paddrPeer</name></decl></parameter>, <parameter><decl><type><name>ServiceFlags</name></type> <name>nLocalServices</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>fDiscover</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>fListen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>g_relay_txes</name></decl>;</decl_stmt>

<comment type="block" format="doxygen">/** Subversion as sent to the P2P network in `version` messages */</comment>
<extern>extern std::string strSubVersion;</extern>

<struct>struct <name>LocalServiceInfo</name> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nScore</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nPort</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>extern</specifier> <name>CCriticalSection</name></type> <name>cs_mapLocalHost</name></decl>;</decl_stmt>
<extern>extern std::map&lt;CNetAddr<operator>,</operator> LocalServiceInfo&gt; mapLocalHost GUARDED_BY(cs_mapLocalHost</extern>)<empty_stmt>;</empty_stmt>

<extern>extern const std::string NET_MESSAGE_COMMAND_OTHER;</extern>
<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name><name>map</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>, <argument><expr><name>uint64_t</name></expr></argument>&gt;</argument_list></name> <name>mapMsgCmdSize</name></expr>;</expr_stmt></typedef> <comment type="line">//command, total bytes</comment>

<decl_stmt><decl><type><name>class</name></type> <name>CNodeStats</name>
<block>{<block_content>
<label><name>public</name>:</label>
    <decl_stmt><decl><type><name>NodeId</name></type> <name>nodeid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ServiceFlags</name></type> <name>nServices</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>fRelayTxes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>nLastSend</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>nLastRecv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>nTimeConnected</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>nTimeOffset</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>addrName</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nVersion</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>cleanSubVer</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>fInbound</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>m_manual_connection</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nStartingHeight</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>nSendBytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mapMsgCmdSize</name></type> <name>mapSendBytesPerMsgCmd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>nRecvBytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mapMsgCmdSize</name></type> <name>mapRecvBytesPerMsgCmd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NetPermissionFlags</name></type> <name>m_permissionFlags</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>m_legacyWhitelisted</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>dPingTime</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>dPingWait</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>dMinPing</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CAmount</name></type> <name>minFeeFilter</name></decl>;</decl_stmt>
    <comment type="line">// Our address, as reported by the peer</comment>
    <expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>addrLocal</name></expr>;</expr_stmt>
    <comment type="line">// Address of this peer</comment>
    <decl_stmt><decl><type><name>CAddress</name></type> <name>addr</name></decl>;</decl_stmt>
    <comment type="line">// Bind address of our side of the connection</comment>
    <decl_stmt><decl><type><name>CAddress</name></type> <name>addrBind</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<comment type="block" format="doxygen">/** Transport protocol agnostic message container.
 * Ideally it should only contain receive time, payload,
 * command and size.
 */</comment>
<decl_stmt><decl><type><name>class</name></type> <name>CNetMessage</name> <block>{<block_content>
<label><name>public</name>:</label>
    <decl_stmt><decl><type><name>CDataStream</name></type> <name>m_recv</name></decl>;</decl_stmt>                  <comment type="line">// received message data</comment>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>m_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="line">// time (in microseconds) of message receipt.</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>m_valid_netmagic</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>m_valid_header</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>m_valid_checksum</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>m_message_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="line">// size of the payload</comment>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>m_raw_message_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="line">// used wire size of the message (including header/checksum)</comment>
    <expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>m_command</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>CNetMessage</name><argument_list>(<argument><expr><name>CDataStream</name><operator>&amp;&amp;</operator> <name>recv_in</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>m_recv</name><argument_list>(<argument>std::move(recv_in)</argument>)</argument_list></macro> <block>{}</block>

    <name>void</name> <macro><name>SetVersion</name><argument_list>(<argument>int nVersionIn</argument>)</argument_list></macro>
    <block>{
        <expr><call><name><name>m_recv</name><operator>.</operator><name>SetVersion</name></name><argument_list>(<argument><expr><name>nVersionIn</name></expr></argument>)</argument_list></call></expr>;
    }</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block" format="doxygen">/** The TransportDeserializer takes care of holding and deserializing the
 * network receive buffer. It can deserialize the network buffer into a
 * transport protocol agnostic CNetMessage (command &amp; payload)
 */</comment>
<decl_stmt><decl><type><name>class</name></type> <name>TransportDeserializer</name> <block>{<block_content>
<label><name>public</name>:</label>
    <comment type="line">// returns true if the current deserialization is complete</comment>
    <expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>Complete</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <comment type="line">// set the serialization context version</comment>
    <function_decl><type><name>virtual</name> <name>void</name></type> <name>SetVersion</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>
    <comment type="line">// read and deserialize data</comment>
    <function_decl><type><name>virtual</name> <name>int</name></type> <name>Read</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>bytes</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>
    <comment type="line">// decomposes a message from the context</comment>
    <decl_stmt><decl><type><name>virtual</name> <name>CNetMessage</name></type> <name>GetMessage</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CMessageHeader</name><operator>::</operator><name>MessageStartChars</name><operator>&amp;</operator> <name>message_start</name></expr></argument>, <argument><expr><name>int64_t</name> <name>time</name></expr></argument>)</argument_list> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>virtual</name> <operator>~</operator><macro><name>TransportDeserializer</name><argument_list>()</argument_list></macro> <block>{}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name> <name>V1TransportDeserializer</name></type> <name>final</name> <range>: <expr><name>public</name> <name>TransportDeserializer</name>
<block>{
<expr><name>private</name><operator>:</operator>
    <name>mutable</name> <name>CHash256</name> <name>hasher</name></expr>;
    <expr><name>mutable</name> <name>uint256</name> <name>data_hash</name></expr>;
    <expr><name>bool</name> <name>in_data</name></expr>;                   <comment type="line">// parsing header (false) or data (true)</comment>
    <expr><name>CDataStream</name> <name>hdrbuf</name></expr>;             <comment type="line">// partially received header</comment>
    <expr><name>CMessageHeader</name> <name>hdr</name></expr>;             <comment type="line">// complete header</comment>
    <expr><name>CDataStream</name> <name>vRecv</name></expr>;              <comment type="line">// received message data</comment>
    <expr><name>unsigned</name> <name>int</name> <name>nHdrPos</name></expr>;
    <expr><name>unsigned</name> <name>int</name> <name>nDataPos</name></expr>;

    <expr><specifier>const</specifier> <name>uint256</name><operator>&amp;</operator> <macro><name>GetMessageHash</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
    <expr><name>int</name> <macro><name>readHeader</name><argument_list>(<argument>const char *pch</argument>, <argument>unsigned int nBytes</argument>)</argument_list></macro></expr>;
    <expr><name>int</name> <macro><name>readData</name><argument_list>(<argument>const char *pch</argument>, <argument>unsigned int nBytes</argument>)</argument_list></macro></expr>;

    <expr><name>void</name> <macro><name>Reset</name><argument_list>()</argument_list></macro> <block>{
        <expr><call><name><name>vRecv</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;
        <expr><call><name><name>hdrbuf</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;
        <expr><call><name><name>hdrbuf</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;
        <expr><name>in_data</name> <operator>=</operator> <name>false</name></expr>;
        <expr><name>nHdrPos</name> <operator>=</operator> <literal type="number">0</literal></expr>;
        <expr><name>nDataPos</name> <operator>=</operator> <literal type="number">0</literal></expr>;
        <expr><call><name><name>data_hash</name><operator>.</operator><name>SetNull</name></name><argument_list>()</argument_list></call></expr>;
        <expr><call><name><name>hasher</name><operator>.</operator><name>Reset</name></name><argument_list>()</argument_list></call></expr>;
    }</block>

<name>public</name><operator>:</operator>

    <macro><name>V1TransportDeserializer</name><argument_list>(<argument>const CMessageHeader::MessageStartChars&amp; pchMessageStartIn</argument>, <argument>int nTypeIn</argument>, <argument>int nVersionIn</argument>)</argument_list></macro> <operator>:</operator> <call><name>hdrbuf</name><argument_list>(<argument><expr><name>nTypeIn</name></expr></argument>, <argument><expr><name>nVersionIn</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>hdr</name><argument_list>(<argument><expr><name>pchMessageStartIn</name></expr></argument>)</argument_list></call></expr>, <macro><name>vRecv</name><argument_list>(<argument>nTypeIn</argument>, <argument>nVersionIn</argument>)</argument_list></macro> <expr><block>{
        <expr><call><name>Reset</name><argument_list>()</argument_list></call></expr>;
    }</block>

    <name>bool</name> <macro><name>Complete</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name>
    <block>{
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_data</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
        <return>return <expr><operator>(</operator><name><name>hdr</name><operator>.</operator><name>nMessageSize</name></name> <operator>==</operator> <name>nDataPos</name><operator>)</operator></expr>;</return>
    }</block></expr></range></decl></decl_stmt>
    <function><type><name>void</name></type> <name>SetVersion</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nVersionIn</name></decl></parameter>)</parameter_list> override
    <block>{<block_content>
        <expr_stmt><expr><call><name><name>hdrbuf</name><operator>.</operator><name>SetVersion</name></name><argument_list>(<argument><expr><name>nVersionIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>vRecv</name><operator>.</operator><name>SetVersion</name></name><argument_list>(<argument><expr><name>nVersionIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>
    <function><type><name>int</name></type> <name>Read</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pch</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nBytes</name></decl></parameter>)</parameter_list> override <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><ternary><condition><expr><name>in_data</name></expr> ?</condition><then> <expr><call><name>readData</name><argument_list>(<argument><expr><name>pch</name></expr></argument>, <argument><expr><name>nBytes</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>readHeader</name><argument_list>(<argument><expr><name>pch</name></expr></argument>, <argument><expr><name>nBytes</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>Reset</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>ret</name></expr>;</return>
    </block_content>}</block></function>
    <decl_stmt><decl><type><name>CNetMessage</name></type> <name>GetMessage</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CMessageHeader</name><operator>::</operator><name>MessageStartChars</name><operator>&amp;</operator> <name>message_start</name></expr></argument>, <argument><expr><name>int64_t</name> <name>time</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
};

<comment type="block" format="doxygen">/** Information about a peer */</comment>
<decl_stmt><decl><type><name>class</name></type> <name>CNode</name>
<block>{<block_content>
    <decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CConnman</name></decl>;</decl_stmt>
<label><name>public</name>:</label>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>TransportDeserializer</name></expr></argument>&gt;</argument_list></name> <name>m_deserializer</name></expr>;</expr_stmt>

    <comment type="line">// socket</comment>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>atomic</name><argument_list type="generic">&lt;<argument><expr><name>ServiceFlags</name></expr></argument>&gt;</argument_list></name> <name>nServices</name><block>{<expr><name>NODE_NONE</name></expr>}</block></expr>;</expr_stmt>
    <function_decl><type><name>SOCKET</name> <name>hSocket</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_hSocket</name></type></decl></parameter>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>size_t</name></type> <name>nSendSize</name><block>{<block_content><expr><literal type="number">0</literal></expr></block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt> <comment type="line">// total size of all vSendMsg entries</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>nSendOffset</name><block>{<block_content><expr><literal type="number">0</literal></expr></block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt> <comment type="line">// offset inside the first vSendMsg already sent</comment>
    <function><type><name>uint64_t</name> <name>nSendBytes</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_vSend</name></type></decl></parameter>)</parameter_list><block>{<block_content><expr><literal type="number">0</literal></expr></block_content>}</block></function><empty_stmt>;</empty_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>deque</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>vSendMsg</name> <call><name>GUARDED_BY</name><argument_list>(<argument><expr><name>cs_vSend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>CCriticalSection</name></type> <name>cs_vSend</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CCriticalSection</name></type> <name>cs_hSocket</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CCriticalSection</name></type> <name>cs_vRecv</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>CCriticalSection</name></type> <name>cs_vProcessMsg</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>list</name><argument_list type="generic">&lt;<argument><expr><name>CNetMessage</name></expr></argument>&gt;</argument_list></name> <name>vProcessMsg</name> <call><name>GUARDED_BY</name><argument_list>(<argument><expr><name>cs_vProcessMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>nProcessQueueSize</name><block>{<block_content><expr><literal type="number">0</literal></expr></block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

    <decl_stmt><decl><type><name>CCriticalSection</name></type> <name>cs_sendProcessing</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>deque</name><argument_list type="generic">&lt;<argument><expr><name>CInv</name></expr></argument>&gt;</argument_list></name> <name>vRecvGetData</name></expr>;</expr_stmt>
    <function><type><name>uint64_t</name> <name>nRecvBytes</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_vRecv</name></type></decl></parameter>)</parameter_list><block>{<block_content><expr><literal type="number">0</literal></expr></block_content>}</block></function><empty_stmt>;</empty_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>atomic</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name> <name>nRecvVersion</name><block>{<expr><name>INIT_PROTO_VERSION</name></expr>}</block></expr>;</expr_stmt>

    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>atomic</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name> <name>nLastSend</name><block>{<expr><literal type="number">0</literal></expr>}</block></expr>;</expr_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>atomic</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name> <name>nLastRecv</name><block>{<expr><literal type="number">0</literal></expr>}</block></expr>;</expr_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>nTimeConnected</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>atomic</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name> <name>nTimeOffset</name><block>{<expr><literal type="number">0</literal></expr>}</block></expr>;</expr_stmt>
    <comment type="line">// Address of this peer</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CAddress</name></type> <name>addr</name></decl>;</decl_stmt>
    <comment type="line">// Bind address of our side of the connection</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CAddress</name></type> <name>addrBind</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>atomic</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name> <name>nVersion</name><block>{<expr><literal type="number">0</literal></expr>}</block></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>RecursiveMutex</name></type> <name>cs_SubVer</name></decl>;</decl_stmt>
    <comment type="block" format="doxygen">/**
     * cleanSubVer is a sanitized string of the user agent byte array we read
     * from the wire. This cleaned string can safely be logged or displayed.
     */</comment>
    <expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>cleanSubVer</name> <macro><name>GUARDED_BY</name><argument_list>(<argument>cs_SubVer</argument>)</argument_list></macro><block>{}</block></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>m_prefer_evict</name><block>{<block_content><expr><name>false</name></expr></block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt> <comment type="line">// This peer is preferred for eviction.</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>HasPermission</name><argument_list>(<argument><expr><name>NetPermissionFlags</name> <name>permission</name></expr></argument>)</argument_list> const <block>{<block_content>
        <return>return <expr><name>NetPermissions</name><operator>::</operator><call><name>HasFlag</name><argument_list>(<argument><expr><name>m_permissionFlags</name></expr></argument>, <argument><expr><name>permission</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></decl></decl_stmt>
    <comment type="line">// This boolean is unusued in actual processing, only present for backward compatibility at RPC/QT level</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>m_legacyWhitelisted</name><block>{<block_content><expr><name>false</name></expr></block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>fFeeler</name><block>{<block_content><expr><name>false</name></expr></block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt> <comment type="line">// If true this node is being used as a short lived feeler.</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>fOneShot</name><block>{<block_content><expr><name>false</name></expr></block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>m_manual_connection</name><block>{<block_content><expr><name>false</name></expr></block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>fClient</name><block>{<block_content><expr><name>false</name></expr></block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt> <comment type="line">// set by version message</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>m_limited_node</name><block>{<block_content><expr><name>false</name></expr></block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt> <comment type="line">//after BIP159, set by version message</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>fInbound</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name>atomic_bool</name> <name>fSuccessfullyConnected</name><block>{<expr><name>false</name></expr>}</block></expr>;</expr_stmt>
    <comment type="line">// Setting fDisconnect to true will cause the node to be disconnected the</comment>
    <comment type="line">// next time DisconnectNodes() runs</comment>
    <expr_stmt><expr><name>std</name><operator>::</operator><name>atomic_bool</name> <name>fDisconnect</name><block>{<expr><name>false</name></expr>}</block></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>fSentAddr</name><block>{<block_content><expr><name>false</name></expr></block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
    <decl_stmt><decl><type><name>CSemaphoreGrant</name></type> <name>grantOutbound</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>atomic</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name> <name>nRefCount</name><block>{<expr><literal type="number">0</literal></expr>}</block></expr>;</expr_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>nKeyedNetGroup</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name>atomic_bool</name> <name>fPauseRecv</name><block>{<expr><name>false</name></expr>}</block></expr>;</expr_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name>atomic_bool</name> <name>fPauseSend</name><block>{<expr><name>false</name></expr>}</block></expr>;</expr_stmt>

<label><name>protected</name>:</label>
    <decl_stmt><decl><type><name>mapMsgCmdSize</name></type> <name>mapSendBytesPerMsgCmd</name></decl>;</decl_stmt>
    <function_decl><type><name>mapMsgCmdSize</name> <name>mapRecvBytesPerMsgCmd</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_vRecv</name></type></decl></parameter>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>
    <decl_stmt><decl><type><name>uint256</name></type> <name>hashContinue</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>atomic</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name> <name>nStartingHeight</name><block>{<expr><operator>-</operator><literal type="number">1</literal></expr>}</block></expr>;</expr_stmt>

    <comment type="line">// flood relay</comment>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CAddress</name></expr></argument>&gt;</argument_list></name> <name>vAddrToSend</name></expr>;</expr_stmt>
    <expr_stmt><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CRollingBloomFilter</name></expr></argument>&gt;</argument_list></name> <name>m_addr_known</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>fGetAddr</name><block>{<block_content><expr><name>false</name></expr></block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
    <function><type><name>int64_t</name> <name>nNextAddrSend</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_sendProcessing</name></type></decl></parameter>)</parameter_list><block>{<block_content><expr><literal type="number">0</literal></expr></block_content>}</block></function><empty_stmt>;</empty_stmt>
    <function><type><name>int64_t</name> <name>nNextLocalAddrSend</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_sendProcessing</name></type></decl></parameter>)</parameter_list><block>{<block_content><expr><literal type="number">0</literal></expr></block_content>}</block></function><empty_stmt>;</empty_stmt>

    <expr_stmt><expr><name>bool</name> <macro><name>IsAddrRelayPeer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>m_addr_known</name> <operator>!=</operator> <name>nullptr</name></expr>;</return> }</block></expr></expr_stmt>

    <comment type="line">// List of block ids we still have announce.</comment>
    <comment type="line">// There is no final sorting before sending, as they are always sent immediately</comment>
    <comment type="line">// and in the order requested.</comment>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>&gt;</argument_list></name> <name>vInventoryBlockToSend</name> <call><name>GUARDED_BY</name><argument_list>(<argument><expr><name>cs_inventory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>CCriticalSection</name></type> <name>cs_inventory</name></decl>;</decl_stmt>

    <struct>struct <name>TxRelay</name> <block>{
        <macro><name>TxRelay</name><argument_list>()</argument_list></macro> <block>{<block_content> <expr_stmt><expr><name>pfilter</name> <operator>=</operator> <call><name><name>MakeUnique</name><argument_list type="generic">&lt;<argument><expr><name>CBloomFilter</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt> </block_content>}</block>
        <decl_stmt><decl><type><name>mutable</name> <name>CCriticalSection</name></type> <name>cs_filter</name></decl>;</decl_stmt>
        <comment type="line">// We use fRelayTxes for two purposes -</comment>
        <comment type="line">// a) it allows us to not relay tx invs before receiving the peer's version message</comment>
        <comment type="line">// b) the peer may tell us in its version message that we should not relay tx invs</comment>
        <comment type="line">//    unless it loads a bloom filter.</comment>
        <function><type><name>bool</name> <name>fRelayTxes</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_filter</name></type></decl></parameter>)</parameter_list><block>{<block_content><expr><name>false</name></expr></block_content>}</block></function><empty_stmt>;</empty_stmt>
        <expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CBloomFilter</name></expr></argument>&gt;</argument_list></name> <name>pfilter</name> <macro><name>PT_GUARDED_BY</name><argument_list>(<argument>cs_filter</argument>)</argument_list></macro> <call><name>GUARDED_BY</name><argument_list>(<argument><expr><name>cs_filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>mutable</name> <name>CCriticalSection</name></type> <name>cs_tx_inventory</name></decl>;</decl_stmt>
        <function><type><name>CRollingBloomFilter</name> <name>filterInventoryKnown</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_tx_inventory</name></type></decl></parameter>)</parameter_list><block>{<block_content><expr><literal type="number">50000</literal></expr><operator>,</operator> <expr><literal type="number">0.000001</literal></expr></block_content>}</block></function><empty_stmt>;</empty_stmt>
        <comment type="line">// Set of transaction ids we still have to announce.</comment>
        <comment type="line">// They are sorted by the mempool before relay, so the order is not important.</comment>
        <expr_stmt><expr><name>std</name><operator>::</operator><name><name>set</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>&gt;</argument_list></name> <name>setInventoryTxToSend</name></expr>;</expr_stmt>
        <comment type="line">// Used for BIP35 mempool sending</comment>
        <function><type><name>bool</name> <name>fSendMempool</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_tx_inventory</name></type></decl></parameter>)</parameter_list><block>{<block_content><expr><name>false</name></expr></block_content>}</block></function><empty_stmt>;</empty_stmt>
        <comment type="line">// Last time a "MEMPOOL" request was serviced.</comment>
        <expr_stmt><expr><name>std</name><operator>::</operator><name><name>atomic</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>seconds</name></expr></argument>&gt;</argument_list></name> <name>m_last_mempool_req</name><block>{<expr><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>seconds</name><block>{<expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr>;</expr_stmt>
        <expr_stmt><expr><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>microseconds</name> <name>nNextInvSend</name><block>{<expr><literal type="number">0</literal></expr>}</block></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>CCriticalSection</name></type> <name>cs_feeFilter</name></decl>;</decl_stmt>
        <comment type="line">// Minimum fee rate with which to filter inv's to this node</comment>
        <function><type><name>CAmount</name> <name>minFeeFilter</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_feeFilter</name></type></decl></parameter>)</parameter_list><block>{<block_content><expr><literal type="number">0</literal></expr></block_content>}</block></function><empty_stmt>;</empty_stmt>
        <decl_stmt><decl><type><name>CAmount</name></type> <name>lastSentFeeFilter</name><block>{<block_content><expr><literal type="number">0</literal></expr></block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>nextSendTimeFeeFilter</name><block>{<block_content><expr><literal type="number">0</literal></expr></block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
    }</block>;</struct>

    <comment type="line">// m_tx_relay == nullptr if we're not relaying transactions with this peer</comment>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>TxRelay</name></expr></argument>&gt;</argument_list></name> <name>m_tx_relay</name></expr>;</expr_stmt>

    <comment type="line">// Used for headers announcements - unfiltered blocks to relay</comment>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>&gt;</argument_list></name> <name>vBlockHashesToAnnounce</name> <call><name>GUARDED_BY</name><argument_list>(<argument><expr><name>cs_inventory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Block and TXN accept times</comment>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>atomic</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name> <name>nLastBlockTime</name><block>{<expr><literal type="number">0</literal></expr>}</block></expr>;</expr_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>atomic</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name> <name>nLastTXTime</name><block>{<expr><literal type="number">0</literal></expr>}</block></expr>;</expr_stmt>

    <comment type="line">// Ping time measurement:</comment>
    <comment type="line">// The pong reply we're expecting, or 0 if no pong expected.</comment>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>atomic</name><argument_list type="generic">&lt;<argument><expr><name>uint64_t</name></expr></argument>&gt;</argument_list></name> <name>nPingNonceSent</name><block>{<expr><literal type="number">0</literal></expr>}</block></expr>;</expr_stmt>
    <comment type="line">// Time (in usec) the last ping was sent, or 0 if no ping was ever sent.</comment>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>atomic</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name> <name>nPingUsecStart</name><block>{<expr><literal type="number">0</literal></expr>}</block></expr>;</expr_stmt>
    <comment type="line">// Last measured round-trip time.</comment>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>atomic</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name> <name>nPingUsecTime</name><block>{<expr><literal type="number">0</literal></expr>}</block></expr>;</expr_stmt>
    <comment type="line">// Best measured round-trip time.</comment>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>atomic</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name> <name>nMinPingUsecTime</name><block>{<expr><name>std</name><operator>::</operator><name><name>numeric_limits</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>max</name><argument_list>()</argument_list></macro></expr>}</block></expr>;</expr_stmt>
    <comment type="line">// Whether a ping is requested.</comment>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>atomic</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>fPingQueued</name><block>{<expr><name>false</name></expr>}</block></expr>;</expr_stmt>

    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>set</name><argument_list type="generic">&lt;<argument><expr><name>uint256</name></expr></argument>&gt;</argument_list></name> <name>orphan_work_set</name></expr>;</expr_stmt>

    <macro><name>CNode</name><argument_list>(<argument>NodeId id</argument>, <argument>ServiceFlags nLocalServicesIn</argument>, <argument>int nMyStartingHeightIn</argument>, <argument>SOCKET hSocketIn</argument>, <argument>const CAddress &amp;addrIn</argument>, <argument>uint64_t nKeyedNetGroupIn</argument>, <argument>uint64_t nLocalHostNonceIn</argument>, <argument>const CAddress &amp;addrBindIn</argument>, <argument>const std::string &amp;addrNameIn = <literal type="string">""</literal></argument>, <argument>bool fInboundIn = false</argument>, <argument>bool block_relay_only = false</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    <expr_stmt><expr><operator>~</operator><call><name>CNode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CNode</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CNode</name><operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>CNode</name><modifier>&amp;</modifier></type> <name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>CNode</name><operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>

<label><name>private</name>:</label>
    <decl_stmt><decl><type><specifier>const</specifier> <name>NodeId</name></type> <name>id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>nLocalHostNonce</name></decl>;</decl_stmt>

    <comment type="line" format="doxygen">//! Services offered to this peer.</comment>
    <comment type="line" format="doxygen">//!</comment>
    <comment type="line" format="doxygen">//! This is supplied by the parent CConnman during peer connection</comment>
    <comment type="line" format="doxygen">//! (CConnman::ConnectNode()) from its attribute of the same name.</comment>
    <comment type="line" format="doxygen">//!</comment>
    <comment type="line" format="doxygen">//! This is const because there is no protocol defined for renegotiating</comment>
    <comment type="line" format="doxygen">//! services initially offered to a peer. The set of local services we</comment>
    <comment type="line" format="doxygen">//! offer should not change after initialization.</comment>
    <comment type="line" format="doxygen">//!</comment>
    <comment type="line" format="doxygen">//! An interesting example of this is NODE_NETWORK and initial block</comment>
    <comment type="line" format="doxygen">//! download: a node which starts up from scratch doesn't have any blocks</comment>
    <comment type="line" format="doxygen">//! to serve, but still advertises NODE_NETWORK because it will eventually</comment>
    <comment type="line" format="doxygen">//! fulfill this role after IBD completes. P2P code is written in such a</comment>
    <comment type="line" format="doxygen">//! way that it can gracefully handle peers who don't make good on their</comment>
    <comment type="line" format="doxygen">//! service advertisements.</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ServiceFlags</name></type> <name>nLocalServices</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nMyStartingHeight</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nSendVersion</name><block>{<block_content><expr><literal type="number">0</literal></expr></block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
    <decl_stmt><decl><type><name>NetPermissionFlags</name></type> <name>m_permissionFlags</name><block>{<block_content> <expr_stmt><expr><name>PF_NONE</name></expr></expr_stmt> </block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name><name>list</name><argument_list type="generic">&lt;<argument><expr><name>CNetMessage</name></expr></argument>&gt;</argument_list></name> <name>vRecvMsg</name></expr>;</expr_stmt>  <comment type="line">// Used only by SocketHandler thread</comment>

    <decl_stmt><decl><type><name>mutable</name> <name>CCriticalSection</name></type> <name>cs_addrName</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>addrName</name> <call><name>GUARDED_BY</name><argument_list>(<argument><expr><name>cs_addrName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Our address, as reported by the peer</comment>
    <function_decl><type><name>CService</name> <name>addrLocal</name></type> <name>GUARDED_BY</name><parameter_list>(<parameter><decl><type><name>cs_addrLocal</name></type></decl></parameter>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>mutable</name> <name>CCriticalSection</name></type> <name>cs_addrLocal</name></decl>;</decl_stmt>
<label><name>public</name>:</label>

    <expr_stmt><expr><name>NodeId</name> <macro><name>GetId</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
        <return>return <expr><name>id</name></expr>;</return>
    }</block></expr></expr_stmt>

    <expr_stmt><expr><name>uint64_t</name> <macro><name>GetLocalNonce</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
        <return>return <expr><name>nLocalHostNonce</name></expr>;</return>
    }</block></expr></expr_stmt>

    <expr_stmt><expr><name>int</name> <macro><name>GetMyStartingHeight</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
        <return>return <expr><name>nMyStartingHeight</name></expr>;</return>
    }</block></expr></expr_stmt>

    <expr_stmt><expr><name>int</name> <macro><name>GetRefCount</name><argument_list>()</argument_list></macro> <specifier>const</specifier>
    <block>{
        <expr><call><name>assert</name><argument_list>(<argument><expr><name>nRefCount</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;
        <return>return <expr><name>nRefCount</name></expr>;</return>
    }</block></expr></expr_stmt>

    <function_decl><type><name>bool</name></type> <name>ReceiveMsgBytes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pch</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nBytes</name></decl></parameter>, <parameter><decl><type><name>bool</name><modifier>&amp;</modifier></type> <name>complete</name></decl></parameter>)</parameter_list>;</function_decl>

    <function><type><name>void</name></type> <name>SetRecvVersion</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nVersionIn</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name>nRecvVersion</name> <operator>=</operator> <name>nVersionIn</name></expr>;</expr_stmt>
    </block_content>}</block></function>
    <expr_stmt><expr><name>int</name> <macro><name>GetRecvVersion</name><argument_list>()</argument_list></macro> <specifier>const</specifier>
    <block>{
        <return>return <expr><name>nRecvVersion</name></expr>;</return>
    }</block></expr></expr_stmt>
    <function_decl><type><name>void</name></type> <name>SetSendVersion</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nVersionIn</name></decl></parameter>)</parameter_list>;</function_decl>
    <expr_stmt><expr><name>int</name> <macro><name>GetSendVersion</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

    <expr_stmt><expr><name>CService</name> <macro><name>GetAddrLocal</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
    <comment type="line" format="doxygen">//! May not be called more than once</comment>
    <function_decl><type><name>void</name></type> <name>SetAddrLocal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CService</name><modifier>&amp;</modifier></type> <name>addrLocalIn</name></decl></parameter>)</parameter_list>;</function_decl>

    <function><type><name>CNode</name><modifier>*</modifier></type> <name>AddRef</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name>nRefCount</name><operator>++</operator></expr>;</expr_stmt>
        <return>return <expr><name>this</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><name>void</name></type> <name>Release</name><parameter_list>()</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name>nRefCount</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></function>



    <function><type><name>void</name></type> <name>AddAddressKnown</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CAddress</name><modifier>&amp;</modifier></type> <name>_addr</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>m_addr_known</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>m_addr_known</name><operator>-&gt;</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>_addr</name><operator>.</operator><name>GetKey</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type> <name>PushAddress</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CAddress</name><modifier>&amp;</modifier></type> <name>_addr</name></decl></parameter>, <parameter><decl><type><name>FastRandomContext</name> <modifier>&amp;</modifier></type><name>insecure_rand</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="line">// Known checking here is only to save space from duplicates.</comment>
        <comment type="line">// SendMessages will filter it again for knowns that were added</comment>
        <comment type="line">// after addresses were pushed.</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>m_addr_known</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>_addr</name><operator>.</operator><name>IsValid</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>m_addr_known</name><operator>-&gt;</operator><name>contains</name></name><argument_list>(<argument><expr><call><name><name>_addr</name><operator>.</operator><name>GetKey</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>vAddrToSend</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>MAX_ADDR_TO_SEND</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>vAddrToSend</name><index>[<expr><call><name><name>insecure_rand</name><operator>.</operator><name>randrange</name></name><argument_list>(<argument><expr><call><name><name>vAddrToSend</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>_addr</name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name><name>vAddrToSend</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>


    <function><type><name>void</name></type> <name>AddInventoryKnown</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CInv</name><modifier>&amp;</modifier></type> <name>inv</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>m_tx_relay</name> <operator>!=</operator> <name>nullptr</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>m_tx_relay</name><operator>-&gt;</operator><name>cs_tx_inventory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>m_tx_relay</name><operator>-&gt;</operator><name>filterInventoryKnown</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name><name>inv</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type> <name>PushInventory</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CInv</name><modifier>&amp;</modifier></type> <name>inv</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>inv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>MSG_TX</name> <operator>&amp;&amp;</operator> <name>m_tx_relay</name> <operator>!=</operator> <name>nullptr</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name><name>m_tx_relay</name><operator>-&gt;</operator><name>cs_tx_inventory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>m_tx_relay</name><operator>-&gt;</operator><name>filterInventoryKnown</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name><name>inv</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>m_tx_relay</name><operator>-&gt;</operator><name>setInventoryTxToSend</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name><name>inv</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>inv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>MSG_BLOCK</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_inventory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>vInventoryBlockToSend</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name><name>inv</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type> <name>PushBlockHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint256</name> <modifier>&amp;</modifier></type><name>hash</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOCK</name><argument_list>(<argument><expr><name>cs_inventory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>vBlockHashesToAnnounce</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function_decl><type><name>void</name></type> <name>CloseSocketDisconnect</name><parameter_list>()</parameter_list>;</function_decl>

    <function_decl><type><name>void</name></type> <name>copyStats</name><parameter_list>(<parameter><decl><type><name>CNodeStats</name> <modifier>&amp;</modifier></type><name>stats</name></decl></parameter>)</parameter_list>;</function_decl>

    <expr_stmt><expr><name>ServiceFlags</name> <macro><name>GetLocalServices</name><argument_list>()</argument_list></macro> <specifier>const</specifier>
    <block>{
        <return>return <expr><name>nLocalServices</name></expr>;</return>
    }</block></expr></expr_stmt>

    <expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>GetAddrName</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
    <comment type="line" format="doxygen">//! Sets the addrName only if it was not previously set</comment>
    <decl_stmt><decl><type><name>void</name></type> <name>MaybeSetAddrName</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>addrNameIn</name></expr></argument>)</argument_list></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block" format="doxygen">/** Return a timestamp in the future (in microseconds) for exponentially distributed events. */</comment>
<function_decl><type><name>int64_t</name></type> <name>PoissonNextSend</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>now</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>average_interval_seconds</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/** Wrapper to return mockable type */</comment>
<expr_stmt><expr><specifier>inline</specifier> <name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>microseconds</name> <macro><name>PoissonNextSend</name><argument_list>(<argument>std::chrono::microseconds now</argument>, <argument>std::chrono::seconds average_interval</argument>)</argument_list></macro>
<block>{
    <return>return <expr><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>microseconds</name><block>{<macro><name>PoissonNextSend</name><argument_list>(<argument>now.count()</argument>, <argument>average_interval.count()</argument>)</argument_list></macro>}</block></expr>;</return>
}</block></expr></expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// BITCOIN_NET_H</comment>
</unit>
