<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C++" filename="/home/mmm/Projects/bitcoin/src/test/dbwrapper_tests.cpp"><comment type="line">// Copyright (c) 2012-2019 The Bitcoin Core developers</comment>
<comment type="line">// Distributed under the MIT software license, see the accompanying</comment>
<comment type="line">// file COPYING or http://www.opensource.org/licenses/mit-license.php.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dbwrapper.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;uint256.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;test/util/setup_common.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/memory.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;memory&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;boost/test/unit_test.hpp&gt;</cpp:file></cpp:include>

<comment type="line">// Test if a string consists entirely of null characters</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>is_null_key</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>isnull</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>key</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>isnull</name> <operator>&amp;=</operator> <operator>(</operator><name><name>key</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\x00'</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></for>

    <return>return <expr><name>isnull</name></expr>;</return>
</block_content>}</block></function>

<macro><name>BOOST_FIXTURE_TEST_SUITE</name><argument_list>(<argument>dbwrapper_tests</argument>, <argument>BasicTestingSetup</argument>)</argument_list></macro>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>dbwrapper</argument>)</argument_list></macro>
<block>{<block_content>
    <comment type="line">// Perform tests both obfuscated and non-obfuscated.</comment>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <name>bool</name></type> <name>obfuscate</name> <range>: <expr><block>{<expr><literal type="boolean">false</literal></expr>, <expr><literal type="boolean">true</literal></expr>}</block></expr></range></decl></init>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name><name>fs</name><operator>::</operator><name>path</name></name></type> <name>ph</name> <init>= <expr><call><name>GetDataDir</name><argument_list>()</argument_list></call> <operator>/</operator> <operator>(</operator><ternary><condition><expr><name>obfuscate</name></expr> ?</condition><then> <expr><literal type="string">"dbwrapper_obfuscate_true"</literal></expr> </then><else>: <expr><literal type="string">"dbwrapper_obfuscate_false"</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CDBWrapper</name></type> <name>dbw</name><argument_list>(<argument><expr><name>ph</name></expr></argument>, <argument><expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">20</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name>obfuscate</name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name>key</name> <init>= <expr><literal type="char">'k'</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint256</name></type> <name>in</name> <init>= <expr><call><name>InsecureRand256</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint256</name></type> <name>res</name></decl>;</decl_stmt>

        <comment type="line">// Ensure that we're doing real obfuscation when obfuscate=true</comment>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name>obfuscate</name> <operator>!=</operator> <call><name>is_null_key</name><argument_list>(<argument><expr><call><name><name>dbwrapper_private</name><operator>::</operator><name>GetObfuscateKey</name></name><argument_list>(<argument><expr><name>dbw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>.</operator><name>Read</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>res</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>in</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>dbwrapper_basic_data</argument>)</argument_list></macro>
<block>{<block_content>
    <comment type="line">// Perform tests both obfuscated and non-obfuscated.</comment>
    <for>for <control>(<init><decl><type><name>bool</name></type> <name>obfuscate</name> <range>: <expr><block>{<expr><literal type="boolean">false</literal></expr>, <expr><literal type="boolean">true</literal></expr>}</block></expr></range></decl></init>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name><name>fs</name><operator>::</operator><name>path</name></name></type> <name>ph</name> <init>= <expr><call><name>GetDataDir</name><argument_list>()</argument_list></call> <operator>/</operator> <operator>(</operator><ternary><condition><expr><name>obfuscate</name></expr> ?</condition><then> <expr><literal type="string">"dbwrapper_1_obfuscate_true"</literal></expr> </then><else>: <expr><literal type="string">"dbwrapper_1_obfuscate_false"</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CDBWrapper</name></type> <name>dbw</name><argument_list>(<argument><expr><name>ph</name></expr></argument>, <argument><expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">20</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><name>obfuscate</name></expr></argument>)</argument_list></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>uint256</name></type> <name>res</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>res_uint_32</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>res_bool</name></decl>;</decl_stmt>

        <comment type="line">// Ensure that we're doing real obfuscation when obfuscate=true</comment>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><name>obfuscate</name> <operator>!=</operator> <call><name>is_null_key</name><argument_list>(<argument><expr><call><name><name>dbwrapper_private</name><operator>::</operator><name>GetObfuscateKey</name></name><argument_list>(<argument><expr><name>dbw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">//Simulate block raw data - "b + block hash"</comment>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>key_block</name> <init>= <expr><literal type="string">"b"</literal> <operator>+</operator> <call><name>InsecureRand256</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ToString</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>uint256</name></type> <name>in_block</name> <init>= <expr><call><name>InsecureRand256</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><name>key_block</name></expr></argument>, <argument><expr><name>in_block</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>.</operator><name>Read</name></name><argument_list>(<argument><expr><name>key_block</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>res</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>in_block</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">//Simulate file raw data - "f + file_number"</comment>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>key_file</name> <init>= <expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"f%04x"</literal></expr></argument>, <argument><expr><call><name>InsecureRand32</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>uint256</name></type> <name>in_file_info</name> <init>= <expr><call><name>InsecureRand256</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><name>key_file</name></expr></argument>, <argument><expr><name>in_file_info</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>.</operator><name>Read</name></name><argument_list>(<argument><expr><name>key_file</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>res</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>in_file_info</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">//Simulate transaction raw data - "t + transaction hash"</comment>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>key_transaction</name> <init>= <expr><literal type="string">"t"</literal> <operator>+</operator> <call><name>InsecureRand256</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ToString</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>uint256</name></type> <name>in_transaction</name> <init>= <expr><call><name>InsecureRand256</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><name>key_transaction</name></expr></argument>, <argument><expr><name>in_transaction</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>.</operator><name>Read</name></name><argument_list>(<argument><expr><name>key_transaction</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>res</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>in_transaction</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">//Simulate UTXO raw data - "c + transaction hash"</comment>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>key_utxo</name> <init>= <expr><literal type="string">"c"</literal> <operator>+</operator> <call><name>InsecureRand256</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ToString</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>uint256</name></type> <name>in_utxo</name> <init>= <expr><call><name>InsecureRand256</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><name>key_utxo</name></expr></argument>, <argument><expr><name>in_utxo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>.</operator><name>Read</name></name><argument_list>(<argument><expr><name>key_utxo</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>res</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>in_utxo</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">//Simulate last block file number - "l"</comment>
        <decl_stmt><decl><type><name>char</name></type> <name>key_last_blockfile_number</name> <init>= <expr><literal type="char">'l'</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>lastblockfilenumber</name> <init>= <expr><call><name>InsecureRand32</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><name>key_last_blockfile_number</name></expr></argument>, <argument><expr><name>lastblockfilenumber</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>.</operator><name>Read</name></name><argument_list>(<argument><expr><name>key_last_blockfile_number</name></expr></argument>, <argument><expr><name>res_uint_32</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>lastblockfilenumber</name></expr></argument>, <argument><expr><name>res_uint_32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">//Simulate Is Reindexing - "R"</comment>
        <decl_stmt><decl><type><name>char</name></type> <name>key_IsReindexing</name> <init>= <expr><literal type="char">'R'</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>isInReindexing</name> <init>= <expr><call><name>InsecureRandBool</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><name>key_IsReindexing</name></expr></argument>, <argument><expr><name>isInReindexing</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>.</operator><name>Read</name></name><argument_list>(<argument><expr><name>key_IsReindexing</name></expr></argument>, <argument><expr><name>res_bool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>isInReindexing</name></expr></argument>, <argument><expr><name>res_bool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">//Simulate last block hash up to which UXTO covers - 'B'</comment>
        <decl_stmt><decl><type><name>char</name></type> <name>key_lastblockhash_uxto</name> <init>= <expr><literal type="char">'B'</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint256</name></type> <name>lastblock_hash</name> <init>= <expr><call><name>InsecureRand256</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><name>key_lastblockhash_uxto</name></expr></argument>, <argument><expr><name>lastblock_hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>.</operator><name>Read</name></name><argument_list>(<argument><expr><name>key_lastblockhash_uxto</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>lastblock_hash</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">//Simulate file raw data - "F + filename_number + filename"</comment>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>file_option_tag</name> <init>= <expr><literal type="string">"F"</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint8_t</name></type> <name>filename_length</name> <init>= <expr><call><name>InsecureRandBits</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>filename</name> <init>= <expr><literal type="string">"randomfilename"</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>key_file_option</name> <init>= <expr><call><name>strprintf</name><argument_list>(<argument><expr><literal type="string">"%s%01x%s"</literal></expr></argument>, <argument><expr><name>file_option_tag</name></expr></argument>,<argument><expr><name>filename_length</name></expr></argument>,<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>bool</name></type> <name>in_file_bool</name> <init>= <expr><call><name>InsecureRandBool</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><name>key_file_option</name></expr></argument>, <argument><expr><name>in_file_bool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>.</operator><name>Read</name></name><argument_list>(<argument><expr><name>key_file_option</name></expr></argument>, <argument><expr><name>res_bool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>res_bool</name></expr></argument>, <argument><expr><name>in_file_bool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   </block_content>}</block></for>
</block_content>}</block>

<comment type="line">// Test batch operations</comment>
<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>dbwrapper_batch</argument>)</argument_list></macro>
<block>{<block_content>
    <comment type="line">// Perform tests both obfuscated and non-obfuscated.</comment>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <name>bool</name></type> <name>obfuscate</name> <range>: <expr><block>{<expr><literal type="boolean">false</literal></expr>, <expr><literal type="boolean">true</literal></expr>}</block></expr></range></decl></init>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name><name>fs</name><operator>::</operator><name>path</name></name></type> <name>ph</name> <init>= <expr><call><name>GetDataDir</name><argument_list>()</argument_list></call> <operator>/</operator> <operator>(</operator><ternary><condition><expr><name>obfuscate</name></expr> ?</condition><then> <expr><literal type="string">"dbwrapper_batch_obfuscate_true"</literal></expr> </then><else>: <expr><literal type="string">"dbwrapper_batch_obfuscate_false"</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CDBWrapper</name></type> <name>dbw</name><argument_list>(<argument><expr><name>ph</name></expr></argument>, <argument><expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">20</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name>obfuscate</name></expr></argument>)</argument_list></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>char</name></type> <name>key</name> <init>= <expr><literal type="char">'i'</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint256</name></type> <name>in</name> <init>= <expr><call><name>InsecureRand256</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name>key2</name> <init>= <expr><literal type="char">'j'</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint256</name></type> <name>in2</name> <init>= <expr><call><name>InsecureRand256</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name>key3</name> <init>= <expr><literal type="char">'k'</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint256</name></type> <name>in3</name> <init>= <expr><call><name>InsecureRand256</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>uint256</name></type> <name>res</name></decl>;</decl_stmt>
        <function_decl><type><name>CDBBatch</name></type> <name>batch</name><parameter_list>(<parameter><decl><type><name>dbw</name></type></decl></parameter>)</parameter_list>;</function_decl>

        <expr_stmt><expr><call><name><name>batch</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>batch</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><name>key2</name></expr></argument>, <argument><expr><name>in2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>batch</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><name>key3</name></expr></argument>, <argument><expr><name>in3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Remove key3 before it's even been written</comment>
        <expr_stmt><expr><call><name><name>batch</name><operator>.</operator><name>Erase</name></name><argument_list>(<argument><expr><name>key3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>.</operator><name>WriteBatch</name></name><argument_list>(<argument><expr><name>batch</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>.</operator><name>Read</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>res</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>in</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>.</operator><name>Read</name></name><argument_list>(<argument><expr><name>key2</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>res</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>in2</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// key3 should've never been written</comment>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>.</operator><name>Read</name></name><argument_list>(<argument><expr><name>key3</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>dbwrapper_iterator</argument>)</argument_list></macro>
<block>{<block_content>
    <comment type="line">// Perform tests both obfuscated and non-obfuscated.</comment>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <name>bool</name></type> <name>obfuscate</name> <range>: <expr><block>{<expr><literal type="boolean">false</literal></expr>, <expr><literal type="boolean">true</literal></expr>}</block></expr></range></decl></init>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name><name>fs</name><operator>::</operator><name>path</name></name></type> <name>ph</name> <init>= <expr><call><name>GetDataDir</name><argument_list>()</argument_list></call> <operator>/</operator> <operator>(</operator><ternary><condition><expr><name>obfuscate</name></expr> ?</condition><then> <expr><literal type="string">"dbwrapper_iterator_obfuscate_true"</literal></expr> </then><else>: <expr><literal type="string">"dbwrapper_iterator_obfuscate_false"</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CDBWrapper</name></type> <name>dbw</name><argument_list>(<argument><expr><name>ph</name></expr></argument>, <argument><expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">20</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name>obfuscate</name></expr></argument>)</argument_list></decl>;</decl_stmt>

        <comment type="line">// The two keys are intentionally chosen for ordering</comment>
        <decl_stmt><decl><type><name>char</name></type> <name>key</name> <init>= <expr><literal type="char">'j'</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint256</name></type> <name>in</name> <init>= <expr><call><name>InsecureRand256</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name>key2</name> <init>= <expr><literal type="char">'k'</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint256</name></type> <name>in2</name> <init>= <expr><call><name>InsecureRand256</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><name>key2</name></expr></argument>, <argument><expr><name>in2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CDBIterator</name></expr></argument>&gt;</argument_list></name></type> <name>it</name><argument_list>(<argument><expr><cast type="const">const_cast<argument_list type="generic">&lt;<argument><expr><name>CDBWrapper</name><operator>&amp;</operator></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name>dbw</name></expr></argument>)</argument_list></cast><operator>.</operator><call><name>NewIterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

        <comment type="line">// Be sure to seek past the obfuscation key (if it exists)</comment>
        <expr_stmt><expr><call><name><name>it</name><operator>-&gt;</operator><name>Seek</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>char</name></type> <name>key_res</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint256</name></type> <name>val_res</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>BOOST_REQUIRE</name><argument_list>(<argument><expr><call><name><name>it</name><operator>-&gt;</operator><name>GetKey</name></name><argument_list>(<argument><expr><name>key_res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_REQUIRE</name><argument_list>(<argument><expr><call><name><name>it</name><operator>-&gt;</operator><name>GetValue</name></name><argument_list>(<argument><expr><name>val_res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>key_res</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>val_res</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>in</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>it</name><operator>-&gt;</operator><name>Next</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>BOOST_REQUIRE</name><argument_list>(<argument><expr><call><name><name>it</name><operator>-&gt;</operator><name>GetKey</name></name><argument_list>(<argument><expr><name>key_res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_REQUIRE</name><argument_list>(<argument><expr><call><name><name>it</name><operator>-&gt;</operator><name>GetValue</name></name><argument_list>(<argument><expr><name>val_res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>key_res</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>val_res</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>in2</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>it</name><operator>-&gt;</operator><name>Next</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>it</name><operator>-&gt;</operator><name>Valid</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block>

<comment type="line">// Test that we do not obfuscation if there is existing data.</comment>
<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>existing_data_no_obfuscate</argument>)</argument_list></macro>
<block>{<block_content>
    <comment type="line">// We're going to share this fs::path between two wrappers</comment>
    <decl_stmt><decl><type><name><name>fs</name><operator>::</operator><name>path</name></name></type> <name>ph</name> <init>= <expr><call><name>GetDataDir</name><argument_list>()</argument_list></call> <operator>/</operator> <literal type="string">"existing_data_no_obfuscate"</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>create_directories</name><argument_list>(<argument><expr><name>ph</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Set up a non-obfuscated wrapper to write some initial data.</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CDBWrapper</name></expr></argument>&gt;</argument_list></name></type> <name>dbw</name> <init>= <expr><call><name><name>MakeUnique</name><argument_list type="generic">&lt;<argument><expr><name>CDBWrapper</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ph</name></expr></argument>, <argument><expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">10</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>key</name> <init>= <expr><literal type="char">'k'</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint256</name></type> <name>in</name> <init>= <expr><call><name>InsecureRand256</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint256</name></type> <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>-&gt;</operator><name>Write</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>-&gt;</operator><name>Read</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>res</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>in</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Call the destructor to free leveldb LOCK</comment>
    <expr_stmt><expr><call><name><name>dbw</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Now, set up another wrapper that wants to obfuscate the same directory</comment>
    <decl_stmt><decl><type><name>CDBWrapper</name></type> <name>odbw</name><argument_list>(<argument><expr><name>ph</name></expr></argument>, <argument><expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">10</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></decl>;</decl_stmt>

    <comment type="line">// Check that the key/val we wrote with unobfuscated wrapper exists and</comment>
    <comment type="line">// is readable.</comment>
    <decl_stmt><decl><type><name>uint256</name></type> <name>res2</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>odbw</name><operator>.</operator><name>Read</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>res2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>res2</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>in</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>odbw</name><operator>.</operator><name>IsEmpty</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// There should be existing data</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name>is_null_key</name><argument_list>(<argument><expr><call><name><name>dbwrapper_private</name><operator>::</operator><name>GetObfuscateKey</name></name><argument_list>(<argument><expr><name>odbw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// The key should be an empty string</comment>

    <decl_stmt><decl><type><name>uint256</name></type> <name>in2</name> <init>= <expr><call><name>InsecureRand256</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint256</name></type> <name>res3</name></decl>;</decl_stmt>

    <comment type="line">// Check that we can write successfully</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>odbw</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>in2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>odbw</name><operator>.</operator><name>Read</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>res3</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>res3</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>in2</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<comment type="line">// Ensure that we start obfuscating during a reindex.</comment>
<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>existing_data_reindex</argument>)</argument_list></macro>
<block>{<block_content>
    <comment type="line">// We're going to share this fs::path between two wrappers</comment>
    <decl_stmt><decl><type><name><name>fs</name><operator>::</operator><name>path</name></name></type> <name>ph</name> <init>= <expr><call><name>GetDataDir</name><argument_list>()</argument_list></call> <operator>/</operator> <literal type="string">"existing_data_reindex"</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>create_directories</name><argument_list>(<argument><expr><name>ph</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Set up a non-obfuscated wrapper to write some initial data.</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CDBWrapper</name></expr></argument>&gt;</argument_list></name></type> <name>dbw</name> <init>= <expr><call><name><name>MakeUnique</name><argument_list type="generic">&lt;<argument><expr><name>CDBWrapper</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ph</name></expr></argument>, <argument><expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">10</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>key</name> <init>= <expr><literal type="char">'k'</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint256</name></type> <name>in</name> <init>= <expr><call><name>InsecureRand256</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint256</name></type> <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>-&gt;</operator><name>Write</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>-&gt;</operator><name>Read</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>res</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>in</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Call the destructor to free leveldb LOCK</comment>
    <expr_stmt><expr><call><name><name>dbw</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Simulate a -reindex by wiping the existing data store</comment>
    <decl_stmt><decl><type><name>CDBWrapper</name></type> <name>odbw</name><argument_list>(<argument><expr><name>ph</name></expr></argument>, <argument><expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">10</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></decl>;</decl_stmt>

    <comment type="line">// Check that the key/val we wrote with unobfuscated wrapper doesn't exist</comment>
    <decl_stmt><decl><type><name>uint256</name></type> <name>res2</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>odbw</name><operator>.</operator><name>Read</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>res2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>is_null_key</name><argument_list>(<argument><expr><call><name><name>dbwrapper_private</name><operator>::</operator><name>GetObfuscateKey</name></name><argument_list>(<argument><expr><name>odbw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>uint256</name></type> <name>in2</name> <init>= <expr><call><name>InsecureRand256</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint256</name></type> <name>res3</name></decl>;</decl_stmt>

    <comment type="line">// Check that we can write successfully</comment>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>odbw</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>in2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>odbw</name><operator>.</operator><name>Read</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>res3</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><call><name><name>res3</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>in2</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>iterator_ordering</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>fs</name><operator>::</operator><name>path</name></name></type> <name>ph</name> <init>= <expr><call><name>GetDataDir</name><argument_list>()</argument_list></call> <operator>/</operator> <literal type="string">"iterator_ordering"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CDBWrapper</name></type> <name>dbw</name><argument_list>(<argument><expr><name>ph</name></expr></argument>, <argument><expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">20</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>x</name><init>=<expr><literal type="number">0x00</literal></expr></init></decl>;</init> <condition><expr><name>x</name><operator>&lt;</operator><literal type="number">256</literal></expr>;</condition> <incr><expr><operator>++</operator><name>x</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>uint8_t</name></type> <name>key</name> <init>= <expr><name>x</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>value</name> <init>= <expr><name>x</name><operator>*</operator><name>x</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="line">// Check that creating an iterator creates a snapshot</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CDBIterator</name></expr></argument>&gt;</argument_list></name></type> <name>it</name><argument_list>(<argument><expr><cast type="const">const_cast<argument_list type="generic">&lt;<argument><expr><name>CDBWrapper</name><operator>&amp;</operator></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name>dbw</name></expr></argument>)</argument_list></cast><operator>.</operator><call><name>NewIterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>x</name><init>=<expr><literal type="number">0x00</literal></expr></init></decl>;</init> <condition><expr><name>x</name><operator>&lt;</operator><literal type="number">256</literal></expr>;</condition> <incr><expr><operator>++</operator><name>x</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>uint8_t</name></type> <name>key</name> <init>= <expr><name>x</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>value</name> <init>= <expr><name>x</name><operator>*</operator><name>x</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>x</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <for>for <control>(<init><decl><type><specifier>const</specifier> <name>int</name></type> <name>seek_start</name> <range>: <expr><block>{<expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x80</literal></expr>}</block></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>it</name><operator>-&gt;</operator><name>Seek</name></name><argument_list>(<argument><expr><operator>(</operator><name>uint8_t</name><operator>)</operator><name>seek_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>x</name><init>=<expr><name>seek_start</name></expr></init></decl>;</init> <condition><expr><name>x</name><operator>&lt;</operator><literal type="number">255</literal></expr>;</condition> <incr><expr><operator>++</operator><name>x</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>uint8_t</name></type> <name>key</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uint32_t</name></type> <name>value</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>it</name><operator>-&gt;</operator><name>Valid</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>it</name><operator>-&gt;</operator><name>Valid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="line">// Avoid spurious errors about invalid iterator's key and value in case of failure</comment>
                <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>it</name><operator>-&gt;</operator><name>GetKey</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>x</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>x</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>it</name><operator>-&gt;</operator><name>GetValue</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>x</name><operator>*</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>it</name><operator>-&gt;</operator><name>Next</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>it</name><operator>-&gt;</operator><name>Valid</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block>

<struct>struct <name>StringContentsSerializer</name> <block>{<public type="default">
    <comment type="line">// Used to make two serialized objects the same while letting them have different lengths</comment>
    <comment type="line">// This is a terrible idea</comment>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>str</name></decl>;</decl_stmt>
    <constructor><name>StringContentsSerializer</name><parameter_list>()</parameter_list> <block>{<block_content/>}</block></constructor>
    <constructor><specifier>explicit</specifier> <name>StringContentsSerializer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>inp</name></decl></parameter>)</parameter_list> <member_init_list>: <call><name>str</name><argument_list>(<argument><expr><name>inp</name></expr></argument>)</argument_list></call> </member_init_list><block>{<block_content/>}</block></constructor>

    <function type="operator"><type><name>StringContentsSerializer</name><modifier>&amp;</modifier></type> <name>operator<name>+=</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string</name></name><modifier>&amp;</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name>str</name> <operator>+=</operator> <name>s</name></expr>;</expr_stmt>
        <return>return <expr><operator>*</operator><name>this</name></expr>;</return>
    </block_content>}</block></function>
    <function type="operator"><type><name>StringContentsSerializer</name><modifier>&amp;</modifier></type> <name>operator<name>+=</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>StringContentsSerializer</name><modifier>&amp;</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>*</operator><name>this</name> <operator>+=</operator> <name><name>s</name><operator>.</operator><name>str</name></name></expr>;</return> </block_content>}</block></function>

    <macro><name>ADD_SERIALIZE_METHODS</name></macro><empty_stmt>;</empty_stmt>

    <function><template>template <parameter_list>&lt;<parameter><type><name>typename</name></type> <name>Stream</name></parameter>, <parameter><type><name>typename</name></type> <name>Operation</name></parameter>&gt;</parameter_list></template>
    <type><specifier>inline</specifier> <name>void</name></type> <name>SerializationOp</name><parameter_list>(<parameter><decl><type><name>Stream</name><modifier>&amp;</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>Operation</name></type> <name>ser_action</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>ser_action</name><operator>.</operator><name>ForRead</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>str</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><literal type="boolean">true</literal></expr>)</condition> <block>{<block_content>
                <try>try <block>{<block_content>
                    <expr_stmt><expr><call><name>READWRITE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>str</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>ios_base</name><operator>::</operator><name>failure</name></name><modifier>&amp;</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
                    <break>break;</break>
                </block_content>}</block></catch></try>
            </block_content>}</block></while>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>str</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>READWRITE</name><argument_list>(<argument><expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></function>
</public>}</block>;</struct>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>iterator_string_ordering</argument>)</argument_list></macro>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>fs</name><operator>::</operator><name>path</name></name></type> <name>ph</name> <init>= <expr><call><name>GetDataDir</name><argument_list>()</argument_list></call> <operator>/</operator> <literal type="string">"iterator_string_ordering"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CDBWrapper</name></type> <name>dbw</name><argument_list>(<argument><expr><name>ph</name></expr></argument>, <argument><expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">20</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>x</name><init>=<expr><literal type="number">0x00</literal></expr></init></decl>;</init> <condition><expr><name>x</name><operator>&lt;</operator><literal type="number">10</literal></expr>;</condition> <incr><expr><operator>++</operator><name>x</name></expr></incr>)</control> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>y</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <function_decl><type><name>StringContentsSerializer</name></type> <name>key</name><parameter_list>(<parameter><decl><type><name>buf</name></type></decl></parameter>)</parameter_list>;</function_decl>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>z</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>y</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><name>key</name> <operator>+=</operator> <name>key</name></expr>;</expr_stmt></block_content></block></for>
            <decl_stmt><decl><type><name>uint32_t</name></type> <name>value</name> <init>= <expr><name>x</name><operator>*</operator><name>x</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>dbw</name><operator>.</operator><name>Write</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>

    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CDBIterator</name></expr></argument>&gt;</argument_list></name></type> <name>it</name><argument_list>(<argument><expr><cast type="const">const_cast<argument_list type="generic">&lt;<argument><expr><name>CDBWrapper</name><operator>&amp;</operator></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name>dbw</name></expr></argument>)</argument_list></cast><operator>.</operator><call><name>NewIterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <name>int</name></type> <name>seek_start</name> <range>: <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">5</literal></expr>}</block></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>seek_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <function_decl><type><name>StringContentsSerializer</name></type> <name>seek_key</name><parameter_list>(<parameter><decl><type><name>buf</name></type></decl></parameter>)</parameter_list>;</function_decl>
        <expr_stmt><expr><call><name><name>it</name><operator>-&gt;</operator><name>Seek</name></name><argument_list>(<argument><expr><name>seek_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>x</name><init>=<expr><name>seek_start</name></expr></init></decl>;</init> <condition><expr><name>x</name><operator>&lt;</operator><literal type="number">10</literal></expr>;</condition> <incr><expr><operator>++</operator><name>x</name></expr></incr>)</control> <block>{<block_content>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>y</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <function_decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>exp_key</name><parameter_list>(<parameter><decl><type><name>buf</name></type></decl></parameter>)</parameter_list>;</function_decl>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>z</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>y</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>exp_key</name> <operator>+=</operator> <name>exp_key</name></expr>;</expr_stmt></block_content></block></for>
                <decl_stmt><decl><type><name>StringContentsSerializer</name></type> <name>key</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>uint32_t</name></type> <name>value</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>it</name><operator>-&gt;</operator><name>Valid</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>it</name><operator>-&gt;</operator><name>Valid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="line">// Avoid spurious errors about invalid iterator's key and value in case of failure</comment>
                    <break>break;</break></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>it</name><operator>-&gt;</operator><name>GetKey</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>it</name><operator>-&gt;</operator><name>GetValue</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><name>exp_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>BOOST_CHECK_EQUAL</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>x</name><operator>*</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>it</name><operator>-&gt;</operator><name>Next</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>it</name><operator>-&gt;</operator><name>Valid</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block>

<macro><name>BOOST_AUTO_TEST_CASE</name><argument_list>(<argument>unicodepath</argument>)</argument_list></macro>
<block>{<block_content>
    <comment type="line">// Attempt to create a database with a utf8 character in the path.</comment>
    <comment type="line">// On Windows this test will fail if the directory is created using</comment>
    <comment type="line">// the ANSI CreateDirectoryA  call and the code page isn't UTF8.</comment>
    <comment type="line">// It will succeed if the created with  CreateDirectoryW.</comment>
    <decl_stmt><decl><type><name><name>fs</name><operator>::</operator><name>path</name></name></type> <name>ph</name> <init>= <expr><call><name>GetDataDir</name><argument_list>()</argument_list></call> <operator>/</operator> <literal type="string">"test_runner___20191128_104644"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CDBWrapper</name></type> <name>dbw</name><argument_list>(<argument><expr><name>ph</name></expr></argument>, <argument><expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">20</literal><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>fs</name><operator>::</operator><name>path</name></name></type> <name>lockPath</name> <init>= <expr><name>ph</name> <operator>/</operator> <literal type="string">"LOCK"</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>BOOST_CHECK</name><argument_list>(<argument><expr><call><name><name>boost</name><operator>::</operator><name>filesystem</name><operator>::</operator><name>exists</name></name><argument_list>(<argument><expr><name>lockPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>


<macro><name>BOOST_AUTO_TEST_SUITE_END</name><argument_list>()</argument_list></macro>
</unit>
