<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/mmm/Projects/bitcoin/src/secp256k1/src/ecmult_impl.h"><comment type="block" format="doxygen">/*****************************************************************************
 * Copyright (c) 2013, 2014, 2017 Pieter Wuille, Andrew Poelstra, Jonas Nick *
 * Distributed under the MIT software license, see the accompanying          *
 * file COPYING or http://www.opensource.org/licenses/mit-license.php.       *
 *****************************************************************************/</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SECP256K1_ECMULT_IMPL_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SECP256K1_ECMULT_IMPL_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"group.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scalar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ecmult.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXHAUSTIVE_TEST_ORDER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* We need to lower these values for exhaustive tests because
 * the tables cannot have infinities in them (this breaks the
 * affine-isomorphism stuff which tracks z-ratios) */</comment>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><name>EXHAUSTIVE_TEST_ORDER</name> <operator>&gt;</operator> <literal type="number">128</literal></expr></cpp:if>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>WINDOW_A</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>WINDOW_G</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:elif>#  <cpp:directive>elif</cpp:directive> <expr><name>EXHAUSTIVE_TEST_ORDER</name> <operator>&gt;</operator> <literal type="number">8</literal></expr></cpp:elif>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>WINDOW_A</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>WINDOW_G</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>WINDOW_A</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>WINDOW_G</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<comment type="block">/* optimal for 128-bit and 256-bit exponents. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WINDOW_A</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<comment type="block" format="doxygen">/** larger numbers may result in slightly better performance, at the cost of
    exponentially larger precomputed tables. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ENDOMORPHISM</name></cpp:ifdef>
<comment type="block" format="doxygen">/** Two tables for window size 15: 1.375 MiB. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WINDOW_G</name></cpp:macro> <cpp:value>15</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<comment type="block" format="doxygen">/** One table for window size 16: 1.375 MiB. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WINDOW_G</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ENDOMORPHISM</name></cpp:ifdef>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WNAF_BITS</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WNAF_BITS</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WNAF_SIZE_BITS</name><parameter_list>(<parameter><type><name>bits</name></type></parameter>, <parameter><type><name>w</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((bits) + (w) - 1) / (w))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WNAF_SIZE</name><parameter_list>(<parameter><type><name>w</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>WNAF_SIZE_BITS(WNAF_BITS, w)</cpp:value></cpp:define>

<comment type="block" format="doxygen">/** The number of entries a table with precomputed multiples needs to have. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECMULT_TABLE_SIZE</name><parameter_list>(<parameter><type><name>w</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(1 &lt;&lt; ((w)-2))</cpp:value></cpp:define>

<comment type="block">/* The number of objects allocated on the scratch space for ecmult_multi algorithms */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PIPPENGER_SCRATCH_OBJECTS</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRAUSS_SCRATCH_OBJECTS</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PIPPENGER_MAX_BUCKET_WINDOW</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define>

<comment type="block">/* Minimum number of points for which pippenger_wnaf is faster than strauss wnaf */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ENDOMORPHISM</name></cpp:ifdef>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECMULT_PIPPENGER_THRESHOLD</name></cpp:macro> <cpp:value>88</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECMULT_PIPPENGER_THRESHOLD</name></cpp:macro> <cpp:value>160</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ENDOMORPHISM</name></cpp:ifdef>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECMULT_MAX_POINTS_PER_BATCH</name></cpp:macro> <cpp:value>5000000</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECMULT_MAX_POINTS_PER_BATCH</name></cpp:macro> <cpp:value>10000000</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/** Fill a table 'prej' with precomputed odd multiples of a. Prej will contain
 *  the values [1*a,3*a,...,(2*n-1)*a], so it space for n values. zr[0] will
 *  contain prej[0].z / a.z. The other zr[i] values = prej[i].z / prej[i-1].z.
 *  Prej's Z values are undefined, except for the last value.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>secp256k1_ecmult_odd_multiples_table</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>secp256k1_gej</name> <modifier>*</modifier></type><name>prej</name></decl></parameter>, <parameter><decl><type><name>secp256k1_fe</name> <modifier>*</modifier></type><name>zr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>secp256k1_gej</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>secp256k1_gej</name></type> <name>d</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>secp256k1_ge</name></type> <name>a_ge</name></decl>, <decl><type ref="prev"/><name>d_ge</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>VERIFY_CHECK</name><argument_list>(<argument><expr><operator>!</operator><name><name>a</name><operator>-&gt;</operator><name>infinity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>secp256k1_gej_double_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Perform the additions on an isomorphism where 'd' is affine: drop the z coordinate
     * of 'd', and scale the 1P starting value's x/y coordinates without changing its z.
     */</comment>
    <expr_stmt><expr><name><name>d_ge</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>d</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>d_ge</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>d</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>d_ge</name><operator>.</operator><name>infinity</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>secp256k1_ge_set_gej_zinv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>a_ge</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>d</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>prej</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>a_ge</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>prej</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>a_ge</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>prej</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>z</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>z</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>prej</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>infinity</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>zr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>d</name><operator>.</operator><name>z</name></name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>secp256k1_gej_add_ge_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>prej</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>prej</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d_ge</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Each point in 'prej' has a z coordinate too small by a factor of 'd.z'. Only
     * the final point's z coordinate is actually used though, so just update that.
     */</comment>
    <expr_stmt><expr><call><name>secp256k1_fe_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>prej</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>prej</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>d</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** Fill a table 'pre' with precomputed odd multiples of a.
 *
 *  There are two versions of this function:
 *  - secp256k1_ecmult_odd_multiples_table_globalz_windowa which brings its
 *    resulting point set to a single constant Z denominator, stores the X and Y
 *    coordinates as ge_storage points in pre, and stores the global Z in rz.
 *    It only operates on tables sized for WINDOW_A wnaf multiples.
 *  - secp256k1_ecmult_odd_multiples_table_storage_var, which converts its
 *    resulting point set to actually affine points, and stores those in pre.
 *    It operates on tables of any size, but uses heap-allocated temporaries.
 *
 *  To compute a*P + b*G, we compute a table for P using the first function,
 *  and for G using the second (which requires an inverse, but it only needs to
 *  happen once).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>secp256k1_ecmult_odd_multiples_table_globalz_windowa</name><parameter_list>(<parameter><decl><type><name>secp256k1_ge</name> <modifier>*</modifier></type><name>pre</name></decl></parameter>, <parameter><decl><type><name>secp256k1_fe</name> <modifier>*</modifier></type><name>globalz</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>secp256k1_gej</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>secp256k1_gej</name></type> <name><name>prej</name><index>[<expr><call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>secp256k1_fe</name></type> <name><name>zr</name><index>[<expr><call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/* Compute the odd multiples in Jacobian form. */</comment>
    <expr_stmt><expr><call><name>secp256k1_ecmult_odd_multiples_table</name><argument_list>(<argument><expr><call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>prej</name></expr></argument>, <argument><expr><name>zr</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Bring them to the same Z denominator. */</comment>
    <expr_stmt><expr><call><name>secp256k1_ge_globalz_set_table_gej</name><argument_list>(<argument><expr><call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pre</name></expr></argument>, <argument><expr><name>globalz</name></expr></argument>, <argument><expr><name>prej</name></expr></argument>, <argument><expr><name>zr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>secp256k1_ecmult_odd_multiples_table_storage_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>secp256k1_ge_storage</name> <modifier>*</modifier></type><name>pre</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>secp256k1_gej</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>secp256k1_gej</name></type> <name>d</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>secp256k1_ge</name></type> <name>d_ge</name></decl>, <decl><type ref="prev"/><name>p_ge</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>secp256k1_gej</name></type> <name>pj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>secp256k1_fe</name></type> <name>zi</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>secp256k1_fe</name></type> <name>zr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>secp256k1_fe</name></type> <name>dx_over_dz_squared</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>VERIFY_CHECK</name><argument_list>(<argument><expr><operator>!</operator><name><name>a</name><operator>-&gt;</operator><name>infinity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>secp256k1_gej_double_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* First, we perform all the additions in an isomorphic curve obtained by multiplying
     * all `z` coordinates by 1/`d.z`. In these coordinates `d` is affine so we can use
     * `secp256k1_gej_add_ge_var` to perform the additions. For each addition, we store
     * the resulting y-coordinate and the z-ratio, since we only have enough memory to
     * store two field elements. These are sufficient to efficiently undo the isomorphism
     * and recompute all the `x`s.
     */</comment>
    <expr_stmt><expr><name><name>d_ge</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>d</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>d_ge</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>d</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>d_ge</name><operator>.</operator><name>infinity</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>secp256k1_ge_set_gej_zinv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p_ge</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>d</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pj</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>p_ge</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pj</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>p_ge</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pj</name><operator>.</operator><name>z</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>z</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pj</name><operator>.</operator><name>infinity</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>n</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>secp256k1_fe_normalize_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pj</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>secp256k1_fe_to_storage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pre</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pj</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>secp256k1_gej_add_ge_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d_ge</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>secp256k1_fe_normalize_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>secp256k1_fe_to_storage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pre</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Invert d.z in the same batch, preserving pj.z so we can extract 1/d.z */</comment>
    <expr_stmt><expr><call><name>secp256k1_fe_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pj</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>d</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_fe_inv_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Directly set `pre[n - 1]` to `pj`, saving the inverted z-coordinate so
     * that we can combine it with the saved z-ratios to compute the other zs
     * without any more inversions. */</comment>
    <expr_stmt><expr><call><name>secp256k1_ge_set_gej_zinv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p_ge</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_ge_to_storage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pre</name><index>[<expr><name>n</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p_ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Compute the actual x-coordinate of D, which will be needed below. */</comment>
    <expr_stmt><expr><call><name>secp256k1_fe_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pj</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* d.z = 1/d.z */</comment>
    <expr_stmt><expr><call><name>secp256k1_fe_sqr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dx_over_dz_squared</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>d</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_fe_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dx_over_dz_squared</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dx_over_dz_squared</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>d</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Going into the second loop, we have set `pre[n-1]` to its final affine
     * form, but still need to set `pre[i]` for `i` in 0 through `n-2`. We
     * have `zi = (p.z * d.z)^-1`, where
     *
     *     `p.z` is the z-coordinate of the point on the isomorphic curve
     *           which was ultimately assigned to `pre[n-1]`.
     *     `d.z` is the multiplier that must be applied to all z-coordinates
     *           to move from our isomorphic curve back to secp256k1; so the
     *           product `p.z * d.z` is the z-coordinate of the secp256k1
     *           point assigned to `pre[n-1]`.
     *
     * All subsequent inverse-z-coordinates can be obtained by multiplying this
     * factor by successive z-ratios, which is much more efficient than directly
     * computing each one.
     *
     * Importantly, these inverse-zs will be coordinates of points on secp256k1,
     * while our other stored values come from computations on the isomorphic
     * curve. So in the below loop, we will take care not to actually use `zi`
     * or any derived values until we're back on secp256k1.
     */</comment>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <name>n</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>secp256k1_fe</name></type> <name>zi2</name></decl>, <decl><type ref="prev"/><name>zi3</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>secp256k1_fe</name> <modifier>*</modifier></type><name>rzr</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>secp256k1_ge_from_storage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p_ge</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pre</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* For each remaining point, we extract the z-ratio from the stored
         * x-coordinate, compute its z^-1 from that, and compute the full
         * point from that. */</comment>
        <expr_stmt><expr><name>rzr</name> <operator>=</operator> <operator>&amp;</operator><name><name>p_ge</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>secp256k1_fe_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zi</name></expr></argument>, <argument><expr><name>rzr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>secp256k1_fe_sqr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zi2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>secp256k1_fe_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zi3</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zi2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* To compute the actual x-coordinate, we use the stored z ratio and
         * y-coordinate, which we obtained from `secp256k1_gej_add_ge_var`
         * in the loop above, as well as the inverse of the square of its
         * z-coordinate. We store the latter in the `zi2` variable, which is
         * computed iteratively starting from the overall Z inverse then
         * multiplying by each z-ratio in turn.
         *
         * Denoting the z-ratio as `rzr`, we observe that it is equal to `h`
         * from the inside of the above `gej_add_ge_var` call. This satisfies
         *
         *    rzr = d_x * z^2 - x * d_z^2
         *
         * where (`d_x`, `d_z`) are Jacobian coordinates of `D` and `(x, z)`
         * are Jacobian coordinates of our desired point -- except both are on
         * the isomorphic curve that we were using when we called `gej_add_ge_var`.
         * To get back to secp256k1, we must multiply both `z`s by `d_z`, or
         * equivalently divide both `x`s by `d_z^2`. Our equation then becomes
         *
         *    rzr = d_x * z^2 / d_z^2 - x
         *
         * (The left-hand-side, being a ratio of z-coordinates, is unaffected
         * by the isomorphism.)
         *
         * Rearranging to solve for `x`, we have
         *
         *     x = d_x * z^2 / d_z^2 - rzr
         *
         * But what we actually want is the affine coordinate `X = x/z^2`,
         * which will satisfy
         *
         *     X = d_x / d_z^2 - rzr / z^2
         *       = dx_over_dz_squared - rzr * zi2
         */</comment>
        <expr_stmt><expr><call><name>secp256k1_fe_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p_ge</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name>rzr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zi2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>secp256k1_fe_negate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p_ge</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p_ge</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>secp256k1_fe_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p_ge</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dx_over_dz_squared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* y is stored_y/z^3, as we expect */</comment>
        <expr_stmt><expr><call><name>secp256k1_fe_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p_ge</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p_ge</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zi3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Store */</comment>
        <expr_stmt><expr><call><name>secp256k1_ge_to_storage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pre</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p_ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** The following two macro retrieves a particular odd multiple from a table
 *  of precomputed multiples. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECMULT_TABLE_GET_GE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>pre</name></type></parameter>,<parameter><type><name>n</name></type></parameter>,<parameter><type><name>w</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { \
    VERIFY_CHECK(((n) &amp; 1) == 1); \
    VERIFY_CHECK((n) &gt;= -((1 &lt;&lt; ((w)-1)) - 1)); \
    VERIFY_CHECK((n) &lt;=  ((1 &lt;&lt; ((w)-1)) - 1)); \
    if ((n) &gt; 0) { \
        *(r) = (pre)[((n)-1)/2]; \
    } else { \
        *(r) = (pre)[(-(n)-1)/2]; \
        secp256k1_fe_negate(&amp;((r)-&gt;y), &amp;((r)-&gt;y), 1); \
    } \
} while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECMULT_TABLE_GET_GE_STORAGE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>pre</name></type></parameter>,<parameter><type><name>n</name></type></parameter>,<parameter><type><name>w</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { \
    VERIFY_CHECK(((n) &amp; 1) == 1); \
    VERIFY_CHECK((n) &gt;= -((1 &lt;&lt; ((w)-1)) - 1)); \
    VERIFY_CHECK((n) &lt;=  ((1 &lt;&lt; ((w)-1)) - 1)); \
    if ((n) &gt; 0) { \
        secp256k1_ge_from_storage((r), &amp;(pre)[((n)-1)/2]); \
    } else { \
        secp256k1_ge_from_storage((r), &amp;(pre)[(-(n)-1)/2]); \
        secp256k1_fe_negate(&amp;((r)-&gt;y), &amp;((r)-&gt;y), 1); \
    } \
} while(0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>secp256k1_ecmult_context_init</name><parameter_list>(<parameter><decl><type><name>secp256k1_ecmult_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>pre_g</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ENDOMORPHISM</name></cpp:ifdef>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>pre_g_128</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>secp256k1_ecmult_context_build</name><parameter_list>(<parameter><decl><type><name>secp256k1_ecmult_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>secp256k1_callback</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>secp256k1_gej</name></type> <name>gj</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>pre_g</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get the generator */</comment>
    <expr_stmt><expr><call><name>secp256k1_gej_set_ge</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>secp256k1_ge_const_g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>pre_g</name></name> <operator>=</operator> <operator>(</operator><call><name>secp256k1_ge_storage</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><index>[]</index><operator>)</operator><call><name>checked_malloc</name><argument_list>(<argument><expr><name>cb</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>pre_g</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_G</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* precompute the tables with odd multiples */</comment>
    <expr_stmt><expr><call><name>secp256k1_ecmult_odd_multiples_table_storage_var</name><argument_list>(<argument><expr><call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_G</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>pre_g</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ENDOMORPHISM</name></cpp:ifdef>
    <block>{<block_content>
        <decl_stmt><decl><type><name>secp256k1_gej</name></type> <name>g_128j</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>pre_g_128</name></name> <operator>=</operator> <operator>(</operator><call><name>secp256k1_ge_storage</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><index>[]</index><operator>)</operator><call><name>checked_malloc</name><argument_list>(<argument><expr><name>cb</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>pre_g_128</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_G</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* calculate 2^128*generator */</comment>
        <expr_stmt><expr><name>g_128j</name> <operator>=</operator> <name>gj</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">128</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>secp256k1_gej_double_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g_128j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>g_128j</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>secp256k1_ecmult_odd_multiples_table_storage_var</name><argument_list>(<argument><expr><call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_G</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>pre_g_128</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>g_128j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>secp256k1_ecmult_context_clone</name><parameter_list>(<parameter><decl><type><name>secp256k1_ecmult_context</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>,
                                           <parameter><decl><type><specifier>const</specifier> <name>secp256k1_ecmult_context</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>secp256k1_callback</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>pre_g</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>pre_g</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name><name>dst</name><operator>-&gt;</operator><name>pre_g</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_G</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>pre_g</name></name> <operator>=</operator> <operator>(</operator><call><name>secp256k1_ge_storage</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><index>[]</index><operator>)</operator><call><name>checked_malloc</name><argument_list>(<argument><expr><name>cb</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>dst</name><operator>-&gt;</operator><name>pre_g</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>pre_g</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ENDOMORPHISM</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>pre_g_128</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>pre_g_128</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name><name>dst</name><operator>-&gt;</operator><name>pre_g_128</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_G</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>pre_g_128</name></name> <operator>=</operator> <operator>(</operator><call><name>secp256k1_ge_storage</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><index>[]</index><operator>)</operator><call><name>checked_malloc</name><argument_list>(<argument><expr><name>cb</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>dst</name><operator>-&gt;</operator><name>pre_g_128</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>pre_g_128</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>secp256k1_ecmult_context_is_built</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>secp256k1_ecmult_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><name><name>ctx</name><operator>-&gt;</operator><name>pre_g</name></name> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>secp256k1_ecmult_context_clear</name><parameter_list>(<parameter><decl><type><name>secp256k1_ecmult_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>pre_g</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ENDOMORPHISM</name></cpp:ifdef>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>pre_g_128</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>secp256k1_ecmult_context_init</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** Convert a number to WNAF notation. The number becomes represented by sum(2^i * wnaf[i], i=0..bits),
 *  with the following guarantees:
 *  - each wnaf[i] is either 0, or an odd integer between -(1&lt;&lt;(w-1) - 1) and (1&lt;&lt;(w-1) - 1)
 *  - two non-zero entries in wnaf are separated by at least w-1 zeroes.
 *  - the number of set values in wnaf is returned. This number is at most 256, and at most one more
 *    than the number of bits in the (absolute value) of the input.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>secp256k1_ecmult_wnaf</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>wnaf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>secp256k1_scalar</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>w</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>secp256k1_scalar</name></type> <name>s</name> <init>= <expr><operator>*</operator><name>a</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>last_set_bit</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>sign</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>carry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>VERIFY_CHECK</name><argument_list>(<argument><expr><name>wnaf</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VERIFY_CHECK</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>len</name> <operator>&amp;&amp;</operator> <name>len</name> <operator>&lt;=</operator> <literal type="number">256</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VERIFY_CHECK</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VERIFY_CHECK</name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>&lt;=</operator> <name>w</name> <operator>&amp;&amp;</operator> <name>w</name> <operator>&lt;=</operator> <literal type="number">31</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>wnaf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>wnaf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>secp256k1_scalar_get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>secp256k1_scalar_negate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <while>while <condition>(<expr><name>bit</name> <operator>&lt;</operator> <name>len</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>now</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>word</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>secp256k1_scalar_get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>bit</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>carry</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>bit</name><operator>++</operator></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>now</name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>now</name> <operator>&gt;</operator> <name>len</name> <operator>-</operator> <name>bit</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>now</name> <operator>=</operator> <name>len</name> <operator>-</operator> <name>bit</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>word</name> <operator>=</operator> <call><name>secp256k1_scalar_get_bits_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>bit</name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>carry</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>carry</name> <operator>=</operator> <operator>(</operator><name>word</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>w</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>word</name> <operator>-=</operator> <name>carry</name> <operator>&lt;&lt;</operator> <name>w</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>wnaf</name><index>[<expr><name>bit</name></expr>]</index></name> <operator>=</operator> <name>sign</name> <operator>*</operator> <name>word</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>last_set_bit</name> <operator>=</operator> <name>bit</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>bit</name> <operator>+=</operator> <name>now</name></expr>;</expr_stmt>
    </block_content>}</block></while>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VERIFY</name></cpp:ifdef>
    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>carry</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>bit</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>secp256k1_scalar_get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>bit</name><operator>++</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>last_set_bit</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>secp256k1_strauss_point_state</name> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ENDOMORPHISM</name></cpp:ifdef>
    <decl_stmt><decl><type><name>secp256k1_scalar</name></type> <name>na_1</name></decl>, <decl><type ref="prev"/><name>na_lam</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name><name>wnaf_na_1</name><index>[<expr><literal type="number">130</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name><name>wnaf_na_lam</name><index>[<expr><literal type="number">130</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bits_na_1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bits_na_lam</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>int</name></type> <name><name>wnaf_na</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bits_na</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>size_t</name></type> <name>input_pos</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>secp256k1_strauss_state</name> <block>{
    <decl_stmt><decl><type><name>secp256k1_gej</name><modifier>*</modifier></type> <name>prej</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>secp256k1_fe</name><modifier>*</modifier></type> <name>zr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>secp256k1_ge</name><modifier>*</modifier></type> <name>pre_a</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ENDOMORPHISM</name></cpp:ifdef>
    <decl_stmt><decl><type><name>secp256k1_ge</name><modifier>*</modifier></type> <name>pre_a_lam</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name><name>struct</name> <name>secp256k1_strauss_point_state</name></name><modifier>*</modifier></type> <name>ps</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type> <name>secp256k1_ecmult_strauss_wnaf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>secp256k1_ecmult_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>secp256k1_strauss_state</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>secp256k1_gej</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>secp256k1_gej</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>secp256k1_scalar</name> <modifier>*</modifier></type><name>na</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>secp256k1_scalar</name> <modifier>*</modifier></type><name>ng</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>secp256k1_ge</name></type> <name>tmpa</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>secp256k1_fe</name></type> <name>Z</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ENDOMORPHISM</name></cpp:ifdef>
    <comment type="block">/* Splitted G factors. */</comment>
    <decl_stmt><decl><type><name>secp256k1_scalar</name></type> <name>ng_1</name></decl>, <decl><type ref="prev"/><name>ng_128</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name><name>wnaf_ng_1</name><index>[<expr><literal type="number">129</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bits_ng_1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name><name>wnaf_ng_128</name><index>[<expr><literal type="number">129</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bits_ng_128</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>int</name></type> <name><name>wnaf_ng</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bits_ng</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>np</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>no</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>np</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>np</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><operator>++</operator><name>np</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>secp256k1_scalar_is_zero</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>na</name><index>[<expr><name>np</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>secp256k1_gej_is_infinity</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><name>np</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>no</name></expr>]</index></name><operator>.</operator><name>input_pos</name> <operator>=</operator> <name>np</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ENDOMORPHISM</name></cpp:ifdef>
        <comment type="block">/* split na into na_1 and na_lam (where na = na_1 + na_lam*lambda, and na_1 and na_lam are ~128 bit) */</comment>
        <expr_stmt><expr><call><name>secp256k1_scalar_split_lambda</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>no</name></expr>]</index></name><operator>.</operator><name>na_1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>no</name></expr>]</index></name><operator>.</operator><name>na_lam</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>na</name><index>[<expr><name>np</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* build wnaf representation for na_1 and na_lam. */</comment>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>no</name></expr>]</index></name><operator>.</operator><name>bits_na_1</name>   <operator>=</operator> <call><name>secp256k1_ecmult_wnaf</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>no</name></expr>]</index></name><operator>.</operator><name>wnaf_na_1</name></expr></argument>,   <argument><expr><literal type="number">130</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>no</name></expr>]</index></name><operator>.</operator><name>na_1</name></expr></argument>,   <argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>no</name></expr>]</index></name><operator>.</operator><name>bits_na_lam</name> <operator>=</operator> <call><name>secp256k1_ecmult_wnaf</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>no</name></expr>]</index></name><operator>.</operator><name>wnaf_na_lam</name></expr></argument>, <argument><expr><literal type="number">130</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>no</name></expr>]</index></name><operator>.</operator><name>na_lam</name></expr></argument>, <argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VERIFY_CHECK</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>no</name></expr>]</index></name><operator>.</operator><name>bits_na_1</name> <operator>&lt;=</operator> <literal type="number">130</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VERIFY_CHECK</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>no</name></expr>]</index></name><operator>.</operator><name>bits_na_lam</name> <operator>&lt;=</operator> <literal type="number">130</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>no</name></expr>]</index></name><operator>.</operator><name>bits_na_1</name> <operator>&gt;</operator> <name>bits</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>bits</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>no</name></expr>]</index></name><operator>.</operator><name>bits_na_1</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>no</name></expr>]</index></name><operator>.</operator><name>bits_na_lam</name> <operator>&gt;</operator> <name>bits</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>bits</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>no</name></expr>]</index></name><operator>.</operator><name>bits_na_lam</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <comment type="block">/* build wnaf representation for na. */</comment>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>no</name></expr>]</index></name><operator>.</operator><name>bits_na</name>     <operator>=</operator> <call><name>secp256k1_ecmult_wnaf</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>no</name></expr>]</index></name><operator>.</operator><name>wnaf_na</name></expr></argument>,     <argument><expr><literal type="number">256</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>na</name><index>[<expr><name>np</name></expr>]</index></name></expr></argument>,      <argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>no</name></expr>]</index></name><operator>.</operator><name>bits_na</name> <operator>&gt;</operator> <name>bits</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>bits</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>no</name></expr>]</index></name><operator>.</operator><name>bits_na</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><operator>++</operator><name>no</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Calculate odd multiples of a.
     * All multiples are brought to the same Z 'denominator', which is stored
     * in Z. Due to secp256k1' isomorphism we can do all operations pretending
     * that the Z coordinate was 1, use affine addition formulae, and correct
     * the Z coordinate of the result once at the end.
     * The exception is the precomputed G table points, which are actually
     * affine. Compared to the base used for other points, they have a Z ratio
     * of 1/Z, so we can use secp256k1_gej_add_zinv_var, which uses the same
     * isomorphism to efficiently add with a known Z inverse.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>no</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Compute the odd multiples in Jacobian form. */</comment>
        <expr_stmt><expr><call><name>secp256k1_ecmult_odd_multiples_table</name><argument_list>(<argument><expr><call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>prej</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>zr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>input_pos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>np</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>np</name> <operator>&lt;</operator> <name>no</name></expr>;</condition> <incr><expr><operator>++</operator><name>np</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>secp256k1_gej</name></type> <name>tmp</name> <init>= <expr><name><name>a</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>np</name></expr>]</index></name><operator>.</operator><name>input_pos</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VERIFY</name></cpp:ifdef>
            <expr_stmt><expr><call><name>secp256k1_fe_normalize_var</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>prej</name><index>[<expr><operator>(</operator><name>np</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>z</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>secp256k1_gej_rescale</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>prej</name><index>[<expr><operator>(</operator><name>np</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>z</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>secp256k1_ecmult_odd_multiples_table</name><argument_list>(<argument><expr><call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>prej</name></name> <operator>+</operator> <name>np</name> <operator>*</operator> <call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>zr</name></name> <operator>+</operator> <name>np</name> <operator>*</operator> <call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>secp256k1_fe_mul</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>zr</name></name> <operator>+</operator> <name>np</name> <operator>*</operator> <call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>zr</name></name> <operator>+</operator> <name>np</name> <operator>*</operator> <call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>a</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>np</name></expr>]</index></name><operator>.</operator><name>input_pos</name></expr>]</index></name><operator>.</operator><name>z</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <comment type="block">/* Bring them to the same Z denominator. */</comment>
        <expr_stmt><expr><call><name>secp256k1_ge_globalz_set_table_gej</name><argument_list>(<argument><expr><call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>no</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>pre_a</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Z</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>prej</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>zr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>secp256k1_fe_set_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Z</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ENDOMORPHISM</name></cpp:ifdef>
    <for>for <control>(<init><expr><name>np</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>np</name> <operator>&lt;</operator> <name>no</name></expr>;</condition> <incr><expr><operator>++</operator><name>np</name></expr></incr>)</control> <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>secp256k1_ge_mul_lambda</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>pre_a_lam</name><index>[<expr><name>np</name> <operator>*</operator> <call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>pre_a</name><index>[<expr><name>np</name> <operator>*</operator> <call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>ng</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* split ng into ng_1 and ng_128 (where gn = gn_1 + gn_128*2^128, and gn_1 and gn_128 are ~128 bit) */</comment>
        <expr_stmt><expr><call><name>secp256k1_scalar_split_128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ng_1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ng_128</name></expr></argument>, <argument><expr><name>ng</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Build wnaf representation for ng_1 and ng_128 */</comment>
        <expr_stmt><expr><name>bits_ng_1</name>   <operator>=</operator> <call><name>secp256k1_ecmult_wnaf</name><argument_list>(<argument><expr><name>wnaf_ng_1</name></expr></argument>,   <argument><expr><literal type="number">129</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ng_1</name></expr></argument>,   <argument><expr><name>WINDOW_G</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits_ng_128</name> <operator>=</operator> <call><name>secp256k1_ecmult_wnaf</name><argument_list>(<argument><expr><name>wnaf_ng_128</name></expr></argument>, <argument><expr><literal type="number">129</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ng_128</name></expr></argument>, <argument><expr><name>WINDOW_G</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>bits_ng_1</name> <operator>&gt;</operator> <name>bits</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>bits</name> <operator>=</operator> <name>bits_ng_1</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>bits_ng_128</name> <operator>&gt;</operator> <name>bits</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>bits</name> <operator>=</operator> <name>bits_ng_128</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><name>ng</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>bits_ng</name>     <operator>=</operator> <call><name>secp256k1_ecmult_wnaf</name><argument_list>(<argument><expr><name>wnaf_ng</name></expr></argument>,     <argument><expr><literal type="number">256</literal></expr></argument>, <argument><expr><name>ng</name></expr></argument>,      <argument><expr><name>WINDOW_G</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>bits_ng</name> <operator>&gt;</operator> <name>bits</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>bits</name> <operator>=</operator> <name>bits_ng</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>secp256k1_gej_set_infinity</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>bits</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>secp256k1_gej_double_var</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ENDOMORPHISM</name></cpp:ifdef>
        <for>for <control>(<init><expr><name>np</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>np</name> <operator>&lt;</operator> <name>no</name></expr>;</condition> <incr><expr><operator>++</operator><name>np</name></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>np</name></expr>]</index></name><operator>.</operator><name>bits_na_1</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>n</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>np</name></expr>]</index></name><operator>.</operator><name><name>wnaf_na_1</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>ECMULT_TABLE_GET_GE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpa</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>pre_a</name></name> <operator>+</operator> <name>np</name> <operator>*</operator> <call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>secp256k1_gej_add_ge_var</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmpa</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>np</name></expr>]</index></name><operator>.</operator><name>bits_na_lam</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>n</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>np</name></expr>]</index></name><operator>.</operator><name><name>wnaf_na_lam</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>ECMULT_TABLE_GET_GE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpa</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>pre_a_lam</name></name> <operator>+</operator> <name>np</name> <operator>*</operator> <call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>secp256k1_gej_add_ge_var</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmpa</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>bits_ng_1</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>n</name> <operator>=</operator> <name><name>wnaf_ng_1</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>ECMULT_TABLE_GET_GE_STORAGE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpa</name></expr></argument>, <argument><expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>pre_g</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>WINDOW_G</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>secp256k1_gej_add_zinv_var</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmpa</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>bits_ng_128</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>n</name> <operator>=</operator> <name><name>wnaf_ng_128</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>ECMULT_TABLE_GET_GE_STORAGE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpa</name></expr></argument>, <argument><expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>pre_g_128</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>WINDOW_G</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>secp256k1_gej_add_zinv_var</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmpa</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <for>for <control>(<init><expr><name>np</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>np</name> <operator>&lt;</operator> <name>no</name></expr>;</condition> <incr><expr><operator>++</operator><name>np</name></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>np</name></expr>]</index></name><operator>.</operator><name>bits_na</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>n</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>np</name></expr>]</index></name><operator>.</operator><name><name>wnaf_na</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>ECMULT_TABLE_GET_GE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpa</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>pre_a</name></name> <operator>+</operator> <name>np</name> <operator>*</operator> <call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>secp256k1_gej_add_ge_var</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmpa</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>bits_ng</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>n</name> <operator>=</operator> <name><name>wnaf_ng</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>ECMULT_TABLE_GET_GE_STORAGE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpa</name></expr></argument>, <argument><expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>pre_g</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>WINDOW_G</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>secp256k1_gej_add_zinv_var</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmpa</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>r</name><operator>-&gt;</operator><name>infinity</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>secp256k1_fe_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>r</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>r</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>secp256k1_ecmult</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>secp256k1_ecmult_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>secp256k1_gej</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>secp256k1_gej</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>secp256k1_scalar</name> <modifier>*</modifier></type><name>na</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>secp256k1_scalar</name> <modifier>*</modifier></type><name>ng</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>secp256k1_gej</name></type> <name><name>prej</name><index>[<expr><call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>secp256k1_fe</name></type> <name><name>zr</name><index>[<expr><call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>secp256k1_ge</name></type> <name><name>pre_a</name><index>[<expr><call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>secp256k1_strauss_point_state</name></name></type> <name><name>ps</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ENDOMORPHISM</name></cpp:ifdef>
    <decl_stmt><decl><type><name>secp256k1_ge</name></type> <name><name>pre_a_lam</name><index>[<expr><call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name><name>struct</name> <name>secp256k1_strauss_state</name></name></type> <name>state</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>prej</name></name> <operator>=</operator> <name>prej</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>zr</name></name> <operator>=</operator> <name>zr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>pre_a</name></name> <operator>=</operator> <name>pre_a</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ENDOMORPHISM</name></cpp:ifdef>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>pre_a_lam</name></name> <operator>=</operator> <name>pre_a_lam</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>ps</name></name> <operator>=</operator> <name>ps</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_ecmult_strauss_wnaf</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>na</name></expr></argument>, <argument><expr><name>ng</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>secp256k1_strauss_scratch_size</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>n_points</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ENDOMORPHISM</name></cpp:ifdef>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>point_size</name> <init>= <expr><operator>(</operator><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>secp256k1_ge</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>secp256k1_gej</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>secp256k1_fe</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>*</operator> <call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>secp256k1_strauss_point_state</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>secp256k1_gej</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>secp256k1_scalar</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>point_size</name> <init>= <expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>secp256k1_ge</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>secp256k1_gej</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>secp256k1_fe</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>*</operator> <call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>secp256k1_strauss_point_state</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>secp256k1_gej</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>secp256k1_scalar</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>n_points</name><operator>*</operator><name>point_size</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>secp256k1_ecmult_strauss_batch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>secp256k1_ecmult_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>secp256k1_scratch</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>, <parameter><decl><type><name>secp256k1_gej</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>secp256k1_scalar</name> <modifier>*</modifier></type><name>inp_g_sc</name></decl></parameter>, <parameter><decl><type><name>secp256k1_ecmult_multi_callback</name></type> <name>cb</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cbdata</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n_points</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cb_offset</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>secp256k1_gej</name><modifier>*</modifier></type> <name>points</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>secp256k1_scalar</name><modifier>*</modifier></type> <name>scalars</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>secp256k1_strauss_state</name></name></type> <name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>secp256k1_gej_set_infinity</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>inp_g_sc</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>n_points</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>secp256k1_scratch_allocate_frame</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>, <argument><expr><call><name>secp256k1_strauss_scratch_size</name><argument_list>(<argument><expr><name>n_points</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STRAUSS_SCRATCH_OBJECTS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>points</name> <operator>=</operator> <operator>(</operator><name>secp256k1_gej</name><operator>*</operator><operator>)</operator><call><name>secp256k1_scratch_alloc</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>, <argument><expr><name>n_points</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>secp256k1_gej</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scalars</name> <operator>=</operator> <operator>(</operator><name>secp256k1_scalar</name><operator>*</operator><operator>)</operator><call><name>secp256k1_scratch_alloc</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>, <argument><expr><name>n_points</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>secp256k1_scalar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>prej</name></name> <operator>=</operator> <operator>(</operator><name>secp256k1_gej</name><operator>*</operator><operator>)</operator><call><name>secp256k1_scratch_alloc</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>, <argument><expr><name>n_points</name> <operator>*</operator> <call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>secp256k1_gej</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>zr</name></name> <operator>=</operator> <operator>(</operator><name>secp256k1_fe</name><operator>*</operator><operator>)</operator><call><name>secp256k1_scratch_alloc</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>, <argument><expr><name>n_points</name> <operator>*</operator> <call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>secp256k1_fe</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ENDOMORPHISM</name></cpp:ifdef>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>pre_a</name></name> <operator>=</operator> <operator>(</operator><name>secp256k1_ge</name><operator>*</operator><operator>)</operator><call><name>secp256k1_scratch_alloc</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>, <argument><expr><name>n_points</name> <operator>*</operator> <literal type="number">2</literal> <operator>*</operator> <call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>secp256k1_ge</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>pre_a_lam</name></name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>pre_a</name></name> <operator>+</operator> <name>n_points</name> <operator>*</operator> <call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>pre_a</name></name> <operator>=</operator> <operator>(</operator><name>secp256k1_ge</name><operator>*</operator><operator>)</operator><call><name>secp256k1_scratch_alloc</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>, <argument><expr><name>n_points</name> <operator>*</operator> <call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>WINDOW_A</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>secp256k1_ge</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>ps</name></name> <operator>=</operator> <operator>(</operator>struct <name>secp256k1_strauss_point_state</name><operator>*</operator><operator>)</operator><call><name>secp256k1_scratch_alloc</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>, <argument><expr><name>n_points</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>secp256k1_strauss_point_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n_points</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>secp256k1_ge</name></type> <name>point</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cb</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scalars</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>point</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><name>cb_offset</name></expr></argument>, <argument><expr><name>cbdata</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>secp256k1_scratch_deallocate_frame</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>secp256k1_gej_set_ge</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>points</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_ecmult_strauss_wnaf</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>n_points</name></expr></argument>, <argument><expr><name>points</name></expr></argument>, <argument><expr><name>scalars</name></expr></argument>, <argument><expr><name>inp_g_sc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_scratch_deallocate_frame</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Wrapper for secp256k1_ecmult_multi_func interface */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>secp256k1_ecmult_strauss_batch_single</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>secp256k1_ecmult_context</name> <modifier>*</modifier></type><name>actx</name></decl></parameter>, <parameter><decl><type><name>secp256k1_scratch</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>, <parameter><decl><type><name>secp256k1_gej</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>secp256k1_scalar</name> <modifier>*</modifier></type><name>inp_g_sc</name></decl></parameter>, <parameter><decl><type><name>secp256k1_ecmult_multi_callback</name></type> <name>cb</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cbdata</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>secp256k1_ecmult_strauss_batch</name><argument_list>(<argument><expr><name>actx</name></expr></argument>, <argument><expr><name>scratch</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>inp_g_sc</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>cbdata</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>secp256k1_strauss_max_points</name><parameter_list>(<parameter><decl><type><name>secp256k1_scratch</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>secp256k1_scratch_max_allocation</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>, <argument><expr><name>STRAUSS_SCRATCH_OBJECTS</name></expr></argument>)</argument_list></call> <operator>/</operator> <call><name>secp256k1_strauss_scratch_size</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** Convert a number to WNAF notation.
 *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.
 *  It has the following guarantees:
 *  - each wnaf[i] is either 0 or an odd integer between -(1 &lt;&lt; w) and (1 &lt;&lt; w)
 *  - the number of words set is always WNAF_SIZE(w)
 *  - the returned skew is 0 or 1
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>secp256k1_wnaf_fixed</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>wnaf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>secp256k1_scalar</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>w</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>skew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>max_pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>last_w</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>secp256k1_scalar</name> <modifier>*</modifier></type><name>work</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>secp256k1_scalar_is_zero</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <call><name>WNAF_SIZE</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>pos</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><name><name>wnaf</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></for>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>secp256k1_scalar_is_even</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>skew</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>wnaf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>secp256k1_scalar_get_bits_var</name><argument_list>(<argument><expr><name>work</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>skew</name></expr>;</expr_stmt>
    <comment type="block">/* Compute last window size. Relevant when window size doesn't divide the
     * number of bits in the scalar */</comment>
    <expr_stmt><expr><name>last_w</name> <operator>=</operator> <name>WNAF_BITS</name> <operator>-</operator> <operator>(</operator><call><name>WNAF_SIZE</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>w</name></expr>;</expr_stmt>

    <comment type="block">/* Store the position of the first nonzero word in max_pos to allow
     * skipping leading zeros when calculating the wnaf. */</comment>
    <for>for <control>(<init><expr><name>pos</name> <operator>=</operator> <call><name>WNAF_SIZE</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>pos</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>pos</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><call><name>secp256k1_scalar_get_bits_var</name><argument_list>(<argument><expr><name>work</name></expr></argument>, <argument><expr><name>pos</name> <operator>*</operator> <name>w</name></expr></argument>, <argument><expr><ternary><condition><expr><name>pos</name> <operator>==</operator> <call><name>WNAF_SIZE</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><name>last_w</name></expr> </then><else>: <expr><name>w</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>(<expr><name>val</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>wnaf</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>max_pos</name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pos</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>pos</name> <operator>&lt;=</operator> <name>max_pos</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><call><name>secp256k1_scalar_get_bits_var</name><argument_list>(<argument><expr><name>work</name></expr></argument>, <argument><expr><name>pos</name> <operator>*</operator> <name>w</name></expr></argument>, <argument><expr><ternary><condition><expr><name>pos</name> <operator>==</operator> <call><name>WNAF_SIZE</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><name>last_w</name></expr> </then><else>: <expr><name>w</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>val</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>wnaf</name><index>[<expr><name>pos</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>-=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>w</name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>wnaf</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>wnaf</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <comment type="block">/* Set a coefficient to zero if it is 1 or -1 and the proceeding digit
         * is strictly negative or strictly positive respectively. Only change
         * coefficients at previous positions because above code assumes that
         * wnaf[pos - 1] is odd.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>wnaf</name><index>[<expr><name>pos</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>wnaf</name><index>[<expr><name>pos</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>wnaf</name><index>[<expr><name>pos</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>wnaf</name><index>[<expr><name>pos</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>wnaf</name><index>[<expr><name>pos</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>wnaf</name><index>[<expr><name>pos</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>+=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>w</name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name><name>wnaf</name><index>[<expr><name>pos</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>-=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>w</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name><name>wnaf</name><index>[<expr><name>pos</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>++</operator><name>pos</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>skew</name></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>secp256k1_pippenger_point_state</name> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>skew_na</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>input_pos</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>secp256k1_pippenger_state</name> <block>{
    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>wnaf_na</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>secp256k1_pippenger_point_state</name></name><modifier>*</modifier></type> <name>ps</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * pippenger_wnaf computes the result of a multi-point multiplication as
 * follows: The scalars are brought into wnaf with n_wnaf elements each. Then
 * for every i &lt; n_wnaf, first each point is added to a "bucket" corresponding
 * to the point's wnaf[i]. Second, the buckets are added together such that
 * r += 1*bucket[0] + 3*bucket[1] + 5*bucket[2] + ...
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>secp256k1_ecmult_pippenger_wnaf</name><parameter_list>(<parameter><decl><type><name>secp256k1_gej</name> <modifier>*</modifier></type><name>buckets</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bucket_window</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>secp256k1_pippenger_state</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>secp256k1_gej</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>secp256k1_scalar</name> <modifier>*</modifier></type><name>sc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>secp256k1_ge</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>num</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>n_wnaf</name> <init>= <expr><call><name>WNAF_SIZE</name><argument_list>(<argument><expr><name>bucket_window</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>np</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>no</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>np</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>np</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><operator>++</operator><name>np</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>secp256k1_scalar_is_zero</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sc</name><index>[<expr><name>np</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>secp256k1_ge_is_infinity</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pt</name><index>[<expr><name>np</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>no</name></expr>]</index></name><operator>.</operator><name>input_pos</name> <operator>=</operator> <name>np</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>no</name></expr>]</index></name><operator>.</operator><name>skew_na</name> <operator>=</operator> <call><name>secp256k1_wnaf_fixed</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>wnaf_na</name><index>[<expr><name>no</name><operator>*</operator><name>n_wnaf</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sc</name><index>[<expr><name>np</name></expr>]</index></name></expr></argument>, <argument><expr><name>bucket_window</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>no</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_gej_set_infinity</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>no</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>n_wnaf</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>secp256k1_gej</name></type> <name>running_sum</name></decl>;</decl_stmt>

        <for>for<control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>bucket_window</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>secp256k1_gej_set_infinity</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buckets</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <for>for <control>(<init><expr><name>np</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>np</name> <operator>&lt;</operator> <name>no</name></expr>;</condition> <incr><expr><operator>++</operator><name>np</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>wnaf_na</name><index>[<expr><name>np</name><operator>*</operator><name>n_wnaf</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>struct</name> <name>secp256k1_pippenger_point_state</name></name></type> <name>point_state</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>np</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>secp256k1_ge</name></type> <name>tmp</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <comment type="block">/* correct for wnaf skew */</comment>
                <decl_stmt><decl><type><name>int</name></type> <name>skew</name> <init>= <expr><name><name>point_state</name><operator>.</operator><name>skew_na</name></name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>skew</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>secp256k1_ge_neg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pt</name><index>[<expr><name><name>point_state</name><operator>.</operator><name>input_pos</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>secp256k1_gej_add_ge_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buckets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>buckets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>idx</name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>secp256k1_gej_add_ge_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buckets</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>buckets</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pt</name><index>[<expr><name><name>point_state</name><operator>.</operator><name>input_pos</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>idx</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>n</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>secp256k1_ge_neg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pt</name><index>[<expr><name><name>point_state</name><operator>.</operator><name>input_pos</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>secp256k1_gej_add_ge_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buckets</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>buckets</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <for>for<control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>bucket_window</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>secp256k1_gej_double_var</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>secp256k1_gej_set_infinity</name><argument_list>(<argument><expr><operator>&amp;</operator><name>running_sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Accumulate the sum: bucket[0] + 3*bucket[1] + 5*bucket[2] + 7*bucket[3] + ...
         *                   = bucket[0] +   bucket[1] +   bucket[2] +   bucket[3] + ...
         *                   +         2 *  (bucket[1] + 2*bucket[2] + 3*bucket[3] + ...)
         * using an intermediate running sum:
         * running_sum = bucket[0] +   bucket[1] +   bucket[2] + ...
         *
         * The doubling is done implicitly by deferring the final window doubling (of 'r').
         */</comment>
        <for>for<control>(<init><expr><name>j</name> <operator>=</operator> <call><name>ECMULT_TABLE_SIZE</name><argument_list>(<argument><expr><name>bucket_window</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>secp256k1_gej_add_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>running_sum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>running_sum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>buckets</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>secp256k1_gej_add_var</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>running_sum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>secp256k1_gej_add_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>running_sum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>running_sum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>buckets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>secp256k1_gej_double_var</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>secp256k1_gej_add_var</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>running_sum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Returns optimal bucket_window (number of bits of a scalar represented by a
 * set of buckets) for a given number of points.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>secp256k1_pippenger_bucket_window</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ENDOMORPHISM</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">2</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">20</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">3</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">57</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">4</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">136</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">5</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">235</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">6</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">1260</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">7</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">4420</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">9</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">7880</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">10</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">16050</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">11</literal></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><name>PIPPENGER_MAX_BUCKET_WINDOW</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">11</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">2</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">45</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">3</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">100</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">4</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">275</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">5</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">625</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">6</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">1850</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">7</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">3400</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">8</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">9630</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">9</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">17900</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">10</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">32800</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">11</literal></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><name>PIPPENGER_MAX_BUCKET_WINDOW</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Returns the maximum optimal number of points for a bucket_window.
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>secp256k1_pippenger_bucket_window_inv</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>bucket_window</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <switch>switch<condition>(<expr><name>bucket_window</name></expr>)</condition> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ENDOMORPHISM</name></cpp:ifdef>
        <case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="number">1</literal></expr>;</return>
        <case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="number">4</literal></expr>;</return>
        <case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><literal type="number">20</literal></expr>;</return>
        <case>case <expr><literal type="number">4</literal></expr>:</case> <return>return <expr><literal type="number">57</literal></expr>;</return>
        <case>case <expr><literal type="number">5</literal></expr>:</case> <return>return <expr><literal type="number">136</literal></expr>;</return>
        <case>case <expr><literal type="number">6</literal></expr>:</case> <return>return <expr><literal type="number">235</literal></expr>;</return>
        <case>case <expr><literal type="number">7</literal></expr>:</case> <return>return <expr><literal type="number">1260</literal></expr>;</return>
        <case>case <expr><literal type="number">8</literal></expr>:</case> <return>return <expr><literal type="number">1260</literal></expr>;</return>
        <case>case <expr><literal type="number">9</literal></expr>:</case> <return>return <expr><literal type="number">4420</literal></expr>;</return>
        <case>case <expr><literal type="number">10</literal></expr>:</case> <return>return <expr><literal type="number">7880</literal></expr>;</return>
        <case>case <expr><literal type="number">11</literal></expr>:</case> <return>return <expr><literal type="number">16050</literal></expr>;</return>
        <case>case <expr><name>PIPPENGER_MAX_BUCKET_WINDOW</name></expr>:</case> <return>return <expr><name>SIZE_MAX</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="number">1</literal></expr>;</return>
        <case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="number">11</literal></expr>;</return>
        <case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><literal type="number">45</literal></expr>;</return>
        <case>case <expr><literal type="number">4</literal></expr>:</case> <return>return <expr><literal type="number">100</literal></expr>;</return>
        <case>case <expr><literal type="number">5</literal></expr>:</case> <return>return <expr><literal type="number">275</literal></expr>;</return>
        <case>case <expr><literal type="number">6</literal></expr>:</case> <return>return <expr><literal type="number">625</literal></expr>;</return>
        <case>case <expr><literal type="number">7</literal></expr>:</case> <return>return <expr><literal type="number">1850</literal></expr>;</return>
        <case>case <expr><literal type="number">8</literal></expr>:</case> <return>return <expr><literal type="number">3400</literal></expr>;</return>
        <case>case <expr><literal type="number">9</literal></expr>:</case> <return>return <expr><literal type="number">9630</literal></expr>;</return>
        <case>case <expr><literal type="number">10</literal></expr>:</case> <return>return <expr><literal type="number">17900</literal></expr>;</return>
        <case>case <expr><literal type="number">11</literal></expr>:</case> <return>return <expr><literal type="number">32800</literal></expr>;</return>
        <case>case <expr><name>PIPPENGER_MAX_BUCKET_WINDOW</name></expr>:</case> <return>return <expr><name>SIZE_MAX</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></switch>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ENDOMORPHISM</name></cpp:ifdef>
<function><type><name>SECP256K1_INLINE</name> <specifier>static</specifier> <name>void</name></type> <name>secp256k1_ecmult_endo_split</name><parameter_list>(<parameter><decl><type><name>secp256k1_scalar</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><name>secp256k1_scalar</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>, <parameter><decl><type><name>secp256k1_ge</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><name>secp256k1_ge</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>secp256k1_scalar</name></type> <name>tmp</name> <init>= <expr><operator>*</operator><name>s1</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>secp256k1_scalar_split_lambda</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_ge_mul_lambda</name><argument_list>(<argument><expr><name>p2</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>secp256k1_scalar_is_high</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>secp256k1_scalar_negate</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>secp256k1_ge_neg</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>secp256k1_scalar_is_high</name><argument_list>(<argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>secp256k1_scalar_negate</name><argument_list>(<argument><expr><name>s2</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>secp256k1_ge_neg</name><argument_list>(<argument><expr><name>p2</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/**
 * Returns the scratch size required for a given number of points (excluding
 * base point G) without considering alignment.
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>secp256k1_pippenger_scratch_size</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>n_points</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bucket_window</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ENDOMORPHISM</name></cpp:ifdef>
    <decl_stmt><decl><type><name>size_t</name></type> <name>entries</name> <init>= <expr><literal type="number">2</literal><operator>*</operator><name>n_points</name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>size_t</name></type> <name>entries</name> <init>= <expr><name>n_points</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>size_t</name></type> <name>entry_size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>secp256k1_ge</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>secp256k1_scalar</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>secp256k1_pippenger_point_state</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><call><name>WNAF_SIZE</name><argument_list>(<argument><expr><name>bucket_window</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <return>return <expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>secp256k1_gej</name></expr></argument>)</argument_list></sizeof> <operator>&lt;&lt;</operator> <name>bucket_window</name><operator>)</operator> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>secp256k1_pippenger_state</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>entries</name> <operator>*</operator> <name>entry_size</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>secp256k1_ecmult_pippenger_batch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>secp256k1_ecmult_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>secp256k1_scratch</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>, <parameter><decl><type><name>secp256k1_gej</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>secp256k1_scalar</name> <modifier>*</modifier></type><name>inp_g_sc</name></decl></parameter>, <parameter><decl><type><name>secp256k1_ecmult_multi_callback</name></type> <name>cb</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cbdata</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n_points</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cb_offset</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* Use 2(n+1) with the endomorphism, n+1 without, when calculating batch
     * sizes. The reason for +1 is that we add the G scalar to the list of
     * other scalars. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ENDOMORPHISM</name></cpp:ifdef>
    <decl_stmt><decl><type><name>size_t</name></type> <name>entries</name> <init>= <expr><literal type="number">2</literal><operator>*</operator><name>n_points</name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>size_t</name></type> <name>entries</name> <init>= <expr><name>n_points</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>secp256k1_ge</name> <modifier>*</modifier></type><name>points</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>secp256k1_scalar</name> <modifier>*</modifier></type><name>scalars</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>secp256k1_gej</name> <modifier>*</modifier></type><name>buckets</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>secp256k1_pippenger_state</name></name> <modifier>*</modifier></type><name>state_space</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>point_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bucket_window</name></decl>;</decl_stmt>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>ctx</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_gej_set_infinity</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>inp_g_sc</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>n_points</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>bucket_window</name> <operator>=</operator> <call><name>secp256k1_pippenger_bucket_window</name><argument_list>(<argument><expr><name>n_points</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>secp256k1_scratch_allocate_frame</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>, <argument><expr><call><name>secp256k1_pippenger_scratch_size</name><argument_list>(<argument><expr><name>n_points</name></expr></argument>, <argument><expr><name>bucket_window</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PIPPENGER_SCRATCH_OBJECTS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>points</name> <operator>=</operator> <operator>(</operator><name>secp256k1_ge</name> <operator>*</operator><operator>)</operator> <call><name>secp256k1_scratch_alloc</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>, <argument><expr><name>entries</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>points</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scalars</name> <operator>=</operator> <operator>(</operator><name>secp256k1_scalar</name> <operator>*</operator><operator>)</operator> <call><name>secp256k1_scratch_alloc</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>, <argument><expr><name>entries</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>scalars</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>state_space</name> <operator>=</operator> <operator>(</operator>struct <name>secp256k1_pippenger_state</name> <operator>*</operator><operator>)</operator> <call><name>secp256k1_scratch_alloc</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>state_space</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state_space</name><operator>-&gt;</operator><name>ps</name></name> <operator>=</operator> <operator>(</operator>struct <name>secp256k1_pippenger_point_state</name> <operator>*</operator><operator>)</operator> <call><name>secp256k1_scratch_alloc</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>, <argument><expr><name>entries</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>state_space</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state_space</name><operator>-&gt;</operator><name>wnaf_na</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>secp256k1_scratch_alloc</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>, <argument><expr><name>entries</name><operator>*</operator><operator>(</operator><call><name>WNAF_SIZE</name><argument_list>(<argument><expr><name>bucket_window</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>buckets</name> <operator>=</operator> <operator>(</operator><name>secp256k1_gej</name> <operator>*</operator><operator>)</operator> <call><name>secp256k1_scratch_alloc</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>buckets</name></expr></argument>)</argument_list></sizeof> <operator>&lt;&lt;</operator> <name>bucket_window</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>inp_g_sc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>scalars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>inp_g_sc</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>points</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>secp256k1_ge_const_g</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ENDOMORPHISM</name></cpp:ifdef>
        <expr_stmt><expr><call><name>secp256k1_ecmult_endo_split</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scalars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scalars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>points</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>points</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>

    <while>while <condition>(<expr><name>point_idx</name> <operator>&lt;</operator> <name>n_points</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cb</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scalars</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>points</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><name>point_idx</name> <operator>+</operator> <name>cb_offset</name></expr></argument>, <argument><expr><name>cbdata</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>secp256k1_scratch_deallocate_frame</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ENDOMORPHISM</name></cpp:ifdef>
        <expr_stmt><expr><call><name>secp256k1_ecmult_endo_split</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scalars</name><index>[<expr><name>idx</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scalars</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>points</name><index>[<expr><name>idx</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>points</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>point_idx</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>secp256k1_ecmult_pippenger_wnaf</name><argument_list>(<argument><expr><name>buckets</name></expr></argument>, <argument><expr><name>bucket_window</name></expr></argument>, <argument><expr><name>state_space</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>scalars</name></expr></argument>, <argument><expr><name>points</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Clear data */</comment>
    <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>i</name> <operator>&lt;</operator> <name>idx</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>secp256k1_scalar_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scalars</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state_space</name><operator>-&gt;</operator><name>ps</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>skew_na</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <call><name>WNAF_SIZE</name><argument_list>(<argument><expr><name>bucket_window</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><name><name>state_space</name><operator>-&gt;</operator><name>wnaf_na</name><index>[<expr><name>i</name> <operator>*</operator> <call><name>WNAF_SIZE</name><argument_list>(<argument><expr><name>bucket_window</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>
    <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">1</literal><operator>&lt;&lt;</operator><name>bucket_window</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>secp256k1_gej_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buckets</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>secp256k1_scratch_deallocate_frame</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Wrapper for secp256k1_ecmult_multi_func interface */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>secp256k1_ecmult_pippenger_batch_single</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>secp256k1_ecmult_context</name> <modifier>*</modifier></type><name>actx</name></decl></parameter>, <parameter><decl><type><name>secp256k1_scratch</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>, <parameter><decl><type><name>secp256k1_gej</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>secp256k1_scalar</name> <modifier>*</modifier></type><name>inp_g_sc</name></decl></parameter>, <parameter><decl><type><name>secp256k1_ecmult_multi_callback</name></type> <name>cb</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cbdata</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>secp256k1_ecmult_pippenger_batch</name><argument_list>(<argument><expr><name>actx</name></expr></argument>, <argument><expr><name>scratch</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>inp_g_sc</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>cbdata</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Returns the maximum number of points in addition to G that can be used with
 * a given scratch space. The function ensures that fewer points may also be
 * used.
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>secp256k1_pippenger_max_points</name><parameter_list>(<parameter><decl><type><name>secp256k1_scratch</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>max_alloc</name> <init>= <expr><call><name>secp256k1_scratch_max_allocation</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>, <argument><expr><name>PIPPENGER_SCRATCH_OBJECTS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bucket_window</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>bucket_window</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>bucket_window</name> <operator>&lt;=</operator> <name>PIPPENGER_MAX_BUCKET_WINDOW</name></expr>;</condition> <incr><expr><name>bucket_window</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>n_points</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>max_points</name> <init>= <expr><call><name>secp256k1_pippenger_bucket_window_inv</name><argument_list>(<argument><expr><name>bucket_window</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>space_for_points</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>space_overhead</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>entry_size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>secp256k1_ge</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>secp256k1_scalar</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>secp256k1_pippenger_point_state</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><call><name>WNAF_SIZE</name><argument_list>(<argument><expr><name>bucket_window</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ENDOMORPHISM</name></cpp:ifdef>
        <expr_stmt><expr><name>entry_size</name> <operator>=</operator> <literal type="number">2</literal><operator>*</operator><name>entry_size</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>space_overhead</name> <operator>=</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>secp256k1_gej</name></expr></argument>)</argument_list></sizeof> <operator>&lt;&lt;</operator> <name>bucket_window</name><operator>)</operator> <operator>+</operator> <name>entry_size</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>secp256k1_pippenger_state</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>space_overhead</name> <operator>&gt;</operator> <name>max_alloc</name></expr>)</condition> <block>{<block_content>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>space_for_points</name> <operator>=</operator> <name>max_alloc</name> <operator>-</operator> <name>space_overhead</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>n_points</name> <operator>=</operator> <name>space_for_points</name><operator>/</operator><name>entry_size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>n_points</name> <operator>=</operator> <ternary><condition><expr><name>n_points</name> <operator>&gt;</operator> <name>max_points</name></expr> ?</condition><then> <expr><name>max_points</name></expr> </then><else>: <expr><name>n_points</name></expr></else></ternary></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>n_points</name> <operator>&gt;</operator> <name>res</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>res</name> <operator>=</operator> <name>n_points</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>n_points</name> <operator>&lt;</operator> <name>max_points</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* A larger bucket_window may support even more points. But if we
             * would choose that then the caller couldn't safely use any number
             * smaller than what this function returns */</comment>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Computes ecmult_multi by simply multiplying and adding each point. Does not
 * require a scratch space */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>secp256k1_ecmult_multi_simple_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>secp256k1_ecmult_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>secp256k1_gej</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>secp256k1_scalar</name> <modifier>*</modifier></type><name>inp_g_sc</name></decl></parameter>, <parameter><decl><type><name>secp256k1_ecmult_multi_callback</name></type> <name>cb</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cbdata</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n_points</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>point_idx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>secp256k1_scalar</name></type> <name>szero</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>secp256k1_gej</name></type> <name>tmpj</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>secp256k1_scalar_set_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name>szero</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_gej_set_infinity</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>secp256k1_gej_set_infinity</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* r = inp_g_sc*G */</comment>
    <expr_stmt><expr><call><name>secp256k1_ecmult</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmpj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>szero</name></expr></argument>, <argument><expr><name>inp_g_sc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>point_idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>point_idx</name> <operator>&lt;</operator> <name>n_points</name></expr>;</condition> <incr><expr><name>point_idx</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>secp256k1_ge</name></type> <name>point</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>secp256k1_gej</name></type> <name>pointj</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>secp256k1_scalar</name></type> <name>scalar</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cb</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scalar</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>point</name></expr></argument>, <argument><expr><name>point_idx</name></expr></argument>, <argument><expr><name>cbdata</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* r += scalar*point */</comment>
        <expr_stmt><expr><call><name>secp256k1_gej_set_ge</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pointj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>secp256k1_ecmult</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmpj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pointj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scalar</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>secp256k1_gej_add_var</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmpj</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compute the number of batches and the batch size given the maximum batch size and the
 * total number of points */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>secp256k1_ecmult_multi_batch_size_helper</name><parameter_list>(<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>n_batches</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>n_batch_points</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>max_n_batch_points</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>max_n_batch_points</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>max_n_batch_points</name> <operator>&gt;</operator> <name>ECMULT_MAX_POINTS_PER_BATCH</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>max_n_batch_points</name> <operator>=</operator> <name>ECMULT_MAX_POINTS_PER_BATCH</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>n_batches</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>n_batch_points</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Compute ceil(n/max_n_batch_points) and ceil(n/n_batches) */</comment>
    <expr_stmt><expr><operator>*</operator><name>n_batches</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name>n</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>max_n_batch_points</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>n_batch_points</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name>n</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <operator>*</operator><name>n_batches</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>secp256k1_ecmult_multi_func</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>secp256k1_ecmult_context</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>secp256k1_scratch</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>secp256k1_gej</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>secp256k1_scalar</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>secp256k1_ecmult_multi_callback</name></type> <name>cb</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>secp256k1_ecmult_multi_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>secp256k1_ecmult_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>secp256k1_scratch</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>, <parameter><decl><type><name>secp256k1_gej</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>secp256k1_scalar</name> <modifier>*</modifier></type><name>inp_g_sc</name></decl></parameter>, <parameter><decl><type><name>secp256k1_ecmult_multi_callback</name></type> <name>cb</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cbdata</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

    <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>f</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>secp256k1_ecmult_context</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>secp256k1_scratch</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>secp256k1_gej</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>secp256k1_scalar</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>secp256k1_ecmult_multi_callback</name></type> <name>cb</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>size_t</name></type> <name>n_batches</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>n_batch_points</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>secp256k1_gej_set_infinity</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>inp_g_sc</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>secp256k1_scalar</name></type> <name>szero</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>secp256k1_scalar_set_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name>szero</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>secp256k1_ecmult</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>szero</name></expr></argument>, <argument><expr><name>inp_g_sc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>scratch</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>secp256k1_ecmult_multi_simple_var</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>inp_g_sc</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>cbdata</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Compute the batch sizes for pippenger given a scratch space. If it's greater than a threshold
     * use pippenger. Otherwise use strauss */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>secp256k1_ecmult_multi_batch_size_helper</name><argument_list>(<argument><expr><operator>&amp;</operator><name>n_batches</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n_batch_points</name></expr></argument>, <argument><expr><call><name>secp256k1_pippenger_max_points</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>n_batch_points</name> <operator>&gt;=</operator> <name>ECMULT_PIPPENGER_THRESHOLD</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>f</name> <operator>=</operator> <name>secp256k1_ecmult_pippenger_batch</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>secp256k1_ecmult_multi_batch_size_helper</name><argument_list>(<argument><expr><operator>&amp;</operator><name>n_batches</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n_batch_points</name></expr></argument>, <argument><expr><call><name>secp256k1_strauss_max_points</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>f</name> <operator>=</operator> <name>secp256k1_ecmult_strauss_batch</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n_batches</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>nbp</name> <init>= <expr><ternary><condition><expr><name>n</name> <operator>&lt;</operator> <name>n_batch_points</name></expr> ?</condition><then> <expr><name>n</name></expr> </then><else>: <expr><name>n_batch_points</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>offset</name> <init>= <expr><name>n_batch_points</name><operator>*</operator><name>i</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>secp256k1_gej</name></type> <name>tmp</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>f</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>scratch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><ternary><condition><expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>inp_g_sc</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>cbdata</name></expr></argument>, <argument><expr><name>nbp</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>secp256k1_gej_add_var</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name> <operator>-=</operator> <name>nbp</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SECP256K1_ECMULT_IMPL_H */</comment>
</unit>
